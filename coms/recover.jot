%%Recovers a crashed editor session using journal files.
%% 

%%
%%    Copyright (C) 2017-2018 Jon. Easterbrook
%%
%%    This file is part of jot (Joy Of Text - a text editor).
%%
%%    jot is free software: you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation, either version 3 of the License, or
%%    (at your option) any later version.
%%
%%    jot is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with jot.  If not, see <https://www.gnu.org/licenses/>.
%%
%%

%g? 
  Usage:
    Restart the editor with -init=%r=recover
    It picks up the journal file using the pathname of the primary file - <primaryPathName>.jnl/history.txt
    A copy of the primary file and any modified secondaries is in the same directory.
    
  For simple cases the following procedure should be sufficient:
    jot <originalPrimaryFile> -init="%r=recover"
  then
    jot <originalPrimaryFile> -init="%r=./recover_now.jot -asConsole"
  It may be necessary to edit the ./recover_now.jot script - especially if the original failure was due 
  to operator error, then you will need to remove the faulty commands from the script before running it. 
    
  Buffers, original contents of these are held in the ^ buffer while this script extracts the next command.:
    j - The history.txt file
    c - the current key code or escape sequence from history
    t - the hotkey/escape sequence translation from the ^ buffer.
    o - the recovery script.
    p - the journal-directory path.
    n - the Ctrl+C command count.
:

%%One comfort definition for debugging.
obz^m-0bi/q       %s=trace 0;/boz

%g#
%%Main recovery macro.
%%
%%Check for readonly buffers etc - remove all locks.
ob %q~=system; f/Buffers:/m 
%%Buffer loop - reset write lock etc on all buffers.
( f1/ Buffer /- q/a-z/m, oicoz %b=unrestricted; z~m)0 osozok
 
%%Pick up pathName for primary.
%q~=buffer; f/pathName = / (r0f-1"/"-, f-1" "-)n.r0ap&zpr0i".jnl/"
%%Read the history file.
z. (%ij='p/history.txt;, %x=Cannot open history file 'p/history.txt - giving up now; )
%%Add a dummy keycode for simple typed-in commands.
z^m0r0b-i/        /
%%Clear out the output buffer.
%qo=date
ki/%%Recovery file generated by recover.jot, run date /r0b
zj %q~=buffer; f/pathname = /-e-0i/%%Using history file /m-k-0 f/currentDatestamp = /-e-0j-i/ dated / zoi'~ okb
%q$=date; mzoi/%%Recovery script ran at /i'$b
%%  i/ob/b 
zjm-0
%%Now add instructions to read the primary buffer.
zjm-0f/%%Primary file /-n.r0ac& zci/z. %b=pathname /r0i/;/ zohcb 
%%Copy the recovery-pathname line for the startup script.
zjf/%%Recovery pathname: /-oidrn.orac& zcr-0i/%i=/r0i/; %b=pathname /zjf1/, Original pathname: /-oidrn.orac&+zcr0i/;/ zohcb
%%Add instruction to disable I/O.
i"%s=recoverymode 1"b
%%Check that we're being run as -startup=recover.
ob%q$=system; (f/ Startup script = /-v/recover/r0v-//oz, oz %x=Error: recovery must be run as a -startup=recover;)
%%Check that current screen size is sufficient for emulating any size in the original session.
ol0 ol0 zjm-0 (f/%%Recovery terminal size: /- oid(o>, okf-1/ /oid) osroid(o>, okf-1/ /oid) os)0
%%Check that the xterm height is sufficient - *very* important if there are any PageUp or PageDown operations in the session.
os %q$=window; f/ screenHeight = /-oid (o>\, %X=Original max screen height was '~ - you should adjust your xterm to that height at least.;, )
osmf1/ screenWidth = /-oid (o>\, %X=Original max screen width was '~ - you should adjust your xterm to that width at least.;, )
%%Set the initial term dimensions.
zjm-0f/%%Recovery terminal size:/- oid oid oszooo/%%L=%d /r0oo/%d;/r0b
%%Deal with any detected invalid commands and escape sequences now.
zjm-0 (f/<Invalid command>/ r-0i/%%  /m-i//((v//s/{Esc}/, ) f1//b, )m2)0 
zjm-0 (f/<Invalid escape sequence>/r-0i/%%  /m(v//e2i/%%  {Esc}{Esc}/b, ))0
%%  

%%If there was a startup file, use the name-check path - the original startup was called directly not by %R=...
zjm-0 
( f/%%Startup script/m 
  zoi/%%Re-run the startup script from the journal area./b 
  zjn.f1/, Original pathname: /- oidrn.orac& zoi/%r=/hcr0i/;/b 
  %%Copy startup-script pathname translations etc.
  zjr-0n.f/%%Startup sequence ends/m
, %%No startup file.
  zjm-0f/%%Startup Sequence ends/n.m )
ac&zohc
    
%%Add a few recovery-specific translations to the escape-sequence-translation buffer.
zoi"obz^m-0i/^[<<DEL>>    i`## `e-(e-, j-)/b   i/^[<<INS>>    i`## `e-/b  i/^[<<BRK>>    i`## `e-/b  oz"b
%%If there were -init commands, these follow here.
(zjv/%%Init commands follow/ n.m2ac& zohc, )

( %%Main loop - translate history into a recovery script. 
  %%Pick up the keycode and the string argument.
  zj n.r0ac&m
  ( %%Is this a readFile operation, a keycode or some text?
    %%Comment out failed reads.
    zcv/%%Read file failed/ i.//.zom-r-0i.//.m, 
    %%Nobble the %s=commandstring lines, the actual string is going to appear in the next line anyway.
    zc 
    %%Remove command-file calls.
    f1/%%Running script /,
    %%Suppress <Esc I> - we don't need screen-enter mode and it just make life too confusing.
    zc(v/I       /\v/i       /\)\ zoi/%%InsertMode suppressed/b, 
    %%
    %%Any changes to the following code needs careful testing - verify that recovery session correctly follows:
    %%  - "opt " - %s=tracedefault +40; must appear before command line.
    %%  - "(r, m, m-0)0 ... {Ctrl+c}" - must be at *exactly* the same character as original session.
    %%  - "{Ctrl+c}" - typing {{Ctrl+c} to the command prompt should not upset it.
    %%  - "t (r)0 {Return}*10 {Ctrl+c} oco?" - typing Ctrl+c to the debugger prompt should exit the loop at exactly the right point.
    %%  - "G0{Return} a{Return} ... {Ctrl+c}" - G exits at the correct point with no commands leaking into the G stream.
    %%  
    %% <<INT n>> %%Each of the three identifiable flavours needs specific handling.
    zcv/<<INT /
    ( zjm(v/%%G-command terminated/m-, m-?\)
      n.mac&m zci/:/bi/%%Original G command terminated by {Ctrl+c}/bi/m-/r0bzohc
    , zcv/<<INT 0>>/ %%Interrupt while sitting in the command-read loop of an interactive or debugger session.
      zom-i/%s=tracedefault -40; %s=trace 0; %x=Interrupt in original session.;/bm
    , %%Else - interruping a long loop/macro/script, if followed by a %%Debugger off line then ignore this.
      %%Otherwise place the commandcounter setting before the launching command.
      zj(v/%%Debugger off/ zoi/%s=trace 0; %x=Original session was interrupted here.;/b, 
        zcr7oid f1/>> /-oid ol0oso- zoomoo/%%s=commandcounter %d;  / bmi/%s=tracedefault -40; %s=trace 0; %x=Original session was interrupted here.;/bn.ac), ),
    %% %%Debugger on/off events.
    %%N.B. it is possible that the T command was not on the previous line - e.g: op t - then the query line appears next.
    zcv/%%Debugger / f1/ /(v/ on / r4oid zoo#ol0oso-omi/%s=tracedefault +40;/bom zj(r\m)0r-, v/ off/zoi/%s=trace 0;/b), 
    %%Keep going if we're looking at a secondhand history file (i.e. the session has been restored and crashed again).
    v/%%Recovery session pid / zoi'cb zjf/%%Startup Sequence ends,/m, 
    %%Prevent session-termination commands passing through.
    zc (v/%a/\ v/%c/\)\i/%%  /zohcb,
    %%Anything else passes straight through.
    zohcb )
  )0

%%Now post-hoc tweaking of the %% %s=commandstring lines.
%%These might be wrapped up in a longer string of commands so, rather than attempting to comment these out, convert to a harmless message.
zom-0 (f/%s=commandstring/ i/%M=/m(f1//m, ))0
  
:
'#
 
zo (m-v/%a/r2 (v/ /, r\) r-0i/%%  /m, m)
i/%%Re-enable file writing./b
i/%s=recoverymode 0/b
%b=pathname ./recover_now.jot
%o
  
%%Final tidy up before recovery.
%q~=system; f/Buffers:/ (z~mf1/  buffer /- (v/$/, oic n.a$z$oo/n.a%c/ '$))0
z.n.a$
o@
%%Clear out all buffers before restarting.
%r=freeall

%%Do it.
%r=recover_now.jot -asConsole;
