%%Defines the hot-keys, functions and function mappings for emacs-like operation.
%%
%%
%%    Copyright (C) 2017-2018 Jon. Easterbrook
%%
%%    This file is part of jot (Joy Of Text - a text editor).
%%
%%    jot is free software: you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation, either version 3 of the License, or
%%    (at your option) any later version.
%%
%%    jot is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with jot.  If not, see <https://www.gnu.org/licenses/>.
%%
%%
%%

%g?
  Typical usage:
$ jot <file> -st=fake_emacs
  or
$ jot <file> -st="fake_emacs [ -<ption1>][ -<otion2> ... ]]"
  
  Valid options:
    - -debug  -- Reduces the eindow size in order to display more console messages.
    - -test   -- Stops it starting the fake_emacs command scanner.
:

%%Set up hash table and region tag.
%h.=create 100; 
%%
%%First pick up any user-specified args.
obz$m-0n.r0a~&
%h=setdata -new .=Args;
r-0i/ /r0i/ /
r-0(f1/ -test /ol1, ol0) %h=setdata -new .=Test;
r-0(f1/ -debug /ol1, ol0) %h=setdata -new .=Debug;
%%
%b=tagtype -colour=0:7 Region; 
%b=tagtype -colour=0:5 Substring; 
%%
%%Region data - setting the region-start character negative indicates that there os no current region.
%h=data .=RegionTopLine;  ol0ov/.=RegionTopLine/  %h=data .=RegionTopChr; ol-1ov/.=RegionTopChr/
%h=data .=RegionBotLine;  ol0ov/.=RegionBotLine/  %h=data .=RegionBotChr; ol-1ov/.=RegionBotChr/  
%h=data .=RegionTopOrBot; ol0ov/.=RegionTopOrBot/
%h=data .=SearchSubstring; n.a~& ov/.=SearchSubstring/
%%The kill ring.
%h=data .=killRing; n.a~&  z~%h=create 100; z. ov/.=killRing/   
%h=data .=killRing|killIndex; ol0 ov/.=killRing|killIndex/
%h=data .=killRing|thisKill; ol0 ov/.=killRing|thisKill/
%%
%%Start the minibuffers at jot-buffer A (ASCII-code 65).
%h=data .=CurrentMinibuffer; ol65ov/.=CurrentMinibuffer/
%%
oz

%%Call the standard startup fake_emacs is being run as a -startup.
ob( z'm-0m, %r=startup; )oz
  
%%Pick up the cursor keys for the key-map later.
obn.a!&  z@m-0(f/Arrow}/(f-1/+/\na!+, m) )0 oz

%%
%g@=Fake emacs functions
<<emacs_QuitDebugger>>
%% {Esc q} - exit the jot debugger, returning to emacs-style command mode.
%s=trace 0; %s=commandmode 12;
  
<<emacs_EnterJotMode>>
%%Returns from emacs insert mode to normal jot editing mode
ob %q$=system; %m=Currently in emacs mode; f/Verbosity = /r-0p f/Command mode = /r-0p oz
%%
%s=verbose 3;
%s=commandmode 0;
%m=Returning to jot command mode.
x3
  
<<emacs_Exit>>
%%  {Ctrl+x Alt+c}		exit Emacs permanently ;
%A=Normal fake_emacs exit.;
  
<<emacs_ReadFile>>
%%  {Ctrl+x Ctrl+f}		read a file into Emacs ;
%%Setup initial search path.
ob %q$=buffer; f/ pathName = /-b-k-0r0(f-1./.-b, e-0i"./"m)k0 oz
( %%Search loop. 
  %%Prompt and pick up next character of search string.
  %s=verbose 3; %s=prompt Find file: &'$; og 
  %%Erase last character and re-prompt on backspace.
  olx7Fo=ok
, %%Exit on {Return} - (ASCII-code 10).
  ol10o=\ 
  %%Add character to the pathname and return to original point.
  obz$r0osoo/%c/oz )0 k
%s=verbose 0; %s=prompt > ;
%%Check that the file exists and is readable.
okob %q@=file '$; (f/writable by this UID = yes/oz, m-0f/nonexistent/oz %x=Error: File &'$& not found;, oz %M=File &'$& is not writable; )
%%Identify the next available minibuffer and read the file into that buffer (A, B, ...).
oq/.=CurrentMinibuffer/o#o~ov/.=CurrentMinibuffer/ z$r-0oo/%%i%c=/r0i/;/ '$ 
  
<<emacs_SaveFileImage>>
%%  %m={Ctrl+x Ctrl+s}		save a file back to disk ;
%o;
  
<<emacs_SaveAllFiles>>
%m={Ctrl+x s}		save all files ;
  
<<emacs_PromptAndPckUpPathName>>
%%Set up prompt - the current file's path.
ob %q$=buffer; f/pathname = /-e-0r0(f-1"/"-e0, e-0i"./")mk0m-k-0 %s=prompt Find alternate file: '$;
( %%Path-character loop.
  ( %%Path-character block.
    z$og
    olx7Fo=ok  %%It was a backspace - erase one character from the existing pathname.
    r0e-
  , ol3o=ok %% {Ctrl+c} - exit the search with a fail.
    %m=File search abandonded by {Ctrl+C};
    x2\
  , ol10o=ok %% {Return} - exit the search with success.
    x2
  , ol9o=ok    %%  {Tab} check path.
    %%Select only files matching the latest incompletely-defined pathname.
    f-1"/"b- %q-=dir '$; k(v/./r(v/./r,)v"/"k, m)0 z$me z-m-0 (v'$m, k)0
    %%For each subsequent character, if all the other entries are the same then fold those entries.
    (z$r0oc z-m-0o#oroic(m, z$r-0e0i'-x2 ) (oso#orosoico=m)0 oso#orosoic(o=, x2) z$r0oo/%lc/ ok)0 okok z$j-i"/"
    %%If there's only one entry left than that's our man.
    m0onol1(o=okx, ok)
    o#oz %h'=call PopupRestore;  %w=refresh; 
  , %%Append the latest character to the pathname.
    r0oo/%lc/ )
  %%Redefine the prompt string.
  %s=prompt Find alternate file: '$; )0
%h'=call PopupReset;
oz %s=prompt > ;

<<emacs_PromptAndPckUpPathName_OLD>>
%%Set up prompt - the current file's path.
ob %q$=buffer; f/pathname = /-e-0r0(f-1"/"-e0, e-0i"./")mk0m-k-0 %s=prompt '$;
%%Prompt and pick up filename.
z$r0bg
%%Reset prompt.
%s=prompt > ;
%%Join path to name and read the secondary file.
m-0ji"/" oz

<<emacs_InsertFileImage>>
%%  %m={Ctrl+x i}		insert contents of another file into this buffer ;
%h'=call emacs_PromptAndPckUpPathName;
%%Return to original buffer and insert secondary file.
ob %i@='$; ozh@
  
<<emacs_ReplaceFileImage>>
( %h'=call emacs_PromptAndPckUpPathName;
  %%Read file image to current buffer.
  %i='$; y0, %m=Error: file &'$& not found.; )
  
<<emacs_WriteToPathName>>
%%  %m={Ctrl+x Ctrl+w}		write buffer to a specified file ;
%h'=call emacs_PromptAndPckUpPathName;
%%Write;
%o='$;
  
<<emacs_ToggleReadOnly>>
%%  %m={Ctrl+x Ctrl+q}		toggle read-only status of buffer ;
%%Get surrent status of buffer.
ob %q$=buffer; f/ editLock = /r0(v-/ReadOnly/ %b=unrestricted;, %b=readonly;)
  
<<emacs_Help>>
%m={Ctrl+h} (or F1)}		and follow the directions. The help system is simple. Type ;
  
<<emacs_HelpTutorial>>
%m={Ctrl+h t}		For a tutorial. If you are a first-time user, type ;
  
<<emacs_HelpClose>>
%m={Ctrl+x 1}		remove help window ;
  
<<emacs_HelpScroll>>
%m={Ctrl+Alt+v}		scroll help window ;
  
<<emacs_HelpApropos>>
%m={Ctrl+h a}		apropos: show commands matching a string ;
  
<<emacs_HelpDescribeKey>>
%m={Ctrl+h k}		describe the function a key runs ;
  
<<emacs_HelpFunction>>
%m={Ctrl+h f}		describe a function ;
  
<<emacs_HelpMode>>
%m={Ctrl+h m}		get mode-specific information ;
  
<<emacs_RecoverSession>>
%m={Alt+x} recover-session		recover files lost by a system crash;
  
<<emacs_Undo>>
%m={Ctrl+x u}, {Ctrl+_} or {Ctrl+/}		undo an unwanted change ;
  
<<emacs_RestoreOriginal>>
%%  %m={Alt+x} revert-buffer		restore a buffer to its original contents;
%i;

<<emacs_IncrementalSearchNext>>
%% {Ctrl+S}  - Incremental search.
%%Note starting position.
onocof
%%Initialize.
oboq/.=SearchSubstring/z~m-0k0 z$okm-0k0oz
( %%Search loop. 
%%  obz$pozo?
  %%Set up prompt and pick up next character of search string.
  %s=prompt Search string ( {Ctrl+G} to exit) > &'$; og 
  %%Clear any old substring tags.
  %h'=call emacs_ClearSubstringTags;
  ( %%Character block.
    olx7Fo=ok  %% Erase last character and re-prompt  {Backspace}
    ob (oq/.=SearchSubstring/z~m-0r0e-? n.r-0a$& osozok, ) obz$r-0(rozx, ozx-3)
  , ol7o=(ok)4  %%Exit search {Ctrl+g}
    %m=Normal exit from fake-emacs incremental search; 
    x2
  , ol10o=ok  %%Next page {Return}
    %h'=call emacs_GetWindowHeight; ofo+ono-ol1o-omr0 oboq/.=SearchSubstring/z~r-0n.r0a$&osozok
  , %%Any other character is added to the search string.
    obos oq/.=SearchSubstring/ z~osr0oo/%lc/n.r-0a$& osozok )
  %%
  %%Find first instance of the updated string - shift view if necessary, if not found then return to starting point.
  of ( (obz$r-0roz, ozx-2)f'$, %m=Failed to find instances of "&'$&"; okono-omor ono-ow onocofx-2 )
  %%If it's moved off the current screen, move to top of screen.
  ( %w=refresh;  ofo=ok, onofo-owok) oconof
  %%
  ( %%Subsequent-instances loop - highlight only those currently in view.
    %b=addtag Substring;
    %%Find next on-screen instance.
    f'$ ofo=)0
  %%Return to first-found instance and restore view.
  osono-omosorono-ow %l; w
 )0
%%Exit.
%s=prompt > ;

<<emacs_IncrementalSearchPrev>>
%% {Ctrl+R}  - Incremental reverse search.
%%Note starting position.
onocof
%%Initialize.
oboq/.=SearchSubstring/z~m-0k0 z$okm-0k0oz
( %%Search loop. 
%%  obz$pozo?
  %%Set up prompt and pick up next character of search string.
  %s=prompt Search string ( {Ctrl+G} to exit) > &'$; og 
  %%Clear any old substring tags.
  %h'=call emacs_ClearSubstringTags;
  ( %%Character block.
    olx7Fo=ok  %% Erase last character and re-prompt  {Backspace}
    ob (oq/.=SearchSubstring/z~m-0r0e-? n.r-0a$& osozok, ) obz$r-0(rozx, ozx-3)
  , ol7o=(ok)4  %%Exit search {Ctrl+g}
    %m=Normal exit from fake-emacs incremental search; 
    x2
  , ol10o=ok  %%Next page {Return}
    %h'=call emacs_GetWindowHeight; ofo+ono-ol1o-omr0 oboq/.=SearchSubstring/z~r-0n.r0a$&osozok
  , %%Any other character is added to the search string.
    obos oq/.=SearchSubstring/ z~osr0oo/%lc/n.r-0a$& osozok )
  %%
  %%Find first instance of the updated string - shift view if necessary, if not found then return to starting point.
  of ( (obz$r-0roz, ozx-2)f-'$, %m=Failed to find instances of "&'$&"; okono-omor ono-ow onocofx-2 )
  %%If it's moved off the current screen, move to top of screen.
  ( %w=refresh;  ofo=ok, onofo-owok) oconof
  %%
  ( %%Subsequent-instances loop - highlight only those currently in view.
    %b=addtag Substring;
    %%Find next on-screen instance.
    f-'$ ofo=)0
  %%Return to first-found instance and restore view.
  osono-omosorono-ow %l; w
 )0
%%Exit.
%s=prompt > ;

<<emacs_SearchHistoryPrev>>
%m={Alt+p}		select previous search string ;
  
<<emacs_SearchHistoryNext>>
%m={Alt+n}		select next later search string ;
  
<<emacs_SearchExit>>
%m={-}		exit incremental search ;
  
<<emacs_UndoChr>>
%m={delete}		undo effect of last character ;
  
<<emacs_GotoChrBack>>
%%  {Ctrl+b}		previous character;
(r-, m-r0) y0 %h'=call emacs_PostMovement;
  
<<emacs_GotoChrForwards>>
%%  {Ctrl+f}		next character ;
(r, m) y0 %h'=call emacs_PostMovement;
  
<<emacs_GotoWordBack>>
%%  {Alt+b}		previous word;
%h'=call emacs_BackwardsWord; %h'=call emacs_PostMovement;
  
<<emacs_GotoWordForwards>>
%%  {Alt+f}		next word ;
%h'=call emacs_ForwardsWord; %h'=call emacs_PostMovement;
  
<<emacs_UpInColumn>>
%%  {Ctrl+p}		previous line;
y- %h'=call emacs_PostMovement;
  
<<emacs_DownInColumn>>
%%  {Ctrl+n}		next line ;
y %h'=call emacs_PostMovement;
  
<<emacs_GotoLineStart>>
%%  {Ctrl+a}		go to line beginning;
r-0 y0 %h'=call emacs_PostMovement;
  
<<emacs_GotoLineEnd>>
%%  {Ctrl+e}		go to line end;
r0 y0 %h'=call emacs_PostMovement;
  
<<emacs_GotoSentanceStart>>
%%  {Alt+a}		sentence start;
%h'=call emacs_BackwardsSentance; %h'=call emacs_PostMovement;
  
<<emacs_GotoSentanceEnd>>
%%  {Alt+e}		sentence end;
%h'=call emacs_ForwardsSentance; %h'=call emacs_PostMovement;
  
<<emacs_GotoParaStart>>
%%  {Alt+{}		paragraph back;
m- (rm- (v/ /r)0 )0 r-0 %h'=call emacs_PostMovement;
  
<<emacs_GotoParaEnd>>
%%  {Alt+}}		paragraph forwards;
m (rm (v/ /r)0)0 r-0 %h'=call emacs_PostMovement;
  
<<emacs_GotoPageStart>>
%%  {Ctrl+x[}		page up;
m-0 %h'=call emacs_PostMovement;
  
<<emacs_GotoPageEnd>>
%%  {Ctrl+x]}		page down;
m0 %h'=call emacs_PostMovement;
  
<<emacs_GotoSexpStart>>
%%  {Ctrl+Alt+b}		sexp backwards;
%h'=call emacs_BackwardsMatchSexp; %h'=call emacs_PostMovement;
  
<<emacs_GotoSexpEnd>>
%%  {Ctrl+Alt+f}		sexp forwards;
%h'=call emacs_ForwardsMatchSexp; %h'=call emacs_PostMovement;
  
<<emacs_GotoFunctionStart>>
%%  {Ctrl+Alt+a}		function backwards;
%h'=call ParagraphUp; %h'=call emacs_PostMovement;
  
<<emacs_GotoFunctionEnd>>
%%  {Ctrl+Alt+e}		function forwards ;
%h'=call ParagraphDown; %h'=call emacs_PostMovement;
  
<<emacs_GotoBufferStart>>
%%  {Alt+<}		go to buffer beginning;
m-0 %h'=call emacs_PostMovement;
  
<<emacs_GotoBufferEnd>>
%%  {Alt+>}		go to buffer end;
m0 %h'=call emacs_PostMovement;
  
<<emacs_GotoPagePrev>>
%%  {Alt+v}		scroll to previous screen ;
m-0 %h'=call emacs_PostMovement;
  
<<emacs_GotoPageNext>>
%%  {Ctrl+v}		scroll to next screen ;
m* %h'=call emacs_PostMovement;
  
<<emacs_ViewScrollLeft>>
%%  {Ctrl+x <}		scroll left ;
%q=inview;? okoko~%b=leftoffset '~;
  
<<emacs_ViewScrollRight>>
%%  {Ctrl+x >}		scroll right ;
%q=inview;? okokol0(o>\okol0, ol-1o+) %b=leftoffset '~;
  
X021F
<<emacs_ViewCentTopBot>>
%%  {Ctrl+l}		scroll current line to center, top, bottom ;
onof
( o= %%Currently at top of screen - move toBottom.
  obo#z$m-0k0oo/( %c )/ %q@=window; f'$f1/), /-oidobomm-
, %%Test for cursor at end of window.
  obo#z$m-0k0oo/( %c )/ %q@=window; f'$f1/), /-oidosozoso+
  o= %%Yes we're at the end of the window - move to centre.
  oboidosozol0o-ol2o/omm
, %%From anywhere else move to Top.
  obofono-om )
  
<<emacs_GotoLineNo>>
%%  {Alt+g g}		goto line ;
ob %s=prompt Goto line: ; z$g m-oid osozono-om %h'=call emacs_PostMovement;
  
<<emacs_GotoChrNo>>
%%  {Alt+g c}		goto char ;
ob %s=prompt Chr: ; z$g m-oid osozm-0 (r0oco- ol0o<\m)0 oco+r-0or %h'=call emacs_PostMovement;
  
<<emacs_GotoFirstNonBlank>>
%%  {Alt+m}		back to indentation ;
r-0(q/ 	/r)0 %h'=call emacs_PostMovement;
  
<<emacs_DeleteChrPr>>
%%character delete back, not kill  {Ctrl+?}
n.r-a%-
  
<<emacs_DeleteChrNx>>
%%Character delete forwards, not kill  {Ctrl+d}
n.ra%+
  
<<emacs_abstractKill>>
%%Called by various emacs delete and kill functions, abstracts region to the kill ring.
oq/.=killRing|killIndex/o~o#o# n.a$& z$oo/Kill %d/ ov/.=killRing|'$/ ov/.=killRing|thisKill/

<<emacs_RegionKill>>
%%Removes all text in selected region  {Ctrl+W}
n. oq/.=RegionTopLine/ono-om oq/.=RegionTopChr/or a~
%%Add to kill ring.
%h'=call emacs_abstractKill;
  
<<emacs_DeleteWordNx>>
%%word-delete forwards   {Esc d}
n.(q/a-zA-Zo-0_/r)0 %h'=call emacs_abstractKill;
  
<<emacs_DeleteWordPr>>
%%  {Alt+}		Word-delete backwards.;
n.  %h'=call emacs_BackwardsWord;  a%-
  
<<emacs_DeleteToLineStart>>
%%  {Alt+0 Ctrl+k}		Delete line (backwards to start of);
n.r-0a%-
  
<<emacs_DeleteToLineEnd>>
%%  {Ctrl+k}		Delete line (forwards to end of) ;
n.r0a%+
  
<<emacs_DeleteToSentanceEnd>>
%%  {Ctrl+x DEL}		Delete sentance, forwards to end.;
n.  %h'=call emacs_ForwardsSentance;  a%+
  
<<emacs_DeleteToSentanceStart>>
%%  {Alt+k}		Delete sentence, backwards to start.;
n.  %h'=call emacs_BackwardsSentance;  a%-
  
<<emacs_DeleteSexpForwards>>
%%  {Ctrl+Alt+k}		Delete sexp forwards.;
n. %h'=call emacs_ForwardsMatchSexp; a%+
  
<<emacs_DeleteSexpBackwards>>
%m={Alt+- Ctrl+Alt+k}		Delete sexp backwards.;
n. %h'=call emacs_BackwardsMatchSexp; a%-

<<emacs_RegionCopy>>
%%Copy region to kill ring  {Alt+w}
n. oq/.=RegionTopLine/ono-om oq/.=RegionTopChr/or a_
  
<<emacs_KillToChar>>
%m={Alt+z} char		kill through next occurrence of char ;
  
<<emacs_YankLastKilled>>
%%Yank back last thing killed {Ctrl+Y}
h_
  
<<emacs_YankReplaceKill>>
%m={Alt+y}		replace last yank with previous kill ;
  
<<emacs_MarkHere>>
%%Set emacs mark position  {Ctrl+Space}
onov/.=RegionTopLine/ ocov/.=RegionTopChr/
%m=Mark set;
  
<<emacs_SwapMark>>
%m={Ctrl+x Ctrl+x}		exchange point and mark ;
  
<<emacs_RegionMarkNWords>>
%m={Alt+@}		set mark arg words away ;
  
<<emacs_MarkParagraph>>
%m={Alt+h}		mark paragraph ;
  
<<emacs_MarkPage>>
%m={Ctrl+x Ctrl+p}		mark page ;
  
<<emacs_MarkSexp>>
 %m={Ctrl+Alt+@}		mark sexp ;
  
<<emacs_MarkFunction>>
%m={Ctrl+Alt+h}		mark function ;
  
<<emacs_MarkBuffer>>
%m={Ctrl+x h}		mark entire buffer ;
  
<<emacs_ReplaceText>>
%m={Alt+%}		interactively replace a text string ;
  
<<emacs_RegxReplace>>
%m={Alt+x} query-replace-regexp		using regular expressions ;
  
<<emacs_RecursiveEdit>>
    %m={Ctrl+r}		enter recursive edit ({Ctrl+Alt+c to exit) ;
  
<<emacs_WindowDeleteallButCurrent>>
%m={Ctrl+x 1} {Ctrl+x 5 1}		delete all other windows ;
  
<<emacs_WindowHorizSplit>>
%m={Ctrl+x 2 {Ctrl+x 5 2}		split window, above and below ;
  
<<emacs_WindowDeleteCurrent>>
%m={Ctrl+x 0 {Ctrl+x 5 0}		delete this window ;
  
<<emacs_WindowVertSplit>>
%m={Ctrl+x 3}		split window, side by side ;
  
<<emacs_ScrollOtherWindow>>
%m={Ctrl+Alt+v}		scroll other window ;
  
<<emacs_WindowSwapFocus>>
%m={Ctrl+x o}		switch cursor to another window ;
  
<<emacs_FrameSwapFocus>>
%m={Ctrl+x 5 o}		switch cursor to another frame ;
  
%%<<emacs_FrameSwapFocus>>
%%%m={Ctrl+x 5 b}		select buffer in other frame ;
  
<<emacs_WindowSwap>>
%m={Ctrl+x 4 b}		select buffer in other window ;
  
<<emacs_WindowDisplayBuffer>>
%m={Ctrl+x 4 Ctrl-o}		display buffer in other window ;
  
<<emacs_FrameDisplayBuffer>>
%m={Ctrl+o Ctrl+x 5 Ctrl+o}		display buffer in other frame ;
  
<<emacs_WindowFile>>
%m={Ctrl+x 4 f}		find file in other window ;
  
<<emacs_FrameFile>>
%m={Ctrl+x 5 f}		find file in other frame ;
  
<<emacs_WindowROFile>>
%m={Ctrl+x 4 r}		find file read-only in other window ;
  
<<emacs_FrameROFile>>
%m={Ctrl+x 5 r}		find file read-only in other frame ;
  
<<emacs_WindowDired>>
%m={Ctrl+x 4 d}		run Dired in other window ;
  
<<emacs_FrameDired>>
%m={Ctrl+x 5 d}		run Dired in other frame ;
  
<<emacs_WindowGotoTag>>
%m={Ctrl+x 4 .}		find tag in other window ;
%h'=call emacs_PostMovement;
  
<<emacs_FrameGotoTag>>
%m={Ctrl+x 5 .}		find tag in other frame ;
%h'=call emacs_PostMovement;
  
<<emacs_WindowTaller>>
%m={Ctrl+x =		grow window taller ;
  
<<emacs_WindowSlimmer>>
%m={Ctrl+x {}		shrink window narrower ;
  
<<emacs_WindowFatter>>
%m={Ctrl+x }}		grow window wider ;
  
<<emacs_IndentRegion>>
%m={Ctrl+Alt+\}		indent region (mode-dependent) ;
  
<<emacs_IndentSexp>>
%m={Ctrl+Alt+q}		indent sexp (mode-dependent) ;
  
<<emacs_IndentRegionTab>>
%m={Ctrl+x TAB}		indent region rigidly arg columns ;
  
<<emacs_IndentForComment>>
%m={Alt+;}		indent for comment ;
  
<<emacs_Break>>
%m={Ctrl+o}		insert newline after point ;
  
<<emacs_BreakShift>>
%m={Ctrl+Alt+o}		move rest of line vertically down ;
  
<<emacs_DeleteSurroundingBlankLines>>
%m={Ctrl+x Ctrl+o}		delete blank lines around point ;
  
<<emacs_JoinPrev>>
%m={Alt+=		join line with previous (with arg, next) ;
  
<<emacs_DeleteSurroundingBlanks>>
%% %m={Alt+\}		delete all white space around point ;
(v-/ /e-)0(v/ /e)0
  
<<emacs_InsertBlank>>
%m={Alt+SPC}		put exactly one space at point ;
  
<<emacs_ParagraphFill>>
%m={Alt+q}		fill paragraph ;
  
<<emacs_FillColumn>>
%m={Ctrl+x f}		set fill column to arg ;
  
<<emacs_PrefixSet>>
%m={Ctrl+x .}		set prefix each line starts with ;
  
<<emacs_FaceSet>>
%m={Alt+o}		set face ;
  
<<emacs_UppercaseWord>>
%m={Alt+u}		uppercase word ;
  
<<emacs_LowercaseWord>>
%m={Alt+l}		lowercase word ;
  
<<emacs_CapitalizeWord>>
%m={Alt+c}		capitalize word ;
  
<<emacs_uppercaseRegion>>
%m={Ctrl+x Ctrl+u}		uppercase region ;
  
<<emacs_LowercaseRegion>>
%m={Ctrl+x Ctrl+l}		lowercase region ;
  
<<emacs_CompleteAll>>
%m={TAB}		complete as much as possible in minibuffer.;
i/	/
  
<<emacs_CompleteWord>>
%m={SPC}		complete up to one word in minibuffer.;
i/ /
  
<<emacs_CompleteAndExecute>>
%m={-}		complete and execute in minibuffer. ;
  
<<emacs_CompleteSuggestions>>
%m={?}		show possible completions in minibuffer. ;
  
<<emacs_PreviousInput>>
%m={Alt+p}		fetch previous minibuffer input ;
  
<<emacs_LaterInput>>
%m={Alt+n}		fetch later minibuffer input or default ;
  
<<emacs_HistorySearchBack>>
%m={Alt+r}		regexp search backward through history ;
  
<<emacs_HistorySearchForwards>>
%m={Alt+s}		regexp search forward through history ;
  
<<emacs_HistoryRepeat>>
%m={Ctrl+x Ctrl+[ Ctrl+[}		to edit and repeat the last command that used the minibuffer. Type F10 to activate menu bar items on text terminals.;
  
<<emacs_BufferSelect>>
%m={Ctrl+x b}		select another buffer ;
  
<<emacs_BufferList>>
%m={Ctrl+x Ctrl+b}		list all buffers ;
  
<<emacs_BufferKill>>
%m={Ctrl+x k}		kill a buffer ;
  
<<emacs_TransposeCharacters>>
n.(r-, i/ /)a$(r, m)h$
  
<<emacs_TransposeWords>>
%m={Alt+t}		transpose words ;
  
<<emacs_TransposeLines>>
%m={Ctrl+x Ctrl+t}		transpose lines ;
  
<<emacs_TransposeSexps>>
%m={Ctrl+Alt+t}		transpose sexps ;
  
<<emacs_SpellWord>>
%m={Alt+$}		check spelling of current word ;
  
<<emacs_SpellRegion>>
%m={Alt+x} ispell-region		check spelling of all words in region ;
  
<<emacs_SpellBuffer>>
%m={Alt+x} ispell-buffer		check spelling of entire buffer ;
  
<<emacs_SpellOnOff>>
%m={Alt+x} flyspell-mode		toggle on-the-fly spell checking ;
  
<<emacs_IndexFindDef>>
%m={Alt+.}		find a tag (a definition) ;
  
<<emacs_IndexFindNx>>
%m={Alt+.}		find next occurrence of tag ;
  
<<emacs_IndexFindPr>>
%m={Ctrl+u Alt+.}		Find previous occurrence of tag.;
  
<<emacs_IndexNewFile>>
%m={Alt+x} visit-tags-table	specify a new tags file ;
  
<<emacs_IndexSearchAllFiles>>
%m={Alt+x} tags-search		regexp search on all files in tags table ;
  
<<emacs_IndexQueryReplace>>
%m={Alt+x} tags-query-replace		run query-replace on all the files ;
  
<<emacs_IndexContinueSearch>>
%m={Alt+,}		continue last tags search or query-replace ;
  
<<emacs_ShellCommand>>
%m={Alt+!}		execute a shell command ;
  
<<emacs_ShellCommandNowait>>
%m={Alt+&}		execute a shell command asynchronously ;
  
<<emacs_ShellCommandRegion>>
%m={Alt+|}		run a shell command on the region ;
  
<<emacs_ShellCommandFilterRegion>>
%m={Ctrl+u Alt+|}		filter region through a shell command ;
  
<<emacs_ShellStartInWindow>>
%m={Alt+x} shell		start a shell in window *shell* ;
  
<<emacs_RectCopy>>
%m={Ctrl+x r r}		copy rectangle to register ;
  
<<emacs_RectKill>>
%m={Ctrl+x r k}		kill rectangle ;
  
<<emacs_RectYank>>
%m={Ctrl+x r y}		yank rectangle ;
  
<<emacs_RectOpen>>
%m={Ctrl+x r o}		open rectangle, shifting text right ;
  
<<emacs_RectBlank>>
%m={Ctrl+x r c}		blank out rectangle ;
  
<<emacs_PrefixLines>>
%m={Ctrl+x r t}		prefix each line with a string ;
  
<<emacs_AbbrAddGlobal>>
%m={Ctrl+x a g}		add global abbrev ;
  
<<emacs_AbbrAddLocal>>
%m={Ctrl+x a l}		add mode-local abbrev ;
  
<<emacs_AbbrAddGlobalExp>>
%m={Ctrl+x a i g}		add global expansion for this abbrev ;
  
<<emacs_AbbrAddLocalExp>>
%m={Ctrl+x a i l}		add mode-local expansion for this abbrev ;
  
<<emacs_AbbrExpand>>
%m={Ctrl+x a e}		explicitly expand abbrev ;
  
<<emacs_AbbrExpandPrev>>
%m={Alt+/}		expand previous word dynamically ;
  
<<emacs_PosArg>>
%m={Ctrl+u} num		numeric argument ;
  
<<emacs_NegArg>>
%m={Alt+-}		negative argument ;
  
<<emacs_String>>
%m={Ctrl+q} char		quoted insert ;
  
<<emacs_LanguageSet>>
%m={Ctrl+x - l}		specify principal language ;
  
<<emacs_LanguageListInput>>
%m={Alt+x} list-input-methods		show all input methods ;
  
<<emacs_LanguageInputToggle>>
%m={Ctrl+\}		enable or disable input method ;
  
<<emacs_LanguageSetCoding>>
%m={Ctrl+x - c}		set coding system for next command ;
  
<<emacs_LanguageListCoding>>
%m={Alt+x} list-coding-systems		show all coding systems ;
  
<<emacs_LanguagePrefer>>
%m={Alt+x} prefer-coding-system		choose preferred coding system ;
  
<<emacs_InfoStart>>
%m={Ctrl+h i}		enter the Info documentation reader ;
  
<<emacs_InfoFind>>
%m={Ctrl+h S}		find specified function or variable in Info ;
( %%Scan info command.  
  v/b/  %h'=call emacs_InfoNodeStart;               %%  b           --
, v/n/  %h'=call emacs_InfoNodeNext;                %%  n           --
, v/p/  %h'=call emacs_InfoNodePrev;                %%  p           --
, v/u/  %h'=call emacs_InfoUp;                      %%  u           --
, v/m/  %h'=call emacs_InfoSelName;                 %%  m           --
, v/n/  %h'=call emacs_InfoSelNumber;               %%  n           --
, v/f/  %h'=call emacs_InfoFollowLink;              %%  f           --
, v/l/  %h'=call emacs_InfoBack;                    %%  l           --
, v/d/  %h'=call emacs_InfoDir;                     %%  d           --
, v/t/  %h'=call emacs_InfoTop;                     %%  t           --
, v/g/  %h'=call emacs_InfoNode;                    %%  g           --
, v/h/  %h'=call emacs_InfoTutorial;                %%  h           --
, v/i/  %h'=call emacs_InfoLookup;                  %%  i           --
, v/s/  %h'=call emacs_InfoSearch;                  %%  s           --
, v/q/  %h'=call emacs_InfoQuit;                    %%  q           --
, %X=Invalid info request.;
  )

<<emacs_InfoScrollFwd>>
%m={spc}		scroll forward;
  
<<emacs_EraseCharacter>>
%%Erase character to the left of the cursor.
(e-, j-?) y0
  
<<emacs_InfoScrollRev>>
%m={DEL}		scroll reverse;
  
<<emacs_InfoNodeStart>>
%m={b}		beginning of node;
  
<<emacs_InfoNodeNext>>
%m={n}		next node;
  
<<emacs_InfoNodePrev>>
%m={p}		previous node;
  
<<emacs_InfoUp>>
%m={u}		move up;
  
<<emacs_InfoSelName>>
%m={m}		select menu item by name ;
  
<<emacs_InfoSelNumber>>
%m={n}		select nth menu item by number (1-9);
  
<<emacs_InfoFollowLink>>
%m={f}		follow cross reference (return with l);
  
<<emacs_InfoBack>>
%m={l}		return to last node you saw;
  
<<emacs_InfoDir>>
%m={d}		return to directory node;
  
<<emacs_InfoTop>>
%m={t}		go to top node of Info file;
  
<<emacs_InfoNode>>
%m={g}		go to any node by name;
  
<<emacs_InfoTutorial>>
%m={h}		run Info tutorial;
  
<<emacs_InfoLookup>>
%m={i}		look up a subject in the indices;
  
<<emacs_InfoSearch>>
%m={s}		search nodes for regexp ;
  
<<emacs_InfoQuit>>
%m={q}		quit Info;
  
<<emacs_RegSaveRegion>>
%m={Ctrl+x r s}		save region in register ;
  
<<emacs_RegInsertHere>>
%m={Ctrl+x r i}		insert register contents into buffer ;
  
<<emacs_RegSaveValue>>
%m={Ctrl+x r SPC}		save value of point in register ;
  
<<emacs_RegJump>>
%m={Ctrl+x r j}		jump to point saved in register ;
  
<<emacs_KbdDefineStart>>
%m={Ctrl+x (}		start defining a keyboard macro ;
  
<<emacs_KbdDefineEnd>>
%m={Ctrl+x )}		end keyboard macro definition ;
  
<<emacs_KbdExLast>>
%m={Ctrl+x e}		execute last-defined keyboard macro ;
  
<<emacs_KbdAppend>>
%m={Ctrl+u Ctrl+x (}		append to last keyboard macro ;
  
<<emacs_KbdName>>
%m={Alt+x} name-last-kbd-macro		name last keyboard macro ;
  
<<emacs_KbdLisp>>
%m={Alt+x} insert-kbd-macro		insert Lisp definition in buffer ;
  
<<emacs_EvalSesp>>
%m={Ctrl+x Ctrl+e}		eval sexp before point ;
  
<<emacs_EvalCurrent>>
%m={Ctrl+Alt+x}		eval current defun ;
  
<<emacs_EvalRegion>>
%m={Alt+x} eval-region		eval region ;
  
<<emacs_EvalRead>>
%m={Alt+:}		read and eval minibuffer ;
  
<<emacs_LoadLibLisp>>
%m={Alt+x} load-library		load a Lisp library from load-path ;
  
<<emacs_Customize>>
%m={Alt+x} customize		customize variables and faces ;
  
<<emacs_InteractiveSpec>>
%m={Ctrl+h f} interactive {RET}		The interactive spec says how to read arguments interactively.;
  
<<emacs_Interactive>>
%m={-}		interactive for more details.;

<<emacs_ForwardsMatchSexp>>
%%Called by various sexp-matching functions
%%Plods forwards one word until one of '(', '{' or '[' is encountered.
%%Then locates matching end brace.
%%
(rr-, m)
%%Skip past leading whitespace and linebreaks.
(q/ 	/(r, m))0
(
  q"A-Za-z0-9_+*/=-"  %%A word or expression - go to end.
  (q//r)0
, q/({[/   %%A bracketed expression starts - skip to end.
  %%Save start-brace point
  ocon
  ( v/(/ (ol0(v./*.f.*/., v/"/r(f1/"/v-/*/r)0r, v/'/f1/'/, q/(/ol1o-r, q/)/\(r, m, r0okol-1?\), o~r)0ok)?
  , v/{/ (ol0(v./*.f.*/., v/"/r(f1/"/v-/*/r)0r, v/'/f1/'/, q/{/ol1o-r, q/}/\(r, m, r0okol-1?\), o~r)0ok)?
  , v/[/ (ol0(v./*.f.*/., v/"/r(f1/"/v-/*/r)0r, v/'/f1/'/, q/[/ol1o-r, q/]/\(r, m, r0okol-1?\), o~r)0ok)? )
  (ocmm-orrokok, okono-omor %X=Error: Unbalanced parentheses.; )
, q/({[/ %x=Error: Containing expression ends prematurely;
, (q"(){}[]A-Za-z0-9_+*/=-"\r)0 )
  
<<emacs_BackwardsMatchSexp>>
%%Called by various sexp-matching functions
%%Plods backwards one word until one of ')', '}' or ']' is encountered.
%%Then locates matching open brace.
%%
(r-r, m-r0)
%%Skip past trailing whitespace and linebreaks.
(q-/ 	/(r-, m-r0))0
(
  q-"A-Za-z0-9_+*/=-"  %%A word or expression - go to start.
  (q-//r-)0
, q-/)}]/   %%A bracketed expression ends - skip back to start.
  %%Save end-brace point
  ocon
  ( v-/)/ (ol0(v.*/.f-./*., v/"/(r-f-1/"/v-/*/)0r-, v/'/f-1/'/r-, q/)/ol1o-r-, q/(/\(r-, m-r0), o~r-)0ok)?
  , v-/}/ (ol0(v.*/.f-./*., v/"/(r-f-1/"/v-/*/)0r-, v/'/f-1/'/r-, q/}/ol1o-r-, q/{/\(r-, m-r0), o~r-)0ok)?
  , v-/]/ (ol0(v.*/.f-./*., v/"/(r-f-1/"/v-/*/)0r-, v/'/f-1/'/r-, q/]/ol1o-r-, q/[/\(r-, m-r0), o~r-)0ok)? )
  (((r-r)\ (m-m\)\)\okok, ono-omor %X=Error: Unbalanced parentheses.; )
, q-/({[/ %x=Error: Containing expression ends prematurely;
, (q-"(){}[]A-Za-z0-9_+*/=-"\r-)0 )
  
<<emacs_BackwardsSentance>>
%%Called by emacs_GotoSentanceEnd etc - finds the start of the current or previous sentance.
%%
%%An emacs sentance sems to be a bunch of words terminated by a full stop followed by either:
%%  - end of line,
%%  - one blank at end of line or
%%  - two or more blanks,
%%
%%Step back through whitespace and line breaks - if chr is a fullstop then discount that one.
((q-/ 	/r-)0 r-\m-r0)0 (v/./f-/ /(v-/ /r-)0, )
%%Find the previous-sentance terminating fullstop, discount any that don't meet emacs sentance-ending criteria.
(f-/./- ( v/  /\ (v/ /r\)\ r r-) f-/./)0 
%%Advance to the start of the sentance.
((q/ 	/r)0 r\m)0 r-
  
<<emacs_ForwardsSentance>>
%%Called by emacs_GotoSentanceStart etc - finds the end of the current or next sentance.
%%
%%An emacs sentance sems to be a bunch of words terminated by a full stop followed by either:
%%  - end of line,
%%  - one blank at end of line or
%%  - two or more blanks,
%%
%%Much simpler than emacs_BackwardsSentance since we stop immediately after the terminating fullstop.
(f/./- ( v/  /\ (v/ /r\)\ r r-) )0 f-/./-
  
<<emacs_BackwardsWord>>
%%Called by emacs_GotoWordBack etc. moves back 1 word/non-word as emacs might.
(v-/ /r-)0(r-, m-r0) (q-/A-Za-z0-9_/\r-)0 (q-//r-)0 
y0
  
<<emacs_ForwardsWord>>
%%Called by emacs_GotoWordForwards etc. moves forwards 1 word/non-word as emacs might.
(r, m) (q/A-Za-z0-9_/\r)0 (q//r)0 
y0

<<emacs_PostMovement>>
%%Updates the region display etc. - called by all emacs functions that may have caused the cursor to move.
oq/.=RegionTopChr/ol0
( o<\  %%Non-negative RegionTopChr indicates that region is active - update region tags.
%%( o< %%Non-negative RegionTopChr indicates that region is active - update region tags.
  %%Remove all tags.
  %h'=call emacs_ClearRegionTags;
  %%Calculate lines range.
  ( oq/.=RegionTopLine/ on 
    ( o= %%Top and Bot lines are the same - compare Top and Bot Chrs and set Top or Bot parameters as appropriate.
      okoq/.=RegionTopOrBot/ (ol0o=onov/.=RegionTopLine/ ocov/.=RegionTopChr/, onov/.=RegionBotLine/ ocov/.=RegionBotChr/ )
    , ono<\ %%We're above the previous top of the region.
      okoq/.=RegionTopOrBot/( ol0o=onov/.=RegionTopLine/ ocov/.=RegionTopChr/, onov/.=RegionBotLine/ ocov/.=RegionBotChr/ )
    , %%We're below the previous top of region.
      okoq/.=RegionTopOrBot/( ol1o=onov/.=RegionBotLine/ ocov/.=RegionBotChr/, onov/.=RegionTopLine/ ocov/.=RegionTopChr/ ) ) ok
      %%Tag all untagged lines in the range - first set up line counter and go to the top line.
    oq/.=RegionTopLine/o# oq/.=RegionBotLine/o~o- 
    %%If there's been a crossover swap and redo the calculation of the counter.
    ol0 o<\ oq/.=RegionTopLine/oq/.=RegionTopChr/oq/.=RegionBotLine/oq/.=RegionBotChr/ ov/.=RegionTopChr/ov/.=RegionTopLine/ 
    ov/.=RegionBotChr/ov/.=RegionBotLine/ oq/.=RegionTopOrBot/o!ol1o&ov/.=RegionTopOrBot/
    )2?
  osono-om
, %%Not in an active region.
  ok )

<<emacs_ClearRegionTags>>
%%Removes any instance of a RegionTag and returns cursor to original position.
oconob %q$=tags; 
(f/Region/f-1/ At rec /-oidosozono-om obz$f1/, chr /-oidosf/ to /-oido~osoz oso#oro-ou %b=remove_tag -colour Region; obz$m)0
%%Return to original position.
ozono-omor  %w=refresh; 

<<emacs_ClearSubstringTags>>
%%Removes any instance of a Substring and returns cursor to original position.
oconob %q$=tags; 
(f/Substring/f-1/ At rec /-oidosozono-om obz$f1/, chr /-oidosf/ to /-oido~osoz oso#oro-ou %b=remove_tag -colour Substring; obz$m)0
%%Return to original position.
ozono-omor  %w=refresh; 

<<emacs_GetWindowHeight>>
%%Get overall size of window and allow for delimiter line, returns effective height in top of stack.
%%
ob %q@=window; z$m-0k0o#oo/ ( %c ), / z@f'$-oid (f1/end delimiter./ol1o-, )
%%Allow for header line.
oso#ozos %q@=buffer; (f/ Header = /-v/(null)/, ol1o-) osoz

<<emacs_KeyboardScanner>>
%%Called in jot mode, enters emacs insert mode
%%
ob %q$=system; %m=Currently in jot mode; f/Verbosity = /r-0p f/Command mode = /r-0p oz
ob %q$=system;
( %%Reset command mode as appropriate for current command-mode setting.
  f/ Command mode = /r0
  v-/12/ %%In emacs insert mode - change to emacs command mode.
  %s=commandmode 10;
  %s=verbose 0;
  %m=Returning to emacs command mode;
, v-/10/ %%In emacs info mode - change to emacs-insert mode.
  %m=Returning to emacs insert mode;
  %s=commandmode 12;
  %s=verbose 0;
, %%Catch all case turn off debugger etc. and return to emacs insert mode.
  %s=trace 0;
  %s=commandmode 12;
  %s=verbose 0;
  %m=Returning to emacs insert mode; )
oz
    
( %%emacs command loop - first clear the ( $ ) buffer.
  obz$m-0k0e0oz 
  %%Pick up sufficient characters to define the command.
  ( %%Part-command loop - some emacs command sequences are more than one character, this loop checks and assembles the complete command string.
    %w=refresh; og obosz$r0oo/%02X /oz
    %h^=testkey -type '$;
    ol4o=ok  %%Yes it's a call object.
    %h^=call -oneline '$;  %%Command is OK.
  , ol1o=ok  %%It's a data object, that's OK - read another byte.
    x-
  , %%If it's not a control character insert it into the text.
    obz$r0ocosoz ol3o= %%Yes it's just one character, insert it into the buffer.
    obz$r-0oix osoz (ol10o=okb, olx7Fo=ok(e-, j-), (rr-, )oo/%c/ y0)
  , %%Invalid command - report it.
    ob%qz=system; f/ Prompt string /poz
    %m=Error: Unrecognized emacs sequence "&'$&"; %d$=; oz )? )0

Fake emacs functions:
%h'=call AddNewFunctions;
  
%%Define keycodes  -  N.B: emacs_EnterJotMode marks the start of the emacs-style keymaps - do not add any above this one.
%g$=Fake emacs keymap
^[i         %h'=call emacs_KeyboardScanner;
1B 69                    %h'=call emacs_EnterJotMode;                %%  {Esc i}                  -- Return to sane command-driven operation.
7F                       %h'=call emacs_EraseCharacter;              %%  {Backspace}              -- Erase character to the left of the cursor.
1B 58 30 31 35           %h'=call emacs_PageDown;                    %%  {PageDown}               -- Move down by one page on the screen.
1B 58 30 31 35           %h'=call emacs_PageUp;                      %%  {PageUp}                 -- Move up by one page on the screen.
18 03                    %h'=call emacs_Exit;                        %%  {Ctrl+X Ctrl+C}          -- Exits without writing file.
18 06                    %h'=call emacs_ReadFile;                    %%  {Ctrl+X Ctrl+F}          -- Prompts and searches for matching file.
18 13                    %h'=call emacs_SaveFileImage;               %%  {Ctrl+X Ctrl+S}          -- Writes file image back out to disc.
18 53                    %h'=call emacs_SaveAllFiles;                %%  {Ctrl+X S}               -- 
18 69                    %h'=call emacs_InsertFileImage;             %%  {Ctrl+X i}               -- Insert another file at the current cursor position.
18 16                    %h'=call emacs_ReplaceFileImage;            %%  {Ctrl+X Ctrl+V}          -- Replaces current file image with that of some other file.
18 17                    %h'=call emacs_WriteToPathName;             %%  {Ctrl+X Ctrl+W}          -- Writes current buffer to specified pathnae.
18 11                    %h'=call emacs_ToggleReadOnly;              %%  {Ctrl+X Ctrl+Q}          -- Switches between readonly and unrestricted.
08 08                    %h'=call emacs_Help;                        %%  {Ctrl+H Ctrl+H}          -- Has no effect in mg
08 74                    %h'=call emacs_HelpTutorial;                %%  {Ctrl+H t}               -- Has no effect in mg
18 31                    %h'=call emacs_HelpClose;                   %%  {Ctrl+X 1}               -- Has no effect in mg
1B 16                    %h'=call emacs_HelpScroll;                  %%  {Esc Ctrl+V}             -- Has no effect in mg
08 61                    %h'=call emacs_HelpApropos;                 %%  {Ctrl+H a}               -- Has no effect in mg
08 6B                    %h'=call emacs_HelpDescribeKey;             %%  {Ctrl+H k}               -- Has no effect in mg
08 66                    %h'=call emacs_HelpFunction;                %%  {Ctrl+H f}               -- Has no effect in mg
08 6D                    %h'=call emacs_HelpMode;                    %%  {Ctrl+H m}               -- Has no effect in mg
1B 78                    %h'=call emacs_RecoverSession;              %%  {Esc x}                  -- Has no effect in mg
18 75                    %h'=call emacs_Undo;                        %%  {Ctrl+X u}               -- Not supported
1B 78                    %h'=call emacs_RestoreOriginal;             %%  {Esc x}                  -- Discards changes and reloads file (no effect in mg).
13                       %h'=call emacs_IncrementalSearchNext;       %%  {Ctrl+S}                 -- Searches forwards for next match to incrementally-defined string.
12                       %h'=call emacs_IncrementalSearchPrev;       %%  {Ctrl+R}                 -- Searches backwards for previous match to incrementally-defined string.
1B 13                    %h'=call emacs_SearchRexNext;               %%  {Esc Ctrl+S}             -- 
1B 12                    %h'=call emacs_SearchRexPrev;               %%  {Esc Ctrl+R}             -- 
1B 70                    %h'=call emacs_SearchHistoryPrev;           %%  {Esc p}                  -- 
1B 6E                    %h'=call emacs_SearchHistoryNext;           %%  {Esc n}                  -- 
0D                       %h'=call emacs_SearchExit;                  %%  {Ctrl+M}                 -- 
02                       %h'=call emacs_GotoChrBack;                 %%  {Ctrl+B}                 -- Backwards 1 Chr
06                       %h'=call emacs_GotoChrForwards;             %%  {Ctrl+F}                 -- Forwards 1 Chr.
1B 62                    %h'=call emacs_GotoWordBack;                %%  {Esc b}                  -- Backwards 1 word
1B 66                    %h'=call emacs_GotoWordForwards;            %%  {Esc f}                  -- Forwards 1 word
10                       %h'=call emacs_UpInColumn;                  %%  {Ctrl+P}                 -- Move up in column.
0E                       %h'=call emacs_DownInColumn;                %%  {Ctrl+N}                 -- Move down in column.
01                       %h'=call emacs_GotoLineStart;               %%  {Ctrl+A}                 -- To line start.
05                       %h'=call emacs_GotoLineEnd;                 %%  {Ctrl+E}                 -- To line end.
1B 61                    %h'=call emacs_GotoSentanceStart;           %%  {Esc a}                  -- 
1B 65                    %h'=call emacs_GotoSentanceEnd;             %%  {Esc e}                  -- 
1B 7B                    %h'=call emacs_GotoParaStart;               %%  {Esc {}                  -- 
1B 7D                    %h'=call emacs_GotoParaEnd;                 %%  {Esc}}                   -- 
18 5B                    %h'=call emacs_GotoPageStart;               %%  {Ctrl+X [}               -- 
18 5D                    %h'=call emacs_GotoPageEnd;                 %%  {Ctrl+X ]}               -- 
1B 02                    %h'=call emacs_GotoSexpStart;               %%  {Esc Ctrl+B}             -- 
1B 06                    %h'=call emacs_GotoSexpEnd;                 %%  {Esc Ctrl+F}             -- 
1B 01                    %h'=call emacs_GotoFunctionStart;           %%  {Esc Ctrl+A}             -- 
1B 05                    %h'=call emacs_GotoFunctionEnd;             %%  {Esc Ctrl+E}             -- 
1B 3C                    %h'=call emacs_GotoBufferStart;             %%  {Esc <}                  -- 
1B 3E                    %h'=call emacs_GotoBufferEnd;               %%  {Esc >}                  -- 
1B 76                    %h'=call emacs_GotoPagePrev;                %%  {Esc v}                  -- 
16                       %h'=call emacs_GotoPageNext;                %%  {Ctrl+V}                 -- 
18 3C                    %h'=call emacs_ViewScrollLeft;              %%  {Ctrl+X <}               -- 
18 3E                    %h'=call emacs_ViewScrollRight;             %%  {Ctrl+X >}               -- 
0C                       %h'=call emacs_ViewCentTopBot;              %%  {Ctrl+L}                 -- 
1B 67 67                 %h'=call emacs_GotoLineNo;                  %%  {Esc gg}                 -- 
1B 67 63                 %h'=call emacs_GotoChrNo;                   %%  {Esc gc}                 -- 
1B 6D                    %h'=call emacs_GotoFirstNonBlank;           %%  {Esc m}                  -- 
3F                       %h'=call emacs_DeleteChrPr;                 %%  {Ctrl+?}                 -- 
04                       %h'=call emacs_DeleteChrNx;                 %%  {Ctrl+D}                 -- 
1B 64                    %h'=call emacs_DeleteWordNx;                %%  {Esc d}                  -- 
1B 1B 58 30 31 34        %h'=call emacs_DeleteWordPr;                %%  {Esc Delete}             -- 
1B 30 0B                 %h'=call emacs_DeleteToLineStart;           %%  {Esc 0Ctrl+K}            -- 
0B                       %h'=call emacs_DeleteToLineEnd;             %%  {Ctrl+K}                 -- 
18                       %h'=call emacs_DeleteToSentanceEnd;         %%  {Ctrl+X Ctrl+?}          -- 
1B 6B                    %h'=call emacs_DeleteToSentanceStart;       %%  {Esc k}                  -- 
1B 2D 1B 0B              %h'=call emacs_DeleteSexpBackwards;         %%  {Esc - Esc Ctrl+K}       -- 
1B 0B                    %h'=call emacs_DeleteSexpForwards;          %%  {Esc Ctrl+K}             -- 
17                       %h'=call emacs_RegionKill;                  %%  {Ctrl+W}                 -- Removes defined region from current buffer.
1B 77                    %h'=call emacs_RegionCopy;                  %%  {Esc w}                  -- 
1B 7A                    %h'=call emacs_KillToChar;                  %%  {Esc z}                  -- 
19                       %h'=call emacs_YankLastKilled;              %%  {Ctrl+Y}                 -- 
1B 79                    %h'=call emacs_YankReplaceKill;             %%  {Esc y}                  -- 
00                       %h'=call emacs_MarkHere;                    %%  {Ctrl+Space}             -- 
18 18                    %h'=call emacs_SwapMark;                    %%  {Ctrl+X Ctrl+X}          -- 
1B 40                    %h'=call emacs_RegionMarkNWords;            %%  {Esc @}                  -- 
1B 68                    %h'=call emacs_MarkParagraph;               %%  {Esc h}                  -- 
18 10                    %h'=call emacs_MarkPage;                    %%  {Ctrl+X Ctrl+P}          -- 
1B                       %h'=call emacs_MarkSexp;                    %%  {Esc Ctrl+@}             -- 
1B 08                    %h'=call emacs_MarkFunction;                %%  {Esc Ctrl+H}             -- 
18 68                    %h'=call emacs_MarkBuffer;                  %%  {Ctrl+X h}               -- 
1B 25                    %h'=call emacs_ReplaceText;                 %%  {Esc %}                  -- 
1B 78                    %h'=call emacs_RegxReplace;                 %%  {Esc x}                  -- 
1B 72                    %h'=call emacs_RecursiveEdit;               %%  {Esc r}                  -- 
18 31                    %h'=call emacs_WindowDeleteallButCurrent;   %%  {Ctrl+X 1}               -- 
18 32 7B 18 35 32        %h'=call emacs_WindowHorizSplit;            %%  {Ctrl+X 2{Ctrl+X 52}     -- 
18 30 7B 18 35 30        %h'=call emacs_WindowDeleteCurrent;         %%  {Ctrl+X 0{Ctrl+X 50}     -- 
18 33                    %h'=call emacs_WindowVertSplit;             %%  {Ctrl+X 3}               -- 
1B 16                    %h'=call emacs_ScrollOtherWindow;           %%  {Esc Ctrl+V}             -- 
18 6F                    %h'=call emacs_WindowSwapFocus;             %%  {Ctrl+X o}               -- 
18 35 6F                 %h'=call emacs_FrameSwapFocus;              %%  {Ctrl+X 5o}              -- 
18 34 62                 %h'=call emacs_WindowSwap;                  %%  {Ctrl+X 4b}              -- 
18 35 62                 %h'=call emacs_FrameSwapFocus;              %%  {Ctrl+X 5b}              -- 
18 34 0F                 %h'=call emacs_WindowDisplayBuffer;         %%  {Ctrl+X 4Ctrl+O}         -- 
0F 18 35 0F              %h'=call emacs_FrameDisplayBuffer;          %%  {Ctrl+O Ctrl+X 5 Ctrl+O} -- 
18 34 66                 %h'=call emacs_WindowFile;                  %%  {Ctrl+X 4f}              -- 
18 35 66                 %h'=call emacs_FrameFile;                   %%  {Ctrl+X 5f}              -- 
18 34 72                 %h'=call emacs_WindowROFile;                %%  {Ctrl+X 4r}              -- 
18 35 72                 %h'=call emacs_FrameROFile;                 %%  {Ctrl+X 5r}              -- 
18 34 64                 %h'=call emacs_WindowDired;                 %%  {Ctrl+X 4d}              -- 
18 35 64                 %h'=call emacs_FrameDired;                  %%  {Ctrl+X 5d}              -- 
18 34 2E                 %h'=call emacs_WindowGotoTag;               %%  {Ctrl+X 4.}              -- 
18 35 2E                 %h'=call emacs_FrameGotoTag;                %%  {Ctrl+X 5.}              -- 
18                       %h'=call emacs_WindowTaller;                %%  {Ctrl+X Ctrl+}           -- 
18 7B                    %h'=call emacs_WindowSlimmer;               %%  {Ctrl+X {}               -- 
18 7D                    %h'=call emacs_WindowFatter;                %%  {Ctrl+X}}                -- 
1B 1C                    %h'=call emacs_IndentRegion;                %%  {Esc Ctrl+\}             -- 
1B 11                    %h'=call emacs_IndentSexp;                  %%  {Esc Ctrl+Q}             -- 
18 54 41 42              %h'=call emacs_IndentRegionTab;             %%  {Ctrl+X TAB}             -- 
1B 3B                    %h'=call emacs_IndentForComment;            %%  {Esc ;}                  -- 
0F                       %h'=call emacs_Break;                       %%  {Ctrl+O}                 -- 
1B 0F                    %h'=call emacs_BreakShift;                  %%  {Esc Ctrl+O}             -- 
18 0F                    %h'=call emacs_DeleteSurroundingBlankLines; %%  {Ctrl+X Ctrl+O}          -- 
1B                       %h'=call emacs_JoinPrev;                    %%  {Esc Ctrl+}              -- 
1B 5C                    %h'=call emacs_DeleteSurroundingBlanks;     %%  {Esc \}                  -- Deletes any blanks either side of the current character.
1B 20                    %h'=call emacs_InsertBlank;                 %%  {Esc SPC}                -- 
1B 71                    %h'=call emacs_ParagraphFill;               %%  {Esc q}                  -- 
18 66                    %h'=call emacs_FillColumn;                  %%  {Ctrl+X f}               -- 
18 2E                    %h'=call emacs_PrefixSet;                   %%  {Ctrl+X .}               -- 
1B 6F                    %h'=call emacs_FaceSet;                     %%  {Esc o}                  -- 
1B 75                    %h'=call emacs_UppercaseWord;               %%  {Esc u}                  -- 
1B 6C                    %h'=call emacs_LowercaseWord;               %%  {Esc l}                  -- 
1B 63                    %h'=call emacs_CapitalizeWord;              %%  {Esc c}                  -- 
18 15                    %h'=call emacs_uppercaseRegion;             %%  {Ctrl+X Ctrl+U}          -- 
18 0C                    %h'=call emacs_LowercaseRegion;             %%  {Ctrl+X Ctrl+L}          -- 
0D                       %h'=call emacs_CompleteAndExecute;          %%  {Ctrl+M}                 -- 
3F                       %h'=call emacs_CompleteSuggestions;         %%  {?}                      -- 
1B 70                    %h'=call emacs_PreviousInput;               %%  {Esc p}                  -- 
1B 6E                    %h'=call emacs_LaterInput;                  %%  {Esc n}                  -- 
1B 72                    %h'=call emacs_HistorySearchBack;           %%  {Esc r}                  -- 
1B 73                    %h'=call emacs_HistorySearchForwards;       %%  {Esc s}                  -- 
18 1B 1B                 %h'=call emacs_HistoryRepeat;               %%  {Ctrl+X Esc Esc}         -- 
18 62                    %h'=call emacs_BufferSelect;                %%  {Ctrl+X b}               -- 
18 02                    %h'=call emacs_BufferList;                  %%  {Ctrl+X Ctrl+B}          -- 
18 6B                    %h'=call emacs_BufferKill;                  %%  {Ctrl+X k}               -- 
14                       %h'=call emacs_TransposeCharacters;         %%  {Ctrl+T}                 -- swaps current chr with previous and moves forward by one chr.
1B 74                    %h'=call emacs_TransposeWords;              %%  {Esc t}                  -- 
18 14                    %h'=call emacs_TransposeLines;              %%  {Ctrl+X Ctrl+T}          -- 
1B 14                    %h'=call emacs_TransposeSexps;              %%  {Esc Ctrl+T}             -- 
1B 24                    %h'=call emacs_SpellWord;                   %%  {Esc $}                  -- 
1B 78                    %h'=call emacs_SpellRegion;                 %%  {Esc x}                  -- 
1B 78                    %h'=call emacs_SpellBuffer;                 %%  {Esc x}                  -- 
1B 78                    %h'=call emacs_SpellOnOff;                  %%  {Esc x}                  -- 
1B 2E                    %h'=call emacs_IndexFindDef;                %%  {Esc .}                  -- 
1B 2E                    %h'=call emacs_IndexFindNx;                 %%  {Esc .}                  -- 
15 1B 2E                 %h'=call emacs_IndexFindPr;                 %%  {Ctrl+U Esc .}           -- 
1B 78                    %h'=call emacs_IndexNewFile;                %%  {Esc x}                  -- 
1B 78                    %h'=call emacs_IndexSearchAllFiles;         %%  {Esc x}                  -- 
1B 78                    %h'=call emacs_IndexQueryReplace;           %%  {Esc x}                  -- 
1B 2C                    %h'=call emacs_IndexContinueSearch;         %%  {Esc ,}                  -- 
1B 21                    %h'=call emacs_ShellCommand;                %%  {Esc !}                  -- 
1B 26                    %h'=call emacs_ShellCommandNowait;          %%  {Esc &}                  -- 
1B 7C                    %h'=call emacs_ShellCommandRegion;          %%  {Esc |}                  -- 
15 1B 7C                 %h'=call emacs_ShellCommandFilterRegion;    %%  {Ctrl+U Esc |}           -- 
1B 78                    %h'=call emacs_ShellStartInWindow;          %%  {Esc x}                  -- 
18 72 72                 %h'=call emacs_RectCopy;                    %%  {Ctrl+X rr}              -- 
18 72 6B                 %h'=call emacs_RectKill;                    %%  {Ctrl+X rk}              -- 
18 72 79                 %h'=call emacs_RectYank;                    %%  {Ctrl+X ry}              -- 
18 72 6F                 %h'=call emacs_RectOpen;                    %%  {Ctrl+X ro}              -- 
18 72 63                 %h'=call emacs_RectBlank;                   %%  {Ctrl+X rc}              -- 
18 72 74                 %h'=call emacs_PrefixLines;                 %%  {Ctrl+X rt}              -- 
18 61 67                 %h'=call emacs_AbbrAddGlobal;               %%  {Ctrl+X ag}              -- 
18 61 6C                 %h'=call emacs_AbbrAddLocal;                %%  {Ctrl+X al}              -- 
18 61 69 67              %h'=call emacs_AbbrAddGlobalExp;            %%  {Ctrl+X aig}             -- 
18 61 69 6C              %h'=call emacs_AbbrAddLocalExp;             %%  {Ctrl+X ail}             -- 
18 61 65                 %h'=call emacs_AbbrExpand;                  %%  {Ctrl+X ae}              -- 
1B 2F                    %h'=call emacs_AbbrExpandPrev;              %%  {Esc /}                  -- 
15                       %h'=call emacs_PosArg;                      %%  {Ctrl+U}                 -- 
1B 2D                    %h'=call emacs_NegArg;                      %%  {Esc -}                  -- 
11                       %h'=call emacs_String;                      %%  {Ctrl+Q}                 -- 
18 0D 6C                 %h'=call emacs_LanguageSet;                 %%  {Ctrl+X Ctrl+M l}        -- 
1B 78                    %h'=call emacs_LanguageListInput;           %%  {Esc x}                  -- 
1C                       %h'=call emacs_LanguageInputToggle;         %%  {Ctrl+\}                 -- 
18 0D 63                 %h'=call emacs_LanguageSetCoding;           %%  {Ctrl+X Ctrl+M c}        -- 
1B 78                    %h'=call emacs_LanguageListCoding;          %%  {Esc x}                  -- 
1B 78                    %h'=call emacs_LanguagePrefer;              %%  {Esc x}                  -- 
08 69                    %h'=call emacs_InfoStart;                   %%  {Ctrl+H i}               -- 
08 53                    %h'=call emacs_InfoFind;                    %%  {Ctrl+H S}               -- 
1B 58 30 31 34           %h'=call emacs_InfoScrollRev;               %%  {Delete}                 -- 
18 72 73                 %h'=call emacs_RegSaveRegion;               %%  {Ctrl+X rs}              -- 
18 72 69                 %h'=call emacs_RegInsertHere;               %%  {Ctrl+X ri}              -- 
18 72 53 50 43           %h'=call emacs_RegSaveValue;                %%  {Ctrl+X rSPC}            -- 
18 72 6A                 %h'=call emacs_RegJump;                     %%  {Ctrl+X rj}              -- 
18 28                    %h'=call emacs_KbdDefineStart;              %%  {Ctrl+X (}               -- 
18 29                    %h'=call emacs_KbdDefineEnd;                %%  {Ctrl+X )}               -- 
18 65                    %h'=call emacs_KbdExLast;                   %%  {Ctrl+X e}               -- 
15 18 28                 %h'=call emacs_KbdAppend;                   %%  {Ctrl+U Ctrl+X (}        -- 
1B 78                    %h'=call emacs_KbdName;                     %%  {Esc x}                  -- 
1B 78                    %h'=call emacs_KbdLisp;                     %%  {Esc x}                  -- 
18 05                    %h'=call emacs_EvalSesp;                    %%  {Ctrl+X Ctrl+E}          -- 
1B 18                    %h'=call emacs_EvalCurrent;                 %%  {Esc Ctrl+X}             -- 
1B 78                    %h'=call emacs_EvalRegion;                  %%  {Esc x}                  -- 
1B 3A                    %h'=call emacs_EvalRead;                    %%  {Esc :}                  -- 
1B 78                    %h'=call emacs_LoadLibLisp;                 %%  {Esc x}                  -- 
1B 78                    %h'=call emacs_Customize;                   %%  {Esc x}                  -- 
08 66                    %h'=call emacs_InteractiveSpec;             %%  {Ctrl+H f}               -- 
0D                       %h'=call emacs_Interactive;                 %%  {Ctrl+M}                 -- 
20                       %h'=call emacs_CompleteWord;                %%  {SPC}                    -- 
0B                       %h'=call emacs_CompleteAll;                 %%  {TAB}                    -- 
Fake emacs keymap:
ob z^m0h$ 
%%Remove {Esc i n} and {Esc I n}.
m-0(f/^[in  /k)0
%%64 65 6C 65 74 65        %h'=call emacs_UndoChr;                     %%  {delete}                 -- 
%%53 50 43                 %h'=call emacs_CompleteWord;                %%  {SPC}                    -- 
%%54 41 42                 %h'=call emacs_CompleteAll;                 %%  {TAB}                    -- 
oz

%g#
%%Now set up the emacs key mappings hashtable - emacs_EnterJotMode must be the first entry.
%%Remove the old hashtable - the test_all.jot test script runs fake_emacs immediately after fake_vim an ther don't co-exist.
obz^ %h=destroy; %h=create 1000;
%%
z^m-0 f/call emacs_EnterJotMode;/
%%Add keycode-to-function translation entries.
( %%Ensure all part-completed command strings are registered.
  r-0r3n.(r-0a$&v/ / (v/ /e)0b %h=code '$;? x, %h=data '$;? r3n.)0
  %%Index to next string and repeat.
  m )0
%%Copy the actions for all arrow keys and any others selected in the ( ! ) buffer.
%%These may not be present if fake_emacs was not run immediately after the strartup scrpt.
z^m0r0bon z! m-0(m, %%No cursor-control keys  - these may do.
  i/^[X0103                          {UpArrow}/b
  i/^[X0102                          {DownArrow}/b
  i/^[X0104                          {LeftArrow}/b
  i/^[X0105                          {RightArrow}/b )
m-0f/{UpArrow}/s/%h'=call emacs_UpInColumn;/
m-0f/{DownArrow}/s/%h'=call emacs_DownInColumn;/
m-0f/{RightArrow}/s/%h'=call emacs_GotoChrForwards;/
m-0f/{LeftArrow}/s/%h'=call emacs_GotoChrBack;/
%%Now transform the control characters.
m-0(f/^[/ol27oo/%lc/)0
z^m0h!
%%
%%Copy the actions for all arrow keys and any others selected in the ( ! ) buffer - these were saved immediately after running the normal startup script.
%%Again, ensuring all part-completed command strings are registered as data objects.
%% t  %w=clear; %w=new -height=9 -delim;
z^ono-om ( ( (v/^/eoicolx40o-, oic) oo/%02X / v/  /\)0 r-0r3n. (r-0a$&v/ / (v/ /e)0b %h=code '$; mx, %h=data '$;? r3n.)0 )0
oz
%%
%%Define the initial window size.
ob %q$=window; f/screenHeight = /- oid (oq/.=Debug/ol1o=okol20, okol1)o- %w=clear; %w=new -height='~ -delim; oz
:
'#
  
%%
%%emacs setup complete - off we go.
y0
(oq/.=Test/ol1o=, %h'=call emacs_KeyboardScanner; )
