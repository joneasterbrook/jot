%%Defines the key functions, these are mapped onto escape sequences by keybord/os-specific keyboard map.
%%
%%
%%    Copyright (C) 2013-2018 Jon. Easterbrook
%%
%%    This file is part of jot (Joy Of Text - a text editor).
%%
%%    jot is free software: you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation, either version 3 of the License, or
%%    (at your option) any later version.
%%
%%    jot is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with jot.  If not, see <https://www.gnu.org/licenses/>.
%%
%%
%%
%%Buffers used/defined.
%%  $ - passes args from CLI then used in construction of some key functions and key codes resolution.
%%  ! - hotkey-function lookup table.
%%  @ - keycap-to-keycode translation.
%%  ^ - the hotkey translation buffer, defined from scratch or left unchanged.
%%  : - The help repository, initialized to the contents of the top help file, also used as temporary key-functions buffer.
%%

%%Copy args to stack.
%d~='$;
%%Set up window - if in -tty mode %w=clear; will fail.
(%w=clear;\, %q$=window; f/screenHeight = /- oid ol1o- %w=clear; %w=new -height='~ -delim; (%q=windows; , %s=mousemask 0;) )
%s=console 20;
  
%%Read the appropriate keymap file - the finalize macro expects this table in buffer ( @ ).
%%e.g. curses_keys_xterm_<cursesVersion>.jot or WindowsNT_keys.jot
%g#
z^m-0
( %q=windows;
  %r=WindowsNT_keys;
, %%Not windows, use term defined by the TERM env and curses version.
  %q@=version; m
  ( f1/ ncurses /-  
    %%Use correct keymap for this version of curses.
    e-0 (f1/./s/_/)0
    %r=curses_keys_&'@;
  , %%For all other versions of curses, use TERM-specific keymap.
    %q@=env TERM; m %r=curses_keys_&'@;
  , %%No keymap for that flavour of TERM - give up with generic xterm keymap.
    %m=Error: No key-mapping file for TERM &'@&, using xterm instead.;
    %r=curses_keys_xterm; ) )
:
'#

%%Set up the functions and assign function names
%%N.B. At startup time this will be run in case-insensitive mode
%%If run later, case-sensitivity might have been turned on.
%%
%%In the forgoing, single-line functions are copied directly into the keymap buffer ( ^ ).
%%Multi-line functions are copied into the code repository buffer ( ' ) and a function-call
%%entry point is set up ine the hashtable.
%%For functions that need to prompt for parameter values, the prompt string 
%%must be in a line-1 comment of the form:
%%Prompt string: <string>
%%
%g'=Code_Repository;
<<TermResize>>
%l;

<<Do>>
%%Prompt string: Command file pathName> 
obz$n.(f1/ /, r0)a@(v/ /e)0oz %r='@& &'$;
%%obz$n.(f1/ /, r0)a@(v/ /e)0oz %r=\'@& &\'$;
%%obz$n.(f1/ /, r0)a@(v/ /e)0oz %r='@ '$;
  
<<Substitute>>
%%Prompt string: Substitute string> 
obz$(rr-i/i`/'$, )oz s//
  
<<SubstituteBack>>
%%Prompt string: Substitute string> 
obz$(rr-i/i`/'$, )oz s-//
  
<<Remove>>
(s/ /e-)
  
<<SubstituteInd>>
s'_
  
<<SubstituteAgain>>
s//
  
<<Insert>>
%%Prompt string: Insert string> 
obz$ %s=system 1; i/i`/ %s=system 0; oz'$
   
<<InsertBack>>
%%Prompt string: Insert string> 
obz$(rr-i/i`/'$, )oz i-//
  
<<InsertAgain>>
i//
  
<<InsertWithBackTick>>
%%Prompt string: Insert string> 
obz$ %s=system 1; i/i`/r0i/ / ozi-/`/ %s=system 0; '$oxe-rou

<<Overwrite>>
%%Prompt string: Overwrite string> 
%%If still in system mode this function will erase the remaining line.
%s=system 0; obz$(rr-i/i`/'$, )oz oci//oco-(eo~)0ok
  
<<OverwriteBack>>
%%Prompt string: Overwrite string> 
%%If still in system mode this function will erase the remaining line.
%s=system 0; obz$(rr-i/i`/'$, )oz ocr0ocosr-0o#ori//r0osoco-osr-0or(e-o~)0ok
  
<<FindBack>>
%%Prompt string: Find string> 
obz$(rr- %s=system 1; i/f`/ %s=system 0; '$, )oz 
f-//?
  
<<SubsThenFindPv>>
s-//f-//
  
<<FindBackInd>>
f-'_
  
<<FindBackAgain>>
f-//
  
<<FindNext>>
%%Prompt string: Find string> 
obz$(rr- %s=system 1; i/f`/ %s=system 0; '$, )oz 
f//?
  
<<SubsThenFindNx>>
s//f//
  
<<FindNextAgain>>
(f//, %x=Find-again failed;)
  
<<DeleteLineLeft>>
(n.(rr-r-0, m-r0)? a%-)
%%(n.(r-r(rr-0, m-r0)?, m-r0) a%-)
  
<<RestoreLineLeft>>
obz%m-0n.(rr0,m,)a$ozh$
  
<<DeleteWordLeft>>
(n.(r-r, m-r0)(q-/a-zA-Z0-9Ā-𠀹/\r-)0 (q-/a-zA-Z0-9Ā-𠀹/r-)0 a%-)
  
<<RestoreWordLeft>>
obz%m-0n.(r(q/a-zA-Z0-9._Ā-𠀹/\r)0(q//r)0,m,)a$ozh$
  
<<DeleteWordRight>>
(n.(rr-,m)(q/a-zA-Z0-9Ā-𠀹/\r)0(q/a-zA-Z0-9Ā-𠀹/r)0a%+)
  
<<RestoreWordRight>>
obz%m0r0n.(r-(q-/a-zA-Z0-9._Ā-𠀹/\r-)0(q//r-)0,m-r0,)a$  o#ozh$(z$r o#ozr-,m o#ozm-r0)0 oz
  
<<DeleteLineRight>>
(n.(rr-(r-r0,m),m)a%+)
  
<<RestoreLineRight>>
obz%m0r0n.(r-r-0, m-,) a$o#ozh$z$m0r0 (z$r-o#ozr-,m-r0o#ozm-r0)0oz
  
<<FindExact>>
%%Prompt string: Find-exact string> 
obz$(rr- %s=system 1; i/f`/ %s=system 0; '$, )oz (v//r, ) ( (f//- q/_A-Za-z0-9Ā-𠀹/f-//)0 f-1// q-//r)0
(v//, %m=Find-exact failed; x\)
  
<<FindExactBack>>
%%Prompt string: Find-exact string> 
obz$(rr- %s=system 1; i/f`/ %s=system 0; '$, )oz (v//(r-, m-r0), )( (f-//- q/_A-Za-z0-9Ā-𠀹/r-f-//)0 f-1// q-//r-)0 
(v//, %X=Find-exact failed;)
  
<<SetFindString>>
(a$&, (obol36o= %x=Can not call <<SetFindString>> from the ( $ ) buffer.;, )r-r(q-/_a-zA-Z0-9Ā-𠀹/r-)0n.(q//r)0a$&, n.r0a$&)obz$r-0 %s=system 1; i-/f-1`/oz %s=system 0; '$
  
<<Paste>>
(h_)
  
<<Cut>>
a_
  
<<CumulativeCut>>
(a_+, r-0n.ma_+&)
  
<<CutTabular>>
a_ obz_r0ocosoz ol-1oso-o# (o~i/ /)0ok o~or?
  
<<CumulativeCopy>>
(a_+&, r-0n.ma_+&)
  
<<Copy>>
oba_&
  
<<Note>>
n.
  
<<PageUp>>
(m-* %w=refresh; )?
  
<<Home>>
m-0
  
<<GotoFoldStart>>
%s=system 1; ol0r-0(f1/}}}/\m-)0r-0 (f1/}}}/ol1o-m-,f1/{{{/\m-,o~m-)0 ok %s=system 0;
  
<<PageDown>>
(m* %w=refresh; )?
  
<<WindowOne>>
%%Prompt string: Console size > 
%%Default window size is 1 less than total screen height.
%%Pick up optional console-area size arg.
oconobz$m-0(v/ /r)0 (q/0-9/oid, ol1) osoz
%%Set the window size.
obos %s=system 1; %q$=window; f/screenHeight = /- oid oso- %w=clear; %w=new -height='~ -delim; (%q=windows; , %s=mousemask 0;)
%%Clear any colour tags.
(z$obo=, o#oz %q$=tags;
  ( %%Colour-tag removal loop.
    f/active colour is /-b- 
    %%First calculate the substring length.
    o#f-1/ to /-oidf-1/, chr /-oido-os
    %%Now get the substring start point.
    f-1/, chr /-oidos
    %%Finally, the line no.
    f-1/At rec /-oidos
    %%Now remove the tag.
    m oz ono-om or o~ou %b=remove_tag -colour '$; z$m)0 )
%%Restore original cursor position.
ozono-omor
%s=verbose 3;
%b=leftoffset 0;
o@
%s=system 0;

<<WindowNine>>
%%Replaces all windows with a nine-line debugging window.
%w=clear; %w=new -height=9 -delim;

<<WindowHorizSplit>>
%%Adds a new window below size-adjusted existing windows.
%%
%s=system 1; ob
%%Calculate the size of each new window.
%%First get the terminal height, count the number of existing slices and calculate the new window width.
%w=refresh; %q@=window; f/ screenHeight = /-oid ol1o-ol0m=4 (f1/ win:/ (f1/ Leftmost/o~m, m) )0 o~o/
%%If there's a floating window, fix it now.
m=4 ( f/ = currently buffer ( /-n.ra$&f-/ win:/-oid %w=modify='~ -key='$;, )
%%
%%Reduce the height of each the original windows to allow the new window to fit in.
m=4 (o#f1/ win:/-oid (f1/ Leftmost/ %w=modify='~ -height='~;, ok) m)0 okokok
%%Create a new floating window.
%w=new -height='~ -delim; %w=refresh;
%s=system 0; oz

<<WindowVertSplit>>
%%Adds a new slice to the right of size-adjusted existing windows.
%%
%s=system 1; ob
%%Calculate the size of each new window.
%%First get the terminal width.
%w=refresh; ob %q@=window; f/ screenWidth = /-oid 
%%Fix any floating windows.
m=4 ( f/ = currently buffer ( /-n.ra$&f-/ win:/-oid %w=modify='~ -key='$;, )
%%Locate the current buffer by checking the buffer keys - this window will be split.
m=4os (f1/ win:/ f1/ ( /-oido=\ )0 r-0(f1/ win:/, m-) os
%%
%%If the current window was a slice then split it once more, otherwis split the current window int two slices.
(f1/ slice / %%Current window is a slice, count members of this group and calculate new slice width.
  onosr0 f-/ Leftmost/on(mf1/ Leftmost/\f1/ slice /)0ono~oso- o/
  %%if more windows follow, insert the new slice, othrwise simply creates the new slice at the end of the window list.
  osono-om (o#f1/ win:/-oid f1/ ( /-n.ra$& %w=modify='~ -width='~ -key='$; m)0  m(f1/ win:/-oid %w=new -insert='~ -width='~ -delim;, %w=new -width='~ -delim;)
, %%A full-width window.
  ol2o/o# r-0f1/ win:/-oid f1/ ( /-n.ra$& %w=modify='~ -width='~ -key='$; m(f1/ win:/-oid %w=new -insert='~ -width='~ -delim;, %w=new -width='~ -delim; )
  )
%s=system 0; oz

<<WindowSave>>
%%Prompt string: Optionally specify a window-configuration name> 
%%Saves window configuration and temporarially returns to a simple single window configuration.
%%Original configuration is saved in the /'=WindowConfig/ data object.
%%Default config name is "default".
%s=system 1; 
obz$(rr-i/WindowConfig_/, i/WindowConfig_default/) oz %s=system 0;
ob %q~=window; (z' %h=testkey '$;, %h'=data '$; ) ov'$ oz %d$=; %h'=call WindowOne;
%%ob %q~=window; (z' oq'$ok, %h'=data '$; ) ov'$ oz %h'=call WindowOne;
%s=system 0;

<<WindowRestore>>
%%Prompt string: Optionally specify a window-configuration name> 
%%Restores the window configuration previously saved by the WindowSave function.
%s=system 1;
obz$(rr-i/WindowConfig_/, i/WindowConfig_default/)
(z' oq'$, %x=Error: no previously-saved window configuration named "&'$&".; )
z$m-0k0e0i/%w=clear;/b z~m-0f/win:0/r-
( %%Window loop.
  f1/ win:/-
    ( f1/ fixed on buffer  ( /- oicz$oo/%%w%C=new/, f1/ currently buffer ( /-oic z$oo/(z%c, z.) %%w=refresh; %%w=new/, f1/ currently blank  /z$i/%w=new /z~) z~ 
    %%Only include height if it's a non-sliced or the first slice.
    ( (f1/ column slice / f1/ Leftmost/\)\ r-0f1/ lines /(q-/0-9/r-)0oid z$r0oo/ -height=%d/, ) z~
    %%Add slice width.
    ( f1/ column slice / (q-/0-9/r-)0oid z$r0oo/ -width=%d/, ) z~
    %%Add Delimiter line.
    r-0 (f1/ Height includes an end delimiter/ z$r0i/ -delim/, ) z~
    %%Set popup details.
    ( f1/ column popup /(q-/0-9/r-)0oid f1/(/-(v/0 /, ol0oso-) z$r0oo/ -width=%d -popup/, ) z~
    %%Add terminating semicolon.
    z$r0i/;/b z~m
  )0
osozok '$ %s=system 0;

<<WindowDown>>
%%Changes focus to next window or slice.
%%
%%First find the current window.
%s=system 1; ob %q@=window; z$m-0k0 oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 
%%Now move to the next window, or top window if already at last window and pick up the key.
m (f1/ ( /, f-/  screenWidth = /m) r-0f1/ win:/- f1/ ( /-oico#
%%  m (f1/ ( /, f-/  screenWidth = /m) r-0f1/ win:/-oid %w=modify='~ -freeze=0; f1/ ( /-oico#
%%If there are earlier windows showing that buffer then make sure they're frozen.
(z@m- (f1'$\, r-0f1/ win:/-) )0
%%If there's a floating window restore that now.
z@m-0 (f/ currently buffer ( /-oic m-0k0 %w=refresh;  oz %w=refresh; , )
%%Now switch to new buffer.
%s=system 0; oz %w=refresh; 

<<WindowUp>>
%%Changes focus to previous window or slice.
%%
%%First find the current window.
%s=system 1; ob %q@=window; z$m-0k0 oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 
%%Now move to the previous, or bottom window if already at first window and pick up the key.
m- (f1/ ( /r-0, f/  Console area /m-) f1/ win:/- f1/ ( /-oic m-
%%  m- (f1/ ( /r-0, f/  Console area /m-) f1/ win:/-oid %w=modify='~ -freeze=0; f1/ ( /-oic m-
%%Freeze any earlier windows matching this buffer.
(f1'$r-0f1/ win:/- m-, m-)0
%%If there's a floating window restore that now.
z@m-0 (f/ currently buffer ( /-oic m-0k0 %w=refresh;  oz %w=refresh; , )
%%Now switch to new buffer.
%s=system 0; oz %w=refresh; 

<<WindowReassign>>
%%Prompt string: Window no.(optional) and buffer > 
%%
%%First pick up the correct window number.
ob z$(v/ /e)0(q/0-9/(q//r)0r-0oid(v/ /r)0, %x=Error: You must specify a window number followed by a buffer key, separated by whitespace.; )
%%Changes the buffer assignment of current window.
z$e-0oo/%%w=modify=%d -key=/(v/ /e)0r0i/;/ '$ oz

<<WindowAlignTop>>
%%Prompt string: Window no.> 
%%Aligns current line with top of window in selected [or all] windows.
%s=system 1; 
%q@=window; z$r-0 (v/ /r)0 
( r %%A window number was specified - adjust only that one.
  r-e-0i/win:/r0i/ /
  %%Get the buffer key for whatever is being displayed by that window.
  z@f'$f1/ ( /- oicoz onofo-ow
, %%No window number was specified - adjust all windows. 
  z@m-0m2 (z@mf1/win:/-f1/ ( /-oicoz  %w=refresh; onofo-ow)0
  z@m-0f/currently buffer ( /-oicoz )
%s=system 0;

<<WindowAlignCent>>
%%Prompt string: Window no.> 
%%Aligns current line with center of window in selected [or all] windows.
%%By default applies to the current-buffers window the optional arg specifies which window to scroll.
%s=system 1;
ob %q@=window; z$r-0 (v/ /r)0 
(r  %%A window number was specified - adjust only that one.
  r-e-0i/win:/r0i/ /
  %%Get the buffer key for whatever is being displayed by that window.
  z@f'$f1/ ( /-oicf1/), /-oidol2o/ osoz onoso-ofo-ow %% oz
, %%No window number was specified - adjust all windows. 
  z@m-0m2 (mf1/win:/-f1/ ( /- oicf1/), /-oidol2o/ osoz onoso-ofo-ow z@)0 ) oz %w=refresh; 
%s=system 0;

<<WindowAlignBot>>
%%Prompt string: Window no.> 
%%Aligns current line with bottom of window in selected [or all] windows.
%%By default applies to all visible windows the optional arg specifies which window to scroll.
%s=system 1; 
ob %q@=window; z$r-0(v/ /r)0 
( r %%A window number was specified - adjust only that one.
  r-e-0i/win:/r0i/ /
  %%Get the buffer key for whatever is being displayed by that window.
  %q@=window; f'$f1/ ( /-oicf1/), /-oidosoz onoso-ofo-ow %%oz
, %%No window number was specified - adjust all windows. 
  z@m-0m2(mf1/win:/-f1/ ( /- oicf1/), /-oidosoz onoso-ofo-ow z@)0 ) oz %w=refresh; 
%s=system 0;

<<WindowStretch>>
%%Prompt string: [Window no.]> 
%%First pick up the given window number or find the window number of the current buffer.
%s=system 1;  %w=refresh;  ob %q@=window; z$(v/ /r)0(q/0-9/oido#z@f/win:0/om, z$m-0k0 o#oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 r-0f1/ win:/-oid) 
%%Now set up the window-identification part of the window-change command.
z$k?oo/%%w=modify=%d/r0 
%%If it's a full-width window tweak the height, if a slice, tweak the width. 
( z@f1/Slice/\  %%It's a full-width window - get the original height and set the new height.
  (f1/ ), /-oidol1o+z$oo/ -height=%d;/ '$? )
, %%It's a slice - get original width and tweak the width.
  (z@f-1/ ), /-rf1/), /-oidol1o+z$oo/ -width=%d;/ '$? ) )
%%Refresh all windows.
z@m=4(v/      win:/f/ ( /-oic oz %w=refresh; z@m)0 
%%  %l; z@m=4(v/      win:/f/ ( /-oic ozwz@m)0 
%s=system 0; oz
  
<<WindowShrink>>
%%Prompt string: [Window no.]> 
%%First pick up the given window number or find the window number of the current buffer.
%s=system 1;  %w=refresh;  ob %q@=window; z$(v/ /r)0(q/0-9/oido#z@f/win:0/om, z$m-0k0 o#oo/ ( %c ),/z@ (f'$ f1/, frozen/m)0 r-0f1/ win:/-oid) 
%%Now set up the window-identification part of the window-change command.
z$k?oo/%%w=modify=%d/r0 
%%If it's a full-width window tweak the height, if a slice, tweak the width. 
( z@f1/Slice/\  %%It's a full-width window - get the original height and set the new height.
  (f1/ ), /-oidol1o-z$oo/ -height=%d;/ '$? )
, %%It's a slice - get original width and tweak the width.
  (z@f-1/ ), /-rf1/), /-oidol1o-z$oo/ -width=%d;/ '$? ) )
%%Refresh all windows.
z@m=4(v/      win:/f/ ( /-oic oz %w=refresh; z@m)0
%%  %l; z@m=4(v/      win:/f/ ( /-oic ozwz@m)0
%s=system 0; oz

<<WindowWithLineNumbers>>
%%Add a slice down the lefthand sid with line numbers of the current buffer.
%%
ob %q$=window; 
( f/win:0  = fixed on buffer  ( * ), / %%Linenumbers slice is already set up - remove it.
  oz
  %s=on_key -after;
  %h'=call WindowOne;
, %%No it was not already set up - set up the line-number window now.
  m-0 f/screenHeight = /- oid ol1o- 
  %w=clear; %w*=new -height='~ -width=7;
  f/ screenWidth = /-oidol8o- 
  %w=new -width='~ -delim;
  oz
  %%Activate the LineNumberUpdate function as an on_key sequence.
  %s=on_key -after %h\'=call LineNumberUpdate; )

<<LineNumberUpdate>>
%%The %S=on_key handler for the line-numbers display buffer.
%%
%s=system 1; obn.
( a*  %%In any buffer other than ( * ).
  %%Get the window height, if there isn't a linenumber window then exit now..
  %q$=window; 
  ( f/win:0  = fixed on buffer  ( * ), /- %%Found the linenumber slice.
    oid
  , %%The linenumber slice has gone walkabout - yet the callback is still set???
    oz
    %s=on_key -after; 
    %h'=call WindowOne;
    %m=The linenumer window has been removed.; x0 )
  %%Get the line number at the top of the window.
  oso#ozos %q$=buffer; f/ OldFirstLineNo = /-oid
  %%If no colour pair set up for the linenumbers slice, do that now.
  z*m-0k0 %q$=buffer; (f/  TagType = Name    LineCount, /, z* %b=tagtype -colour=white:blue LineCount; )
  %%Set up the line numbers.
  osol0oso- (o~oso#oo/%6d / %b=addtag LineCount; o~osb)0 okokoz
, %%Abstracion failed, presumably because we're in the ( * ) buffer.
  )
%s=system 0;

<<ViewSave>>
%%Prompt string: Optionally specify a view name> 
%%Default view name is "default".
%s=system 1; obz$(rr-, i/default/ ) oz
%%Save view.
%h'=addjump ViewJump_&'$; obofz' z$r-0i/View_FirstLine_/ z'(oq'$ok, %h'=data '$;) ov'$ oz
%s=system 0;
  
<<ViewRestore>>
%%Prompt string: Optionally specify a view name> 
%%Default view name is "default".
%s=system 1; obz$(rr-, i/default/) oz
%%Restore view - if the original buffer was ( ~ ) then use z~ instead of oz and hope that the correct floating buffer is at the top of the stack.
(%h'=jump ViewJump_&'$; obz$r-0i/View_FirstLine_/z' oq'$os(ol126o=okosz~os, oz), oz %x=Could not find a saved view for &'$;)
%%Now adjust the view.
%w=refresh; ofo-ow
%%An unfortunate consequence of using hashtables is that the line numbers can go wrong - this fixes it.
oconm-0onol1o. o-om or %s=system 0;

<<PopupSearch>>
%%Prompt string: Popup search string> 
%%Search up and down looking for likely matches to the given word.
%%
%%First check the arg - exit now if not given.
obz$m-0(roz, oz%X=Error: no search string given for PopupSearch function.;)
%%Initialization - clear the ( - ) buffer.
%s=system 1; ob z.n.a-& oz
%%The original start point.
ofocon
%%
%%Find all nearest words (before or after current point) matching the given string.
%%Collect matching words in popup-buffer ( - ).
%%Search backwards for previous word match.
o#ono-omoso#oros ((f-'$(q-/A-Za-z0-9_Ā-𠀹/r-)0n.(q//r)0a@&f-'$ obz@r-0i/ /r0i// z-m-0(f'@oz, m-0h@boz\) )0 m-m)0
%%Search forwards for next word match.
o#ono-omoso#oros 
%%Note current-point in word list.
obz-m0onosoz 
%%Now do the forwards-looking search.
((f'$(q-/A-Za-z0-9_Ā-𠀹/r-)0n.(q//r)0a@& obz@r-0i/ /r0i// z-m-0(f'@oz, h@boz\) )0 mm-)0
obz-m0onm-0osozol1o- 
( ol0o=ok %m=Found no matching words.;
, %m=Found &'~& matching words.;
  %%Prepare and display the popup.
  %h'=call PopupRestore;
  %%Return to corresponding point in words list.
  obosz-m-0omoz )
%%Return to original current-character point on main text.
ono-omor
%%Restore view.
 %w=refresh;  ofo-ow %s=system 0;

<<PopupIncrementalSearch>>
%%Prompt string: Popup search string> 
%%Search up and down looking for likely matches to the given word, updating popup as characters are typed in.
%%
%%Initialization, clear the ( $ ) buffer -  used to hold search string.
%s=system 1; obz$n.a-&oz
%%Set prompt.
%s=prompt Incremental search> &'$;
%%
  
( %%Search-character loop.
  %%Loop init - collect focus-point details, clear results buffer and prepare search string.
  oconob z-m-0k0 %w=refresh;  z$m-0
  %%If we have a non-empty search string, collect matching words and search back from current chr.
  ( r %%A non-empty search string - collect matching words.
    oz((f-'$(q/A-Za-z0-9_Ā-𠀹/r)0n.(q-/A-Za-z0-9_Ā-𠀹/r-)0a@& (q-/A-Za-z0-9_Ā-𠀹/r-)0(r-, m-r0) obz@r-0i/ /r0i/ / z-m-0(f'@oz, m-0h@boz\) )0 oc(m-mor, ok\) )0
    %%Search forwards for next word match - first return to original point.
    ono-omor ocon
    %%Now do the forwards-looking search.
    ((f'$(q-/A-Za-z0-9_Ā-𠀹/r-)0n.(q/A-Za-z0-9_Ā-𠀹/r)0a@& obz@r-0i/ /r0i/ / z-m-0(f'@oz, r0h@boz\) )0 oc(mm-or, ok\) )0
  , %%The search string was empty.
    oz )
  %%Set prompt, report match count, return to original point and display the popup, also disable mouse events until exit.
  obz-m0 (m-onm-0, i/  /ol0) %s=prompt Currently &'~& matching words> &'$; %h'=call PopupRestore; %s=mousemask 0; z-m-0 ozono-omor  %w=refresh; 
  %%
  %%Prompt and pick up next character.
  ob %w=refresh;  og z$r0
  ( ol127 o= %%It's a rubout - remove last character from search string.
    okm-0r0 e-?
  , ol10 o= %%It's a {Return} - refocus, re-enable mouse events and exit.
    okoz %s=mousemask 0004; x2
  , %%Any other character gets added to the search string.
    oo/%lc/ ) oz )0 
%s=system 0;
%s=prompt > ;

<<PopupRestore>>
%%Prepares the the popup window for display.
%s=system 1; obz-onm-0
( r  %%A new popup - top and tail all entries.
  m-0((v/ /e)0r0(v-/ /e-)0m)0 
  %%Set up data object - create it if necessary.
  (oq/'=PopupMenu/ok, %h'=data PopupMenu; ) m-0n.m0r0a~&?m-0 ov/'=PopupMenu/
, %%Restore last-used popup.
  oq/'=PopupMenu/z~m-0n.m0r0a-z-ok )
%%Add colour tag to each item - define the colour tag-type if necessary.
m-0(oxou (%b=addtag SelectWord;, %b=tagtype -colour=white:blue SelectWord; %b=addtag SelectWord;) m)0
%%m-0(oxou (%b=addtag SelectWord;, (%q=windows; %b=tagtype -colour=7:1 SelectWord;, %b=tagtype -colour=7:4 SelectWord;) %b=addtag SelectWord;) m)0
%%If the popup window is not yet defined, do that here.
%q~=window; f/Screen dump follows:/ ( f-/ column popup (/, oq/'=DocRightMargin/ %w-=new -height=20 -width=20 -popup='~; ) z-ok
%%  %q~=window; f/Screen dump follows:/ ( f-/ column popup (/, %w-=new -height=20 -width=20 -popup=60; ) z-ok
%%Enable mouse events (Button-1 click) and set up callback.
%s=mousemask 0004;
z^m-0(f/%h'=call FocusToMouse;/s/%h'=call PopupMouseSelect;/)0
%%Return to original position in menu and to original buffer.
%s=system 0; z-ono-om oz

<<PopupMouseSelect>>
%%The mouse-event callback - coordinates identify the required spelling (45 is ASCII code for ( - ) BTW).
%%Identify the popup word.
%s=system 1; ob opol45o=okz-ono-omok n.r0a$ m-0k0
%%Tidy up - disable mouse-clicks and destroy popup menu.
%s=mousemask 0;  %w=refresh; 
%%Restore original mouseclick handler.
z^m-0(f/%h'=call PopupMouseSelect;/s/%h'=call FocusToMouse;/)0
%%Push selected word into command stream.
z$i/%s=commandstring /r0i/;/ oz '$ %s=system 0; 

<<PopupReset>>
%%Clears the popup buffer and resets mousemask.
obz-m-0k0oz %s=mousemask 0; %l;

<<PopupPageUp>>
%%Scrolls the popup window up to previous page.
%%Unfortunately, the usual M* command won't work for popups because it takes the height of the current window, not of the popup.
%s=system 1; obz-of %q$=window; (f/ column popup (/f-1/( - ), /-oidol1o- z-o-ono-om?
  %%Report current position in popup.
  onm0m-onosono-omof %m=Displaying popup from line no. &'~& (&'~& lines in total).;, ok)
%s=system 0; oz

<<PopupPageDown>>
%%Unfortunately, the usual M* command won't work for popups because it takes the height of the current window, not of the popup.
%s=system 1; obz-of %q$=window; (f/ column popup (/f-1/( - ), /-oidol2o*ol1o- z-o+ono-om? %w=refresh; 
  %%Report current position in popup.
  onm0m-onosono-omof %m=Displaying popup from line no. &'~& (&'~& lines in total).;, ok)
%s=system 0; oz

<<End>>
m0m-
  
<<GotoFoldEnd>>
ol0r-0(f1/{{{/\m)0r-0 (f1/{{{/ol1o-m,f1/}}}/\m,o~m)0 ok
  
<<Up>>
(m-?)
  
<<StraightUp>>
(y-)
  
<<ViewUp>>
%%Prompt string: Window no.> 
%%By default applies to the current-buffers window the optional arg specifies which window to scroll.
%s=system 1; obz$r-0(v/ /r)0 (r  %%A window number was specified - adjust only that one.
  %q@=window;
  r-e-0i/win:/r0i/ /
  %%Get the buffer key for whatever is being displayed by that window.
  z@m-0 f'$f1/ ( /-oicoz(ol1ow) oz
, %%No window number was specified - adjust all windows. 
  %q$=window;
  z$m=3
  (mf1/win:/-f1/ ( /-oic (f1/ popup /oz, ozol1ow) z$)0 ) oz %w=refresh; 
%s=system 0;
  
<<Down>>
(m?)
  
<<StraightDown>>
(y)
  
<<ViewDown>>
%%Prompt string: Window no.> 
%%By default applies to the current-buffers window the optional arg specifies which window to scroll.
%s=system 1; obz$r-0(v/ /r)0 (r  %%A window number was specified - adjust only that one.
  %q@=window;
  r-e-0i/win:/r0i/ /
  %%Get the buffer key for whatever is being displayed by that window.
  z@m-0 f'$f1/ ( /-oicoz(ol-1ow) oz
, %%No window number was specified - adjust all windows. 
  %q$=window;
  z$m=3
  (mf1/win:/-f1/ ( /-oic (f1/ popup /oz, ozol-1ow) z$)0 ) oz %w=refresh; 
%s=system 0;
  
<<Right>>
(r, m)
  
<<Left>>
(r-, m-r0)
  
<<LineLeft>>
(r-r-0, m-) %b=leftoffset 0;
  
<<MatchAny>>
( v/(/ %h'=call MatchParenRight;,
  v/{/ %h'=call MatchCurlyRight;,
  v/[/ %h'=call MatchSquareRight;,
  v/</ %h'=call MatchAngleRight;,
  v/)/ %h'=call MatchParenLeft;,
  v/}/ %h'=call MatchCurlyLeft;,
  v/]/ %h'=call MatchSquareLeft;,
  v/>/ %h'=call MatchAngleLeft;,
  %x=Try moving the cursor to any of (, [, {, <, >, }, ] or ) then try again.; )

<<MatchParenLeft>>
%%This is more complicated than ParenMatchRigt because we're trying to parse backwards.
%%The solution adopted here is to copy the original text with all the troublesome lingistic features removed
%%and then count brackets in this simplified text.
%%
%%First attempt to identify the coding language.
%s=system 1; ocon m-0
%%Just check the first few lines for a coding-language clue.
(v"//"\ v"/*"\ v/%%/\ m)10?
%%
( (v"//"\v"/*"\)\ %%Assumed to be C.
  ( ono-omor (v/(/\, (r-, (m-v"//")0(f1"//", r0))) ol0 ( (v.*/.f-./*., v/"/((r-, m-r0)f-1/"/v-/*/)0, v/'/f-1/'/, v/)/ol1o-, v/(/(o~, x3) )? (r-, (m-v"//")0(f1"//", r0) ) )0 okx2 )
, v/%%/  %%Assumed to be jot script
  %%Go back to the original line copy it to ( @ ) and strip out the troublesome stuff.
  ono-omor ol0 (v/(/(r-, m-r0), )
  ( %%ine loop - pick up and simplify each line.
    oboc r-0n.r0a@& z@
    ( %%Command character loop.
      ( %%Command character block.
        oc
        %%Skip to terminating semicolon or remainder of line for percent commands.
        v/%/ (v/%%/r0, r2f1/;/\r0, (oc(v-/\/r-)0oc f1/;/ro-ol2o%(ol0o=okx2, ok) f1/;/)0 ),
%%        v/%/ (v/%%/r0, r2f1/;/\r0, (v-/\/rf1/;/)0 v-/\/r0, r),
        %%Exit now if we find the function header.
        v/<</ okokozok %m=Error: Function header encountered in MatchParenLeft; x4\,
        %%Else clause.
        v/,/r,
        %%Simple commands (some have numeric argument).
        q/bcegjkprtwxyBCEGJKPRTWXY?\/ r(q/-0-9-/r)0,
        %% Commands with string argument.
        q/fiqsvFIQSV/(r(q/-0-9/r)0 (v/'/r2, n.ra!&f1'!-, m?) (q/-0-9/r)0 ),
        %%Commands with a buffer-key argument.
        q/ahuzAHUZ/(v/a/(r2q/+-./r)? (q/&/r)?, v/h/r2(q/0-9/r)0, r2),
        %%Operand-stack commands.
        q/oO/r(q/lL/r(q/-.0-9/r(q/.0-9/r)0, q/xX/(q/0-9a-fA-F/r)0, q/cC/r2), q/iI/r2, q/oOvVqQ/ rn.ra!&f1'!-, r),
        %%Move command.
        q/mM/r(q/=+*/r,)(q/-0-9/r)0,
        %%Macro call.
        v/'/r2,
        %%Note.
        q/nN/r(v/./r,) )
      %%Replace with whitespace.
      oc (o=, oco- (e-i-/ /o~)0 ) ok (v/ /r)0
    , %%Step past anything that's left - should be only parenthesis.
      okr )0
    %%Now we're good to perform simplistic parenthesis counting.
    r-0oros (v/)/ol1o-(r-, x2), v/(/\(r-, x2), o~ r-)0
    %%Check the perenthesis count.
    ol0o=\ osoz (m-, )r0)0 ok
  %%Now go back to the same character in the original text.
  ocosozr-0or
  
, %%Assumed to be natural language.
  ( ono-omor v/(/(r-,m-r0), ol0(v.*/.f-./*.,v/"/((r-, m-r0)f-1/"/v-/*/)0(r-, m-r0),v/'/f-1/'/(r-, m-r0),q/)/ol1o-(r-, r-r0),q/(/\(r-, m-r0),o~(r-, m-r0))0 okx )
  )
%s=system 0; 

<<MatchCurlyLeft>>
v/{/(r-,m-r0), ol0(v.*/.f-./*.,v/"/((r-, m-r0)f-1/"/v-/*/)0(r-, m-r0),v/'/f-1/'/(r-, m-r0),q/}/ol1o-(r-, r-r0),q/{/\(r-, m-r0),o~(r-, m-r0))0ok
  
<<MatchAngleLeft>>
v/</(r-,m-r0), ol0(v.*/.f-./*.,v/"/((r-, m-r0)f-1/"/v-/*/)0(r-, m-r0),v/'/f-1/'/(r-, m-r0),q/>/ol1o-(r-, r-r0),q/</\(r-, m-r0),o~(r-, m-r0))0ok
  
<<MatchSquareLeft>>
v/[/(r-,m-r0), ol0(v.*/.f-./*.,v/"/((r-, m-r0)f-1/"/v-/*/)0(r-, m-r0),v/'/f-1/'/(r-, m-r0),q/]/ol1o-(r-, r-r0),q/[/\(r-, m-r0),o~(r-, m-r0))0ok
  
<<LineRight>>
((r, m)r0) ( %q=inview; okokok, oso-osok %b=leftoffset '~;)
  
<<ViewLeft>>
%q=inview;? okoko~%b=leftoffset '~;
  
<<ViewRight>>
%q=inview;? okokol0(o>\okol0, ol-1o+) %b=leftoffset '~;
  
<<WordLeft>>
( %q=tabstops; 
  %%Tabstops have been set - find next table cell, first identify the table-separator character.
  %s=system 1; ob %q$=system; f/Table-entry separator = '0x/-oixm-0b-oo/%c/ oz %s=system 0;
  ((v-'$, f1'$-, r0)oc (f-1'$r, r-0)oc o~o-ou)?
, %%No tabstops - just take standard definition of a word.
  (q-/a-zA-Z0-9Ā-𠀹/(q//r)0, (q-//\r-)0)(r-r, m-r0) oc (q-//r-)0 oc o-ou) 
(%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)
  
<<WordRight>>
( %q=tabstops; 
  %%Tabstops have been set - find next table cell, first identify the table-separator character.
  %s=system 1; ob %q$=system; f/Table-entry separator = '0x/-oixm-0b-oo/%c/ oz %s=system 0;
  %%Move to next cell.
  ( (v'$r, )(f-1'$-, r-0)oc (f1'$, r0)oc o-ou)?
, %%No tabstops - just take standard definition of a word.
  (r, m)(q/a-zA-Z0-9Ā-𠀹/(q-//r-)0, (q//\r)0) oc (q//r)0 oco-ou) 
( %q=inview; okokok, oso-osok %b=leftoffset '~;)
  
<<WordDown>>
(%q=tabstops; yocr(f1/	/, r0)oco-o#orol0oso-ou, y) (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)
  
<<NewWordDown>>
y0 (%q=tabstops; yocr(f1/	/, r0)oco-o#orol0oso-ou, y) (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)
  
<<WordUp>>
(%q=tabstops; y-ocr(f1/	/, r0)oco-o#orol0oso-ou, y-) (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)
  
<<NewWordUp>>
y0 (%q=tabstops; y-ocr(f1/	/, r0)oco-o#orol0oso-ou, y-) (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)

<<CmdEditStart>>
%%Prompt string: Command string (optional)> 
ob%q-=history; m0m-kb-i'$b m-0mb-oo/In buffer %c/m0m-2
  
<<CmdEditGo>>
( %s=system 1; obolc-o=okmk0m+2f1/In buffer /-oicm0m-k-0
  %%Apply the modified command.
  i/%s=commandstring / (f1/\/i/\/r)0 r-0(f1/&/i/\/r)0 r-0(f1/;/i/\/r)0 %s=system 0; 
  %%Return to original buffer and apply.
  oz '-
, %%Something failed - most probably the checks to ensure we're looking at a valid command-history report.
  ok %x=This is not the valid command-history report.; )
  
<<CmdString>>
%%Prompt string: Command string> 
%%Execute the jot command sequence in the string.
'$

<<MatchParenRight>>
%%First attempt to identify the coding language.
%s=system 1; ocon m-0
%%Just check the first few lines for a coding-language clue.
(v"//"\ v/#/\ v/%%/\ m)10?
( (v"//"\v/#/\)\ %%Assumed to be C.
  ( ono-omor v/)/(r, m), ol0(v./*.f.*/., v"//"r0, v/"/(r, m)(f1/"/v-/*/r)0(r, m), v/'/f1/'/, v/(/ol1o-(r, m),v/)/\(r,m,okol-1?\), o~(r, m))0okx2 )
, v/%%/  %%Assumed to be jot script
  %%If initially at a ')' - move on by one character.
  ono-omor ol0 ( v/)/(r, m), )
  ( %%Command-character loop.
    %%Skip blanks and line breaks.
    ( (v/ /r)0 r\m, r-\)0
    %%Count '(' and ')'.
    v/(/ol1o-(r, m), v/)/(r(q/0-9/r)0, m)(o~, x2),
    %%Skip to terminating semicolon or remainder of line for percent commands.
    v/%/ (v/%%/m, r2f1/;/\r0, (oc(v-/\/r-)0oc f1/;/ro-ol2o%(ol0o=okx2, ok) f1/;/)0 ),
    %%Else clause.
    v/,/r,
    %%Simple commands (some have numeric argument).
    q/bcegjkprtwxyBCEGJKPRTWXY?\/ r(q/-0-9-/r)0,
    %% Commands with string argument.
    q/fiqsvFIQSV/(r(q/-0-9/r)0 (v/'/r2, n.ra!&f1'!-, m?) (q/-0-9/r)0 ),
    %%Commands with a buffer-key argument.
    q/ahuzAHUZ/(v/a/(r2q/+-./r)? (q/&/r)?, v/h/r2(q/0-9/r)0, r2),
    %%Operand-stack commands.
    q/oO/r(q/lL/r(q/-.0-9/r(q/.0-9/r)0, q/xX/(q/0-9a-fA-F/r)0, q/cC/r2), q/iI/r2, q/oOvVqQ/ rn.ra!&f1'!-, r),
    %%Move command.
    q/mM/r(q/=+*/r,)(q/-0-9/r)0,
    %%Macro call.
    v/'/r2,
    %%Note.
    q/nN/r(v/./r,) )0
  okx
, %%Assumed to be natural language.
  ( ono-omor v/)/(r, m), ol0(v/(/ol1o-(r, m), v/)/\(r,m,okol-1?\), o~(r, m))0ok )
  )
%s=system 0; 
  
<<MatchCurlyRight>>
%s=system 1; v/}/(r, m), ol0(v./*.f.*/.,v/"/(r, m)(f1/"/v-/*/r)0(r, m),v/'/f1/'/,q/{/ol1o-(r, m),q/}/\(r,m,okol-1?\),o~(r, m))0ok %s=system 0; 
  
<<MatchAngleRight>>
%s=system 1; v/>/(r, m), ol0(v./*.f.*/.,v/"/(r, m)(f1/"/v-/*/r)0(r, m),v/'/f1/'/,q/</ol1o-(r, m),q/>/\(r,m,okol-1?\),o~(r, m))0ok %s=system 0;
  
<<MatchSquareRight>>
%s=system 1; v/]/(r, m), ol0(v./*.f.*/.,v/"/(r, m)(f1/"/v-/*/r)0(r, m),v/'/f1/'/,q/[/ol1o-(r, m),q/]/\(r,m,okol-1?\),o~(r, m))0ok %s=system 0;
  
<<MatchMarkupRight>>
%%The cursor must be initially positioned over the '<' of a markup block start and finds the corresponding block end.
%%e.g. "<span", in this case it locates the matching "</span" tag.
%%
%s=system 1; 
%%First pick up the block tagName id.
((v/</, f/</)v"</"r)0 rn.(q/ >/\r)0a$&f-1/</
%%Now search for possible block-end tag - updating the depth-search counters as appropriate.
ol-1 
( %%Block-start/end loop.
  %%Search forwards for the next block-start/end with this tagName.
  (( f/</ r(v"/"r, )v'$\)0 r-f1'$-q/A-Za-z0-9_/ r)0
  %%This is either a matching <tagName or a </tagName block delimiter, decrement the counter for another <tagName ... , incriment for </tagName ... 
  f-1/</v"</"\ ol1o-(r, m), o~ r)0ok
%s=system 0;
  
<<MatchMarkupLeft>>
%%The cursor must be initially positioned over the '<' of a markup block end and finds the corresponding block start.
%%e.g. "</span", in this case it locates the matching "<span" tag.
%%
%s=system 1; 
%%First pick up the block tagName id.
((v/</, f-/</)v"</"\(r-2, m-r0))0 r2n.(q/ >/\r)0a$&f-1/</
%%Now search for possible block-end tag - updating the depth-search counters as appropriate.
ol-1 
( %%Block-start/end loop.
  %%Search backwards looking for the previous block-start/end with this tagName.
  (( f-/</ r(v"/"r, )v'$\f-/</)0 r-f1'$-q/A-Za-z0-9_/ f-/</)0
  %%This is either a matching <tagName or a </tagName block delimiter, decrement the counter for another </tagName ... , incriment for <tagName ... 
  f-1/</v"</" ol1o-((r-, m-r0), m-), o~ (r-, m-r0))0ok
%s=system 0;
  
<<DeleteChrLeft>>
(n.(r-,m-r0)?a%-)
  
<<RestoreChrLeft>>
(obz$(obo= %x=Can not restore characters to ( $ ) buffer.;, ) z%m-0n.(r,m,)a$ozh$)
  
<<DeleteChrRight>>
(n.(r,m)?a%+)
  
<<RestoreChrRight>>
(obz$ob(o= %x=Can not restore characters to ( $ ) buffer.;, ) z%m0r0n.((r-,m-r0)a$ozh$(r-,m-r0)), a$oz)
  
<<AppendLeftPrev>>
(q-/ /r-)0(q/ /e)0n.r-0(q/ /r)0a$r-0h$b-j-(q-/ /r-)0(q/ /e)0i-/ /
  
<<AppendRightNext>>
(q-/ /r-)0(q/ /e)0n.r0a$m(q/ /r)0h$(q-/ /r-)0(q/ /e)0i-/ /
  
<<JoinLeftPrev>>
r-0(q-/ /r-)0(q/ /e)0n.r-0(q/ /r)0a$r-0h$b-j-(q-/ /r-)0(q/ /e)0i-/ /j
  
<<JoinRightNext>>
r-0(q-/ /r-)0(q/ /e)0n.r0a$m(q/ /r)0h$(q-/ /r-)0(q/ /e)0i-/ /j-
  
<<Break>>
%%Breaks line at current-character position and indents to match original, respecting bullet strings.
%s=system 1; 
%%Count blanks.
b(v/ /e)0m-(v/ /r)0 
%%Is this a bullet line.
oq/'=DocBulletString/ (v'~rr-f1'~-, ) 
%%Indent the 2nd. half line.
ocmol-1oso- (o~i/ /)0 
%%Adjust view if necessary.
(%q=inview; okokok, osokosokol1o- %b=leftoffset '~;) 
%s=system 0; ok
  
<<Join>>
%s=system 1; j-(v-/ /e-)0(v/ /e)0i/ / (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;) %s=system 0;
  
<<IndentFromPrev>>
%s=system 1; r-0(v/ /e)0m-n.(v/ /r)0a$&mh$ %s=system 0;
  
<<IndentFromNext>>
%s=system 1; r-0(v/ /e)0mn.(v/ /r)0a$&m-h$ %s=system 0;
  
<<BlockUp>>
m-(r\m-)0r-(rm-)0m
  
<<BlockDown>>
m(r\m)0r-(rm)0(r\m)0r-
  
<<ChapterUp>>
(m-(q/A-Za-zĀ-𠀹/\,r\))0r- (m-(q/ /r)0q/A-Za-zĀ-𠀹/)0m
  
<<ChapterDown>>
(mq/A-Za-zĀ-𠀹/\,r\mm-)0 mm-

<<HeadedSectionUp>>
(m-(q/0-9/\,r\))0r- (m-(q/ /r)0q/0-9/)0m
  
<<HeadedSectionDown>>
(mq/0-9/\,r\mm-)0 mm-

<<ParagraphUp>>
%%Pick up bullet string.
on oq/'=DocBulletString/ 
( %%Main loop - only repeats if original start line was a one-line paragraph.
  %%If on an unindented, blank or bullet-point line, search back for previous indented line and push initial indent to stack.
  r-0 ( (v/ /\(m-, x2))0 (v/ /r)0 (v'~r-f1'~-x2, ) (r\(m-, x3), ) r-\)0 oc r-0
  ( %%Record loop - exit if the line is blank or if it's a bullet or if indent doesn't match.
    (v/ /r)0 (rr-, m\) os(v'~\os, r-f1'~-osoc (o=x3, mx3)) oc (o=, m\)
    %%Index to next line.
    (m-2m, okx3) )0 ok
  %%If we're still at the original start line, then move up one line and repeat
  osono=osm- )0 okok
m-m
%%r-0

<<ParagraphDown>>
%%Pick up bullet string.
on oq/'=DocBulletString/ 
( %%Main loop - only repeats if original start line was a one-line paragraph.
  %%Search for next indented line and push initial indent to stack.
  ( (v/ /\(m, x2))0 (v/ /r)0 (v'~r-f1'~-x2, ) (r\(m, x3), ) r-\)0
  %%If we're still at the original start line, exit now.
  osono=os oc
  ( (m, x3) %%Record loop - index to next line.
    %%Exit if the line is blank or if it's a bullet or if it's indent doesn't match.
    (v/ /r)0 (rr-, m\) os(v'~\os, x3) oc o=)0 okr-0
  )0 okok 
mm-
%%r-0

<<SentenceUp>>
(q-/. /r-)0r-?( (f-1/./\m-(v/ /r)0rr0)0 (v/./r, ) (v/ /r)0 rr-q/A-ZА-ЯҐΑ-Ω/\f-1/./ )0 oc(m-mor, okx\)
  
<<SentenceDown>>
(v/./, )( (f1/./\m(v/ /r)0rr-)0 (v/./r, ) (v/ /r)0 rr-q/A-ZА-ЯҐΑ-Ω/\f-1/./ )0 oc(mm-or, okx\)
  
<<IndentMatchUp>>
%s=system 1; r-0q/ /\(m-(q. /$.,r\))0r-,(v/ /r)0oc(m-(v/ /r)0oco=\)0ok %s=system 0;
  
<<IndentMatchDown>>
%s=system 1; r-0q/ /\(m(q. /$.,r\))0r-,(v/ /r)0oc(m(v/ /r)0oco=\)0ok %s=system 0;
  
<<Macro0>>
%%Prompt string: Macro-0 parameters> 
'0
  
<<Macro1>>
%%Prompt string: Macro-1 parameters> 
'1
  
<<Macro2>>
%%Prompt string: Macro-2 parameters> 
'2
  
<<Macro3>>
%%Prompt string: Macro-3 parameters> 
'3
  
<<Macro4>>
%%Prompt string: Macro-4 parameters> 
'4
  
<<Macro5>>
%%Prompt string: Macro-5 parameters> 
'5
  
<<Macro6>>
%%Prompt string: Macro-6 parameters> 
'6
  
<<Macro7>>
%%Prompt string: Macro-7 parameters> 
'7
  
<<Macro8>>
%%Prompt string: Macro-8 parameters> 
'8
  
<<Macro9>>
%%Prompt string: Macro-9 parameters> 
'9
  
<<UpRegardless>>
%s=system 1; ocol-1oso- (m-, b-)(o~ (r, i/ /))0 ok %s=system 0;
  
<<DownRegardless>>
%s=system 1; ocol-1oso- (m, r0b)(o~ (r, i/ /))0 ok %s=system 0;
  
<<RightRegardless>>
(r, i/ /)
  
<<Enter>>
%%Prompt string: Enter string> 
%s=system 1; r-0ol0(ol1o-v/ /r)0 r0b (o~i/ /)0 ok i'$ %s=system 0;
  
<<InsertMode>>
%s=commandmode +2
  
<<TempInsertMode>>
%s=commandmode +3
  
<<Again>>
1
  
<<AgainExhaustive>>
%%Repeats the last command until it fails, reporting total iterations.
%%First pick up last command - to buffer ( * ).
ob %q*=history; m0m-k0m-k-0oz 
%%Set up counter, do repeats and report.
ol0 ('*o~)0 %m=Completed &'~& repeats; 

<<DebuggerQuit>>
%%With no value or a zero this simply bombs out of the debugger, when a numeric parameter is given it exits the specified number of blocks.
ol0## (ol0o=ok %s=commandcounte 0; %s=trace 0;, ol2o+ %s=traceskip '~; )
  
<<FocusToMouse>>
%%This needs to be at least two lines long, then it gets entered as a function call which can be redefined
%%by functions needing to redefine mouse-event behaviour.
opozono-omor 
(q/0-9a-zA-Z_Ā-𠀹/r)0oc(q-//r-)0oco-ou
  
<<NoteFromMouse>>
opozono-omor p n.
  
<<CopyFromMouse>>
opozono-omor p a_&
  
<<InsertHereMouse>>
opozono-omor h_
  
<<SelectionStart>>
oconobop
  
<<SelectionEnd>>
ozono-omorn. opozono-omor a$& ozono-omor
  
<<SelectionWord>>
oconobopozono-omor (q-/A-Za-z0-9_Ā-𠀹/r-)0n.(q//r)0 a$& ozono-omor
  
<<SelectionLine>>
oconobopozono-omor r-0n.r0 a$& ozono-omor
  
<<SelectionPut>>
obz$i/%s=commandstring /oz'$
  
<<SelectionFree>>
n.a$&

<<ScriptByName>>
%%Prompt string: Script subname> 
%%Searches scripts in PWD and ${JOT_HOME}/coms for scripts matching a a specified name.
%s=system 1; ob
%%Define buffer 0.
n.a0&z0 oo/z%c/ i/%s=commandstring %r='+/
%%Acquire search string.
%%Add instructions to + buffer.
n.a+&z+i/Select one of these scripts with names matching "/i'$i/" then hit {KP_0}./
%%Get raw directory listing.
%q~=dir ${JOT_HOME}/coms/;
%%Add the raw directory listing.
z+bh~ok
%%Filter the directory listing.
m-0m (v/dir /m, r0v-/.jot/m, k)0 m-0m z$r-0(r z+(v/dir /m, f1'$m, k)0, z+)
%%Construct the pathnames.
m-0m (v/dir /r4n.r0a$k, rr-h$m)0
%%Rewind and finish.
z+m-0m %s=system 0;

<<ScriptByFunc>>
%%Prompt string: Script function string> 
%%Searches scripts in PWD and ${JOT_HOME}/coms for scripts matching a a specified name.
%s=system 1; ob
%%Define buffer 0.
n.a0&z0 z0i"z+l0n.f1/ /a$&"r0 oo/z%c/ i"%s=commandstring %r='$"
%%Acquire search string.
%%%d$=mc;
%%Add instructions to + buffer.
n.a+&z+i/These script's 1-line descriptions all match "/i'$i/" select one then hit {KP_0}./
%%Get the first-line comments.
%e~=\head -1 ${JOT_HOME}/coms/*.jot ./*.jot;
%%Top and tail the report and append to + buffer.
m-0 (v/==> /e4f1/ <==/s/	/j2m, m)0 z+r0bh~bok
%%Filter out those matching the given string.
m-0f/"/-n.f1/"/a$&m (z$r-0r z+(mm-f1/	/f1'$m, k)0, z+)
%%Find rightmost tab.
ol0m-0m(f/	/roc (o<okoc,) m)0
%%Resolve the first tabs.
m-0(f/	/ei/ /o#oc (o> ocoso- (i/ /o~)0, ) ok m)0 ok
%%Rewind and finish.
z+m-0m %l; %s=system 0;

<<CompareBufs>>
%%Prompt string: Comparison buffer> 
%%Compares current record of current buffer with that of nominated buffer.
obz$m-0(rr\r-  %%The reference buffer is given set up new values for CompareBufs.
  (q/a-z/cr-, )oic(oq/'=CompRefBuf/ oq/'=CompCurrBuf/, %h'=data CompRefBuf; %h'=data CompCurrBuf; ov/'=CompRefBuf/ ov/'=CompCurrBuf/)
  %%Pick up buffer keys.
  (oq/'=CompRefBuf/ oq/'=CompCurrBuf/, %x=Error: no predefined comparison buffers;)
, %%Use previously-defined buffers.
  ok
  %%Pick up buffer keys.
  (oq/'=CompRefBuf/ oq/'=CompCurrBuf/, %x=Error: no predefined comparison buffers;)
  (z$r-0r2 %m=Applying "&'$&";
    oso#oz'$ oso#oz'$ )
  , %m=Restarting from next line of both buffers;
    oso#ozm oso#ozm )
%%Compare records until there's a failure.
(oso#oz r(r-n.r0a$& oso#ozr-0(v'$r0v-'$, posozpozx3), oso#ozr-0(r\, posozpozx2)) moso#ozmos)0 

<<FindWild>>
%%Prompt string: Find-wild string> 
%%finds next line containing substrings in correct order.
%%Set up argument list if given - use last entry if it's null.
%s=system 1; obz$ (rr- (f1/*/eb)0 m-0n.m0r0a@, ) z@m-0oz
%%reset search list and advance current character if already at an initial match point
obz@m-0oz (v'@r,)
%%Main search loop.
f'@rr-oc (f1'@-\ mobz@m-0ozf'@rr-okoc, obz@(moz, oz\))0
%%If successfully completed search select complete string.
(v-'@ n.oco-ora$h$f-1'$, ) %s=system 0;

<<FindWildBack>>
%%Prompt string: Find-wild string> 
%%finds previous line containing substrings in correct order.
%%Set up argument list if given - use last entry if it's null.
%s=system 1; obz$ (rr- (f1/*/eb)0 m-0n.m0r0a@, ) z@m0oz
%%reset search list and advance current character if already at an initial match point
obz@m0oz (v'@(r-, m-r0),)
%%Main search loop.
f-'@-r-roc (f-1'@\ m-r0obz@m0ozf-'@-r-rokoc, obz@(m-oz, oz\))0
%%If successfully completed search select complete string.
(v'@ n.oco-ora$h$f-1'$, ) %s=system 0;

<<FindLineUn>>
%%Prompt string: Find-in same line string> 
%%Function finds next line matching a set of substrings in the any order.
%%
%%Prepare args in @ buffer.
%s=system 1; obz$ (r\z@, r-n.r0a@&z@ ((v/ /e)0(f1/ /v-/\/e-r)0 v/ /b(v/ /e)0)0 r0b) m-0oz
%%Go
(f'@ (obz@(m2m-oz, oz\)r-0 f1'@-)0 obz@(mm-0oz, oz\)m)0 
%%If the previous loop completed at the end of the list of substrings then a match was found.
obz@(m\oz, oz %x=Failed to find a line containing the specified set of substrings.; ) %s=system 0;

<<FindLineOrd>>
%%Prompt string: Find-in same line string> 
%%Function finds next line matching a sequence of substrings in the same order as given.
%%
%%Prepare args in @ buffer.
%s=system 1; obz$ (r\z@, r-n.r0a@&z@ ((v/ /e)0(f1/ /v-/\/e-r)0 v/ /b(v/ /e)0)0 r0b) m-0oz
%%  obz$ (r\z@, r-n.r0a@&z@  ((v/ /e)0f1/ /b(v/ /e)0)0 r0b) m-0oz
%%Go
(f'@oc (obz@m2m-oz f1'@-)0 obz@mm-0ozokr)0 okoz
%%If the previous loop completed at the end of the list of substrings, a match was found - let's see.
(obz@m\ ozoc o-ou, ozok) %s=system 0;

<<FindLineOrdBack>>
%%Prompt string: Find-in same line string> 
%%Function finds previous line matching a sequence of substrings any order.
%%
%%Prepare args in @ buffer.
%s=system 1; obz$ (r\z@, r-n.r0a@&z@ ((v/ /e)0(f1/ /v-/\/e-r)0 v/ /b(v/ /e)0)0 r0b) m-0oz
%%  obz$ (r\z@, r-n.r0a@&z@  ((v/ /e)0f1/ /b(v/ /e)0)0 r0b) m-0oz
%%Go
(f-'@oc (obz@m2m-ozr-0 f1'@-)0 obz@mm-0ozokr-?)0 okoz
%%If the previous loop completed at the end of the list of substrings, a match was found - let's see.
(obz@m\ ozoc o-ou, ozok) %s=system 0;

<<FindSequence>>
%%Prompt string: Find-sequence string> 
%%function finds the sequence of words in arg - ignoring of whitespace & breaks.
%%Set up argument list if given - use last entry if it's null.
%s=system 1; obz$ (rr- (r(v-/*/q/_A-Za-z0-9Ā-𠀹/b, r-) (q/_A-Za-z0-9Ā-𠀹/\e)0 q//(q//r)0 brr-)0 r-0(r, j-) z@m-0k0e0h$,) z@m-0o#oz
%%If already matched to first item - find next.
(v'@r,)
( %%Main loop - first find the next occurence of the first item.
  %%Initial search for first item. 
  (f'@(q-/_A-Za-z0-9Ā-𠀹/r?, rr-f1'@-q/_A-Za-z0-9Ā-𠀹/))0 v-'@
  %%Match all remaining items.
  ( %%Index to next item - exit on last item.
    z@mo#oz
    %%Find next word.
    ((q/_A-Za-z0-9Ā-𠀹/\r)0r\m)0 r-
    (v'@(q-/_A-Za-z0-9Ā-𠀹/r?, rr-f1'@-q/_A-Za-z0-9Ā-𠀹/))0 (v-'@, obz@(v/*/oz(q/_A-Za-z0-9Ā-𠀹/r)0, oz\))
    )0
  o#ozv-'@\ z@m-0o#oz
  )0
%%Completed search - reset search list and go back to the first item.
v-'@r-rz@m-0o#oz (f-'@(q-/_A-Za-z0-9Ā-𠀹/r-?,rr-f1'@-q/_A-Za-z0-9Ā-𠀹/f-'@))0f-1'@ ok %s=system 0;

<<FindVertInit>>
%%Initialization procedure for all vertical-find functions.
%%If find-column string not set up then do it now.
( oq/'=FindVerticalSpecification/ok, %h'=data FindVerticalSpecification; ) 
%%Save/retrieve FindVerticalSpecification.
(obz$r-0r %d~='$; ov/'=FindVerticalSpecification/, ) oz
%%Setup colour tags - if not already done for this buffer.
ob %q$=buffer; (f/TagType = Name     Vertical,/oz, oz %b=tagtype -colour=black:magenta Vertical; )
%%ob %q$=buffer; (f/TagType = Name     Vertical,/oz, oz (%q=windows; %b=tagtype -colour=0:5 Vertical;, %b=tagtype -colour=0:5 Vertical;) )
%%Clear any old tags.
oconob %q$=tags;
( %%Colour-tag removal loop.
  f/active colour is Vertical/
  %%Pick up substring length, start point and line no.
  o#f-1/ to /-oidf-1/, chr /-oido-os f-1/, chr /-oidos f-1/At rec /-oidos
  %%Now remove the tag.
  moz ono-om or o~ou %b=remove_tag -colour Vertical;  %w=refresh; z$m)0
%%Return cursor to original position.
ozono-omor

<<FindVertVerifyColumn>>
%%Verifies column match.
%%Calling function has set buffer ( @ ) to contain column specification
%%and has done y0 to lock y into the correct column.
obz@
( %%Character loop.
  %%Check for end of specification line.
  (rr-, ozx0)
  %%A ( * ) indicates a wild match - skip any number of characters in the column until we wind a match.
  ( v/*/ ozon ( %h'=call FindVertVerifyWild; okx0, o~ono-omy- x0\ ), )
  %% blanks are ignored.
  (v/ /r)0
  %% ( . ) is a single wild character.
  v/./o#ozyz@(r2r-, ozx0),
  %%Escaped characters treated as-is.
  (v/\/r, )
  %%Verify all other characters.
  n.ra$&ozv'$y obz@, x0\)0

<<FindVertVerifyWild>>
%%Verifies column wildcard match, called by FindVertVerifyColumn and recursively by itself to synchronize and match the column pattern.
( %%Find the next-matching character in the column.
  obz@r (v/ /r)0 (v/\/r, ) (v/./ozy, n.ra$& oz (v'$\ y)0 (v'$, x0\) yobz@ )
  %%Verify the remainder of column normally.
  ( %%Character loop.
    %%Check for end of specification line.
    (rr-, ozx0)
    %%A ( * ) indicates another wild match.
    ( v/*/ ozon ( %h'=call FindVertVerifyWild; okx0, o~ono-omy- x0\ ), )
    %% blanks are ignored.
    (v/ /r)0
    %% ( . ) is a single wild character.
    v/./o#ozyz@(r2r-, okokx0),
    %%Escaped characters treated as-is.
    (v/\/r, )
    %%Verify all other characters.
    n.ra$&oz v'$yobz@, x0\)0 )0

<<FindVert>>
%%Prompt string: Find vertical string:
%%Finds specified string in any column.
%%Initialize for search.
%h'=call FindVertInit; oboq/'=FindVerticalSpecification/ %d@='~; z@m-0 ozy0
( %%Initial match search loop.
  obz@r-0
  %%Find next initial match.
  (v/ /r)0v/./oz, (v/\/r, )n.ra$&r-0 oz (f'$y0, x0\)
  %%Verify the column and, if successful, add colour tags.
  on %h'=call FindVertVerifyColumn;\ o~ono-omy-(r, m) )0
ono-o#o#o~omy- ( ol1ou %b=addtag Vertical; o~y )0  %w=refresh; ok ol2o+omy-(r, m)

<<FindVertBack>>
%%Prompt string: Find vertical string:
%%Finds specified string in any column.
%%Initialize for search.
%h'=call FindVertInit; oboq/'=FindVerticalSpecification/ %d@='~; z@m-0 ozy0
( %%Initial match search loop.
  obz@r-0
  %%Find next initial match.
  (v/ /r)0v/./oz, (v/\/r, )n.ra$&r- oz (f-'$y0, x2\)
  %%Verify the column and, if successful, add colour tags.
  on %h'=call FindVertVerifyColumn;\ ono-omyy-(r-, m-r0) )0
ono-o#o#o~omy- ( ol1ou %b=addtag Vertical; o~y )0  %w=refresh; ok ol2o+omy-(r-, m-r0)

<<FindCol>>
%%Prompt string: Find column string:
%%Finds specified string in current column.
%%Initialize for search.
%h'=call FindVertInit; oboq/'=FindVerticalSpecification/ %d@='~; z@m-0 ozy0
( %%Initial match search loop.
  yy-
  obz@r-0
  %%Find next initial match.
  (v/ /r)0v/./oz, n.ra$&r- oz(v'$\y)0
  %%Verify the column and, if successful, add colour tags.
  on %h'=call FindVertVerifyColumn;\ ono-omy )0
ono-o#o#o~omy- ( ol1ou %b=addtag Vertical; o~y )0  %w=refresh; ok ol3o+omy-

<<FindColBack>>
%%Prompt string: Find column string:
%%Finds specified string in current column.
%%Initialize for search.
%h'=call FindVertInit; oboq/'=FindVerticalSpecification/ %d@='~; z@m-0 ozy0
( %%Initial match search loop.
  y-y
  obz@r-0
  %%Find next initial match.
  (v/ /r)0v/./oz, n.ra$&r- oz(v'$\y-)0
  %%Verify the column and, if successful, add colour tags.
  on %h'=call FindVertVerifyColumn;\ ono-omy- )0
ono-o#o#o~omy- ( ol1ou %b=addtag Vertical; o~y )0  %w=refresh; ok ol3o+omy-

<<findRect>>
%%Prompt string: Find rectangle buffer:
%%Searches the current buffer for a rectangular area matching text in the nominated buffer.
%h'=call findRectInit;
%%
%%Pick up specification
oq/'=FindVerticalSpecification/ z~m-0n.m0r0a@&osozok
( %%Rectangle-start loop - find next match to top-left character in specification.
  %%Find initial match and save start position.
  obz@m-0 (v/ /r)0v/./oz, (v/\/r, ) n.ra$&r- oz(f'$, x3\)y0 oconol0
  ( %%Column loop.
    %%Check for a wild column ( * ).
    obz@ ( v/*/oz ( %h'=call findRectWildColumn; x4, x-4 ), oz)
    %%Verify this column.
    on %h'=call FindVertVerifyColumn;
    %%Column match success - save LWM line no. and index to next column.
    oson(o<\, okon) oso~ono-omy- obz@(moz, ozx3) ry0
  , %%Column-verification failed, return to previous rectangle start and resume first-character search.
    o~ono-omy-(r, m) okokokx)0
  )0
%%Match success, add colour tags.
oso-o#om %w=refresh; ol-1oso- oso#y-oco~oso- osr-0ory0 (oso~ os o#ou %b=addtag Vertical; y-)0 okok y(r, m)

<<findRectBack>> 
%%Prompt string: Find rectangle buffer:
%%Searches back in the current buffer for a rectangular area matching text in the nominated buffer.
%h'=call findRectInit;
%%
%%Pick up specification
oq/'=FindVerticalSpecification/ z~m-0n.m0r0a@&osozok
( %%Rectangle-start loop - find next match to top-left character in specification.
  %%Find initial match and save start position.
  obz@m-0 (v/ /r)0v/./oz, (v/\/r, ) n.ra$&r- oz(f-'$, x3\)y0 oconol0
  ( %%Column loop.
    %%Check for a wild column ( * ).
    obz@ ( v/*/oz ( %h'=call findRectWildColumn; x4, x-4 ), oz)
    %%Verify this column.
    on %h'=call FindVertVerifyColumn;
    %%Column match success - save LWM line no. and index to next column.
    oson(o<\, okon) oso~ono-omy- obz@(moz, ozx3) ry0
  , %%Column-verification failed, return to previous rectangle start and resume first-character search.
    okok ono-om or(r-, m-r0) okx)0
  )0
%%Match success, add colour tags.
oso-o#om %w=refresh; ol-1oso- oso#y-oco~oso- osr-0ory0 (oso~ os o#ou %b=addtag Vertical; y-)0 okok y(r-, m-r0)

<<findRectInit>> 
%%Initialize for rectangle search.
%h'=call FindVertInit; 
%%FindVertInit has only copied the buffer key into FindVerticalSpecification, here we copy the actual specification.
oboq/'=FindVerticalSpecification/ 
%%Copy specified buffer, if buffer key is specified.
( z~m-0mz$ok %%A previously-defined specification seems to exist.
, %%Assumed to be just a buffer key.
  oso#ozos %d$='~; 
  %%Copy the specification.
  z$(r\, %%A buffer key was specified, check and copy the spec.
    r- (q/a-zA-Z0-9/, %x=Error: findNext parameter must be a buffer containing the rectangular search specification.; )
    (q/a-z/cr-, )oicoz m-0n.m0r0a~& ov/'=FindVerticalSpecification/ ) )

<<findRectWildColumn>>
%%Called recursively - finds next 1st-character match and verifies the column.
( %%Save current position in specification and pick up the character to be matched.
  obz@onos m(v/\/r, )n.ra$&r- oz (f1'$y0oc, okokx0\) 
  ( %%Column loop - verify each column.
    obz@ (v/ /r)0v/./, (v/\/r, )
    v/*/ %%Another wild column, if that fails then set focus to next first-character search-start point.
    oz ( %h'=call findRectWildColumn; okokx0, r-0rr obz@m-0osomoz x0\ )
  , %%A normal column.
    ozon %h'=call FindVertVerifyColumn; 
    %%Column match success - index to next column.
    o~ono-omy- obz@(m, ozokokx0) ozry0x-1
  , %%Column-verification failed, return to wild-column specification and resume wild-column search.
    ono-om orr obz@osono-om ozx-2) )

<<rotateDiagonal>>
%%Rotates the current block of text around the leading diagonal.
%%Init.
n.a$& m0(rr0b, )
( %%Main loop - assembles one line of output.
  m-0 ol0
  %%Pick up a line of output.
  ((ro~, i/ /)r-n.ra$+m2m-)0 obz$r0boz
  %%If all lines are empty, stop now.
  ol0o=\ok)0 ok
m-0k0h$

<<rotateVertical>>
%%Reverses the order of the columns in the buffer, adds whitespace where necessary.
%%
%%First find the longest line then pad out all other line ends to match.
ol0m-0 (r0oc(o<okoc,)m)0 m-0(r0o#ocoso-ol-1o+ (o~i/ /)0 okm)0 ok
%%Reverse each column.
m-0 (n.a$& (n.ra$-)0 h$m)0

<<rotateHorizontal>>
%%Reverses the order of the lines in current buffer.
%%First get length of buffer.
m0on(r, ol1o-) r0bm-0
%%Move lines.
(ol1o=\ m-0na$ ol1o-o#omh$)0
%%Remove added linebreak.
m0j-m-0

<<FindSequenceBack>>
%%Prompt string: Find-sequence string> 
%%Finds previous instance of sequence of words in arg.
%%Set up argument list if given - use last entry if it's null.
%s=system 1; obz$ (rr- (r(v-/*/q/_A-Za-z0-9Ā-𠀹/b, r-) (q/_A-Za-z0-9Ā-𠀹/\e)0 q//(q//r)0 brr-)0 r-0(r, j-) z@m-0k0e0h$,) z@m-0o#oz
%%If already matched to first item - find next.
(v'@r-,)
( %%Main loop - first find the next occurence of the first item.
  %%Initial search for first item. 
  (f-'@(q-/_A-Za-z0-9Ā-𠀹/r?,r-?f1'@-q/_A-Za-z0-9Ā-𠀹/)r-f-1'@)0 v-'@
  %%Match all remaining items.
  ( %%Index to next item - exit on last item.
    z@mo#oz
    %%Find next word.
    ((q/_A-Za-z0-9Ā-𠀹/\r)0r\m)0 r-
    (v'@(q-/_A-Za-z0-9Ā-𠀹/r?, rr-f1'@-q/_A-Za-z0-9Ā-𠀹/))0 (v-'@, obz@(v/*/oz(q/_A-Za-z0-9Ā-𠀹/r)0, oz\))
    )0
  o#ozv-'@\ (r-, m-r0)z@m-0o#oz
  (f-'@(q-/_A-Za-z0-9Ā-𠀹/r?,r-?f1'@-q/_A-Za-z0-9Ā-𠀹/)r-f-1'@)0 v-'@
  )0
%%Completed search - reset search list and go back to the first item.
v-'@r-rz@m-0o#oz (f-'@(q-/_A-Za-z0-9Ā-𠀹/r-?,rr-f1'@-q/_A-Za-z0-9Ā-𠀹/f-'@))0f-1'@ ok, ok %s=system 0; 

<<ProximityFindSetup>> 
%s=system 1;
%%Initialization.
( oq/'=ProximityExpression/ok,    %h'=data ProximityExpression;    %d~=; ov/'=ProximityExpression/ )      %%The given expression.
( oq/'=ProximityKeywords/ok,      %h'=data ProximityKeywords;      %d~=; ov/'=ProximityKeywords/ )        %%The simplified list of essential keywords, used for initial search.
( oq/'=ProximityMultiplier/ok,    %h'=data ProximityMultiplier;    ol0   ov/'=ProximityMultiplier/ )      %%The optional count - defines no. of phrases, words  etc. in proximity section.
( oq/'=ProximityBuf/ok,           %h'=data ProximityBuf;           ob    ov/'=ProximityBuf/ )             %%The buffer to be searched.
( oq/'=ProximityRestartLine/ok,   %h'=data ProximityRestartLine;   on    ov/'=ProximityRestartLine/ )     %%The restart line for resumption of initial search.
( oq/'=ProximityRestartChr/ok,    %h'=data ProximityRestartChr;    oc    ov/'=ProximityRestartChr/ )      %%The restart character no. for resumption of initial search.
( oq/'=ProximityBraceCount/ok,    %h'=data ProximityBraceCount;    oc    ov/'=ProximityBraceCount/ )      %%Counts open-brace depth in extraction of ProximityKeywords.
%%
%%Set up argument list for proximity search, if none specified, use previous entry and clear colour tags.
obz$r-0(v/ /r)0
( rr- %%Args given - clean up the expression, save it and extract the simplified keywords list.
  %%Pick up number if given or default to 0.
  (v/ /e)0 (q/0-9/oide-0, ol0) ov/'=ProximityMultiplier/
  %%If only the number was given, then stick with the original word list.
  (v/ /r)0e-0rr-
  %%Respect escaped blanks, if there's an unescaped blank that's not adjacent to s ( & ) or a ( | ) report an error.
  (f1/ / (v-/\/e-r, (v/ /e)0 (q/|&/r(v/ /e)0, %x=Error: blanks are not valid separators in proximity expressions - use \& or | .;) ) )0 
  %%Save args in ProximityExpression data object.
  m-0n.r0a~& ov/'=ProximityExpression/
  %%
  %%Extract a list of essential terms - first simplify the expression one term to each line with no brackets or operators
  z$r-0n.r0a@ ol100 ol0ov/'=ProximityBraceCount/ z@r-0(q/&|/eb, q/(/rb, q/)/br, r)0 m0r0bm-0
  ( %%In the inversion-counting loop, the top of stack is the inversion count for the current brace - 100 for non-inversion or -101 for inversion.
    %%The ( $ ) buffer is set to "!" if an inversion is pending, otherwise empty.
    (v/ /e)0 ol100(o=, i/!/)
    %%If there's an inversion save in ( $ ) - defer any action until the type of term has been determined.
    v/!/ n.ra$ (v/ /r)0,  
    %%If an open-brace then copy the current inversion status to the stack.
    v/(/k? z$r-0o#(v/!/eo!, )z@ oq/'=ProximityBraceCount/ol1o-ov/'=ProximityBraceCount/,
    %%If a close-brace 
    v/)/k?ok z$r-0e0 ol100(o=, i/!/)z@ oq/'=ProximityBraceCount/o~?ov/'=ProximityBraceCount/,
    %%Next term.
    n.a$& m)0 
  %%Brackets-nesting sanity check.
  (oq/'=ProximityBraceCount/ol0o=okok, okok %x=Syntax: Parenthesis mismatch in proximity expression.; )
  %%Remove all double inversions, strip out inverted terms and join up and save the simplified keywords list.
  m0j- m-0(f/!!/e2m-0)0 m-0(v/!/k, m)0 m-0(ji/	/)0 m-0n.m0r0a~& ov/'=ProximityKeywords/
%%  m0j- m-0(v/#/em, m)0 m-0(f/!!/e2m-0)0 m-0(v/!/k, m)0 m-0(ji/	/)0 m-0n.m0r0a~& ov/'=ProximityKeywords/
  %%
, %%No args given - use old search parameters.
  oq/'=ProximityExpression/z~m-0n.r0a$&z$r-0ok )
%%
%%If undefined, define colour-tag types now.
ozob %q$=buffer; (f/TagType = Name    Substring,/\ oz %b=tagtype -colour=white:green Substring; %b=tagtype -colour=white:red UnitDelim;, oz )
%%ozob %q$=buffer; (f/TagType = Name    Substring,/\ oz 
%%  ( %q=windows; %b=tagtype -colour=7:2 Substring; %b=tagtype -colour=7:4 UnitDelim;, %b=tagtype -colour=7:2 Substring; %b=tagtype -colour=7:1 UnitDelim;), oz )
%%
%%Clear any colour tags.
oconob %q$=tags;
( %%Colour-tag removal loop.
  f/active colour is /-b- 
  %%First calculate the substring length.
  o#f-1/ to /-oidf-1/, chr /-oido-os
  %%Now get the substring start point.
  f-1/, chr /-oidos
  %%Finally, the line no.
  f-1/At rec /-oidos
  %%Now remove the tag.
  moz ono-om or o~ou %b=remove_tag -colour '$;  %w=refresh; z$m)0
ozono-omor

<<ProximityReport>>
%%Reports on recently-completed proximity search.
%%
%%First check for the existence of a substring.
oxol0 (o= okx0\, ok)
%%Add the UnitDelim tag before the matching section - first tag the last non-blank text above.
ob %q@=system; f/ %F aperture = /-oidosroidosozos  ono-om or (r-\m-r0)0 (rocr-0ou %b=addtag UnitDelim;, )  %w=refresh;
%%Now highlight after the section.
obz@r- f1/ - /- oidosroidosozos  ono-om or(r, m?) (r\m)0 (r- ocr0oco-ou %b=addtag UnitDelim;, )  %w=refresh; 
%%
oboq/'=ProximityKeywords/ z~r-0osoz
( %%Keyword loop - search in aperture for each key word.
  obosz~ (rr-, osozok\)n.(f1/	/, r0)a$&r? z$r-0(v/#/rb, )osoz 
  ( %f= -aperture -first '$;
    ( %%Keyword instance loop.
      obz$( (m-moz (q-/_A-Za-z0-9Ā-𠀹/\f'$-q//\v-'$ oxo~r-ou, rx3), oz)  %b=addtag Substring; (r, m) )
      %f= -aperture -restart -first '$; )0, ) )0
%%Leave the cursor at the restart point.
oq/'=ProximityRestartLine/ono-omoq/'=ProximityRestartChr/or
%%Clear  " $ " to allow repeated calls to proximity search functions.
n.a$&

<<ProximityFindNext>>
%%Searches forwards from the current character position to end of buffer to find the next occurence of the minimum keywords.
%%
%%Initialization - reset both the keywords list and the full expression, set ProximityRestartChr for resumption of failed search.
ob oq/'=ProximityExpression/z~r-0n.r0a@&z@r-0okoz
%%Search each line for the list of essential keywords.
oboq/'=ProximityKeywords/ z~r-0n.r0a$&z$okr-0(f/#/e)0oz ( %f= -first '$; x0, x0\)

<<ProximityFindBack>>
%%Searches back from the current character position to start of buffer to find the previous occurence of the minimum keywords.
%%
%%Initialization - reset both the keywords list and the full expression.
ob oq/'=ProximityExpression/z~r-0n.r0a@&z@r-0okoz
%%Search each line for the list of essential keywords.
oboq/'=ProximityKeywords/ z~r-0n.r0a$&z$okr-0(f/#/e)0oz ( %f= -first -back -reverse '$; (r-, m-r0) x0, x0\)

<<ProximityExpr>>
%%Elements (words or braces) are delimited by AND " & " or OR " | " and optionally prefixed by the NOT " ! " operators.
%%
%%After picking up the first element to buffer ( $ ), it calls either the OR or the AND functions as appropriate.
%%
%%
( %%Term loop - evaluate next term in the expression and set the top of stack with term status.
  obz@ 
  %%Set the inversion flag - inverts the value of the complete subexpression -  100 for non-inversion, -101 for inversion.
  (v/!/rol-101, ol100) os
  %%Evaluate term status.
  ( v/(/  %%A subexpression term.
    roz ( %h'=call ProximityExpr; ol-1, ol0) 
  , %%A simple word term - pick up word and launch a search.
    (n.(q/()|&!/\r)0a$&z$r-0 
    ( v/#/ %%This word must match exactly.
      rb oz (%f= -aperture '$; ((q-/_A-Za-z0-9Ā-𠀹/\f'$-q//\)\(r, m) onoc %f= -aperture -restart '$;)0 v-'$ol-1, ol0)
    , %%A non-exact match will do.
      oz %f= -aperture '$; ol-1, ol0) ) )
  %%Invert the result, if required.
  ( osol-101o=oko!, ok ) 
  %%
  %%At this point the current buffer should be the main text and the top of stack is the status of the most recent term.
  obz@
  ( %%AND/OR block.
    v/&/roz %%  AND 
    ( ol-1o=ok,   %%The latest term of the AND subexpressions failed - skip to the matching end-brace and exit with FALSE.
      okobz@ ol-1(v/(/ol1o-(r, m), v/)/\(r,m,okol-1?\),o~(r, m))0  okoz x0\ )
  , v/|/roz  %%  OR
    ( ol-1o=\ok,  %%The latest of the OR subexpressions matched within the proximity aperture - skip to the matching end-brace and exit with TRUE.
      okobz@ ol-1(v/(/ol1o-(r, m), v/)/\(r,m,okol-1?\),o~(r, m))0 okoz x0 )
  , (rv-/)/\)\    %%Expression terminated by close brace or an EOL - return with correct status value.
    %%
    %%Now irrespective of whether it's OR or AND, if it gets to the last term and the last term is TRUE then the whole expresson value *must* be TRUE.
    oz(ol-1o= okx0, okx0\)
  , r- %x=Syntax error: Unexpected character found in proximity expression.; pozx0\ )
  )0
%%
%%A matched expression will exit before this point - this must be a failure.
x0\

<<ProximityCharacters>>
%%Prompt string: Find-in-N-characters substring list> 
%%Finds next set of n consecutive characters containing a set of substrings, optional arg n defaults to 1 and is the first arg.
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindNext;
  %%Start point is the current character.
  onoc %f= -setaperture -startchr='~ -startline='~;
  onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/ 
  %%This loop has two counters because we need to set the restart point at the end of the first phrase, then set the aperture at the end of the n-th character.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol100, )ol0oso-
  ( (r, m) os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok
  onoc %f= -setaperture -endchr='~ -endline='~;
  %%Check the full expression.
  %h'=call ProximityExpr;\
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%
%h'=call ProximityReport;
%s=system 0;

<<ProximityCharactersBack>>
%%Prompt string: Find-in-N-characters substring list> 
%%Finds next set of n consecutive characters containing a set of substrings, optional arg n defaults to 1 and is the first arg.
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindBack;
  %%End point is the current character.
  onoc %f= -setaperture -endchr='~ -endline='~;
  %%This loop has two counters because we need to set the restart point at the end of the first phrase, then set the aperture at the end of the n-th phrase.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol100, )ol0oso-
  ( (r-, m-r0) os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok
  onoc %f= -setaperture -startchr='~ -startline='~;
  %%Check the full expression.
  %h'=call ProximityExpr;\
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%
%h'=call ProximityReport;
%s=system 0;

<<ProximityWords>>
%%Prompt string: Find-in-N-words substring list> 
%%Finds next set of n consecutive words containing a set of substrings, optional arg n defaults to 1 and is the first arg.
%%
%s=system 1;
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindNext;
  %%Start point will be the beginning of matching string.
  (q-/a-zA-Z0-9Ā-𠀹/r-)0 onoc %f= -setaperture -startchr='~ -startline='~; 
  %%This loop has two counters because we need to set the restart point at the end of the first phrase, then set the aperture at the end of the n-th word.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol10, )ol0oso-
  ( (q/a-zA-Z0-9Ā-𠀹/r)0(q/a-zA-Z0-9Ā-𠀹/\(r, m))0 os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok
  onoc %f= -setaperture -endchr='~ -endline='~;
  %%Check the full expression.
  %h'=call ProximityExpr;\ 
  %%No match in this aperture, continue searching from end of initial match.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%
%h'=call ProximityReport;
%s=system 0;

<<ProximityWordsBack>>
%%Prompt string: Find-in-N-words substring list> 
%%Working back from current-character position, finds next set of n consecutive words containing a set of substrings, optional arg n defaults to 1 and is the first arg.
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindBack;
  %%End point is the end of the word.
  (q/a-zA-Z0-9Ā-𠀹/r)0 onoc %f= -setaperture -endchr='~ -endline='~;
  %%This loop has two counters because we need to set the restart point at the end of the first phrase, then set the aperture at the end of the n-th word.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol10, )ol0oso-
  ( (q-/a-zA-Z0-9Ā-𠀹/r-)0(q-/a-zA-Z0-9Ā-𠀹/\(r-, m-r0))0 os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok
  onoc %f= -setaperture -startchr='~ -startline='~;
  %%Check the full expression.
  %h'=call ProximityExpr;\
  %%No match in this aperture, continue searching from start of initial match.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%
%h'=call ProximityReport;
%s=system 0;

<<ProximityLines>>
%%Prompt string: Find-in-N-lines substring list> 
%%Finds next set of n consecutive lines containing a set of substrings, optional arg n defaults to 1 and is the first arg.
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindNext;
  %%Start point is the beginning of this line.
  r-0 onoc %f= -setaperture -startchr='~ -startline='~; 
  %%This loop has two counters because we need to set the restart point at the end of the first phrase, then set the aperture at the end of the n-1th line.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  (m os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~)0 okok m-?r0onoc %f= -setaperture -endchr='~ -endline='~;
  %%Check the full expression.
  %h'=call ProximityExpr;\
  %%No match in this aperture, continue searching from end of initial match.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%End of buffer or overall search success - this sentence contains matches for all string specifications.
%h'=call ProximityReport;
%s=system 0;

<<ProximityLinesBack>>
%%Prompt string: Find-in-N-lines substring list> 
%%Finds next set of n consecutive lines containing a set of substrings, optional arg n defaults to 1 and is the first arg.
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindBack;
  %%End point is the end of this line.
  r0onoc %f= -setaperture -endchr='~ -endline='~;
  %%This loop has two counters because we need to set the restart point at the end of the first phrase, then set the aperture at the start of the n-1th line.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  (m- os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~)0 okok m?onoc %f= -setaperture -startchr='~ -startline='~;
  %%Check the full expression.
  %h'=call ProximityExpr;\
  %%Restart
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%
%h'=call ProximityReport;
%s=system 0;

<<ProximityPhrase>>
%%Prompt string: Find-in-phrase substring list> 
%%Finds next phrase containing a set of substrings
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindNext; 
  %%Search back for the start of the phrase and set the aperture staaart.
  (on %f= -back -first -reverse -endline='~ ,	.	:	\;	!	?	 - ;\ m-(v/ /r)0 rr0)0 onoc %f= -setaperture -startchr='~ -startline='~; 
  %%This loop has two counters because we need to set the restart point at the end of the first phrase, then set the aperture at the end of the n-th phrase.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  ( (on %f= -endline='~ -first ,	.	:	\!	?	\; - ;\m (v/ /r)0 rr-)0 (r, m) os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok
  %%Define the aperture end point and we're all set to go.
  onoc %f= -setaperture -endchr='~ -endline='~; 
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this phrase contains matches for all string specifications.
%h'=call ProximityReport; (r, m)
%s=system 0;

<<ProximityPhraseBack>>
%%Prompt string: Find-in-phrase substring list> 
%%Finds next phrase containing a set of substrings
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindBack; 
  %%Search forwards for the end of the phrase and set the aperture end.
  (on %f= -first -endline='~ ,	.	:	\;	!	?	 - 	;\ m(v/ /r)0rr-)0 onoc %f= -setaperture -endchr='~ -endline='~;
  %%This loop has two counters because we need to set the restart point at the start of the first phrase, then set the aperture at the start of the n-th phrase.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  ( (on %f= -back -first -reverse -endline='~ ,	.	:	\;	!	?	 - ;\ m-(v/ /r)0rr0)0 (r-, m-(v/ /r)0rr0) 
    os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok
  onoc %f= -setaperture -startchr='~ -startline='~;
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this phrase contains matches for all string specifications.
%h'=call ProximityReport; (r-, m-r0) 
%s=system 0;

<<ProximitySentence>>
%%Prompt string: Find-in-sentence substring list> 
%%Finds next sentence containing a set of substrings
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindNext; 
  %%Search back for the start of the sentence and set the aperture staaart.
  (on %f= -back -first -reverse -endline='~ .	!~?	 - ;\ m-(v/ /r)0 rr0)0 onoc %f= -setaperture -startchr='~ -startline='~; 
  %%This loop has two counters because we need to set the restart point at the end of the first sentence, then set the aperture at the end of the n-th sentence.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  ( (on %f= -endline='~ -first .	\!	?	\; - ;\m (v/ /r)0 rr-)0 (r, m) os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok
  %%Define the aperture end point and we're all set to go.
  onoc %f= -setaperture -endchr='~ -endline='~; 
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this sentence contains matches for all string specifications.
%h'=call ProximityReport;
%s=system 0;

<<ProximitySentenceBack>>
%%Prompt string: Find-in-sentence substring list> 
%%Finds next sentence containing a set of substrings
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindBack; 
  %%Search forwards for the end of the sentence and set the aperture end.
  (on %f= -first -endline='~ .	!	?	 - 	;\ m(v/ /r)0rr-)0 onoc %f= -setaperture -endchr='~ -endline='~;
  %%This loop has two counters because we need to set the restart point at the start of the first sentence, then set the aperture at the start of the n-th sentence.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  ( (on %f= -back -first -reverse -endline='~ .	!	?	 - ;\ m-(v/ /r)0rr0)0 (r-, m-(v/ /r)0rr0) os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/)  oso~ )0 okok
  onoc %f= -setaperture -startchr='~ -startline='~; 
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this sentence contains matches for all string specifications.
%h'=call ProximityReport; (r-, m-r0) 
%s=system 0;

<<ProximityPara>>
%%Prompt string: Find-in-paragraph substring list>
%%Finds next paragraph containing a set of substrings
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindNext; 
  %%Searching back from initial match, locate start of this paragraph and set aperture start.
  oq/'=DocBulletString/obosz~r-0n.r0a$& osozok r-0 (v/ /r)0oc (v'$oxo+, ) (m- (v/ /r)0oc (v'$okoxorx2, ) (rr-, ok\)o= )0 ok m(v/ /r)0onoc %f= -setaperture -startchr='~ -startline='~; 
  %%This loop has two counters because we need to set the restart point at the start of the first sentence, then set the aperture at the start of the n-th sentence.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso- 
  %%Paragraphs are delimited by any indentation change - search forwards for end of n-th paragraph.
  r-0 ( ((v/ /r)0r\m )0r-oc (v'$oxo+, ) (m (v/ /r)0oc (v'$okoxorx2, ) (rr-, ok\)o= )0 m okos (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok
  onoc %f= -setaperture -endchr='~ -endline='~; 
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this paragraph contains matches for all string specifications.
%h'=call ProximityReport;
%s=system 0;

<<ProximityParaBack>>
%%Prompt string: Find-in-paragraph substring list>
%%Finds previous paragraph containing a set of substrings
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindBack; 
  %%Searching forwards from initial match, locate end of this paragraph and set aperture end.
  oq/'=DocBulletString/obosz~r-0n.r0a$& osozok r-0 (v/ /r)0oc (v'$oxo+, ) m ( (v/ /r)0oc (v'$okx2, ) (rr-, ok\)o= m)0 ok m-r0onoc %f= -setaperture -endchr='~ -endline='~; 
  %%This loop has two counters because we need to set the restart point at the start of the first sentence, then set the aperture at the start of the n-th sentence.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  %%Paragraphs are delimited by any indentation change - search back to start of nth paragraph.
  r-0 ( ((v/ /r)0r\m-)0r-oc (v'$oxo+, ) ( (v/ /r)0oc (v'$okoxorx2, ) (rr-, ok\)o= m-)0 m- okos (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok
  onoc %f= -setaperture -startchr='~ -startline='~; 
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this paragraph contains matches for all string specifications.
%h'=call ProximityReport;
%s=system 0;

<<ProximityHeadedSection>>
%%Prompt string: Find-in-section substring list> 
%%Finds next section containing a set of substrings
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindNext; 
  %%Searching back from initial match, locate start of this section and set aperture start.
  r-0 (q/0-9/\ m-)0 onoc %f= -setaperture -startchr='~ -startline='~; 
  %%This loop has two counters because we need to set the restart point at the start of the first sentence, then set the aperture at the start of the n-th sentence.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  m ( (q/0-9/\ m)0 m os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok m-?
  onoc %f= -setaperture -endchr='~ -endline='~; 
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this section contains matches for all string specifications.
%h'=call ProximityReport;
%s=system 0;

<<ProximityHeadedSectionBack>>
%%Prompt string: Find-in-section substring list> 
%%Finds next section containing a set of substrings
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindBack; 
  %%Searching forwards from initial match, locate end of this section and set aperture end.
  r-0 (q/0-9/\ m)0  onoc %f= -setaperture -endchr='~ -endline='~; 
  %%This loop has two counters because we need to set the restart point at the start of the first sentence, then set the aperture at the start of the n-th sentence.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  m- ( (q/0-9/\ m-)0 m- os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok
  onoc %f= -setaperture -startchr='~ -startline='~; 
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this section contains matches for all string specifications.
%h'=call ProximityReport;
%s=system 0;

<<ProximityBlock>>
%%Prompt string: Find-in-block substring list> 
%%Finds next block containing a set of substrings - a block being any number of paragraphs and headed sections bounded by entierly blank lines.
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindNext; 
  %%Searching back from initial match, locate start of this section and set aperture start.
  r-0 (rm-)0 onoc %f= -setaperture -startchr='~ -startline='~; 
  %%This loop has two counters because we need to set the restart point at the start of the first sentence, then set the aperture at the start of the n-th sentence.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  m ( (rm)0 m os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/)  oso~ )0 okok
  onoc %f= -setaperture -endchr='~ -endline='~; 
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this section contains matches for all string specifications.
%h'=call ProximityReport;
%s=system 0;

<<ProximityBlockBack>>
%%Prompt string: Find-in-block substring list> 
%%Finds next block containing a set of substrings - a block being any number of paragraphs and headed sections bounded by entierly blank lines.
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop.
  %h'=call ProximityFindBack; 
  %%Searching forwards from initial match, locate end of this section and set aperture end.
  r-0 (rm)0  onoc %f= -setaperture -endchr='~ -endline='~; 
  %%This loop has two counters because we need to set the restart point at the start of the first sentence, then set the aperture at the start of the n-th sentence.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  m- ( (rm-)0 m- os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/)  oso~ )0 okok
  onoc %f= -setaperture -startchr='~ -startline='~; 
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this section contains matches for all string specifications.
%h'=call ProximityReport;
%s=system 0;

<<ProximityChapter>>
%%Prompt string: Find-in-chapter substring list> 
%%Finds next chapter containing a set of substrings - a block being any number of paragraphs and headed sections bounded by entierly blank lines.
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop - first find a match to the first substring then abstract the chapter to buffer ( ! ) and check the other required substrings.
  %h'=call ProximityFindNext;
  %%Search back for the start of the chapter and set the aperture start point.
  r-0((q/A-Za-zĀ-𠀹/\m-)0 m-r)0 ocon onoc %f= -setaperture -startchr='~ -startline='~; 
  %%This loop has two counters because we need to set the restart point at the start of the first sentence, then set the aperture at the start of the n-th sentence.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  (m ((rm)0 mq/A-Za-zĀ-𠀹/\)0 os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/)  oso~ )0 okok
  onoc %f= -setaperture -endchr='~ -endline='~; 
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this chapter contains matches for all string specifications.
%h'=call ProximityReport;
%s=system 0;

<<ProximityChapterBack>>
%%Prompt string: Find-in-chapter substring list> 
( %%Finds next chapter containing a set of substrings
%%
%%Pick up args and clear any tagged text.
%h'=call ProximityFindSetup;
( %%Main search loop - first find a match to the first substring then abstract the chapter to buffer ( ! ) and check the other required substrings.
  %h'=call ProximityFindBack;
  %%Search forwards for the end of the chapter and set the aperture end point.
  r-0((q/A-Za-zĀ-𠀹/\m)0m-rm2)0 m onoc %f= -setaperture -endchr='~ -endline='~; 
  %%This loop has two counters because we need to set the restart point at the start of the first sentence, then set the aperture at the start of the n-th sentence.
  ol-1 oq/'=ProximityMultiplier/(ol0o=okol1, )ol0oso-
  ( ((m-q/A-Za-zĀ-𠀹/\)0 (m-r))0 os (o~, onov/'=ProximityRestartLine/ ocov/'=ProximityRestartChr/) oso~ )0 okok onoc %f= -setaperture -startchr='~ -startline='~; 
  %%Check remaining substrings in the list.
  %h'=call ProximityExpr;\
  %%Failed - respin.
  oq/'=ProximityRestartLine/ono-om oq/'=ProximityRestartChr/or )0
%%Overall search success - this chapter contains matches for all string specifications.
%h'=call ProximityReport; )?
%s=system 0;

<<CutRectangle>>
%%Copies (to paste buffer) a rectangular block of text from the note point to the current cursor position.
%%Check note buffer, get note point.
%s=system 1; ob %q$=system; f/Note buffer =    /-oico=\oz, f/Note linenumber = /-oidos f/Note character = /-oidos
%%Get Y aligned with note point.
oz o#ocosr-0ory0oco-or
%%Calculate block height and width.
ocoso- osono-
%%Return to original note point.
oso#ol0oso-or oso#(y-o~)0 ok
%%Abstract block, one record at a time.
n.a_&ol1o- (n.oso#or?a_+obz_r0 ocb osoz ol-1oso-o#(o~i/ /)0oko~or oso~y)0 okok
%%Return to note point (top-left corner of abstracted block).
obz_onol2oso-osoz (y-o~)0ok %s=system 0;

<<PasteRectangle>>
%%Pastes a block graphic image in the paste buffer with it's top-left corner character at the current cursor position.
%%Get return position.
%s=system 1; ocon
%%Setup for copying.
ocol-1oso-r-0 obz_m-0oz 
%%Copy each record.
(obz_(mm-, oz\)n.r0oca$&mosoz oso#(o~(r, i/ /))0okh$ osol-1oso-(o~e)0ok m)0 ok
%%Move back to original insert point.
ono-omor

<<LineNW>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in north-westerly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
%s=system 1; obz$r-0(r, i"\")r-0(r2r-b)0m0oz 
%%Note original column number.
ocol0oso- 
(mo#ol-1oso-or
  v"/" %%We're next on the next character on a north-easterly diagonal - shift up and left.
    m-ol-1o+
  , (m-, b-)2o#ol1oso-orv"/" %%We're at the next character of a south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m, r-0b-) ol-2o+ )
%%Main loop - inserts character(s) along a NW diagonal.
r-0(o#o~ (o~(r, i/ /))0ok r-re?i'$ obz$m-oz (m-, r-0b-) ol1o+ )0 
%%Index to next start point.
oz(m-, r-0b-)ol2o+(o~(r, i/ /))0ok %s=system 0;

<<LineNE>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in north-easterly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
%s=system 1; obz$r-0(r, i"/")r-0(r2r-b)0m-0oz 
%%Note original column number.
ocol0oso- 
(mo#ol1oso-or
  v"\" %%We're next on the next character on a north-westerly diagonal - shift up and left.
    m-ol-3o+
  , (m-, b-)2o#ol-1oso-orv"\" %%We're at the next character of a south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m, r-0b-) ol-2o+ )
%%Main loop - inserts character(s) along a NE diagonal.
r-0(o#o~ (o~(r, i/ /))0ok e?i'$ obz$moz (m-, r-0b-) ol-1o+ )0 
%%Index to next start point.
oz(m-, r-0b-) ol0o+(o~(r, i/ /))0ok %s=system 0;

<<LineSW>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in south-westerly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "/".
%s=system 1; obz$r-0(r, i"/")r-0(r2r-b)0m0oz 
%%Note original column number.
ocol0oso- 
((m-, r-0b-)o#ol-1oso-or
  v"\" %%We're next on the next character on a south-easterly diagonal - shift up and left.
    mol-1o+
  , (m, r0b)2o#ol1oso-orv"\" %%We're at the next character of a south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m-, r-0b-) ol-2o+ )
%%Main loop - inserts character(s) along a SW diagonal.
r-0(o#o~ (o~(r, i/ /))0ok r-re?i'$ obz$m-oz (m, r0b) ol1o+ )0 
%%Index to next start point.
oz(m, r0b)ol2o+(o~(r, i/ /))0ok %s=system 0;

<<LineSE>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in south-easterly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
%s=system 1; obz$r-0(r, i"\")r-0(r2r-b)0m-0oz 
%%Note original column number.
ocol0oso- 
((m-, r-0b-)o#ol1oso-or
  v"/" %%We're next on the next character on a south-westerly diagonal - shift up and left.
    mol-3o+
  , (m, r0b)2o#ol-1oso-orv"/" %%We're at the next character of a north-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m-, r0b) ol-2o+ )
%%Main loop - inserts character(s) along a SE diagonal.
r-0(o#o~ (o~(r, i/ /))0ok e?i'$ obz$moz (m, r0b) ol-1o+ )0
%%Index to next start point.
oz(m, r0b) ol0o+(o~(r, i/ /))0ok %s=system 0;

<<DSLineNW>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws staggerd line in north-westerly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
%s=system 1; obz$r-0(r, i"\")r-0(r2r-b)0m0oz 
%%Note original column number.
ocol0oso- 
((m, r0b)o#ol-2oso-or
  v"/" %%We're next on the next character on a staggerd north-easterly diagonal - shift up and left.
    m-ol0o+
  , (m-, b-)2o#ol1oso-orv"/" %%We're at the next character of a staggerd south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m, r-0b-) ol-1o+ )
%%Main loop - inserts character(s) along a NW diagonal.
r-0(o#o~ (o~(r, i/ /))0ok r-re?i'$ obz$m-oz (m-, r-0b-) ol2o+ )0 
%%Index to next start point.
oz(m-, r-0b-)ol2o+(o~(r, i/ /))0ok %s=system 0;

<<DSLineNE>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws staggerd line in north-easterly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
%s=system 1; obz$r-0(r, i"/")r-0(r2r-b)0m-0oz 
%%Note original column number.
ocol0oso- 
((m, r0b)o#ol2oso-or
  v"\" %%We're next on the next character on a staggerd north-westerly diagonal - shift up and left.
    m-ol-4o+
  , (m-, b-)2o#ol-1oso-orv"\" %%We're at the next character of a staggerd south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m, r-0b-) ol-3o+ )
%%Main loop - inserts character(s) along a NE diagonal.
r-0(o#o~ (o~(r, i/ /))0ok e?i'$ obz$moz (m-, r-0b-) ol-2o+ )0 
%%Index to next start point.
oz(m-, r-0b-) ol0o+(o~(r, i/ /))0ok %s=system 0;

<<DSLineSW>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in a staggerd south-westerly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "/".
%s=system 1; obz$r-0(r, i"/")r-0(r2r-b)0m0oz 
%%Note original column number.
ocol0oso- 
((m-, r-0b-)o#ol-2oso-or
  v"\" %%We're next on the next character on a staggerd south-easterly diagonal - shift up and left.
    mol0o+
  , (m, r0b)2o#ol1oso-orv"\" %%We're at the next character of a staggerd south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m-, r-0b-) ol-1o+ )
%%Main loop - inserts character(s) along a SW diagonal.
r-0(o#o~ (o~(r, i/ /))0ok r-re?i'$ obz$m-oz (m, r0b) ol2o+ )0 
%%Index to next start point.
oz(m, r0b)ol2o+(o~(r, i/ /))0ok %s=system 0;

<<DSLineSE>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in a staggerd south-easterly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
%s=system 1; obz$r-0(r, i"\")r-0(r2r-b)0m-0oz 
%%Note original column number.
ocol0oso- 
( (m-, r-0b-)o#ol2oso-or
  v"/" %%We're next on the next character on a staggerd south-westerly diagonal - shift up and left.
    mol-4o+
  , (m, r0b)2o#ol-1oso-orv"/" %%We're at the next character of a staggerd north-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m-, r0b) ol-3o+ )
%%Main loop - inserts character(s) along a SE diagonal.
r-0(o#o~ (o~(r, i/ /))0ok e?i'$ obz$moz (m, r0b) ol-2o+ )0 
%%Index to next start point.
oz(m, r0b) ol0o+(o~(r, i/ /))0ok %s=system 0;

<<LineDefaultChrs>>
%%Prompt string: Line-drawing default > 
%%
%%Sets default characters set for line drawing.
%%  l - Light (Thin) lines.
%%  h - Heavy (thick) lines.
%%  d - double lines.
%%  anything else (the default) - normal ascii line drawing characters.
%%
%% 4 Valid verticals:    | │ ┃ ║
%%
%% 4 Valid horizontals:  - ─ ━ ═
%%
%%28 Valid corners:      ┌ ┍ ┎ ┏ ╒ ╓ ╔
%%                       ┐ ┑ ┒ ┓ ╕ ╖ ╗ 
%%                       └ ┕ ┖ ┗ ╘ ╙ ╚ 
%%                       ┘ ┙ ┚ ┛ ╛ ╜ ╝
%%
%%44 Valid Tees:         ├ ┝ ┞ ┟ ┠ ┡ ┢ ┣ ╞ ╟ ╠
%%                       ┤ ┥ ┦ ┧ ┨ ┩ ┪ ┫ ╡ ╢ ╣ 
%%                       ┬ ┭ ┮ ┯ ┰ ┱ ┲ ┳ ╤ ╥ ╦ 
%%                       ┴ ┵ ┶ ┷ ┸ ┹ ┺ ┻ ╧ ╨ ╩ 
%%
%%20 Valid crossings:    ┼ ┽ ┾ ┿ ╀ ╁ ╂ ╃ ╄ ╅ ╆ ╇ ╈ ╉ ╊ ╋ ╪ ╫ ╬  
%%
%% 3 valid diagonals:    ╱ ╲ ╳
  
obz$(v/ /e)0 (q/aAlLhHdD/, e0)(q/LHD/cr-, )n.r?a~ ov/'=DefaultLineDrawing/ oz

<<LineCheckIntersection>>
%%Checks all four characters ajacent to current character and modifies current character if lines intersect.
%%
%%This function is called with the direction of travel in buffer ( @ ), add the details od sdjacent characters.
%%If the current character is whitespace then for vertical moves set north and south fonts, for vertical moves set east and west fonts. 
%%Otherwise look up the current character. 
%%
%%Initialization.
oq/'=LineIntersectionLookup/ ob
%%Set the @ interfaces vector from direction of travel and neighbouring characters on the other three other sides.
%%Ensure that there are characters (even whitespace) above, below and to the right of the current character.
(r(r, i/ /), i/  /)ocr-2
(m-, r-0b-) o#(or, o#ol-1oso-r-0 ((r, i/ /) o~)0 ok) 
(m2, r0b)   o#(or, o#ol-1oso-r-0 ((r, i/ /) o~)0 ok) m-orr-2
%%North side.
z@r-0 (o#ozocm-o#orn.ra$&mor osz~m-0f'$r2n.ra$&oso#oz, oso#oz%d$=.;) z@r0i'$
%%South side.
z@r-0 (o#ozocmo#orn.ra$&m-or osz~m-0f'$rn.ra$&oso#oz, oso#oz%d$=.;) z@r0i'$
%%East side.
z@r-0 (o#ozrn.ra$&r-2 osz~m-0f'$r4n.ra$&oso#oz, oso#oz%d$=.;) z@r0i'$
%%West side.
z@r-0 (o#ozr-n.ra$& osz~m-0f'$r3n.ra$&oso#oz, oso#oz%d$=.;) z@r0i'$
%%If it's surrounded by non-connecting characters (typically whitespace) then set the character to a simple horizontal or vertical.
%%Otherwise just set the font for the side facing the direction of travel.
oq/'=DefaultLineDrawing/
z@r-0r (v/..../ (q-/ns/, r2)e2i'~2, (q-/n/, q-/s/r, q-/e/r2, r3)ei'~ ) ok
%%Search for a matching character.
z@r-0rbosz~m-0(f'@r-r-\n.ra$&, %m=Match not found: "&'@&",  "&'$&"; %d$=?;)
%%
%%Insert the new character.
osozoki'$er-

<<LineE>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in easterly direction.
%%Pick up optional string argument - if no arg given, default to "-".
%s=system 1; ocobz$m-0
( r %%One or more characters is specified insert without checking intersections. 
  %%Main loop - inserts character(s) along a easterly line.
  r0ocr-0 osozi'$  ol-1oso- (o~e)0 ok
, %%No characters specified, put in a ASCII hyphen, this may be changed later to a Unicode chr.
  %d@=e; oz %h'=call LineCheckIntersection;
  %%Index to next startpoint.
  (r, i-/ /) )
ok %s=system 0;

<<LineW>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in westerly direction.
%%Pick up optional string argument - if no arg given, default to "-".
%s=system 1; ocobz$m-0
( r %%One or more characters is specified insert without checking intersections. 
  %%Main loop - inserts character(s) along a westerly line.
  r0boz(r, i/ /) (obz$m-(r, x2)r0r-boze-i-'$)0 oz r-
, %%No characters specified, put in a ASCII hyphen, this may be changed later to a Unicode chr.
  %d@=w; oz %h'=call LineCheckIntersection;
  %%Index to next startpoint.
  r- )
ok  %s=system 0;

<<LineS>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in southerly direction.
%%Pick up optional string argument - if no arg given, default to "|".
%s=system 1; ocobz$m-0
( r %%One or more characters is specified insert without checking intersections. 
  %%Main loop - inserts character(s) along a southerly line.
  r-0b-oz (obz$mrb-oz ocol-1oso- e?i'$(m, r0b)(o~(r, i/ /))0 ok )0 oz
, %%No characters specified, put in a ASCII vertical bar, this may be changed later to a Unicode chr.
  %d@=s; oz %h'=call LineCheckIntersection;
  %%Index to next start point.
  (m, r-0b-) ol-1oso-(o~(r, i/ /))0 (rr-, ) )
ok %s=system 0;

<<LineN>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in northerly direction.
%%Pick up optional string argument - if no arg given, default to "|".
%s=system 1; ocobz$m-0
( r %%One or more characters is specified insert without checking intersections. 
  %%Main loop - inserts character(s) along a northerly line.
  r0boz (obz$m-r0r-boz ocol-1oso- e?i'$(m-, r-0b-)(o~(r, i/ /))0 ok )0 oz
, %%No characters specified, put in a ASCII vertical bar, this may be changed later to a Unicode chr.
  %d@=n; oz %h'=call LineCheckIntersection;
  %%Index to next start point.
  (m-, r-0b-) ol-1oso-(o~(r, i/ /))0 (rr-, ) )
ok %s=system 0;

<<Box>>
%%Prompt string: Box size> 
%%Drawing function - draws a box with the top-left corner at the current cursor position.
%%Pick up dimensions argument.
%%o@%d$=9 5; 
%%Check - if no arg given, default to "10 5".
%s=system 1; obz$r-0(rr-(q/0-9/ f1/ /(v/ /r)0q/0-9/, %x=Box argument must be <Width> <Height> (both integers).;), i"10 5") r-0oidol0oso-os oidol0oso-os ozos 
%%Start drawing - first the top horizontal line.
o# e?i/ / (o~e?i/-/)0 e?i/ / ok
%%2nd. the right-hand vertical.
oso# (ocol0oso-(m, r0b)(o~(r, i/ /))0 oke?i/|/o~)0 ok
%%3rd. the bottom horizontal.
os ocol0oso-(m, r0b) (o~ (r, i/ /))0 ok (o~e-i-/-/)0 ok
%%Lastly the left-hand vertical.
(ocol0oso-m-(o~(r, i/ /))0 okei/|/o~)0 ok %s=system 0;

<<Lozenge>>
%%Prompt string: Lozenge size> 
%%Drawing function - draws a lozenge-shaped box with the top corner at the current cursor position.
%%Pick up dimensions argument.
%%Check - if no arg given, default to 5, check that current character is at least the lozenge size.
%s=system 1; obz$r-0(rr-(q/0-9/, %x=Lozenge argument must be <Side> (an integer).;), i"5") r-0oidol-1oso-os oz
%%Check starting point.
o#oco+ ol0(o< %x=Error can not draw a lozenge of that size from the this starting point.;, ) ok
%%Start drawing - first the top-right diagonal.
o#ocol0oso- (ol-1o+ oso~oso#e?i"\"(m, r0b)((r, i/ /)o~)0 ok)0 okok
%%2nd. the bottom-right diagonal.
o#r-ocol0oso- (ol1o+ oso~oso#e?i"/"(m, r0b)((r, i/ /)o~)0 ok)0 okok
%%3rd. the bottom-left diagonal.
o#oc (o#m-or ol-1o+ oso~ose?i"\")0 okok
%%Lastly the top-left diagonal.
o#roc (ol1o+ oso~ose?i"/" o#(m-, r-0b-)or)0 mokol-1o+orok %s=system 0;

<<DSLozenge>>
%%Prompt string: Lozenge size> 
%%Drawing function - draws a double-spaced lozenge-shaped box with the top corner at the current cursor position.
%%Pick up dimensions argument.
%%o@%d$=6; 
%%Check - if no arg given, default to 5, check that current character is at least the lozenge size.
%s=system 1; obz$r-0(rr-(q/0-9/, %x=Lozenge argument must be <Side> (an integer).;), i"5") r-0oidol-1oso-os oz
%%Check starting point.
o#ol2o*oco+ ol0(o< %x=Error can not draw a lozenge of that size from the this starting point.;, ) ok
%%Start drawing - first the top-right diagonal.
o#ocol0oso- (ol-2o+ oso~oso#e?i"\"(m, r0b)((r, i/ /)o~)0 ok)0 okok
%%2nd. the bottom-right diagonal.
o#r-2ocol0oso- (ol2o+ oso~oso#e?i"/"(m, r0b)((r, i/ /)o~)0 ok)0 okok
%%3rd. the bottom-left diagonal.
o#(r, i/ /)oc (o#m-or ol-2o+ oso~ose?i"\")0 okok
%%Lastly the top-left diagonal.
o#r2oc (ol2o+ oso~ose?i"/" o#(m-, r-0b-)or)0 mokol-1o+orok %s=system 0;

<<BoxText>>
%%Prompt string: Box text> 
%%function - writes given text into line-drawing box.
%%Pick up optional string argument - if none given then clears out all text.
%%Split arg into words, if no arg given, default to " ".
%s=system 1; obz$r-0((f/ /r(v/ /e)0b)0r0i/ /m-0, i" ")r-0 oz
%%Find top boundary of box (may be lozenge-shaped with diagonal boundaries) load the column no. onto stack.
( q-"--"\(q"|/\"\r)0 v"|"oco#m-or, v"/"oco#m-or(v" /"r,), v"\"oco#ol1o-m-or(v-"\"r-,) q"|/\"ok)0 mo#or
%%
%%Line loop - fill this line with words until we find a word that won't go.
%%Find next line in box big enough for next word.
%%Get the box width for the first line.
(q"-|\/"\r)0oc(q-//\r-)0oco-
( %%Word loop - add words to current line until the next word would make it go pop.
  %%Get the width of the next word.
  obz$r0ocosoz
  %%Is the remaining line-width sufficient?
  ( o< %%No - move on to next line.
    oko#mor(q-"-|\/"\r-)0((q"-|\/"\ v-/-/\)\ %x=Insufficient space for your text;, ) (q"-|\/"\ei/ /)0r-oc(q-//\r-)0oco-ei/ / 
    %%Pick up width of next word.
    obz$ocosoz
  , %%Yes add the word.
    i'$obz$ocosozol0oso-(eo~)0ok obz$ocosozo- obz$mr0ocosoz)0
  obz$mm-oz)0
ok osokosok z$(m\, %x=Failed to add some of your words.;) oz %w=refresh;  %s=system 0;

<<Help>>
%%Prompt string: Help key> 
%%Function to browse through help normally.
%%
%%If in the ; buffer (help menu) reload from selected topic, 
%%  if none selected then go up one level,
%%  if in some other buffer load from top level, saving original buffer key.
%%If an argument is specified then list all matching help keys.
%%
%s=system 1; ob z$r-0(v/ /e)0 
  (rr-
  %%A search-string was given - Preserve top line, fold header, for return
  z;m-0 (mk0,)e0i/  The following keys refer to "/i'$i/"/b2 z:m-0
  %%Find matching fold headers.
  (f'$r-0(v/{{{/,v/[/)na@h@z;h@z:,m)0 z;m-0n.r0a$h$m0ok,
  %%No search-string given - first check that we're in the help buffer.
  z;ob(o=ok, z:m0ozr-0na;&z;)
  %%Check for file-fold.
  r-0v/[/ 
  %%It's a file fold - expand path and fetch help info.
  ( (m-k-0,)mk0n.(f1/ /, r0) z:m-0f'; z;e0i/.hlp/r-0e(v/]/e,f1/]/ei"/")r-0i"%i@=${JOT_RESOURCES}/help/" ';
    %%Integrate new data with help text.
    m0n.r0a$i/}}}/m-0b-i/{{{ /h$ 
    %%Replace correct file-fold mark with new entry - preserving comments.
    z: n.r0a;z@r0h;z: h@z;m-0k0h@, )\ ,
  %%Assume it's a normal fold - traverse fold and extract help entry.
  z;r-0
    (f1/{{{/
    %%At a fold mark, find this fold mark in main buffer.
    r-0n.r0a$h$ z:(f-'$r0v-'$\m-)0,
    %%Not on a fold mark - go back up hierarchy, first find current header.
    z;m-0 (f/{{{/n.r0a$h$ z:(f-'$r0v-'$\m-)0r-0, z:m-0)
    %%Now find parent header.
    ol-1(m-(f1/}}}/ol1o-, (f1/{{{/\, o~)))0 ok ) 
  %%Copy fold-mark into ';'. 
  r-0n.ma;h;ol-1
  %%Copy current-level fold marks and text into ';'.
  ((f1/}}}/\(ol-1o= n.ma@h@z;m0h@z:m-, ), o~) (f1/{{{/ol1o-,) m)0 ok )
%%Add the index help point.
z;m-0f'$(r-m-0m3, mf/{{{/, m-0) %s=system 0;

<<FindAllHelp>>
%%Prompt string: Find-help string> 
%%function - returns all keys where text contains the string.
%s=system 1; z$
(v/ /rr\
  %%Argument not given - report hierarchy.
  z;m-0 z:on
  %%Find current Fold mark and initialize list.
  f-';na;h;m-2
  ( %%Loop to find parent fold mark.
    %%Find parent fold.
    ol-1 r-0 (f1/}}}/ol1o-m-,f1/{{{/\m-,o~m-)0 ok
    %%Extract parent fold comment.
    na$h$ z;m-0h$
    %%Ascend one level.
    z:m-2)0
    
  z:ono-om
  z;
  
  , %%Argument given - save the original fold mark and search for key.
  z;m-0(mk0,)e0i/  The following entries refer to "/i'$i/"/b2 z:m-0 
  (  f'$
    %%Keep the actual line for display.
    na@h@z;m0h@z:m-
    %%Step back to the header for this fold.
    on ol-1r-0 (f1/}}}/ol1o-m-,f1/{{{/\m-,o~m-)0 ok 
    %%If this is the first entry in this fold add it to the help list.
    na@h@z;m-0m2(f'@, m0m-h@)z:
    %%Got the item header - now return.
    ono-om m
    )0 z;m-0m3
  ) 
%s=system 0;

<<RemoveHelpFold>>
%%function - restores original file fold where appropriate.
%%Collapse file fold in help repository.
%s=system 1; z:m-0f';mn.m-
ol0r-0(f1/{{{/\m)0r-0 (f1/{{{/ol1o-m,f1/}}}/\m,o~m)0 ok
ma$ m-v/{{{ /e4
%%Collapse file fold in help window.
z;e4 %s=system 0;

<<NewParagraph>>
%%Prompt string: New paragraph> 
%%Inserts a new paragraph below the current line.
%s=system 1;
%%If there's any given text then this becomes a new paragraph.
obz$(v/ /r)0(rr-e-0oz (v/ /r)0(rr0b, )r0 i'$m-n.(v/ /r)0a$&mh$bh$ m(v/ /r)0(rr-0b-h$, )m-, oz)
%h'=call ReformatParagraph;

<<ReformatParagraph>>
%%Reformat current paragraph.
%%
oq/'=DocBulletString/ 
%%Get initial-line indentation.
(mm- (v/ /\m)0 (v/ /r)0r\m)0 (r-, okx0) (v'~rr-f1'~-, )oc
%%Find start of the paragraph - checking for bullet strings, 
r-0 ((v/ / (v/ /r)0 rr- os(v'~rr-f1'~-(osoco=x4, ), os)oc(o=m-, \))0 m) r-0o#orb-r-0bm
%%Join up lines to the end of paragraph.
(mo#or rr-v/ /\os(v'~os, os\)\(v-/ /r-)0r-\ j-)0 m-(f1/  /e)0 osokr0b-
%%Get paragraph right margin and subtract left margin.
o#oq/'=DocRightMargin/oso-
%%Restore bullet string.
oq/'=DocBulletString/ os
%%
( %%Record loop - split the long record on word boundaries.
  r-0rr-o#or (rr-f-1/ /- os(v-'~r-f-1'~f-1/ /2, r-)os, ) (rr-b-,) 
  %%Calculate how many padding blanks are required to align right margin.
  o#ocoso- ocoxoso-o+
  %%Insert padding blanks.
  ol0(o=\mrm-r0f-1/ / (i-/ /o~ (v-/ /r-)0 r-(f-1/ /\r0)0 )0, ) ok
  %%Prepare for next record, exit if length of next record is less-than or equal right margin.
  mrr-v/ /er0oc o<)0 okok
%%Reunite first line with it's indentation or bullet string.
(m-r)0j2
%%Reindent.
ol0oso- (mrr-o# (i/ /o~)0 ok)0 ok
%%Remove end line break delimiter.
j-m
%s=system 0;

<<ReformatAll>>
%%Format all paragraphs.
m-0 ( %h'=call ReformatParagraph; mm-)0

<<SetParagraphMargin>>
%%Prompt string: Specify right margin > 
obz$r-0(v/ /r)0 
(q/0-9/oid, %q$=window; f/ screenWidth = /-oidol2o-)osoz 
ov/'=DocRightMargin/

<<FindParagraphStart>>
%%Go to start of current paragraph, paragraphs being delimited by blank lines, change in indentation level, underlines or bullets.
%%  Cursor is left at 1st. character of paragraph,
%%    for ordinary paragraphs this is the first nonblank,
%%    for bullets it is the character immediately after the bullet,
%%    for headings and leave-alone lines it is the begining of the line and
%%    for blank lines it is the last character.
%%
%%
%%Check that it's a valid paragraph.
r-0(v/ /, %X=Error: this is not a valid paragraph.; )
%%Get current indentation level.
(v/ /r)0 oq/'=DocBulletString/ (v'~rr-f1//-,)oc
(
  %%Exit if bullet at current level.
  os(v-'~\, m-?\)
  %%Exit if indentation level has gone up.
  v/ /\
  %%Exit if indentation level has gone down.
  (v-/ /r-)0 r-\
  %%Try first text column for current level of indentation of line above.
  %%Exit if nonblank in column 1 - thats a don't touch line.
  r-0(r\, r-(v/ /, m-?\))
  %%Exit now if any bullet.
  (v/ /r)0v'~\
  %%Exit if line is blank.
  rr-
  m-
  %%Index to current indentation level.
  oso#or )0
m(v/ /r)0
okok

<<FindNextParagraphStart>>
%%Go to start of line following paragraph, paragraphs are  delimited by blank lines, change in indentation level or bullets.
%%
%%Check that it's a valid paragraph.
r-0(v/ /, %X=Error: this is not a valid paragraph.; )
%%Get the current indentation level.
oq/'=DocBulletString/ ((v/ /r)0r\m)0r- (v'~rr-f1//-,)oc
(
  %%Exit if a change in indentation level.
  (v/ /r)0oco=
  %%Exit if it's a next-level bullet.
  osv'~\os
  %%Exit if don't touch line.
  r-0(r\, r-v/ /)
  %%Exit if it's a blank line.
  (v/ /r)0r
  m)0
r-0okok

<<SpellcheckGeneral>>
%%Checks spellings in temporary file /tmp/spell.tmp - the current buffer should be the source text.
%%
%%Note the length of the spellcheck section.
z$m0onos
%%Acquire pathName for local spelling dictonary.
o#oz %q~=buffer; f/pathName = /-br0(f-1./.-, r-0i"./")b-i/spell.dic/
%%Run the spelling checker and read back results, if there is there a local spelling dictonary use that.
z_n.a$&z$ i"%e#=\cat /tmp/spell.tmp | \aspell -a " (o# %q=file '~; i/--personal=/i'~ , )ok r0i/ list;/
%%  %s=trace F901;
 ('$, %X=failed to run the spelling checker;)
%%Strip out blank lines, those only containing one or less character and those beginning with "# " - words allowed by the personal spelling dic.
m-0(r2\k, v-/# /k, m)0
%%Sort and purge.
%b=sort; m0r0b m-0(n.r2(f1/ /-q/0-9/\)0a$& m(v'$k)0)0
%%Remove any words which appear in the spelling list.
o#oz (%i$=spell.dic; (i/ /r0i//m)0m-0 z#m-0(rn.rf1/ /-a;& (z$m-0f';z#k, z#m))0, )
%%Report number of spelling mistakes.
z#m-0ol0(ro~m, k)0m-0 
(ol0o= 
  ok%m=Congratulations, there were no spelling mistakes.; ozok
, %%Some spellings to fix.
  %m=Oh dear, there were &'~& spelling mistakes.;
  %%Add return signpost to buffer ( # ).
  o#m-0b-oo/Spell-check report, original buffer: %c/ ozo#onoso-o~obosz#r0oo/ lines %d/ ozonol-1o+obosz#r0oo/ to %d/b
  %%Go to first misspelling.
  m=2 %h'=call NextMisspelling; )

<<SpellcheckDocument>>
%%Checks spellings in complete document (sends errors to '#' buffer).
%%Clear out any old popup data.
ob z-m-0k0 oz
%%Copy then output the document.
m-0n.m0a$& ob%o=/tmp/spell.tmp;
%h'=call SpellcheckGeneral;

<<SpellcheckChapter>>
%%Checks spellings in current chapter - chapters are bounded by chapter headings, a line beginning with an alphabetical character or by a document boundary.
%%Clear out any old popup data.
ob z-m-0k0 oz
%%Grab current chapter
ob r-0(q/a-zA-ZĀ-𠀹/\m-)0n. (mq/a-zA-ZĀ-𠀹/\)0 a$&
%%Output the chapter.
z$ %o=/tmp/spell.tmp;
%h'=call SpellcheckGeneral;

<<SpellcheckParagraph>>
%%Checks spellings in current paragraph.
%%Clear out any old popup data.
ob z-m-0k0 oz
%%Grab current paragraph
ob((r\, r-(v/ /r)0r\, r-0v/ /\)m)0 %h'=call FindParagraphStart;  r-0n. %h'=call FindNextParagraphStart;  a$& 
%%Output the paragraph.
z$ %o=/tmp/spell.tmp;
%h'=call SpellcheckGeneral;

<<SpellcheckWord>>
%%Prompt string: Word(s) for spelling checker> 
%%Checks spellings of a given word or the word at the current-character position.
%%
%%If no word given, pick up word under or left of the cursor.
obz$r-0(roz, oz(q/a-zA-ZĀ-𠀹/(q//\r-)0,)(q-//r-)0n.(q//r)0a$&v-'$)
%%write the word(s) for Aspell.
obz$ %o=/tmp/spell.tmp;
%%Clear out any old popup data.
z-m-0k0
%%Acquire pathName for local spelling dictonary.
o#oz%q~=buffer; f/pathName = /-br0(f-1./.-, r-0i"./")b-i/spell.dic/
%%Run the spelling checker and read back results, if there is there a local spelling dictonary use that.
z_n.a$&z$ i"%e#=\cat /tmp/spell.tmp | \aspell -a " (o# %q=file '~; i/--personal=/i'~ , )ok r0i/ list;/ '$ z#
%%Set up popup menu.
k(f1/: /-n.r0a-& z-(f1/, /e2b)0 m-0oz %h'=call PopupRestore; , oz %x=The spelling was correct.; ) oz

<<NextMisspelling>>
%%Goes to next word in spelling-errors list, if at end of line move to next misspelling.
%%
%%First go back to start of document.
z#onm-0f1/original buffer: /-oicos f/lines /-oidos ono-omosozono-om
obz#(m, oz%x=All done;)
%%Place current misspelling in $ and suggested corrections in -
( %%What type of report have we been given.
  %%Maybe a new-style report with no suggestions.
  v/# /r2n.f1/ /a$&
, %%Maybe the old-style report, just pick up the misspelling.
  v/& /\ n.r0a$& n.a-&
, %%It's a new-style Aspell report, hopefully with suggested corrections.
  r2n.f1/ /a$& f1/: /-n.r0a-& z-m-0 (f1/, / e2b)0
  %h'=call PopupRestore;
%%  %%Announce.
%%  z-m0m-onm-0 (ol1o=ok, %m=ASpell suggests '~ corrections - see buffer -;)
 )
%%Go
oz %h'=call NextSpellInstance;

<<NextSpellInstance>>
%%Goes to next instance of misspelt word, if none then move to next mis-spelling in # buffer.
%%
obz#r-0(v/& /\n.r0a$&, r2n.f1/ /a$&) r0oz(v'$r, )
( (f'$(q-/a-zA-ZĀ-𠀹/r?,rr-f1'$-q/a-zA-ZĀ-𠀹/))0f-1'$ 
  %%Check that we've not gone beyond original spellcheck scope.
  obz#onm-0r0f-1/ /oidosono-omosoz on(o>ok, ok\)
, %%Exact-match or scoping check failed - index to next reported mis-spelling in # buffer.
  %h'=call NextMisspelling; )

<<FixSpelling>>
%%Substitutes current misspelled instance with word in current line of ; buffer.
z;onm-0f1/original buffer: /-oicosono-om ozs';

<<SpellLexicon>>
%%Prompt string: Lexicon-search REx> 
%%Greps for string in lexicon.
%%
%%Construct the egrep command then do it.
obz$r-0 i"%e-=\egrep -i '"r0i"' ${JOT_RESOURCES}/lexicon.lis" '$
%%Announce and display.
m0onm-0 osoz %m=There were &'~& matching words.; %h'=call PopupRestore;

<<MakeParagraphIntoBullet>>
%%Makes current paragraph a bullet.
oq/'=DocBulletString/ onoc
%%Condense paragraph to one line.
%h'=call FindParagraphStart; on %h'=call FindNextParagraphStart; ono-b-(j-o~)0ok %h'=call FindParagraphStart; 
%%Go back to start of previous paragraph and get it-s indentation level.
on(m-(v/ /r)0r\)0 r-0(v/ / %h'=call FindParagraphStart; r-0ol0(v/ /ro~)0, ol2) 
%%Return to our paragraph and copy in the indent level (defaults to level 2).
osono-om(v/ /e)0 ol0oso-(i/ /o~)0 okokok
%%Add a bullet if required.
(v'~, i'~)ok %h'=call ReformatParagraph; 
%%(v'&, i'&) %h'=call ReformatParagraph; 
%%Don't know what this is for?
%%m-r0(oco=(okono=m, ), ok)ok m

<<CentreAndUnderlineText>>
%%Centres and underlines text on current line.
%%
%%Strip out leading ant trailing whitespace.
r-0(v/ /e)0r0(v-/ /e-)0
%%Get length of line.
oc oq/'=DocLeftMargin/o# oq/'=DocRightMargin/ oso-oco-ol-2o/oso-r-0
%%Underline it.
(o~i/ /)0okn.r-0a$h$r0bh$ol0oso-(i/-/o~)0okm(v/ /r)0(v/--/k,)

<<UnderlineThisLine>>
%%Underlines text on current line without affecting it
na$h$2m-(v/ /r, (v/  /\ ei/-/)0r)0m

<<PurgeAllHeadings>>
%%Purges all headings.
on
%%Find the first heading.
m-0((q/0-9/\m)0mm-q/0-9/((q/0-9/e)0i/1/v/./r)0(v/ /e)0i/ /m)0
%%Change it to all-the-zeros.
n.a$&obz$i/0/oz
m-0
( %%Heading loop.
  %%Find next heading.
  (q/0-9/\m)0q/0-9/obz$r-0
  %%Strip out digits
  ((q/0-9/r)0o#oz(q/0-9/e)0(v/./e,z$e0) z$v/./r)0oz
  h$(v/ /(q-/0-9/r-)0n.oido~a%oo/%d/,i/./)
  r-0f1/ /n.r-0a$h$
m2m-)0
ono-om

<<InheritHeaderLevel>>
%%Fetches last header level to current line.
on
%%Find last header.
(m-q/0-9/\)0
%%Pick it up.
(q/0-9/n.f1/ /a$h$ono-omh$,ono-omi/0 /)

<<UnderlineHeader>>
%%Underlines heading if level 4 or below.
r-0ol0
%%Count up heading levels.
((q/0-9/r)0v/./ro~)0
%%Kill off any pre-existing underlines.
m(v/-/k,)m-r0
%%If levels < Limit add new underlines.
oq/'=DocHeaderMax/ o-ol0o< (v-/ /e-)0ol0oco-b(i/-/o~)0okm,

<<ConvertLineToHeading>>
%%Prompt string: Heading proforma> 
%%Converts current line into a heading.
%%
%%If a proforma header tag is given then use that.
obz$r-0(r, ozr-0(n.(q/0-9./r)0a$, oz))
%%Locate and pick up previous heading.
on (m-q/0-9/\)0 (q/0-9/n.f1/ /a$&, i-/0/n.ra$)
%%Go back.
ono-om
%%If heading level is already defined accept that, otherwise inherit from predecessor.
r-0(v/ /e)0 ol1
( q/0-9./
  %%Some heading-level structure exists - first count the levels.
  ((q/0-9/r)0v/./ro~)0
, %%No predefined header levels - inherit from predecessor.
  obz$osr-0 ((q/0-9/r)0v/./ro~)0 osoz )
%%Insert inherited heading level.
r-0h$n.(q/0-9./r)0a$i/ /(v/ /e)0
%%Adjust no. of levels - may be necessary to add or remove subsection numbers.
ol-1oso- r-0 (o~ ( (q/0-9./(q/0-9/r)0(v/./r,), i/.0/), i/./) )0 (q/0-9./e)0
%%Finally increment last level.
(v-/./e-,) (q-/0-9/r-)0 oido~oo/%d/
%%Add underlining code from ! buffer.
%h'=call UnderlineHeader; 

<<DownHeadingLevel>>
%%Adds a new heading level.
%h'=call InheritHeaderLevel;
%%Now remove the last element of the heading level.
i/.1 /(q/0-9. /e)0
%h'=call UnderlineHeader;

<<UpHeadingLevel>>
%%Unwinds one heading level.
%h'=call InheritHeaderLevel;
%%Now increment the final element of the heading level.
(((q-/ 0-9/r-)0v-/./r-)2r,)n.oida%o~oo/%d/i/ /(q/0-9. /e)0
%h'=call UnderlineHeader; oz

<<RightJustifyLine>>
%%Right-justifies current line.
r-0(q/	 /e)0r0(q-/	 /e-)0oc oq/'=DocRightMargin/ o-r-0(i/ /o~)0okm

<<AddNewFunctions>>
%%Adds function definitions in ( @ ) buffer to code repository and updates hashtable.
%%
%s=system 1; obz'm0 (rr0bm-, m-)2m0 onh@ ono-om
%%Check the function definitions and set up the function hashtable.
( (v/<</\m)0 mm-r2n.f1/>>/a@&r2 %h=code '@;)0
%%
%%If the keymap buffer contains any symbolic keys ( of the form {<keySequenceDescription>} ) then resolve these now.
z^m-0(v/{/\m)0 
( v/{/\,
  ( %q=windows;
    %r=WindowsNT_keys;
  , %%Use correct keymap for this version of curses.
    %q@=version; m
    f1/ncurses/-(v/ /r)0e-0 (f1/./s/_/)0 %r=curses_keys_&'@;
  , %%All other versions of curses, use TERM-specific keymap.
    %q@=env TERM; m %r=curses_keys_&'@;
  , %%Give up and use the generic xterm keymap.
    %r=curses_keys_xterm; )
  (z^v/{/n.f1/}/-a$&v-'$ z@m-0(f'$r-0n.r12a$&z^s'$m
  , %%Not in the keymap file - maybe it's {Ctrl+<ordinaryKey>}
    z^r-0v/{Ctrl+/r7v/}/er-e-0i/^/f/ /(v/ /e)0ocol12o-(i/ /o~)0okm
  , %%Not {Ctrl+<key>} - maybe it's {Alt+<key>}
    z^r-0v/{Alt+/r6v/}/er-e-0i/^[/ f1/ /(v/ /e)0ocol12o-(i/ /o~)0okm
  , %%Not {Alt+<key>}
    m ) )0 ) 
oz %s=system 0;

Code_Repository:
  
%%Define hot-keys map - the finalize macro expects this table in buffer ( ! ).
%g!=Hot_Keys;
<<CopyFromMouse>>            {Button1Up}
<<NoteFromMouse>>            {Button1Down}
<<FocusToMouse>>             {Button1Click}
<<InsertHereMouse>>          {Button1DoubleClick}
<<CopyFromMouse>>            {Button2Up}
<<NoteFromMouse>>            {Button2Down}
<<FocusToMouse>>             {Button2Click}
<<InsertHereMouse>>          {Button3Click}
<<Help>>                     {F1}
<<FindAllHelp>>              {Shift+F1}
<<RemoveHelpFold>>           {Ctrl+F1}
<<Note>>                     {Ctrl+Shift+F1}
<<Note>>                     {Home}
<<TermResize>>               {SizeAdj}
<<Do>>                       {F2}
<<ScriptByName>>             {Shift+F2}
<<ScriptByFunc>>             {Ctrl+F2}
<<Cut>>                      {Ctrl+Shift+F2}
<<Cut>>                      {Delete}
<<CumulativeCut>>            {Shift+Alt+F2}
<<CumulativeCut>>            {Shift+Delete}
<<CutTabular>>               {Ctrl+Shift+Alt+F2}
<<CutTabular>>               {Ctrl+Delete}
<<BlockUp>>                  {F3}
<<ChapterUp>>                {Shift+F3}
<<SentenceUp>>               {Ctrl+F3}
<<Copy>>                     {Ctrl+Shift+F3}
<<CumulativeCopy>>           {Shift+Alt+F3}
<<CumulativeCopy>>           {Shift+End}
<<CutRectangle>>             {Ctrl+Shift+Alt+F3}
<<CutRectangle>>             {Alt+Delete}
<<BlockDown>>                {F4}
<<ChapterDown>>              {Shift+F4}
<<SentenceDown>>             {Ctrl+F4}
<<Paste>>                    {Ctrl+Shift+F4}
<<Paste>>                    {Insert}
<<PasteRectangle>>           {Ctrl+Shift+Alt+F4}
<<PasteRectangle>>           {Alt+Insert}
<<Substitute>>               {F5}
<<Remove>>                   {Shift+F5}
<<SubstituteAgain>>          {Ctrl+F5}
<<MatchAngleLeft>>           {Ctrl+Shift+F5}
<<MatchParenLeft>>           {Shift+Alt+F5}
<<MatchCurlyLeft>>           {Ctrl+Shift+Alt+F5}
<<Insert>>                   {F6}
<<Overwrite>>                {Shift+F6}
<<InsertAgain>>              {Ctrl+F6}
<<MatchAngleRight>>          {Ctrl+Shift+F6}
<<MatchParenRight>>          {Shift+Alt+F6}
<<MatchCurlyRight>>          {Ctrl+Shift+Alt+F6}
<<FindBack>>                 {F7}
<<SubsThenFindPv>>           {Shift+F7}
<<FindBackAgain>>            {Ctrl+F7}
<<MatchMarkupLeft>>          {Shift+Alt+F7}
<<IndentMatchUp>>            {Ctrl+Shift+F7}
<<MatchSquareLeft>>          {Ctrl+Shift+Alt+F7}
<<FindNext>>                 {F8}
<<SubsThenFindNx>>           {Shift+F8}
<<FindNextAgain>>            {Ctrl+F8}
<<MatchMarkupRight>>         {Shift+Alt+F8}
<<IndentMatchDown>>          {Ctrl+Shift+F8}
<<MatchSquareRight>>         {Ctrl+Shift+Alt+F8}
<<FindExact>>                {F9}
<<FindExactBack>>            {Shift+F9}
<<SetFindString>>            {Ctrl+F9}
<<AppendLeftPrev>>           {Alt+F9}
<<IndentFromPrev>>           {Ctrl+Shift+F9}
<<JoinLeftPrev>>             {Shift+Alt+F9}
<<Again>>                    {F10}
<<AgainExhaustive>>          {Shift+F10}
<<AppendRightNext>>          {Alt+F10}
<<IndentFromNext>>           {Ctrl+Shift+F10}
<<JoinRightNext>>            {Shift+Alt+F10}
<<Up>>                       {UpArrow}
<<WordUp>>                   {Shift+UpArrow}
<<NewWordUp>>                {Ctrl+UpArrow}
<<PageUp>>                   {PageUp}
<<PopupPageUp>>              {Ctrl+Alt+PageUp}
<<ViewUp>>                   {Ctrl+Shift+UpArrow}
<<WindowShrink>>             {Ctrl+Alt+UpArrow}
<<Down>>                     {DownArrow}
<<WordDown>>                 {Shift+DownArrow}
<<NewWordDown>>              {Ctrl+DownArrow}
<<PageDown>>                 {PageDown}
<<PopupPageDown>>            {Ctrl+Alt+PageDown}
<<ViewDown>>                 {Ctrl+Shift+DownArrow}
<<WindowStretch>>            {Ctrl+Alt+DownArrow}
<<Left>>                     {LeftArrow}
<<WordLeft>>                 {Shift+LeftArrow}
<<LineLeft>>                 {Ctrl+LeftArrow}
<<PageUp>>                   {Alt+UpArrow}
<<PageDown>>                 {Alt+DownArrow}
<<ViewLeft>>                 {Ctrl+Shift+LeftArrow}
<<Right>>                    {RightArrow}
<<WordRight>>                {Shift+RightArrow}
<<LineRight>>                {Ctrl+RightArrow} Collides with {Ctrl+Alt+PageUp}
<<ViewRight>>                {Ctrl+Shift+RightArrow}
<<Macro1>>                   {KP_1}
<<LineSW>>                   {Ctrl+Alt+KP_1}
<<Macro2>>                   {KP_2}
<<DownRegardless>>           {Ctrl+KP_2}
<<LineS>>                    {Ctrl+Alt+KP_2}
<<Macro3>>                   {KP_3}
<<LineSE>>                   {Ctrl+Alt+KP_3}
<<Macro4>>                   {KP_4}
<<Left>>                     {Ctrl+KP_4}
<<LineW>>                    {Ctrl+Alt+KP_4}
<<Macro5>>                   {KP_5}
<<Macro6>>                   {KP_6}
<<RightRegardless>>          {Ctrl+KP_6}
<<LineE>>                    {Ctrl+Alt+KP_6}
<<Macro7>>                   {KP_7}
<<LineNW>>                   {Ctrl+Alt+KP_7}
<<Macro8>>                   {KP_8}
<<UpRegardless>>             {Ctrl+KP_8}
<<LineN>>                    {Ctrl+Alt+KP_8}
<<Macro9>>                   {KP_9}
<<LineNE>>                   {Ctrl+Alt+KP_9}
<<Macro0>>                   {KP_0}
<<Enter>>                    {KP_Enter}
<<Again>>                    {KP_Decimal}
<<MatchParenRight>>          ^[m(
<<MatchParenLeft>>           ^[m)
<<MatchCurlyLeft>>           ^[m}
<<MatchCurlyRight>>          ^[m{
<<MatchSquareLeft>>          ^[m]
<<MatchSquareRight>>         ^[m[
<<MatchAngleRight>>          ^[m<
<<MatchAngleLeft>>           ^[m>
<<MatchAny>>                 ^[ma
<<MatchMarkupRight>>         ^[mm
<<MatchMarkupLeft>>          ^[-mm
<<IndentMatchDown>>          ^[mi
<<IndentMatchUp>>            ^[-mi
<<ParagraphDown>>            ^[mp
<<ParagraphUp>>              ^[-mp
<<SentenceDown>>             ^[ms
<<SentenceUp>>               ^[-ms
<<ChapterDown>>              ^[mc
<<ChapterUp>>                ^[-mc
<<HeadedSectionDown>>        ^[mh
<<HeadedSectionUp>>          ^[-mh
<<BlockDown>>                ^[mb
<<BlockUp>>                  ^[-mb
<<FindSequence>>             ^[fq
<<FindSequenceBack>>         ^[-fq
<<FindLineOrd>>              ^[fo
<<FindLineOrdBack>>          ^[-fo
<<FindWild>>                 ^[f*
<<FindWildBack>>             ^[-f*
<<FindCol>>                  ^[fy
<<FindColBack>>              ^[-fy
<<FindVert>>                 ^[fv
<<FindVertBack>>             ^[-fv
<<findRect>>                 ^[fe
<<findRectBack>>             ^[-fe
<<ProximityCharacters>>      ^[fn
<<ProximityCharactersBack>>  ^[-fn
<<ProximityLines>>           ^[fl
<<ProximityLinesBack>>       ^[-fl
<<ProximityWords>>           ^[fw
<<ProximityWordsBack>>       ^[-fw
<<ProximitySentence>>        ^[fs
<<ProximitySentenceBack>>    ^[-fs
<<ProximityPhrase>>          ^[fr
<<ProximityPhraseBack>>      ^[-fr
<<ProximityPara>>            ^[fp
<<ProximityParaBack>>        ^[-fp
<<ProximityHeadedSection>>    ^[fh
<<ProximityHeadedSectionBack>>   ^[-fh
<<ProximityBlock>>           ^[fb
<<ProximityBlockBack>>       ^[-fb
<<ProximityChapter>>         ^[fc
<<ProximityChapterBack>>     ^[-fc
<<DeleteChrLeft>>            {Alt+LeftArrow}
<<DeleteChrRight>>           {Alt+RightArrow} Collides with {Ctrl+PageUp}
<<DeleteLineLeft>>           {Ctrl+Alt+LeftArrow}
<<DeleteWordLeft>>           {Shift+Alt+LeftArrow}
<<DeleteLineRight>>          {Ctrl+Alt+RightArrow}
<<DeleteWordRight>>          {Shift+Alt+RightArrow}
<<RestoreChrRight>>          {Ctrl+Shift+Alt+RightArrow}
<<RestoreChrLeft>>           {Ctrl+Shift+Alt+LeftArrow}
<<RestoreWordRight>>         ^[rw
<<RestoreLineRight>>         ^[rl
<<RestoreWordLeft>>          ^[-rw
<<RestoreLineLeft>>          ^[-rl
<<CutRectangle>>             ^[rc
<<PasteRectangle>>           ^[rp
<<RightJustifyLine>>         ^[rj
<<rotateDiagonal>>           ^[rd
<<rotateHorizontal>>         ^[rh
<<rotateVertical>>           ^[rv
<<ViewUp>>                   ^[vu
<<ViewDown>>                 ^[vd
<<ViewSave>>                 ^[vs
<<ViewRestore>>              ^[vr
<<WindowDown>>               ^[wd
<<WindowUp>>                 ^[wu
<<WindowOne>>                ^[w1
<<WindowNine>>               ^[w9
<<WindowSave>>               ^[ws
<<WindowRestore>>            ^[wr
<<WindowReassign>>           ^[wa
<<WindowHorizSplit>>         ^[wh
<<WindowVertSplit>>          ^[wv
<<WindowAlignTop>>           ^[wt
<<WindowAlignCent>>          ^[wc
<<WindowAlignBot>>           ^[wb
<<WindowStretch>>            ^[w+
<<WindowShrink>>             ^[w-
<<WindowWithLineNumbers>>    ^[wl
<<PopupSearch>>              ^[ps
<<PopupIncrementalSearch>>   ^[pi
<<PopupRestore>>             ^[pr
<<PopupPageUp>>              ^[pu
<<PopupPageDown>>            ^[pd
<<InsertWithBackTick>>       ^[`
<<DebuggerQuit>>             ^[q
<<Enter>>                    ^[e
<<TempInsertMode>>           ^[in
<<InsertMode>>               ^[In
<<CompareBufs>>              ^[cb
<<CmdEditStart>>             ^[ce
<<CmdEditGo>>                ^[cg
<<CmdString>>                ^[cs
<<WordLeft>>                 ^[-mw
<<WordRight>>                ^[mw
<<LineDefaultChrs>>          ^[ld
<<LineSW>>                   ^[/d
<<DSLineSW>>                 ^[/s
<<LineSE>>                   ^[\d
<<DSLineSE>>                 ^[\s
<<LineS>>                    ^[ls
<<LineW>>                    ^[lw
<<LineNW>>                   ^[\u
<<DSLineNW>>                 ^[\n
<<LineNE>>                   ^[/u
<<DSLineNE>>                 ^[/n
<<LineN>>                    ^[ln
<<LineE>>                    ^[le
<<Break>>                    ^[br
<<BoxText>>                  ^[bt
<<Box>>                      ^[bx
<<Lozenge>>                  ^[z1
<<DSLozenge>>                ^[z2
<<Macro0>>                   ^[0
<<Macro1>>                   ^[1
<<Macro2>>                   ^[2
<<Macro3>>                   ^[3
<<Macro4>>                   ^[4
<<Macro5>>                   ^[5
<<Macro6>>                   ^[6
<<Macro7>>                   ^[7
<<Macro8>>                   ^[8
<<Macro9>>                   ^[9
<<ReformatParagraph>>        ^[pa
<<NewParagraph>>             ^[pn
<<ReformatAll>>              ^[Pa
<<MakeParagraphIntoBullet>>  ^[bu
<<CentreAndUnderlineText>>   ^[cu
<<UnderlineThisLine>>        ^[ul
<<SetParagraphMargin>>       ^[pm
<<ConvertLineToHeading>>     ^[he
<<DownHeadingLevel>>         ^[h+
<<UpHeadingLevel>>           ^[h-
<<PurgeAllHeadings>>         ^[ha
<<SpellcheckParagraph>>      ^[sp
<<SpellcheckChapter>>        ^[sc
<<SpellcheckDocument>>       ^[sd
<<SpellcheckWord>>           ^[sw
<<NextSpellInstance>>        ^[si
<<NextMisspelling>>          ^[sn
<<FixSpelling>>              ^[sf
<<SpellLexicon>>             ^[sx

Hot_Keys:
%%Windows does not send events on window resize.
(%q=windows; z!m-0f/{SizeAdj}/k, )

%%Set up the hashtable in the code-repository buffer ( ' ).
%h'=destroy; %h'=create 1000;

%%This macro finalizes the startup, normally called at the end of this script but may be deferred by the -nofinalize qualifier 
%%and called by the parent startup script.
%%
%%This macro expects to see the followig:
%%  - The correct key-mapping table in buffer ( @ ) - normally defined by the relevant curses_keys_xyz.jot  or WindowsNT.jot script.
%%  - The symbolic hotkey to function call table in ( ! ) - normally set up earlier in startup.jot, 
%%    but custom startup scripts calling startup with the -nofinalize qualifier will add some more.
%%    Each entry in ( ! ) consists of a function name in double angle brackets followed by a symbolic key description or an escape sequence.
%%
%%It also checks for the existence of referenced functions in tthe ( ' ) buffer - the code repositary.
%%
%g#=Finalize_Macro;
%%For single-line functions, the code is copied directly into the key-translations buffer ( ^ )
%%for multi-line functions a call stub of the form "%h'=call <name>;" goes into the key-translations buffer.
%%
%s=system 1;
%%
%%Key-code identification requires case sensitivity on.
%s=case 1;
%%Now check the function definitions and set up the function hashtable.
obz'm-0 ((v/<</\m)0 mm-r2n.f1/>>/a$& (%h=code '$;, %m?=Warning: duplicate function definition for &'$;) )0 oz
%%Add code to pick up parameters and call functions.
ob z?m0r0b z!m-0
( %%Skip blank lines and comments.
  (((v/ /r)0r\m)0 r-v/%%/m)0 
  %%For each function name, pick up either the key description or the escape-sequence specification.
  ( v/<</r2n.f1/>>/a$&
    %%Check function names ( in $ buffer) and keycodes.
    (z'm-0 %f=<<&'$&>>;
  , 
    %m?=Error: No definition of function &'$;)
    %%
    %%The remainder of the line is either a key description or an escape sequence.
    z! ( f1/ {/ %%It's a key description of the form {<[shift][ctrl][Alt]><KeyName>} to be translated using key translations in ( ! ) buffer.
      rn.(f1/}/-a;&, %m?=Error: Syntax of key-name to keycode translation for &'!&.;) 
      %%Now pick up the key code.
      z@m-0(f';r-0n.r12a;&, %m?=Error: Syntax or missing keycode in translation of key &''; z?r0i'; ) 
    , %%Not a key description - should be a simple escape sequence.
      r2(v/ /r)0n.(r12, r0i-/            /r-f-1/  /-n.r12)a;& 
    , %m?=Error: syntax of function-names to key-description map at &'!&.; ) 
    %%
    %%Add the key code and single-line function code or, for longer functions, function call to the ( ^ ) buffer.
    z'on(mv/%%/, r\)0 onm ((v/%%/, (v/ /r)0r\)m)0r-? (v/<</ono-omz^i'', okz^i/%h'=call /h$i/;/) r-0h; z'ono-om
    %%If function code has parameters, insert parameter-capture code to ( ^ ) buffer.
    ( z'mv/%%Prompt string:/\, f1/:/-n.r0a$& z^i|%d$= -LITERAL_DEFINITION ##"|h$i|" -BUFFERDEFINITIONENDSHERE; | )
  , %%Line should begin "<<FunctionName>>" flag it as an error.
    %m?=Error: invalid line in function to key mapping entry "&'!&"; )
  %%
  %%Index to next key description.
  z^r0b z!m2m-)0
  
%s=case 0;
oz
  
%%Initialize help repository. 
ob
( %%Help repository setup.
  %%If JOT_RESOURCES is not defined then set it to ${JOT_HOME}/resources
  ( %q$=env JOT_RESOURCES; mf1/- <Undefined>/\, %q$=env JOT_HOME; k i"%s=setenv JOT_RESOURCES " r0i"/resources" '$ )
  %%
  %q=file ${JOT_RESOURCES}/help/help.hlp; %i:=${JOT_RESOURCES}/help/help.hlp;
, %%the help repository could not found
  %m:=Warning: Could not find a help tree below the JOT_RESOURCES directory.; )
oz
  
%%Check for errors and display them if necessary.
ob z?m0ol0 (v/Error: /m-o~)0 ol0(o=ok, m0 %w=refresh;  %m=Oh dear! - there were &'~& errors in your startup file - hit {return} to continue; g )
%%Restore original verbosity level.
( %q$=system; f/Verbosity =    /-v/0/, %q=version; ) oz
%s=system 0;
Finalize_Macro:

%%All functions are now defined in the code repository ( ' buffer).
%%All function-names to key-description mapping is now defined up in ( ! ) buffer.
%%All physical-keys to Key-descriptions are are defined up in the ( @ ) buffer.
%%
z~m-0(f/-nofinalize/-b-k-0, '#)? z.ok

%%define default properties for document processing.
z'
ol2        %h'=setdata -new DocLeftMargin;
ol78       %h'=setdata -new DocRightMargin;
%d~=\- ;   %h'=setdata -new DocBulletString;
ol4        %h'=setdata -new DocHeaderMax;
%d~=a;     %h'=setdata -new DefaultLineDrawing;
%d~=;      %h'=setdata -new LineIntersectionLookup;
z.

%%This table is used by <<LineCheckIntersection>> it is part of the line-drawing system (LineN, LineS, LineE and LineW).
%%It shows the correct drawing character for various combinations of adjacent characters.
%%Each entry consists of 5 characters. with no blanks: 
%%  - 1 the drawing character to be returned,
%%  - 2 The font code for the North side.
%%  - 3 The font code for the South side.
%%  - 4 The font code for the East side.
%%  - 5 The font code for the West side.
%%
%%The font codes are ( . ) no connection, ( a ) ASCII, ( l ) light, ( h ) heavy and  ( d ) double.
%%
%g~
%%All ASCII intersections.
╵l...
╷.l..
╹h...
╻.h..
╽lh..
╿hl..
│ll..
┃hh..
║dd..
%%Simple horizontal lines.
╴...l
╶..l.
╸...h
╺..h.
╼..hl
╾..lh
─..ll
━..hh
═..dd
%%Simple corners top-left quadrent.
┌.ll.
┍.lh.
╒.ld.
┎.hl.
┏.hh.
╓.dl.
╔.dd.
%%Simple corners bottom-left quadrent.
└l.l.
╚d.d.
╙d.l.
╘l.d.
┗h.h.
┖h.l.
┕l.h.
%%Simple corners bottom-right quadrent.
┘l..l
┙l..h
┚h..l
┛h..h
╛l..d
╜d..l
╝d..d
%%Simple corners top-right quadrent.
┐.l.l
┑.l.h
╕.l.d
┒.h.l
┓.h.h
╖.d.l
╗.d.d
%%Vertical-right tee.
├lll.
┝llh.
┞lld.
┡hlh.
╞lld.
┟lhl.
┠hhl.
┢lhh.
┣hhl.
╟ddl.
╠ddd.
%%Vertical-left tee.
╢dd.l
╣dd.d
┧lh.l
┨hh.l
┩hl.h
┪lh.h
┫hh.h
┤ll.l
┥ll.h
┦hl.l
╡ll.d
%%Horizontal-down tee.
┬.lll
┭.llh
┮.lhl
┯.lhh
┰.hll
┱.hlh
┲.hhl
┳.hhh
╤.ldd
╥.dll
╦.ddd
%%Horizontal-up tee.
┴l.ll
┵l.lh
┶l.hl
┷l.hh
┸h.ll
┹h.lh
┺h.hl
┻h.hh
╧l.dd
╨d.ll
╩d.dd 
%%Crossovers
┼llll
┽lllh
┾llhl
┿llhh
╀hlll
╃hllh
╄hlhl
╇hlhh
╪lldd
╁lhll
╂hhll
╅lhlh
╆lhhl
╈lhhh
╉hhlh
╊hhhl
╋hhhh
╫ddll
╬dddd
%%ASCII intersections
 .a.a
 .aa.
 a..a
 a.a.
-..aa
-...a
-..a.
|aa..
|.a..
|a...
+aaaa
:

obosz~m-0 (f/%%/e0)0 osoz
ov/'=LineIntersectionLookup/

