
%%Defines the key functions, these are mapped onto escape sequences by keybord/os-specific keyboard map.
%%
%%
%%    Copyright (C) 2013-2018 Jon. Easterbrook
%%
%%    This file is part of jot (Joy Of Text - a text editor).
%%
%%    jot is free software: you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation, either version 3 of the License, or
%%    (at your option) any later version.
%%
%%    jot is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with jot.  If not, see <https://www.gnu.org/licenses/>.
%%
%%
%%
%%Buffers used/defined.
%%  ^ - the hotkey translation buffer, defined from scratch or left unchanged.
%%  : - The help repository, initialized to the contents of the top help file, also used as temporary key-functions buffer.
%%  @ - temporary, holds keycap-to-keycode translation.
%%  $ - passes args from CLI then used in construction of some key functions and key codes resolution.
%%

%%Set up window.
ob %w; %q$=window; f/screenHeight = /- oid ol1o- %w; %w= -height='~ -delim; (%q=windows; , %s=mousemask 0;)
%s=console 10;
  
%%Preserve the original args for later use.
z$m-0n.m0r0a~
%%Read the relevant keyboard map file.
%g#
z^m-0
( %q=windows;
  %r=WindowsNT_keys;
, %%unix then.
  %%If chrome then use the chrome keys.
  %q@=version; mf1/ chrome / %r=curses_keys_chrome;
, %%Not chrome use term.
  %q@=env TERM; m %r=curses_keys_'@;
, %m=Error: No keys for TERM '@, using xterm instead.;
  %r=curses_keys_xterm; )
:
'#

%%Set up the functions and assign function names
%%N.B. At startup time this will be run in case-insensitive mode
%%If run later, case-sensitivity might have been turned on.
%%
%%In the forgoing, single-line functions are copied directly into the keymap buffer ( ^ ).
%%Multi-line functions are copied into the code repository buffer ( ' ) and a function-call
%%entry point is set up ine the hashtable.
%%For functions that need to prompt for parameter values, the prompt string 
%%must be in a line-1 comment of the form:
%%Prompt string: <string>
%%
%g'
<<TermResize>>
%l;

<<Do>>
%%Prompt string: Command file pathName> 
%r='$
  
<<Substitute>>
%%Prompt string: Substitute string> 
obz$(rr-i/i`/'$, )oz s//
  
<<SubstituteBack>>
%%Prompt string: Substitute string> 
obz$(rr-i/i`/'$, )oz s-//
  
<<Remove>>
(s/ /e-)
  
<<SubstituteInd>>
s'_
  
<<SubstituteAgain>>
s//
  
<<Insert>>
%%Prompt string: Insert string> 
obz$ %s=system 1; i/i`/ %s=system 0; oz'$
   
<<InsertBack>>
%%Prompt string: Insert string> 
obz$(rr-i/i`/'$, )oz i-//
  
<<InsertAgain>>
i//
  
<<InsertWithBackTick>>
%%Prompt string: Insert string> 
obz$ %s=system 1; i/i`/r0i/ / ozi-/`/ %s=system 0; '$oee-rou

<<Overwrite>>
%%Prompt string: Overwrite string> 
obz$(rr-i/i`/'$, )oz oci//oco-(eo~)0ok
  
<<OverwriteBack>>
%%Prompt string: Overwrite string> 
obz$(rr-i/i`/'$, )oz ocr0ocosr-0o#ori//r0osoco-osr-0or(e-o~)0ok
  
<<FindPrev>>
%%Prompt string: Find string> 
obz$(rr- %s=system 1; i/f`/ %s=system 0; '$, )oz 
f-//
  
<<SubsThenFindPv>>
s-//f-//
  
<<FindPrevInd>>
f-'_
  
<<FindPrevAgain>>
f-//
  
<<FindNext>>
%%Prompt string: Find string> 
obz$(rr- %s=system 1; i/f`/ %s=system 0; '$, )oz 
f//
  
<<SubsThenFindNx>>
s//f//
  
<<FindNextInd>>
f'_
  
<<FindNextAgain>>
(f//, %x=Find-again failed;)
  
<<DeleteLineLeft>>
(n.(rr-r-0, m-r0)? a%-)
%%(n.(r-r(rr-0, m-r0)?, m-r0) a%-)
  
<<RestoreLineLeft>>
obz%m-0n.(rr0,m,)a$ozh$
  
<<DeleteWordLeft>>
(n.(r-r, m-r0)(q-/a-zA-Z0-9/\r-)0 (q-/a-zA-Z0-9/r-)0 a%-)
  
<<RestoreWordLeft>>
obz%m-0n.(r(q/a-zA-Z0-9._/\r)0(q//r)0,m,)a$ozh$
  
<<DeleteWordRight>>
(n.(rr-,m)(q/a-zA-Z0-9/\r)0(q/a-zA-Z0-9/r)0a%+)
  
<<RestoreWordRight>>
obz%m0r0n.(r-(q-/a-zA-Z0-9._/\r-)0(q//r-)0,m-r0,)a$  o#ozh$(z$r o#ozr-,m o#ozm-r0)0 oz
  
<<DeleteLineRight>>
(n.(rr-(r-r0,m),m)a%+)
  
<<RestoreLineRight>>
obz%m0r0n.(r-r-0, m-,) a$o#ozh$z$m0r0 (z$r-o#ozr-,m-r0o#ozm-r0)0oz
  
<<FindExactNext>>
%%Prompt string: Find-exact string> 
obz$(rr- %s=system 1; i/f`/ %s=system 0; '$, )oz (f//(q-/_A-Za-z0-9/r?,rr-f1//-q/_A-Za-z0-9/))0
(f-1//, %X=Find-exact failed;)
  
<<FindExactPrev>>
%%Prompt string: Find-exact string> 
obz$(rr- %s=system 1; i/f`/ %s=system 0; '$, )oz ((f-//q-/_A-Za-z0-9/ (r-, m-r0))0 v//rr-f1//-q/_A-Za-z0-9/ (v-//, m-r0) f-//rr-)0 
(v-//, %X=Find-exact failed;)
  
<<SetFindString>>
(a$&, (obol36o= %x=Can not call <<SetFindString>> from the ( $ ) buffer.;, )r-r(q-/_a-zA-Z0-9/r-)0n.(q//r)0a$&, n.r0a$&)obz$r-0 %s=system 1; i-/f-1`/oz %s=system 0; '$
  
<<Paste>>
(h_)
  
<<PasteOver>>
(h_*)
  
<<Cut>>
a_
  
<<CumulativeCut>>
(a_+, r-0n.ma_+&)
  
<<CutTabular>>
a_*
  
<<CumulativeCopy>>
(a_+&, r-0n.ma_+&)
  
<<Copy>>
oba_&
  
<<Note>>
n.
  
<<PageUp>>
(m*-w)?
  
<<Home>>
m-0
  
<<GotoFoldStart>>
ol0r-0(f1/}}}/\m-)0r-0 (f1/}}}/ol1o-m-,f1/{{{/\m-,o~m-)0 ok
  
<<PageDown>>
(m*w)?
  
<<WindowOne>>
%%Set window size to be 1 less than screen height.
ob %q$=window; f/screenHeight = /- oid ol1o- %w; %w= -height='~ -delim; (%q=windows; , %s=mousemask 0;) oz

<<WindowHorizSplit>>
%%Adds a new window below size-adjusted existing windows.
%%
%%First calculate the size of each new window.
ob %q@=window; %s=system 1; f/ Console area /m-f1/  win:/-oidol2o+ f-/ screenHeight = /-oidol1o- oso/
%%Create each shrunk version of original windows.
m-0f/  win:/m- %w; (z@mf1/  win:/f1/ ( /-oicz$m-0k0 oo/%%W%c=/r0 o#oo/ -height=%d -delim;/ '$ z@)0
%%Create a new floating window.
%s=system 0; z$m-0k0 oo/%%W= -height=%d -delim;/ '$ oz

<<WindowVertSplit>>
%%Adds a new slice to the right of size-adjusted existing windows.
%%
%%First calculate the size of each new slice.
ob %q@=window; f/ Console area /m-f1/  win:/-oidol2o+ f-/ screenWidth = /-oid oso/ m-f1/ screenHeight = /-oidol1o-
%%Create proforma command.
z$m-0k0 oo/= -height=%d/r0ol1o-oo/ -width=%d+1 -delim;/
%%Initialize.
z@m-0f/  win:/m- %w; 
%%Create each shrunk version of original windows.
(z@mf1/  win:/(f1/ fixed on buffer  ( /-oicz$r-0oo/%%W%c/, z$r-0i/%W/) '$ (f1/= /e-0 f1/-height=/s/ /, ) )0
%%Create a new floating window.
z$r-0i/%W/ '$ oz

<<WindowDown>>
%%Changes focus to next window or slice.
%%
%%First find the current window.
ob %q@=window; z$m-0k0 oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 
%%Now move to the next window, or top window if already at last window and pick up the key.
m (f1/ ( /, f-/  screenWidth = /m) r-0f1/ win:/-oid %w= -winno='~ -freeze=0; f1/ ( /-oico#
%%If there are earlier windows showing that buffer then make sure they're frozen.
(z@m- (f1'$\, r-0f1/ win:/-oid %w= -winno='~ -freeze=1;) )0
%%Now switch to new buffer.
oz

<<WindowUp>>
%%Changes focus to previous window or slice.
%%
%%First find the current window.
ob %q@=window; z$m-0k0 oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 
%%Now move to the previous, or bottom window if already at first window and pick up the key.
m- (f1/ ( /r-0, f/  Console area /m-) f1/ win:/-oid %w= -winno='~ -freeze=0; f1/ ( /-oic m-
%%Freeze any earlier windows matching this buffer.
(f1'$r-0f1/ win:/-oid %w= -winno='~ -freeze=1; m-, m-)0
%%Now switch to new buffer.
oz

<<WindowReassign>>
%%Prompt string: Window no.(optional) and buffer > 
%%
%%First pick up the correct window number.
ob z$(v/ /e)0(q/0-9/(q//r)0r-0oid(v/ /r)0, %x=Error: You must specify a window number followed by a buffer key, separated by whitespace.; )
%%Changes the buffer assignment of current window.
z$e-0oo/%%w= -winno=%d -key=/(v/ /e)0r0i/;/ '$ oz

<<WindowAlignTop>>
%%Aligns current line with top of window.
onofo-owr-0 

<<WindowAlignCent>>
%%Aligns current line with centre of window, checks that current character is in view, if not then applies an apprpriate left-offset setting..
ob %q$=window; (f/currently buffer ( /-, m-0f/fixed on buffer  ( /- (oico=\mf1//-)0) f1/),/- oid osoz ol2o/ofo+onoso- ow
%%If not in view then adjust left offset.
(%q=inview;, obocz$m-0f/ screenWidth = /-oidol2o/o-osoz %b=leftoffset '~;) (ok)3w

<<WindowAlignBot>>
%%Aligns current line with bottom of window.
ob %q$=window; (f/currently buffer ( /-, m-0f/fixed on buffer  ( /- (oico=\mf1//-)0) f1/),/- oid osoz ofo+onoso- ow r-0

<<WindowStretch>>
%%Prompt string: [Window no.]> 
%%First pick up the given window number or find the window number of the current buffer.
ob %q@=window; z$(v/ /r)0(q/0-9/oido#z@f/win:0/om, z$m-0k0 o#oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 r-0f1/ win:/-oid) 
%%Now set up the window-identification part of the window-change command.
z$k?oo/%%w= -winno=%d/r0 
%%ob %q@=window; z$m-0k0 o#oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 r-0f1/ win:/-oidz$k?oo/%%w= -winno=%d/r0 
%%If it's a full-width window tweak the height, if a slice, tweak the width. 
( z@f1/Slice/\  %%It's a full-width window - get the original height and set the new height.
  (f1/ ), /-oidol1o+z$oo/ -height=%d;/ '$ )
, %%It's a slice - get original width and tweak the width.
  (z@f-1/ ), /-rf1/), /-oidol1o+z$oo/ -width=%d;/ '$ ) )
oz
  
<<WindowShrink>>
%%Prompt string: [Window no.]> 
%%First pick up the given window number or find the window number of the current buffer.
ob %q@=window; z$(v/ /r)0(q/0-9/oido#z@f/win:0/om, z$m-0k0 o#oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 r-0f1/ win:/-oid) 
%%Now set up the window-identification part of the window-change command.
z$k?oo/%%w= -winno=%d/r0 
%%ob %q@=window; z$m-0k0 o#oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 r-0f1/ win:/-oidz$k?oo/%%w= -winno=%d/r0 
%%If it's a full-width window tweak the height, if a slice, tweak the width. 
( z@f1/Slice/\  %%It's a full-width window - get the original height and set the new height.
  (f1/ ), /-oidol1o-z$oo/ -height=%d;/ '$ )
, %%It's a slice - get original width and tweak the width.
  (z@f-1/ ), /-rf1/), /-oidol1o-z$oo/ -width=%d;/ '$ ) )
oz
  
<<ViewSave>>
%%Prompt string: Optionally specify a view name> 
%%Default view name is "default".
obz$(rr-, %s=system 1; i/default/ %s=system 0;) oz
%%Save view.
%h'=add ViewJump_'$; obofz' z$r-0i/View_FirstLine_/ z'(oq'$ok, %h'=data '$;) ov'$ oz
%%oe(rr-,)oe(o=okol0, o#ou) oc wof on ob
  
<<ViewRestore>>
%%Prompt string: Optionally specify a view name> 
%%Default view name is "default".
obz$(rr-, %s=system 1; i/default/ %s=system 0;) oz
%%Restore view.
(%h'=jump ViewJump_'$; obz$r-0i/View_FirstLine_/z' oq'$osoz, oz %x=Could not find a saved view for '$;)
%%Now adjust the view.
wofo-ow
%%An unfortunate consequence of using hashtabes is that the line numbers can go wrong - this fixes it.
onm-0onol1o. o-om

<<PopupSearch>>
%%Prompt string: Popup search string> 
%%Search up and down looking for likely matches to the given word.
%%
%%Initialization - clear the ( - ) buffer.
ob z.n.a- oz
%%The original start point.
ofocon
%%
%%Find all nearest words (before or after current point) matching the given string.
%%Collect matching words in popup-buffer ( - ).
%%Search backwards for previous word match.
o#ono-omoso#oros ((f-'$(q-/A-Za-z0-9_/r-)0n.(q//r)0a@&f-'$ obz@r-0i/ /r0i// z-m-0(f'@oz, m-0h@boz\) )0 m-m)0
%%Search forwards for next word match.
o#ono-omoso#oros 
%%Note current-point in word list.
obz-m0onosoz 
%%Now do the forwards-looking search.
((f'$(q-/A-Za-z0-9_/r-)0n.(q//r)0a@& obz@r-0i/ /r0i// z-m-0(f'@oz, h@boz\) )0 mm-)0
obz-m0onm-0osozol1o- 
( ol0o=ok %m=Found no matching words.;
, %m=Found '~ matching words.;
  %%Prepare and display the popup.
  %h'=call PopupRestore;
  %%Return to corresponding point in words list.
  obosz-m-0omoz )
%%Return to original current-character point on main text.
osono-omosor
%%Restore view.
ofo-ow

<<PopupIncrementalSearch>>
%%Search up and down looking for likely matches to the given word, updating popup as characters are typed in.
%%
%%Initialization, clear the ( $ ) buffer -  used to hold search string.
ofob z.n.a-n.a$ oz
%%
  
( %%Search-character loop.
  %%The start point.
  ocon
  %%Set prompt, add an endstop marker to the stack and pick up next character.
  %s=prompt Incremental search> '$; obol0w og z$r0
  ( ol127 o= %%It's a rubout - remove last character from search string.
    okokm-0r0e-?
  , ol10 o= %%It's a {Return} - exit now.
    okokozokok ofo-ow %X=done.;
  , %%Any other character gets added it to the search string.
    (ol0o=\ oo/%lc/)0 ok )
    
  %%Clear the ( - ) buffer now.
  z-m-0k0w
  %%Collect matching words and search back from current chr.
  oz((f-'$(q/A-Za-z0-9_/r)0n.(q-//r-)0a@& (q-//r-)0r- obz@r-0i/ /r0i// z-m-0(f'@oz, m-0h@boz\) )0 ocm-mor )0 ok
  %%Search forwards for next word match - first return to original point.
  ono-omorocon
  %%Now do the forwards-looking search.
  ((f'$(q-/A-Za-z0-9_/r-)0n.(q//r)0a@& obz@r-0i/ /r0i// z-m-0(f'@oz, r0h@boz\) )0 ocmm-or )0 ok
  %%Add match count and display the popup, return to original point and display popup.
  obz-m0m-onm-0oo/ Found %d /b %h'=call PopupRestore; z-m-0ozono-omor )0

<<PopupRestore>>
%%Prepares the the popup window for display.
obz-m-0
( r  %%A new popup - top and tail all entries.
  m-0((v/ /e)0r0(v-/ /e-)0m)0 
  %%Set up data object - create it if necessary.
  (oq/'=PopupMenu/ok, %h'=data PopupMenu; ) m-0n.m0r0a~&?m-0 ov/'=PopupMenu/
, %%Restore last-used popup.
  oq/'=PopupMenu/z~m-0n.m0r0a-z-ok )
%%Add colour tag to each item - define the colour tag-type if necessary.
m-0(oeou (%b=addtag SelectWord;, %b=tagtype SelectWord colour 7 4; %b=addtag SelectWord;) m)0
%%If the popup window is not yet defined, do that here.
%q~=window; ( f/ column popup (/, %w-= -height=20 -width=-20 -popup; ) z-ok
%%Report popup size - N.B. this line assumes a popup size of 20 lines, this must match the popup size above.
ol20on(o>ok %m=Displaying all of popup menu.;, onos %m=Displaying '~ lines of '~ in popup menu.;)
%%Enable mouse events (Button-1 click) and set up callback.
%s=mousemask 0004;
z^m-0(f/%h'=call FocusToMouse;/s/%h'=call PopupMouseSelect;/, )
%%Return to original position.
oz

<<PopupMouseSelect>>
%%The mouse-event callback - coordinates identify the required spelling (45 is ASCII code for ( - ) btw).
%%Identify the popup word.
ob opol45o=okz-ono-omok n.r0a$ m-0k0
%%Tidy up - disable mouse-clicks and destroy popup menu.
%s=mousemask 0; w
%%Restore original mouseclick handler.
z^m-0(f/%h'=call PopupMouseSelect;/s/%h'=call FocusToMouse;/, )
%%Push selected word into command stream.
z$i/%s=commandstring /r0i/;/ oz '$
  
<<PopupReset>>
%%Clears the popup buffer and resets mousemask.
obz-m-0k0oz %s=mousemask 0; %l;

<<PopupPageUp>>
%%Scrolls the popup window up to previous page.
%%Unfortunately, the usual M* command won't work for popups because it takes the height of the current window, not of the popup.
obz-of %q$=window; (f/ column popup (/f-1/( - ), /-oidol1o- z-o-ono-om?
  %%Report current position in popup.
  onm0m-onosono-omof %m=Displaying popup from line no. '~ ('~ lines in total).;, ok)
oz

<<PopupPageDown>>
%%Unfortunately, the usual M* command won't work for popups because it takes the height of the current window, not of the popup.
obz-of %q$=window; (f/ column popup (/f-1/( - ), /-oidol2o*ol1o- z-o+ono-om?w
  %%Report current position in popup.
  onm0m-onosono-omof %m=Displaying popup from line no. '~ ('~ lines in total).;, ok)
oz

<<End>>
m0m-
  
<<GotoFoldEnd>>
ol0r-0(f1/{{{/\m)0r-0 (f1/{{{/ol1o-m,f1/}}}/\m,o~m)0 ok
  
<<Up>>
(m-)
  
<<StraightUp>>
(y-)
  
<<ViewUp>>
%%Prompt string: Window no.> 
%%By default applies to the current-buffers window the optional arg specifies which window to scroll.
%s=system 1; obz$r-0(v/ /r)0(rr-e-0i/win:/r0i/ / %q@=window; f'$f1/ ( /-oicoz(ol1ow)oz, oz(ol1ow) ) %s=system 0;
  
<<Down>>
(m)
  
<<StraightDown>>
(y)
  
<<ViewDown>>
%%Prompt string: Window no.> 
%%By default applies to the current-buffers window the optional arg specifies which window to scroll.
%s=system 1; obz$r-0(v/ /r)0(rr-e-0i/win:/r0i/ / %q@=window; f'$f1/ ( /-oicoz(ol-1ow)oz, oz(ol-1ow) ) %s=system 0;
  
<<Right>>
(r\m,r-r)
  
<<Left>>
(r-\m-r0,rr-)
  
<<LineRightUp>>
(rr0,m-r0)
  
<<LineLeft>>
(r-r-0, m-)
  
<<AnyMatch>>
( v/(/ %h'=call ParenMatchRight;,
  v/{/ %h'=call CurlyMatchRight;,
  v/[/ %h'=call SquareMatchRight;,
  v/</ %h'=call AngleMatchRight;,
  v/)/ %h'=call ParenMatchLeft;,
  v/}/ %h'=call CurlyMatchLeft;,
  v/]/ %h'=call SquareMatchLeft;,
  v/>/ %h'=call AngleMatchLeft;,
  %x=Try moving the cursor to any of (, [, {, <, >, }, ] or ) then try again.; )
  
<<ParenMatchLeft>>
v/(/(r-,m-r0), ol0(v.*/.f-./*.,v/"/((r-, m-r0)f-1/"/v-/*/)0(r-, m-r0),v/'/f-1/'/(r-, m-r0),q/)/ol1o-(r-, r-r0),q/(/\(r-, m-r0),o~(r-, m-r0))0ok
  
<<CurlyMatchLeft>>
v/{/(r-,m-r0), ol0(v.*/.f-./*.,v/"/((r-, m-r0)f-1/"/v-/*/)0(r-, m-r0),v/'/f-1/'/(r-, m-r0),q/}/ol1o-(r-, r-r0),q/{/\(r-, m-r0),o~(r-, m-r0))0ok
  
<<AngleMatchLeft>>
v/</(r-,m-r0), ol0(v.*/.f-./*.,v/"/((r-, m-r0)f-1/"/v-/*/)0(r-, m-r0),v/'/f-1/'/(r-, m-r0),q/>/ol1o-(r-, r-r0),q/</\(r-, m-r0),o~(r-, m-r0))0ok
  
<<SquareMatchLeft>>
v/[/(r-,m-r0), ol0(v.*/.f-./*.,v/"/((r-, m-r0)f-1/"/v-/*/)0(r-, m-r0),v/'/f-1/'/(r-, m-r0),q/]/ol1o-(r-, r-r0),q/[/\(r-, m-r0),o~(r-, m-r0))0ok
  
<<MarkupMatchLeft>>
v/</\f-/</, (v"</", f-"</")r2n.f1/>/a$& (f-/</-2(v/ /r)0(v'$\, (q/ >/\r)0v-'$\))0 f-/</
  
<<LineRight>>
((r, m)r0)
  
<<ViewLeft>>
%q=inview;? okoko~%b=leftoffset '~;
  
<<ViewRight>>
%q=inview;? okokol0(o>\okol0, ol-1o+) %b=leftoffset '~;
  
<<WordLeft>>
(%q=tabstops; ((v-/	/, f1//-, r0)oc (f-1//r, r-0)oc o~o-ou)?, (r-, m-r0)(q-/a-zA-Z0-9/(q//r)0, (q-//\r-)0) oc (q-//r-)0 oc o-ou) (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)
  
<<WordRight>>
(%q=tabstops; (r?r-(f-1/	/-, r-0)oc (f1//, r0)oc o-ou)?, (r, m)(q/a-zA-Z0-9/(q-//r-)0, (q//\r)0) oc (q//r)0 oco-ou) (%q=inview; okokok, oso-osok %b=leftoffset '~;)
  
<<WordDown>>
(%q=tabstops; yocr(f1/	/, r0)oco-o#orol0oso-ou, y) (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)
  
<<NewWordDown>>
y0 (%q=tabstops; yocr(f1/	/, r0)oco-o#orol0oso-ou, y) (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)
  
<<WordUp>>
(%q=tabstops; y-ocr(f1/	/, r0)oco-o#orol0oso-ou, y-) (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)
  
<<NewWordUp>>
y0 (%q=tabstops; y-ocr(f1/	/, r0)oco-o#orol0oso-ou, y-) (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)

<<CmdEditStart>>
%%Prompt string: Command string (optional)> 
ob%q-=history; m0m-kb-i'$b m-0mb-oo/In buffer %c/m0m-2
  
<<CmdEditGo>>
( obol45o=okmk0m+2f1/In buffer /-oicm0m-k-0
  %%Apply the modified command.
  i/%s=commandstring / (f1/\/i/\/r)0 r-0(f1/;/i/\/r)0
  %%Return to original buffer and apply.
  oz '-
, %%Something failed - most probably the checks to ensure we're looking at a valid command-history report.
  ok %x=This is not the valid command-history report.; )
  
<<CmdString>>
%%Prompt string: Command string> 
%%Execute the jot command sequence in the string.
'$

<<ParenMatchRight>>
v/)/(r, m), ol0(v./*.f.*/.,v/"/(r, m)(f1/"/v-/*/r)0(r, m),v/'/f1/'/,q/(/ol1o-(r, m),q/)/\(r,m,okol-1?\),o~(r, m))0ok
  
<<CurlyMatchRight>>
v/}/(r, m), ol0(v./*.f.*/.,v/"/(r, m)(f1/"/v-/*/r)0(r, m),v/'/f1/'/,q/{/ol1o-(r, m),q/}/\(r,m,okol-1?\),o~(r, m))0ok
  
<<AngleMatchRight>>
v/>/(r, m), ol0(v./*.f.*/.,v/"/(r, m)(f1/"/v-/*/r)0(r, m),v/'/f1/'/,q/</ol1o-(r, m),q/>/\(r,m,okol-1?\),o~(r, m))0ok
  
<<SquareMatchRight>>
v/]/(r, m), ol0(v./*.f.*/.,v/"/(r, m)(f1/"/v-/*/r)0(r, m),v/'/f1/'/,q/[/ol1o-(r, m),q/]/\(r,m,okol-1?\),o~(r, m))0ok
  
<<MarkupMatchRight>>
(v"<"v"</"\)\(f"<"v"</"r)0, rn.(q/ >/\r)0a$& f/>/(v-/ /r-)0v-"/"f/</, (f/</-(v/ /r)0(v"/"\, r(v/ /r)0(v'$\, f1/>/v-'$\)))0 f/</(v"</"(r-f-/</, m-r0), )
  
<<DeleteChrLeft>>
(n.(r-,m-r0)?a%-)
  
<<RestoreChrLeft>>
(obz$(obo= %x=Can not restore characters to ( $ ) buffer.;, ) z%m-0n.(r,m,)a$ozh$)
  
<<DeleteChrRight>>
(n.(r,m)?a%+)
  
<<RestoreChrRight>>
(obz$ob(o= %x=Can not restore characters to ( $ ) buffer.;, ) z%m0r0n.((r-,m-r0)a$ozh$(r-,m-r0)), a$oz)
  
<<AppendLeftPrev>>
(q-/ /r-)0(q/ /e)0n.r-0(q/ /r)0a$r-0h$b-j-(q-/ /r-)0(q/ /e)0i-/ /
  
<<AppendRightNext>>
(q-/ /r-)0(q/ /e)0n.r0a$m(q/ /r)0h$(q-/ /r-)0(q/ /e)0i-/ /
  
<<JoinLeftPrev>>
r-0(q-/ /r-)0(q/ /e)0n.r-0(q/ /r)0a$r-0h$b-j-(q-/ /r-)0(q/ /e)0i-/ /j
  
<<JoinRightNext>>
r-0(q-/ /r-)0(q/ /e)0n.r0a$m(q/ /r)0h$(q-/ /r-)0(q/ /e)0i-/ /j-
  
<<Break>>
b(v/ /e)0m-n.(v/ /r)0a$&mh$ (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)
  
<<Join>>
j-(v-/ /e-)0(v/ /e)0i/ / (%q=inview; okokok, osokosokol1o- %b=leftoffset '~;)
  
<<IndentFromPrev>>
r-0(v/ /e)0m-n.(v/ /r)0a$&mh$
  
<<IndentFromNext>>
r-0(v/ /e)0mn.(v/ /r)0a$&m-h$
  
<<ParagraphUp>>
m-(r\m-)0r-(rm-)0m
  
<<CodeSectionUp>>
(m-(q/A-Za-z/\,r\))0r- (m-(q/ /r)0q/0-9A-Za-z/)0m
  
<<IndentMatchUp>>
r-0q/ /\(m-(q. /$.,r\))0r-,(v/ /r)0oc(m-(v/ /r)0oco=\)0ok
  
<<ParagraphDown>>
m(r\m)0r-(rm)0(r\m)0r-
  
<<CodeSectionDown>>
(mq/A-Za-z/\,r\mm-)0 r-0
  
<<IndentMatchDown>>
r-0q/ /\(m(q. /$.,r\))0r-,(v/ /r)0oc(m(v/ /r)0oco=\)0ok
  
<<Macro0>>
%%Prompt string: Macro-0 parameters> 
'0
  
<<Macro1>>
%%Prompt string: Macro-1 parameters> 
'1
  
<<Macro2>>
%%Prompt string: Macro-2 parameters> 
'2
  
<<Macro3>>
%%Prompt string: Macro-3 parameters> 
'3
  
<<Macro4>>
%%Prompt string: Macro-4 parameters> 
'4
  
<<Macro5>>
%%Prompt string: Macro-5 parameters> 
'5
  
<<Macro6>>
%%Prompt string: Macro-6 parameters> 
'6
  
<<Macro7>>
%%Prompt string: Macro-7 parameters> 
'7
  
<<Macro8>>
%%Prompt string: Macro-8 parameters> 
'8
  
<<Macro9>>
%%Prompt string: Macro-9 parameters> 
'9
  
<<UpRegardless>>
ocol-1oso- (m-, b-)(o~ (r, i/ /))0 ok
  
<<DownRegardless>>
ocol-1oso- (m, r0b)(o~ (r, i/ /))0 ok
  
<<RightRegardless>>
(r, i/ /)
  
<<Enter>>
%%Prompt string: Enter string> 
obz$i/i`/r0i/ /'$ oz r-0(q/ /r)0(r,m-n.(v/ /r)0(rr-)?a$h$me0h$,)r0bm-n.(q/ /r)0a$h$mh$i//e-
  
<<InsertMode>>
%s=commandmode +2
  
<<TempInsertMode>>
%s=commandmode +3
  
<<Again>>
1
  
<<QuitDebugger>>
ob %q~=system; f/Default trace vector = /-oixol32o& (ol0o=, okol20) %s=trace '~; osozok
  
<<FocusToMouse>>
%%This needs to be at least two lines long, then it gets entered as a function call which can be redefined
%%by functions needing to redefine mouse-event behaviour.
opozono-omor 
(q/0-9a-zA-Z_/r)0oc(q-//r-)0oco-ou
  
<<NoteFromMouse>>
opozono-omor p n.
  
<<CopyFromMouse>>
opozono-omor p a_&
  
<<InsertHereMouse>>
opozono-omor h_
  
<<SelectionStart>>
oconobop
  
<<SelectionEnd>>
ozono-omorn. opozono-omor a$& ozono-omor
  
<<SelectionWord>>
oconobopozono-omor (q-/A-Za-z0-9_/r-)0n.(q//r)0 a$& ozono-omor
  
<<SelectionLine>>
oconobopozono-omor r-0n.r0 a$& ozono-omor
  
<<SelectionPut>>
obz$i/%s=commandstring /oz'$
  
<<SelectionFree>>
n.a$&

<<ScriptByName>>
%%Prompt string: Script subname> 
%%Searches scripts in PWD and ${JOT_HOME}/coms for scripts matching a a specified name.
ob
%%Define buffer 0.
n.a0&z0 oo/z%c/ i/%s=commandstring %r='+/
%%Acquire search string.
%%Add instructions to + buffer.
n.a+z+i/Select one of these scripts with names matching "/i'$i/" then hit {KP_0}./
%%Get raw directory listing.
%q~=dir ${JOT_HOME}/coms/;
%%Add the raw directory listing.
z+bh~ok
%%Filter the directory listing.
m-0m (v/dir /m, r0v-/.jot/m, k)0 m-0m z$r-0(r z+(v/dir /m, f1'$m, k)0, z+)
%%Construct the pathnames.
m-0m (v/dir /r4n.r0a$k, rr-h$m)0
%%Rewind and finish.
z+m-0m

<<ScriptByFunc>>
%%Prompt string: Script function string> 
%%Searches scripts in PWD and ${JOT_HOME}/coms for scripts matching a a specified name.
ob
%%Define buffer 0.
n.a0&z0 z0i"z+l0n.f1/ /a$&"r0 oo/z%c/ i"%s=commandstring %r='$"
%%Acquire search string.
%%%d$=mc;
%%Add instructions to + buffer.
n.a+z+i/These script's 1-line descriptions all match "/i'$i/" select one then hit {KP_0}./
%%Get the first-line comments.
%e~=\head -1 ${JOT_HOME}/coms/*.jot ./*.jot;
%%Top and tail the report and append to + buffer.
m-0 (v/==> /e4f1/ <==/s/	/j2m, m)0 z+r0bh~bok
%%Filter out those matching the given string.
m-0f/"/-n.f1/"/a$&m (z$r-0r z+(mm-f1/	/f1'$m, k)0, z+)
%%Find rightmost tab.
ol0m-0m(f/	/roc (o<okoc,) m)0
%%Resolve the first tabs.
m-0(f/	/ei/ /o#oc (o> ocoso- (i/ /o~)0, ) ok m)0 ok
%%Rewind and finish.
z+m-0m %l;

<<FindWild>>
%%Prompt string: Find-wild string> 
%%finds next line containing substrings in correct order.
%%Set up argument list if given - use last entry if it's null.
obz$ (rr- (f1/*/eb)0 m-0n.m0r0a@, ) z@m-0oz
%%reset search list and advance current character if already at an initial match point
obz@m-0oz (v'@r,)
%%Main search loop.
f'@rr-oc (f1'@-\ mobz@m-0ozf'@rr-okoc, obz@(moz, oz\))0
%%If successfully completed search select complete string.
(v-'@ n.oco-ora$h$f-1'$, )

<<FindWildPrev>>
%%Prompt string: Find-wild string> 
%%finds previous line containing substrings in correct order.
%%Set up argument list if given - use last entry if it's null.
obz$ (rr- (f1/*/eb)0 m-0n.m0r0a@, ) z@m0oz
%%reset search list and advance current character if already at an initial match point
obz@m0oz (v'@(r-, m-r0),)
%%Main search loop.
f-'@-r-roc (f-1'@\ m-r0obz@m0ozf-'@-r-rokoc, obz@(m-oz, oz\))0
%%If successfully completed search select complete string.
(v'@ n.oco-ora$h$f-1'$, )

<<FdInLineUn>>
%%Prompt string: Find-in same line string> 
%%Function finds next line matching a set of substrings in the any order.
%%
%%Prepare args in @ buffer.
obz$ (r\z@, r-n.r0a@&z@ ((v/ /e)0(f1/ /v-/\/e-r)0 v/ /b(v/ /e)0)0 r0b) m-0oz
%%Go
(f'@ (obz@(m2m-oz, oz\)r-0 f1'@-)0 obz@(mm-0oz, oz\)m)0 
%%If the previous loop completed at the end of the list of substrings then a match was found.
obz@(m\oz, oz %x=Failed to find a line containing the specified set of substrings.; )

<<FdInLineUnPrev>>
%%Prompt string: Find-in same line string> 
%%Function finds previous line matching a set of substrings in the any order.
%%
%%Prepare args in @ buffer.
obz$ (r\z@, r-n.r0a@&z@ ((v/ /e)0(f1/ /v-/\/e-r)0 v/ /b(v/ /e)0)0 r0b) m-0moz
%%Go
(f-'@ (obz@(m2m-oz, oz\)r-0 f1'@-)0 obz@(mm-0oz, oz\)m-)0 
%%If the previous loop completed at the end of the list of substrings then a match was found.
obz@(m\oz, oz %x=Failed to find a line containing the specified set of substrings.; )

<<FdInNLinesUn>>
%%Prompt string: Find-in same line string> 
%%Function finds next sequence of no more than N lines containing a set of substrings in the any order.
%%
%%Prepare args in @ buffer, first arg is aperture (allowable no. of lines).
obz$ (r\z@, r-n.r0a@&z@ ((v/ /e)0(f1/ /v-/\/e-r)0 v/ /b(v/ /e)0)0 r0b) m-0oz
%%Go
( %%Search loop - find the next line that contains any of the required substrings.
  %%Reset substrings list.
  obz@m-0moz 
  ( f1'@\obz@(m2m-oz, m-0mozm) )0 obz@ob(o=\oz, okoz %x=Initail search failed.;)
  %%Abstract the aperture.
  obz@m-0oidmosozr-0n.oma$&
  %%Check the abstract for each required substring.
  ob( z$m-0f'@ z@(m2m-, m))0 z@moz )0 obz@ob(o=okoz, oz)
%%If the main loop completed on the last required substring rhen we've found a matching set of lines.
obz@(m\oz, oz %x=Failed to find a block of lines containing the specified set of substrings.; )
%%Now return to the first required substring.
wobz@m-0oidmosoz ol-1o*omf'@

<<FdInNLinesUnPrev>>
%%Prompt string: Find-in same line string> 
%%Function finds next sequence of no more than N lines containing a set of substrings in the any order.
%%
%%Prepare args in @ buffer, first arg is aperture (allowable no. of lines).
obz$ (r\z@, r-n.r0a@&z@ ((v/ /e)0(f1/ /v-/\/e-r)0 v/ /b(v/ /e)0)0 r0b) m-0oz
%%Go
( %%Search loop - find the next line that contains any of the required substrings.
  %%Reset substrings list.
  obz@m-0moz 
  ( f1'@\obz@(m2m-oz, m-0mozm-) )0 obz@ob(o=\oz, okoz %x=Initail search failed.;)
  %%Abstract the aperture.
  obz@m-0oidmosozmn. ol-1o*oma$&
  %%Check the abstract for each required substring.
  ob( z$m-0f'@ z@(m2m-, m))0 z@mozm-2 )0 obz@ob(o=okoz, oz)
%%If the main loop completed on the last required substring rhen we've found a matching set of lines.
obz@(m\oz, oz %x=Failed to find a block of lines containing the specified set of substrings.; )
%%Now return to the first required substring.
wobz@m-0oidmosoz ol-1o*omf'@

<<FdInLineOrd>>
%%Prompt string: Find-in same line string> 
%%Function finds next line matching a sequence of substrings in the same order as given.
%%
%%Prepare args in @ buffer.
obz$ (r\z@, r-n.r0a@&z@ ((v/ /e)0(f1/ /v-/\/e-r)0 v/ /b(v/ /e)0)0 r0b) m-0oz
%%  obz$ (r\z@, r-n.r0a@&z@  ((v/ /e)0f1/ /b(v/ /e)0)0 r0b) m-0oz
%%Go
(f'@oc (obz@m2m-oz f1'@-)0 obz@mm-0ozokr)0 okoz
%%If the previous loop completed at the end of the list of substrings, a match was found - let's see.
(obz@m\ ozoc o-ou, ozok) 

<<FdInLineOrdPrev>>
%%Prompt string: Find-in same line string> 
%%Function finds previous line matching a sequence of substrings any order.
%%
%%Prepare args in @ buffer.
obz$ (r\z@, r-n.r0a@&z@ ((v/ /e)0(f1/ /v-/\/e-r)0 v/ /b(v/ /e)0)0 r0b) m-0oz
%%  obz$ (r\z@, r-n.r0a@&z@  ((v/ /e)0f1/ /b(v/ /e)0)0 r0b) m-0oz
%%Go
(f-'@oc (obz@m2m-ozr-0 f1'@-)0 obz@mm-0ozokr-)0 okoz
%%If the previous loop completed at the end of the list of substrings, a match was found - let's see.
(obz@m\ ozoc o-ou, ozok) 

<<FindSequence>>
%%Prompt string: Find-sequence string> 
%%function finds the sequence of words in arg - ignoring of whitespace & breaks.
%%Set up argument list if given - use last entry if it's null.
obz$ (rr- (r(v-/*/q/_A-Za-z0-9/b, r-) (q/_A-Za-z0-9/\e)0 q//(q//r)0 brr-)0 r-0(r, j-) z@m-0k0e0h$,) z@m-0o#oz
%%If already matched to first item - find next.
(v'@r,)
( %%Main loop - first find the next occurence of the first item.
  %%Initial search for first item. 
  (f'@(q-/_A-Za-z0-9/r?, rr-f1'@-q/_A-Za-z0-9/))0 v-'@
  %%Match all remaining items.
  ( %%Index to next item - exit on last item.
    z@mo#oz
    %%Find next word.
    ((q/_A-Za-z0-9/\r)0r\m)0 r-
    (v'@(q-/_A-Za-z0-9/r?, rr-f1'@-q/_A-Za-z0-9/))0 (v-'@, obz@(v/*/oz(q/_A-Za-z0-9/r)0, oz\))
    )0
  o#ozv-'@\ z@m-0o#oz
  )0
%%Completed search - reset search list and go back to the first item.
v-'@r-rz@m-0o#oz (f-'@(q-/_A-Za-z0-9/r-?,rr-f1'@-q/_A-Za-z0-9/f-'@))0f-1'@ ok, ok

<<FindSequencePrev>>
%%Prompt string: Find-sequence string> 
%%Finds previous instance of sequence of words in arg.
%%Set up argument list if given - use last entry if it's null.
obz$ (rr- (r(v-/*/q/_A-Za-z0-9/b, r-) (q/_A-Za-z0-9/\e)0 q//(q//r)0 brr-)0 r-0(r, j-) z@m-0k0e0h$,) z@m-0o#oz
%%If already matched to first item - find next.
(v'@r-,)
( %%Main loop - first find the next occurence of the first item.
  %%Initial search for first item. 
  (f-'@(q-/_A-Za-z0-9/r?,r-?f1'@-q/_A-Za-z0-9/)r-f-1'@)0 v-'@
  %%Match all remaining items.
  ( %%Index to next item - exit on last item.
    z@mo#oz
    %%Find next word.
    ((q/_A-Za-z0-9/\r)0r\m)0 r-
    (v'@(q-/_A-Za-z0-9/r?, rr-f1'@-q/_A-Za-z0-9/))0 (v-'@, obz@(v/*/oz(q/_A-Za-z0-9/r)0, oz\))
    )0
  o#ozv-'@\ (r-, m-r0)z@m-0o#oz
  (f-'@(q-/_A-Za-z0-9/r?,r-?f1'@-q/_A-Za-z0-9/)r-f-1'@)0 v-'@
  )0
%%Completed search - reset search list and go back to the first item.
v-'@r-rz@m-0o#oz (f-'@(q-/_A-Za-z0-9/r-?,rr-f1'@-q/_A-Za-z0-9/f-'@))0f-1'@ ok, ok

<<FindInParaNext>>
%%Prompt string: Find-in-paragraph substring list> 
%%Finds next paragraph containing a set of substrings
%%Set up argument list if given - use last entry if it's null.
obz$ (r\z@, r-n.r0a@&z@ ((v/ /e)0(f1/ /v-/\/e-r)0 v/ /b(v/ /e)0)0 r0b) m-0o#oz
( %%Main loop - first find a match to the first substring then abstract the paragraph to buffer $ and check the other required substrings.
  z@m-0o#oz f'@ (m-(v/ /r)0r)0 mn. ((v/ /r)0rm)0 r-0a$&
  %%Check remaining substrings in the list.
  (z$m-0f'@z@m2m-)0
  %%Does this paragraph match - if so we're at the end of the substring list.
  z@m
  %%No - continue with next paragraph. 
  o#ozmm-)0
z@(m\ m-oz w (m-r)0f'@, oz %x=Failed to locate a paragraph containing the specified substrings.; )

<<FindInParaPrev>>
%%Prompt string: Find-in-paragraph substring list> 
%%Finds next paragraph containing a set of substrings
%%Set up argument list if given - use last entry if it's null.
obz$ (r\z@, r-n.r0a@&z@ ((v/ /e)0(f1/ /v-/\/e-r)0 v/ /b(v/ /e)0)0 r0b) m-0o#oz
( %%Main loop - first find a match to the first substring then abstract the paragraph to buffer $ and check the other required substrings.
  z@m-0o#oz f-'@ (m-(v/ /r)0r)0 mn. ((v/ /r)0rm)0 r-0a$&
  %%Check remaining substrings in the list.
  (z$m-0f'@z@m2m-)0
  %%Does this paragraph match - if so we're at the end of the substring list.
  z@m
  %%No - continue with next paragraph. 
  o#oz (m-(v/ /r)0r)0 )0
z@(m\ m-oz (m(v/ /r)0r)0 w (m-(v/ /r)0)0 f'@, oz %x=Failed to locate a paragraph containing the specified substrings.; )

<<CutRectangle>>
%%- Copies (to paste buffer) a rectangular block of text from the note point to the current cursor position.
  %%Check note buffer, get note point.
  ob %q$=system; f/Note buffer =    /-oico=\oz, f/Note linenumber = /-oidos f/Note character = /-oidos
  %%Get Y aligned with note point.
  oz o#ocosr-0ory0oco-or
  %%Calculate block height and width.
  ocoso- osono-
  %%Return to original note point.
  oso#ol0oso-or oso#(y-o~)0 ok
  %%Abstract block, one record at a time.
  n.a_ol1o- (n.oso#or?a_+*obz_r0boz oso~y)0 okok
  %%Return to note point (top-left corner of abstracted block).
  obz_m-2onol0oso-osoz (y-o~)0

<<PasteRectangle>>
%%- Pastes a block graphic image in the paste buffer with it's top-left corner character at the current cursor position.
  %%Get return position.
  ocon
  %%Get length of inserted text.
  obz_m-0onm0ono~o- osoz
  %%Calculate rightmost column of inserted text.
  ocobz_r0ocosozo+ ol-1oso-
  %%Check that we've enough space - add lines and whitespace as necessary.
  r-0(oso~os o#(o~(r, i/ /))0ok (m2m-, onr-0b-o.) )0 okok
  %%Restore position
  ono-om or
  %%Insert here
  h_* 
  %%Move back to original insert point.
  oc obz_m-0ol0(mo~)0osozol0oso- omor

<<LineNW>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in north-westerly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
obz$r-0(r, i"\")r-0(r2r-b)0m0oz 
%%Note original column number.
ocol0oso- 
(mo#ol-1oso-or
  v"/" %%We're next on the next character on a north-easterly diagonal - shift up and left.
    m-ol-1o+
  , (m-, b-)2o#ol1oso-orv"/" %%We're at the next character of a south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m, r-0b-) ol-2o+ )
%%Main loop - inserts character(s) along a NW diagonal.
r-0(o#o~ (o~(r, i/ /))0ok r-re?i'$ obz$m-oz (m-, r-0b-) ol1o+ )0 
%%Index to next start point.
oz(m-, r-0b-)ol2o+(o~(r, i/ /))0ok

<<LineNE>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in north-easterly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
obz$r-0(r, i"/")r-0(r2r-b)0m-0oz 
%%Note original column number.
ocol0oso- 
(mo#ol1oso-or
  v"\" %%We're next on the next character on a north-westerly diagonal - shift up and left.
    m-ol-3o+
  , (m-, b-)2o#ol-1oso-orv"\" %%We're at the next character of a south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m, r-0b-) ol-2o+ )
%%Main loop - inserts character(s) along a NE diagonal.
r-0(o#o~ (o~(r, i/ /))0ok e?i'$ obz$moz (m-, r-0b-) ol-1o+ )0 
%%Index to next start point.
oz(m-, r-0b-) ol0o+(o~(r, i/ /))0ok

<<LineSW>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in south-westerly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "/".
obz$r-0(r, i"/")r-0(r2r-b)0m0oz 
%%Note original column number.
ocol0oso- 
((m-, r-0b-)o#ol-1oso-or
  v"\" %%We're next on the next character on a south-easterly diagonal - shift up and left.
    mol-1o+
  , (m, r0b)2o#ol1oso-orv"\" %%We're at the next character of a south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m-, r-0b-) ol-2o+ )
%%Main loop - inserts character(s) along a SW diagonal.
r-0(o#o~ (o~(r, i/ /))0ok r-re?i'$ obz$m-oz (m, r0b) ol1o+ )0 
%%Index to next start point.
oz(m, r0b)ol2o+(o~(r, i/ /))0ok

<<LineSE>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in south-easterly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
obz$r-0(r, i"\")r-0(r2r-b)0m-0oz 
%%Note original column number.
ocol0oso- 
((m-, r-0b-)o#ol1oso-or
  v"/" %%We're next on the next character on a south-westerly diagonal - shift up and left.
    mol-3o+
  , (m, r0b)2o#ol-1oso-orv"/" %%We're at the next character of a north-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m-, r0b) ol-2o+ )
%%Main loop - inserts character(s) along a SE diagonal.
r-0(o#o~ (o~(r, i/ /))0ok e?i'$ obz$moz (m, r0b) ol-1o+ )0
%%Index to next start point.
oz(m, r0b) ol0o+(o~(r, i/ /))0ok

<<DSLineNW>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws staggerd line in north-westerly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
obz$r-0(r, i"\")r-0(r2r-b)0m0oz 
%%Note original column number.
ocol0oso- 
((m, r0b)o#ol-2oso-or
  v"/" %%We're next on the next character on a staggerd north-easterly diagonal - shift up and left.
    m-ol0o+
  , (m-, b-)2o#ol1oso-orv"/" %%We're at the next character of a staggerd south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m, r-0b-) ol-1o+ )
%%Main loop - inserts character(s) along a NW diagonal.
r-0(o#o~ (o~(r, i/ /))0ok r-re?i'$ obz$m-oz (m-, r-0b-) ol2o+ )0 
%%Index to next start point.
oz(m-, r-0b-)ol2o+(o~(r, i/ /))0ok

<<DSLineNE>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws staggerd line in north-easterly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
obz$r-0(r, i"/")r-0(r2r-b)0m-0oz 
%%Note original column number.
ocol0oso- 
((m, r0b)o#ol2oso-or
  v"\" %%We're next on the next character on a staggerd north-westerly diagonal - shift up and left.
    m-ol-4o+
  , (m-, b-)2o#ol-1oso-orv"\" %%We're at the next character of a staggerd south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m, r-0b-) ol-3o+ )
%%Main loop - inserts character(s) along a NE diagonal.
r-0(o#o~ (o~(r, i/ /))0ok e?i'$ obz$moz (m-, r-0b-) ol-2o+ )0 
%%Index to next start point.
oz(m-, r-0b-) ol0o+(o~(r, i/ /))0ok

<<DSLineSW>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in a staggerd south-westerly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "/".
obz$r-0(r, i"/")r-0(r2r-b)0m0oz 
%%Note original column number.
ocol0oso- 
((m-, r-0b-)o#ol-2oso-or
  v"\" %%We're next on the next character on a staggerd south-easterly diagonal - shift up and left.
    mol0o+
  , (m, r0b)2o#ol1oso-orv"\" %%We're at the next character of a staggerd south-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m-, r-0b-) ol-1o+ )
%%Main loop - inserts character(s) along a SW diagonal.
r-0(o#o~ (o~(r, i/ /))0ok r-re?i'$ obz$m-oz (m, r0b) ol2o+ )0 
%%Index to next start point.
oz(m, r0b)ol2o+(o~(r, i/ /))0ok

<<DSLineSE>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in a staggerd south-easterly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "\".
obz$r-0(r, i"\")r-0(r2r-b)0m-0oz 
%%Note original column number.
ocol0oso- 
( (m-, r-0b-)o#ol2oso-or
  v"/" %%We're next on the next character on a staggerd south-westerly diagonal - shift up and left.
    mol-4o+
  , (m, r0b)2o#ol-1oso-orv"/" %%We're at the next character of a staggerd north-westerly diagonal - shift left only.
    ol-2o+
  , %%All other cases - start drawing at original cursor position.
  (m-, r0b) ol-3o+ )
%%Main loop - inserts character(s) along a SE diagonal.
r-0(o#o~ (o~(r, i/ /))0ok e?i'$ obz$moz (m, r0b) ol-2o+ )0 
%%Index to next start point.
oz(m, r0b) ol0o+(o~(r, i/ /))0ok

<<LineS>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in southerly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "|".
obz$r-0(r, i"|")r-0(r2r-b)0m-0oz 
%%Note original column number.
ocol0oso- 
( v-"-" %%We're next on the next character on an easterly line - shift down and right.
    (m, r0b)ol-2o+
  , rv"-" %%We're at the next character of a westerly line - shift down and left.
    (m, r0b)ol-2o+
  , %%All other cases - start drawing at original cursor position.
  r- ol-2o+ )
%%Main loop - inserts character(s) along a southerly line.
r-0(o#o~ (o~(r, i/ /))0ok e?i'$ obz$moz (m, r0b) )0 
%%Index to next start point.
oz(m, r0b) ol1o+(o~(r, i/ /))0ok

<<LineN>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in northerly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "|".
obz$r-0(r, i"|")r-0(r2r-b)0m0oz 
%%Note original column number.
ocol0oso- 
( v-"-" %%We're next on the next character on an easterly line - shift up and right.
    (m-, r-0b-)ol-2o+
  , rv"-" %%We're at the next character of a westerly line - shift up and left.
    (m-, r-0b-)ol-2o+
  , %%All other cases - start drawing at original cursor position.
  r- ol-2o+ )
%%Main loop - inserts character(s) along a northerly line.
r-0(o#o~ (o~(r, i/ /))0ok e?i'$ obz$m-oz (m-, r-0b-) )0 
%%Index to next start point.
oz(m-, r-0b-) ol1o+(o~(r, i/ /))0ok

<<LineE>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in easterly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "-".
obz$r-0(r, i"-")r-0(r2r-b)0m-0oz 
%%Note original column number.
ocol0oso- 
((m-, r-0b-)o#ol0oso-or v"|" %%We're next on the next character on a northerly line - shift right.
    mol-3o+
  , (m, r0b)2o#ol0oso-orv"|" %%We're at the next character of a southerly line - shift right.
    m-ol-3o+
  , %%All other cases - start drawing at original cursor position.
  m- ol-2o+ )
%%Main loop - inserts character(s) along an easterly line.
r-0o~ (o~(r, i/ /))0ok (e?i'$ obz$moz )0 
%%Already at next start point.
oz

<<LineW>>
%%Prompt string: Draw-line string> 
%%Drawing function - draws line in westerly direction, with tidy corners.
%%Pick up optional string argument.
%%Check - if no arg given, default to "-".
obz$r-0(r, i"-")r-0(r2r-b)0m0oz 
%%Note original column number.
ocol0oso- 
((m-, r-0b-)o#ol0oso-or v"|" %%We're next on the next character on a northerly line - left.
    mol-1o+
  , (m, r0b)2o#ol0oso-orv"|" %%We're at the next character of a southerly line - shift right.
    m-ol-1o+
  , %%All other cases - start drawing at original cursor position.
  m- ol-2o+ )
%%Main loop - inserts character(s) along a westerly line.
r-0 (o~(r, i/ /))0ok (e-?i-'$ obz$m-oz )0 
%%Index to next start point.
oz r-

<<Box>>
%%Prompt string: Box size> 
%%Drawing function - draws a box with the top-left corner at the current cursor position.
%%Pick up dimensions argument.
%%o@%d$=9 5; 
%%Check - if no arg given, default to "10 5".
obz$r-0(rr-(q/0-9/ f1/ /(v/ /r)0q/0-9/, %x=Box argument must be <Width> <Height> (both integers).;), i"10 5") r-0oidol0oso-os oidol0oso-os ozos 
%%Start drawing - first the top horizontal line.
o# e?i/ / (o~e?i/-/)0 e?i/ / ok
%%2nd. the right-hand vertical.
oso# (ocol0oso-(m, r0b)(o~(r, i/ /))0 oke?i/|/o~)0 ok
%%3rd. the bottom horizontal.
os ocol0oso-(m, r0b) (o~ (r, i/ /))0 ok (o~e-i-/-/)0 ok
%%Lastly the left-hand vertical.
(ocol0oso-m-(o~(r, i/ /))0 okei/|/o~)0 ok

<<Lozenge>>
%%Prompt string: Lozenge size> 
%%Drawing function - draws a lozenge-shaped box with the top corner at the current cursor position.
%%Pick up dimensions argument.
%%Check - if no arg given, default to 5, check that current character is at least the lozenge size.
obz$r-0(rr-(q/0-9/, %x=Lozenge argument must be <Side> (an integer).;), i"5") r-0oidol-1oso-os oz
%%Check starting point.
o#oco+ ol0(o< %x=Error can not draw a lozenge of that size from the this starting point.;, ) ok
%%Start drawing - first the top-right diagonal.
o#ocol0oso- (ol-1o+ oso~oso#e?i"\"(m, r0b)((r, i/ /)o~)0 ok)0 okok
%%2nd. the bottom-right diagonal.
o#r-ocol0oso- (ol1o+ oso~oso#e?i"/"(m, r0b)((r, i/ /)o~)0 ok)0 okok
%%3rd. the bottom-left diagonal.
o#oc (o#m-or ol-1o+ oso~ose?i"\")0 okok
%%os ocol0oso-(m, r0b) (o~ (r, i/ /))0 ok (o~e-i-/-/)0 ok
%%Lastly the top-left diagonal.
o#roc (ol1o+ oso~ose?i"/" o#(m-, r-0b-)or)0 mokol-1o+orok

<<DSLozenge>>
%%Prompt string: Lozenge size> 
%%Drawing function - draws a double-spaced lozenge-shaped box with the top corner at the current cursor position.
%%Pick up dimensions argument.
%%o@%d$=6; 
%%Check - if no arg given, default to 5, check that current character is at least the lozenge size.
obz$r-0(rr-(q/0-9/, %x=Lozenge argument must be <Side> (an integer).;), i"5") r-0oidol-1oso-os oz
%%Check starting point.
o#ol2o*oco+ ol0(o< %x=Error can not draw a lozenge of that size from the this starting point.;, ) ok
%%Start drawing - first the top-right diagonal.
o#ocol0oso- (ol-2o+ oso~oso#e?i"\"(m, r0b)((r, i/ /)o~)0 ok)0 okok
%%2nd. the bottom-right diagonal.
o#r-2ocol0oso- (ol2o+ oso~oso#e?i"/"(m, r0b)((r, i/ /)o~)0 ok)0 okok
%%3rd. the bottom-left diagonal.
o#(r, i/ /)oc (o#m-or ol-2o+ oso~ose?i"\")0 okok
%%Lastly the top-left diagonal.
o#r2oc (ol2o+ oso~ose?i"/" o#(m-, r-0b-)or)0 mokol-1o+orok

<<BoxText>>
%%Prompt string: Box text> 
%%function - writes given text into line-drawing box.
%%Pick up optional string argument - if none given then clears out all text.
%%Split arg into words, if no arg given, default to " ".
obz$r-0((f/ /r(v/ /e)0b)0r0i/ /m-0, i" ")r-0 oz
%%Find top boundary of box (may be lozenge-shaped with diagonal boundaries) load the column no. onto stack.
( q-"--"\(q"|/\"\r)0 v"|"oco#m-or, v"/"oco#m-or(v" /"r,), v"\"oco#ol1o-m-or(v-"\"r-,) q"|/\"ok)0 mo#or
%%
%%Line loop - fill this line with words until we find a word that won't go.
%%Find next line in box big enough for next word.
%%Get the box width for the first line.
(q"-|\/"\r)0oc(q-//\r-)0oco-
( %%Word loop - add words to current line until the next word would make it go pop.
  %%Get the width of the next word.
  obz$r0ocosoz
  %%Is the remaining line-width sufficient?
  ( o< %%No - move on to next line.
    oko#mor(q-"-|\/"\r-)0((q"-|\/"\ v-/-/\)\ %x=Insufficient space for your text;, ) (q"-|\/"\ei/ /)0r-oc(q-//\r-)0oco-ei/ / 
    %%Pick up width of next word.
    obz$ocosoz
  , %%Yes add the word.
    i'$obz$ocosozol0oso-(eo~)0ok obz$ocosozo- obz$mr0ocosoz)0
  obz$mm-oz)0
ok osokosok z$(m\, %x=Failed to add some of your words.;) ozw

<<Help>>
%%Prompt string: Help key> 
%%Function to browse through help normally.
%%
%%If in the ; buffer (help menu) reload from selected topic, 
%%  if none selected then go up one level,
%%  if in some other buffer load from top level, saving original buffer key.
%%If an argument is specified then list all matching help keys.
%%
ob z$r-0(v/ /e)0 
  (rr-
  %%A search-string was given - Preserve top line, fold header, for return
  z;m-0 (mk0,)e0i/  The following keys refer to "/i'$i/"/b2 z:m-0
  %%Find matching fold headers.
  (f'$r-0(v/{{{/,v/[/)na@h@z;h@z:,m)0 z;m-0n.r0a$h$m0ok,
  %%No search-string given - first check that we're in the help buffer.
  z;ob(o=ok, z:m0ozr-0na;&z;)
  %%Check for file-fold.
  r-0v/[/ 
  %%It's a file fold - expand path and fetch help info.
  ( (m-k-0,)mk0n.(f1/ /, r0) z:m-0f'; z;e0i/.hlp/r-0e(v/]/e,f1/]/ei"/")r-0i"%i@=${JOT_RESOURCES}/help/" ';
    %%Integrate new data with help text.
    m0n.r0a$i/}}}/m-0b-i/{{{ /h$ 
    %%Replace correct file-fold mark with new entry - preserving comments.
    z: n.r0a;z@r0h;z: h@z;m-0k0h@, )\ ,
  %%Assume it's a normal fold - traverse fold and extract help entry.
  z;r-0
    (f1/{{{/
    %%At a fold mark, find this fold mark in main buffer.
    r-0n.r0a$h$ z:(f-'$r0v-'$\m-)0,
    %%Not on a fold mark - go back up hierarchy, first find current header.
    z;m-0 (f/{{{/n.r0a$h$ z:(f-'$r0v-'$\m-)0r-0, z:m-0)
    %%Now find parent header.
    ol-1(m-(f1/}}}/ol1o-, (f1/{{{/\, o~)))0 ok ) 
  %%Copy fold-mark into ';'. 
  r-0n.ma;h;ol-1
  %%Copy current-level fold marks and text into ';'.
  ((f1/}}}/\(ol-1o= n.ma@h@z;m0h@z:m-, ), o~) (f1/{{{/ol1o-,) m)0 ok )
%%Add the index help point.
z;m-0f'$(r-m-0m3, mf/{{{/, m-0) 

<<FindAllHelp>>
%%Prompt string: Find-help string> 
%%function - returns all keys where text contains the string.
z$
(v/ /rr\
  %%Argument not given - report hierarchy.
  z;m-0 z:on
  %%Find current Fold mark and initialize list.
  f-';na;h;m-2
  ( %%Loop to find parent fold mark.
    %%Find parent fold.
    ol-1 r-0 (f1/}}}/ol1o-m-,f1/{{{/\m-,o~m-)0 ok
    %%Extract parent fold comment.
    na$h$ z;m-0h$
    %%Ascend one level.
    z:m-2)0
    
  z:ono-om
  z;
  
  , %%Argument given - save the original fold mark and search for key.
  z;m-0(mk0,)e0i/  The following entries refer to "/i'$i/"/b2 z:m-0 
  (  f'$
    %%Keep the actual line for display.
    na@h@z;m0h@z:m-
    %%Step back to the header for this fold.
    on ol-1r-0 (f1/}}}/ol1o-m-,f1/{{{/\m-,o~m-)0 ok 
    %%If this is the first entry in this fold add it to the help list.
    na@h@z;m-0m2(f'@, m0m-h@)z:
    %%Got the item header - now return.
    ono-om m
    )0 z;m-0m3
  )

<<RemoveHelpFold>>
%%function - restores original file fold where appropriate.
%%Collapse file fold in help repository.
z:m-0f';mn.m-
ol0r-0(f1/{{{/\m)0r-0 (f1/{{{/ol1o-m,f1/}}}/\m,o~m)0 ok
ma$ m-v/{{{ /e4
%%Collapse file fold in help window.
z;e4

<<AddNewFunctions>>
%%Adds function definitions in ( @ ) buffer to code repository and updates hashtable.
%%
obz'm0 (rr0bm-, m-)2m0 onh@ ono-om
%%Check the function definitions and set up the function hashtable.
((v/<</\m)0 mm-r2n.f1/>>/a@&r2 %h=add '@;)0
%%
%%If the keymap buffer contains any symbolic keys ( of the form {<keySequenceDescription>} ) then resolve these now.
z^m-0(v/{/\m)0 
( v/{/\oz ,
  ( %q=windows;
    %r=WindowsNT_keys;
  , %%unix then.
    %q$=env TERM; m %r=curses_keys_'$;
  , %m=Error: No keys for TERM $TERM, using xterm instead.;
    %r=curses_keys_xterm; )
  %%Replace symbolic keys.
  (z^v/{/n.f1/}/-a$&v-'$ z@m-0(f'$r-0n.r12a$&z^s'$m, m) )0 oz)

:
  
%%Set up the hashtable in the code-repository buffer ( ' ).
%h'=create 1000;

%%Define functins map in buffer ( ! ).
%g!
<<CopyFromMouse>>     {Button1Up}
<<NoteFromMouse>>     {Button1Down}
<<FocusToMouse>>      {Button1Click}
<<InsertHereMouse>>   {Button1DoubleClick}
<<CopyFromMouse>>     {Button2Up}
<<NoteFromMouse>>     {Button2Down}
<<FocusToMouse>>      {Button2Click}
<<InsertHereMouse>>   {Button3Click}
<<Help>>              {F1}
<<FindAllHelp>>       {Shift+F1}
<<RemoveHelpFold>>    {Ctrl+F1}
<<Note>>              {Ctrl+Shift+F1}
<<Note>>              {Home}
<<TermResize>>        {SizeAdj}
<<Do>>                {F2}
<<ScriptByName>>      {Shift+F2}
<<ScriptByFunc>>      {Ctrl+F2}     
<<Cut>>               {Ctrl+Shift+F2}
<<Cut>>               {Delete}
<<CumulativeCut>>     {Shift+Alt+F2}
<<CumulativeCut>>     {Shift+Delete}
<<CutTabular>>        {Ctrl+Shift+Alt+F2}
<<CutTabular>>        {Ctrl+Delete}
<<ParagraphUp>>       {F3}
<<CodeSectionUp>>     {Shift+F3}
<<IndentMatchUp>>     {Ctrl+F3}
<<Copy>>              {Ctrl+Shift+F3}
<<Copy>>              {End}
<<CumulativeCopy>>    {Shift+Alt+F3}
<<CumulativeCopy>>    {Shift+End}
<<CutRectangle>>      {Ctrl+Shift+Alt+F3}
<<CutRectangle>>      {Alt+Delete}
<<ParagraphDown>>     {F4}
<<CodeSectionDown>>   {Shift+F4}
<<IndentMatchDown>>   {Ctrl+F4}
<<Paste>>             {Ctrl+Shift+F4}
<<Paste>>             {Insert}
<<PasteOver>>         {Shift+Alt+F4}
<<PasteOver>>         {Ctrl+Insert}
<<PasteRectangle>>    {Ctrl+Shift+Alt+F4}
<<PasteRectangle>>    {Alt+Insert}
<<Substitute>>        {F5}
<<Remove>>            {Shift+F5}
<<SubstituteAgain>>   {Ctrl+F5}
<<AnyMatch>>          {Alt+F5}
<<AngleMatchLeft>>    {Ctrl+Shift+F5}
<<ParenMatchLeft>>    {Shift+Alt+F5}
<<CurlyMatchLeft>>    {Ctrl+Shift+Alt+F5}
<<Insert>>            {F6}
<<Overwrite>>         {Shift+F6}
<<InsertAgain>>       {Ctrl+F6}
<<AngleMatchRight>>   {Ctrl+Shift+F6}
<<ParenMatchRight>>   {Shift+Alt+F6}
<<CurlyMatchRight>>   {Ctrl+Shift+Alt+F6}
<<FindPrev>>          {F7}
<<SubsThenFindPv>>    {Shift+F7}
<<FindPrevAgain>>     {Ctrl+F7}
<<MarkupMatchLeft>>   {Shift+Alt+F7}
<<SquareMatchLeft>>   {Ctrl+Shift+Alt+F7}
<<FindNext>>          {F8}
<<SubsThenFindNx>>    {Shift+F8}
<<FindNextAgain>>     {Ctrl+F8}
<<MarkupMatchRight>>  {Shift+Alt+F8}
<<SquareMatchRight>>  {Ctrl+Shift+Alt+F8}
<<FindExactNext>>     {F9}
<<FindExactPrev>>     {Shift+F9}
<<SetFindString>>     {Ctrl+F9}
<<AppendLeftPrev>>    {Alt+F9}
<<IndentFromPrev>>    {Ctrl+Shift+F9}
<<JoinLeftPrev>>      {Shift+Alt+F9}
<<Again>>             {F10}
<<AppendRightNext>>   {Alt+F10}
<<IndentFromNext>>    {Ctrl+Shift+F10}
<<JoinRightNext>>     {Shift+Alt+F10}
<<Up>>                {UpArrow}
<<WordUp>>            {Shift+UpArrow}
<<NewWordUp>>         {Ctrl+UpArrow}
<<PageUp>>            {PageUp}
<<PopupPageUp>>       {Ctrl+Alt+PageUp}
<<ViewUp>>            {Ctrl+Shift+UpArrow}
<<WindowShrink>>      {Ctrl+Alt+UpArrow}
<<Down>>              {DownArrow}
<<WordDown>>          {Shift+DownArrow}
<<NewWordDown>>       {Ctrl+DownArrow}
<<PageDown>>          {PageDown}
<<PopupPageDown>>     {Ctrl+Alt+PageDown}
<<ViewDown>>          {Ctrl+Shift+DownArrow}
<<WindowStretch>>     {Ctrl+Alt+DownArrow}
<<Left>>              {LeftArrow}
<<WordLeft>>          {Shift+LeftArrow}
<<LineLeft>>          {Ctrl+LeftArrow}
<<DeleteChrLeft>>     {Alt+LeftArrow}
<<PageUp>>            {Alt+UpArrow}
<<PageDown>>          {Alt+DownArrow}
<<ViewLeft>>          {Ctrl+Shift+LeftArrow}
<<DeleteLineLeft>>    {Ctrl+Alt+LeftArrow}
<<DeleteWordLeft>>    {Shift+Alt+LeftArrow}
<<RestoreChrLeft>>    {Ctrl+Shift+Alt+LeftArrow}
<<Right>>             {RightArrow}
<<WordRight>>         {Shift+RightArrow}
<<LineRight>>         {Ctrl+RightArrow} Collides with {Ctrl+Alt+PageUp}
<<DeleteChrRight>>    {Alt+RightArrow} Collides with {Ctrl+PageUp}
<<ViewRight>>         {Ctrl+Shift+RightArrow}
<<DeleteLineRight>>   {Ctrl+Alt+RightArrow}
<<DeleteWordRight>>   {Shift+Alt+RightArrow}
<<RestoreChrRight>>   {Ctrl+Shift+Alt+RightArrow}
^[fs        <<FindSequence>>      
^[-fs       <<FindSequencePrev>>
^[fo        <<FdInLineOrd>>
^[-fo       <<FdInLineOrdPrev>>   
^[fu        <<FdInLineUn>>        
^[-fu       <<FdInLineUnPrev>>    
^[fn        <<FdInNLinesUn>>    
^[-fn       <<FdInNLinesUnPrev>>    
^[fw        <<FindWild>>          
^[-fw       <<FindWildPrev>>      
^[fp        <<FindInParaNext>>    
^[-fp       <<FindInParaPrev>>    
^[rw        <<RestoreWordRight>>          
^[rl        <<RestoreLineRight>>          
^[-rw       <<RestoreWordLeft>>          
^[-rl       <<RestoreLineLeft>>          
^[vs        <<ViewSave>>          
^[vr        <<ViewRestore>>       
^[wd        <<WindowDown>>        
^[wu        <<WindowUp>>          
^[w1        <<WindowOne>>         
^[wr        <<WindowReassign>>    
^[wh        <<WindowHorizSplit>>  
^[wv        <<WindowVertSplit>>   
^[wt        <<WindowAlignTop>>    
^[wc        <<WindowAlignCent>>   
^[wb        <<WindowAlignBot>>    
^[w+        <<WindowStretch>>     
^[w-        <<WindowShrink>>      
^[ps        <<PopupSearch>>      
^[pi        <<PopupIncrementalSearch>>      
^[pr        <<PopupRestore>>      
^[pu        <<PopupPageUp>>      
^[pd        <<PopupPageDown>>      
^[`         <<InsertWithBackTick>>
^[q         <<QuitDebugger>>
^[e         <<Enter>>             
^[i         <<TempInsertMode>>    
^[I         <<InsertMode>>        
^[ce        <<CmdEditStart>>      
^[cg        <<CmdEditGo>>         
^[cs        <<CmdString>>         
^[mn        <<UpRegardless>>      
^[ms        <<DownRegardless>>    
^[me        <<RightRegardless>>   
^[mw        <<Left>>              
^[/d        <<LineSW>>            
^[/s        <<DSLineSW>>          
^[\d        <<LineSE>>            
^[\s        <<DSLineSE>>          
^[ls        <<LineS>>             
^[lwl       <<LineW>>             
^[\u        <<LineNW>>            
^[\n        <<DSLineNW>>          
^[/u        <<LineNE>>            
^[/n        <<DSLineNE>>          
^[ln        <<LineN>>             
^[le        <<LineE>>             
^[br        <<Break>>             
^[bt        <<BoxText>>           
^[bx        <<Box>>               
^[z1        <<Lozenge>>           
^[z2        <<DSLozenge>>         
^[0         <<Macro0>>            
^[1         <<Macro1>>            
^[2         <<Macro2>>            
^[3         <<Macro3>>            
^[4         <<Macro4>>            
^[5         <<Macro5>>            
^[6         <<Macro6>>            
^[7         <<Macro7>>            
^[8         <<Macro8>>            
^[9         <<Macro9>>            
<<Macro1>>            {KP_1}
<<LineSW>>            {Ctrl+Alt+KP_1}
<<Macro2>>            {KP_2}
<<DownRegardless>>    {Ctrl+KP_2}
<<LineS>>             {Ctrl+Alt+KP_2}
<<Macro3>>            {KP_3}
<<LineSE>>            {Ctrl+Alt+KP_3}
<<Macro4>>            {KP_4}
<<Left>>              {Ctrl+KP_4}
<<LineW>>             {Ctrl+Alt+KP_4}
<<Macro5>>            {KP_5}
<<BoxText>>           {Ctrl+Alt+KP_5}
<<Macro6>>            {KP_6}      
<<RightRegardless>>   {Ctrl+KP_6} 
<<LineE>>             {Ctrl+Alt+KP_6}
<<Macro7>>            {KP_7}
<<LineNW>>            {Ctrl+Alt+KP_7}
<<Macro8>>            {KP_8}
<<UpRegardless>>      {Ctrl+KP_8}
<<LineN>>             {Ctrl+Alt+KP_8}
<<Macro9>>            {KP_9}
<<LineNE>>            {Ctrl+Alt+KP_9}
<<Macro0>>            {KP_0}
<<Enter>>             {KP_Enter}
<<Again>>             {KP_Decimal}
:
%%Windows does not send events on window resize.
(%q=windows; z!m-0f/{SizeAdj}/k, )

%%This macro finalizes the startup, normally called at the end of this script but may be deferred by the -nofinalize qualifier 
%%and called by the parent startup script.
%g#
%%For single-line functions, the code is copied directly into the key-translations buffer ( ^ )
%%for multi-line functions a call stub of the form "%h'=call <name>;" goes into the key-translations buffer.
%%
%%Key-code identification requires case sensitivity on.
%s=case 1;
%%Now check the function definitions and set up the function hashtable.
obz'm-0 ((v/<</\m)0 mm-r2n.f1/>>/a$&r2 ( %h=new '$;, %m=Warning: duplicate function definition for '$;) )0 oz
%%Add code to pick up parameters and call functions.
ob z?m0r0b z!m-0
( %%Skip blank lines and comments.
  (((v/ /r)0r\m)0 r-v/%%/m)0 
  %%For each key description, pick up the function name.
  (v/<</r2n.f1/>>/a$&
    %%Check function names ( in $ buffer) and keycodes.
    ( %h'=jump '$;, %m?=Error: No definition of function '$;)
    %%Add escape sequence to ( ^ ) buffer.
    %%First pick up the key description to ( ; ) buffer.
    z!(f1/{/n.r2f1/}/-a;&, %m?=Error: Syntax of key-name to keycode translation for '!.;) 
    %%Now pick up the key code.
    z@m-0(f';r-0n.r12a;&, %m?=Error: Syntax or missing keycode in translation of key ''; z?r0i'; ) 
  , %%Not a key description - maybe a simple escape sequence, these do not require keycode translation.
    r-0n.r12a;& v/<</r2n.f1/>>/a$& (%h'=jump '$;, %m?=Error: No definition of function '$;)
  , %m?=Error: syntax of function-names to key-description map at '!.;) 
  %%Add the key code and single-line function code or, for longer functions, function call to the ( ^ ) buffer.
  z'on(mv/%%/, r\)0 onm ((v/%%/, (v/ /r)0r\)m)0r-? (v/<</ono-omz^i'',  okz^i/%h'=call /h$i/;/) r-0h; z'ono-om
  %%If function code has parameters, insert parameter-capture code to ( ^ ) buffer.
  ( z'mv/%%Prompt string:/\, f1/:/-n.r0a$& z^i|%d$=##"|h$i| " -hereEndsThePercentCommand; | )
  %%Index to next key description.
  z^r0b z!m2m-)0
  
%s=case 0;
oz
  
%%Initialize help repository. 
ob
( %%Help repository setup.
  %%If JOT_RESOURCES is not defined then set it to ${JOT_HOME}/resources
  ( %q$=env JOT_RESOURCES; mf1/- <Undefined>/\, %q$=env JOT_HOME; k i"%s=setenv JOT_RESOURCES " r0i"/resources" '$ )
  %%
  %q=file ${JOT_RESOURCES}/help/help.hlp; %i:=${JOT_RESOURCES}/help/help.hlp;
, %%the help repository could not found
  %m:=Warning: Could not find a help tree below the JOT_RESOURCES directory.; )
oz
  
%%%h'=call WindowOne;
%%%s=console 10;
%%Check for errors and display them if necessary.
ob z?m0ol0 (v/Error: /m-o~)0 ol0(o=ok, m0w %m=Oh dear! - there were '~ errors in your startup file - hit {return} to continue; g )
%%Restore original verbosity level.
( %q$=system; f/Verbosity =    /-v/0/, %q=version; ) oz
:

%%All functions are defined in the code repository ( ' buffer).
%%All function-names to key-description mapping is set up in ( ! ) buffer.
%%All physical-keys to Key-descriptions are set up in the ( @ ) buffer.
%%
%%Macro ( # ) merges the keycodes and key functions tables to create the keystroke-map in buffer ( ^ ) 
%%and set up the remaining functions in the code repository buffer ( ' ).
z~m-0(f/-nofinalize/-b-k-0, osozok '#)?

%%Broken \ and | keys on my chromebook.
obz^m-0
i"^[bs          %s=commandstring ##\ -hereEndsThePercentCommand;"b
i"^[vb          %s=commandstring ##| -hereEndsThePercentCommand;"b
oz

