%%Reads sections of a large file using hashtables and an index file generated by grep -b <LargeFileName>.

%%
%%    Copyright (C) 2013-2018 Jon. Easterbrook
%%
%%    This file is part of jot (Joy Of Text - a text editor).
%%
%%    jot is free software: you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation, either version 3 of the License, or
%%    (at your option) any later version.
%%
%%    jot is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with jot.  If not, see <https://www.gnu.org/licenses/>.
%%
%%
%%

%g?
abc
:

%%Define the big_file functions now.
%g@
<<big_file_simpleQuery>>
%%Function to launch a query.
%%
%%Pick up buffer key and pathname
z$r-0(v/ /e)0r0(v-/ /e-)0 oq/.=destBuf/ozm0r0bon
( %%It may already exist in the text?
  %h.=jump '$&_InText; m- %w=refresh;
, %%No, read it now.
  oq/.=pathName/ 
  %i= -section='$ -append '~;
  %%Read success - add a label  and make it the target of a conventional hash-table entry for the section.
  ono-omb-i/------------------------------------------ /h$m
  %%Replace SeekObj with HtabObj pointing at the start of the newly-read section.
  %h.=addjump '$&_InText;
  %w=refresh;  %%get top of new section at top of view.
  m*? %w=refresh; %h.=jump '$&_InText; m- %w=refresh;
, %%Read failure.
  ok ( %h.=jump '$&_InText;  %w=refresh;m* %w=refresh; %h.=jump '$&_InText; , oq/.=destBuf/oz %X=Error: Section &'$& is not in the index.; ) )


<<big_file_grepQuery>>
%%Macro to grep for sections containing some feature (e.g a net name). and pull all matching sections.
%%
%%Check the datestamp matches that preserved in the index file.
( %h'=call big_file_verifyMainFile;, %x=Suggest you re-index the file and try again.; )
%%
%%Use grep to search.
oq/.=pathName/ %m=grepping file &'~& for &'$;
n.a#&z#i/%e@=grep -b "/i'$ r0i/" / oq/.=pathName/z#i'~ok '#
%m=grep complete.
%%Merge with sections using tabsort.
(oidoo/	%17ld/m)0 oq/.=destBuf/oz %q#=keys; (f1/ Seek /-oidoo/	%17ld/m, k)0 z@h# %b=tabsort 1;
%%Purge unwanted sections.
m0r0bn. (f-'$f-/ Seek 	/ma#m-n.)0 m-0a# m-0(r4(v/ /r)0e-0f1/ Seek 	/e0m)0
%%
%%Now pull the sections.
%s=verbose 0;
m-0 (pn.f1/,/a$& %h'=call big_file_simpleQuery;  z@m2m-)0
%s=verbose 3;
%%Report no. of sections:
onol1o- %m=Read &'~& sections.
%%Now return to big-file buffer.
oq/.=destBuf/oz

<<big_file_writeModifiedFile>>
%%Write the file back to disc.
%%
%%Check the datestamp matches that preserved in the index file.
%%
%%Arrange the sections we've read into ascending offset-order.
%%
%%Get the InText keys into buffer *, the section keys to buffer @.
z.n.a*& %q@=keys; 
( %%InText sections loop.
  %%Pick up the name of the next InText section.
  z@f/_InText, (JumpObj) buf /r-0r4(v/ /r)0n.f1/_InText,/a*+&m
  %%Find the seek and bytes parameters for this block.
  (z. %q$=keys -key='*;, z. %q$=keys -key='*&_InText;)  k2f1/ Seek /-oid  f1/, Bytes /-oidos z* r0oo/	 Seek %15ld/r0 oo/ Bytes %15ld/ b )0
%%  z. %q$=key '*; k2f1/ Seek /-oid  f1/, Bytes /-oidos z* r0oo/	 Seek %15ld/r0 oo/ Bytes %15ld/ b )0
z* %b=tabsort 1; (r\k,)
%%  
%%Bring back the index file - this has the true sizes of each section (whereas the sections hashtable has the sizes corrected for Bill's folly).
oq/.=index/ %i@='~;
%%
%%Now for ( # ) a list of InText sections in order of appearance  in text.
z*m-0n.m0r0a#&z#m-0 (f1/	/e0 z. %q$=keys -key='#&_InText; k2f1/, line no./-oid z#r0oo/	%15ld/ m)0 %b=tabsort 1; (r\k)0 m0r0b
%%z*m-0n.m0r0a#&z#m-0 (f1/	/e0 z. %q$=key '#&_InText; k2f1/, line no./-oid z#r0oo/	%15ld/ m)0 %b=tabsort 1; (r\k)0 m0r0b
%%
%%Now move the original big file to <name>_orig
oq/.=pathName/ %d$=%e=mv -f ;z$r0i'~r0i/ /i'~i/_orig;/ok '$
%%
%%OK to start copying up to the next section in <bucketsize> blocks, when we get to a section in the text substitute the section with text from buffer.
%%
%%
%%Initialize for copying.
%%Set initial seek-point to 0.
ol0 
%%Reset InText index.
oq/.=pathName/ z*m-0  
%%Open the original version of the file.
%i+= -hold -seek=0 -bytes=0 '~&_orig;
%%
%%Set up progress monitor.
n.a"&z" %w"=new -popup=-5 -height=2 -width=5;
ol0ov/.=progress/
%%
%%Initialize bucket buffer.
n.a+&
%%
%%Suppress normal I/O messages.
%s=verbose 0;
%%
( %%Block/section-copy loop.
  %%Identify next in-text section and it's start point.
  z*r-0n.f1/	 Seek/-oid oso-
  %%Copy blocks up to the start of InText section on completion the only item on the stack is the start offset of the next InText section.
  (oq/.=bucketsize/o> oq/.=pathName/o# oq/.=bucketsize/ %i+= -hold -block='~ '~&_orig; %o= -append '~; m-0k0e0 oq/.=bucketsize/o-
    %%Update progress monitor.
    z. %w=refresh; oq/.=progress/oq/.=bucketsize/o+o#ov/.=progress/ ol100o*oq/.=fileSize/o/ z"oo/%2d%%/ )0
  %%Write remaining bytes.
  ( ol0o=\ oq/.=pathName/os %i+= -hold -block='~ '~&_orig; oq/.=pathName/ z+ %o= -append '~; , ) z+m-0k0
  %%
  %%Abstract InText section to $ buffer then write.
  %%Pick up InText section key.
  z*r-0n.f1/	/a$& 
  %%
  %m=Writing InText section '$;
  %%Abstract to $ and write, we need to know what the next InText section name is - that's where the sorted InText table in the ( # ) buffer comes in.
  z. %h.=jump '$&_InText; ob z#m-0 ((f'$r-\ f1'$-v/	/)\m)0 (mn.f1/	/a$& ozn. %h.=jump '$&_InText;m-2, ozn.m0r0) a$& oq/.=pathName/ z$ %o= -append '~;  
  %%
  %%Set up for next block.
  z*r-0n.f1/	/a$& z@m-0(f'$r0v-'$\m)0 mf1/:/-oido# oq/.=pathName/ os %i+= -hold -seek='~ -bytes=0 '~&_orig;
  %%
  %%Update progress monitor.
  z. %w=refresh; oq/.=progress/oq/.=bucketsize/o+o#ov/.=progress/ ol100o*oq/.=fileSize/o/ z"oo/%2d%%/
  %%Index to next InText section, if no more then copy remainder of file N.B. The only item on the stack should be the current seek point.
  z*mr
  )0
%%Write out all remaining blocks to end of file.
( z. %w=refresh; oq/.=pathName/o# oq/.=bucketsize/ %i+= -hold -block='~ '~&_orig; %o= -append '~; k? 
  z. %w=refresh; oq/.=progress/oq/.=bucketsize/o+o#ov/.=progress/ ol100o*oq/.=fileSize/o/ z"oo/%2d%%/ )0
%%
%%Restore normal verbosity.
%s=verbose 3;
%%Restore windows.
%q~=window; f/screenHeight = /- oidol4o-z.osok
%h'=call WindowOne;
%%Return to sections of file.
oq/.=destBuf/oz

<<big_file_writeModifiedFile_dd>>
%%Write the file back to disc using dd.
%%This was written in the hope and expectation of a significant performance improvement for writing big files
%%It turns out that dd actually takes about twice the time of the jot-IO version.
%%
%%Check the datestamp matches that preserved in the index file.
%%
%%Arrange the sections we've read into ascending offset-order.
%%
%%Get the InText keys into buffer *, the section keys to buffer @.
z.n.a*& %q@=keys; 
( %%InText sections loop.
  %%Pick up the name of the next InText section.
  z@f/_InText, (JumpObj) buf /r-0r4(v/ /r)0n.f1/_InText,/a*+&m
  %%Find the seek and limit parameters for this block.
  z. %q$=keys -key='*; k2f1/ Seek /-oid  f1/, Bytes /-oidos z* r0oo/	 Seek %15ld/r0 oo/ Bytes %15ld/ b )0
%%  z. %q$=key '*; k2f1/ Seek /-oid  f1/, Bytes /-oidos z* r0oo/	 Seek %15ld/r0 oo/ Bytes %15ld/ b )0
z* %b=tabsort 1; (r\k,)
%%  
%%Bring back the index file this has the true sizes of each section (whereas the sections hashtable has the sizes corrected for Bill's folly).
oq/.=index/ %i@='~;
%%
%%Now for ( # ) a list of InText sections in order of appearance  in text.
z*m-0n.m0r0a#&z#m-0 (f1/	/e0 z. %q$=keys -key='#&_InText; k2f1/, line no./-oid z#r0oo/	%15ld/ m)0 %b=tabsort 1; (r\k)0 m0r0b
%%z*m-0n.m0r0a#&z#m-0 (f1/	/e0 z. %q$=key '#&_InText; k2f1/, line no./-oid z#r0oo/	%15ld/ m)0 %b=tabsort 1; (r\k)0 m0r0b
%%
%%Now move the original big file to <name>_orig
oq/.=pathName/ %d$=%e=mv -f ;z$r0i'~r0i/ /i'~i/_orig;/ok '$
%%
%%OK to start copying up to the next section in <bucketsize> blocks, when we get to a section in the text substitute the section with text from buffer.
%%
%%
%%Initialize for copying.
%%Set initial seek-point to 0.
ol0 
%%  %%Reset InText index.
%%  oq/.=pathName/ z*m-0  
z*m-0
%%
%%Set up progress monitor.
n.a"&z" %w"=new -popup -height=2 -width=-5;
ol0ov/.=progress/
%%
%%Suppress normal I/O messages.
%s=verbose 0;
%%
( %%Block/section-copy loop.
  %%Identify next in-text section and it's start point.
  z*r-0n.f1/	 Seek/-oidoso- ol0
  ( o=ok  %%First in-text section is at start of file - no need to bother dd with this.
  , %%Copy initial block with dd.
    n.a$&z$ oo/%%e=\dd iflag=count_bytes,skip_bytes skip=0 count=%d/ oq/.=pathName/o# r0oo/ if=%s_orig/r0oo/ of=%s;/ '$
    , %x=Error: Something went wrong while attempting to copy initial block.;  )
  %%
  %%Abstract InText section to $ buffer then write.
  %%Pick up InText section key.
  z*r-0n.f1/	/a$& 
  %%
  %m=Writing InText section &'$;
  %%Abstract to $ and write, we need to know what the next InText section name is - that's where the sorted InText table in the ( # ) buffer comes in.
  z. %h.=jump '$&_InText; ob z#m-0 ((f'$r-\ f1'$-v/	/)\m)0 (mn.f1/	/a$& ozn. %h.=jump '$&_InText; m-2, ozn.m0r0) a$& oq/.=pathName/ z$ %o= -append '~;  
  %%Set up for next block.
%%  z*r-0n.f1/	/a$& z@m-0(f'$r0v-'$\m)0 mf1/:/-oido# oq/.=pathName/ os %i+= -hold -seek='~ -bytes=0 '~&_orig;
  z*r-0n.f1/	/a$& z@m-0(f'$r0v-'$\m)0 mf1/:/-oid
  %%Update progress monitor.
  z. %w=refresh; oq/.=progress/oq/.=bucketsize/o+o#ov/.=progress/ ol100o*oq/.=fileSize/o/ z"oo/%2d%%/
  %%Index to next InText section, if no more then copy remainder of file N.B. The only item on the stack should be the current seek point.
  z*mr
  )0
%%Written initial sections and all InText with their intermediate sections - now write out all remaining sections to end of file.
z. %w=refresh; n.a$&z$ oo/%%e=\dd iflag=skip_bytes skip=%d/ oq/.=pathName/o#r0oo/ if=%s_orig/r0oo/ >> %s/ '$
%%
%%Restore normal verbosity.
%s=verbose 3;
%%Restore windows.
%q~=window; f/screenHeight = /- oidol4o-z.osok
%h'=call WindowOne;
%%Return to sections of file.
oq/.=destBuf/oz

<<big_file_init>>
%%Initialization macro.
%%
%%Pick up optional -size=<noOfHashTableEntries> arg.
obo#z$r0i/ /(r-0f/-size=/s/ /n.(f1/ /, r0)a~, ol100000) o#ol20o+
( %h.=create '~;, %x=Disaster: failed to create the hashtable.; ) osoz
%%
%%Declare various data objects:
%h.=data tableSize; ov/.=tableSize/
%h.=data destBuf;       %%Destination buffer - the current buffer when the script was started.
o#ov/.=destBuf/
%h.=data pathName;      %%From -file= qualifier, pathname of large file.
%h.=data index;         %%From -index= qualifier, pathname of index file.
%h.=data fileSize;      %%Total size of original file.
%h.=data grep_cmds;     %%From -grep= qualifier, grep commands used to create the index.
%h.=data trim;          %%From -trim=<jotCommands> qualifier, jot commands used to trim the index.
%h.=data bucketsize;    %%From -bucketsize=n qualifier, sets bucket size for bulk reads.
%h.=data progress;      %%Progress-monitor data.
%h.=data fileDatestamp; %%Datestamp of main file.
%h.=data all;           %%If TRUE then read all sections at the outset.
%%
%%Pick up mandatory -file=<pathName> arg and check the file exists.
obz$r-0i/ /r- (f/ -file=/s/ /n.((f1/ /(v/ /r)0v/-/\r)0 v/ /, v/-/(v-/ /r-)0, r0)(v-/ /r-)0 a~ osozov/.=pathName/, %X=Error: No -file=<pathname> arg - cannot continue.;)
%%Escape any whitespace in pathname then check it exists.
( oq/.=pathName/ z~r-0(f1/ /i/\/r)0 o#z. %q=file '~; ok, %m=Error: file &'~& not found.; )
%%
%%Set all data object if -all is given.
obz$(f/ -all /s/ /ol1, ol0) ov/.=all/ oz
%%
%%Pick up name of index file or default to <bigFileName>_index
obz$r-0(f/ -index=/s/ /n.(f1/ /, r0)a~osoz ov/.=index/, oz)
%%
%%Pick up optional -grep=<grepCommandString> arg.
obz$(r-0f/ -grep=/s/ /n.(f1/ /, r0)a~ osozov/.=grep_cmds/, oz)
%%
%%Pick up optional -trim=<jotCommandString> arg.
obz$(r-0f/ -trim=/s/ /n.(f1/ /, r0)a~ osozov/.=trim/, oz)
%%
%%Pick up the optional -cdlindex qualifier.
obz$(r-0f/ -cdlindex/s/ / 
  %d~="\.SUBCKT "; ov/.=grep_cmds/
  %d~=(f/:/-2n.f1/.SUBCKT /-(v/ /r)0a%(f1/ /e0,)m)0; ov/.=trim/, oz)
%%Pick up the optional -vlogindex qualifier.
obz$(r-0f/ -vlogindex/s/ / 
  %d~="^ *module "; ov/.=grep_cmds/
  %d~=(r-0f1/module /e7(v-/ /e-)0(v/ /e)0f1/(/e0(v-/ /e-)0m)0; ov/.=trim/, oz)     %%No trimming required.
%%
%%Pick up the bucketsize arg, default it to 1,000,000 Bytes.
obz$(r-0f/ -bucketsize=/s/ /n.oids/ /, ol1000000os)oz osozov/.=bucketsize/
%%
%%Check for unrecognized qualifier keys.
obz$r-0(v/ /e)0(r\, oz%x=Error: Unrecognized qualifier &'$; ) oz
%%
%%Set default index-file name.
ob(oq/.=index/ok, oq/.=pathName/ z~n.r0a$&z$okr0i/_index/n.r-0a~ ov/.=index/)oz
%%
%%Set the total size.
oboq/.=pathName/ %q@=file '~; f/ size = /-b oidosozov/.=fileSize/
%%
%%If data object /.=grep_cmds/ is defined then re-make the index file.
ob( oq/.=grep_cmds/ %% -grep=<cmds> was given - rebuild the index now.
  oq/.=index/os oq/.=pathName/os %d$=%e=grep -bn ; z$r0i'~ok i/ /i'~ok i/ > / i'~ i/;/ '$
  %%Add datestamp check.
  oq/.=index/ %i@='~; oq/.=pathName/ %q$=file '~; f/ Modify time = /re-0m-k-0mk0 z@h$b
  %%If -trim was given, trim the index now.
  ( oq/.=trim/ z@ '~ ok, ) %o; ok
, ) oz
%%
%%If the index file does not exist, exit now.
oboq/.=index/ o# (%q=file '~; ok, %x=Error: Index file "&'~&" does not exist.;)oz
%%
%%Read the index file
ob ol0 oq/.=index/ %i@='~;
%%If it's a windows generated index being red in lunix, then chop off the '\r' line terminations.
r0r-oic (ol13o= (r0e-m)0, ) m-0ok
(v/Modify time = /n.r0a~&, %d~=Index file did not specify a datestamp.;) mov/.=fileDatestamp/ 
%%
%%Read all sections if -all was given.
oboq/.=all/ ol1
( o=  %%Yes - read all the sections first.
  %%Read the complete file, copy to main buffer and set the pathname.
  okoq/.=pathName/ %i.= -append '~;
  %%Section loop - add a jump obj for each index-file entry.
  (z@oidf/:/-2n.r0a$& z.ono-om %h=addjump '$&_InText; z@m)0 z.
, %%No -all was not given - set up for section-by-section interactive reading.
  %%
  %%For files written in windowsland, although the byte offsets to the sections are correct, the calculated byte counts for each section include the carriage-return characters.
  %%This is only a problem when running big_file.jot also in windowsland, the OS helpfully deducts, not one, but two bytes from the oveall byte count.
  %%We also need to avoid blank lines which might look like a "CRLF" termination, so we take the first entry from the index file.
  %%
  %%The following line detects windows reading a windows-generated file.
  %%Read the last two bytes of the first file and look for '\r' before the '\n'.
  oq/.=pathName/ m=3f1/:/-oid ol2o- %i$= -seek='~ -bytes=2 '~; z@m-0(v/Modify time = /m,)
  z$m(r %%The line was "\r\n" terminated and we're reading it in linuxland.
    %%Allow for "\r\n" line terminations.
    %d$=Initial_gumph; z@f1/:/2ol0
    ( (%h.=setsect '$;, %d!=1; ( %h.=setsect '$&__&'!;\ z!r-0oido~oo/%d/z@ )0 ) okok r-f-1/:/-oido# rn.r0a$& r-0oidmoidoso- roidoso-oso-)0 ok ok
  , %%Only need to allow for \n terminations.
    %d$=Initial_gumph; z@
    (o#f1/:/-oidoso-  (%h.=setsect '$;, %d!=1; ( %h.=setsect '$&__&'!;\ z!r-0oido~oo/%d/z@ )0 ) o+ f1/:/-n.r0a$& m)0 ok )
  %%
  %%Add the last entry, this requires the total size of the file in order to calculate the section bytecount.
  oq/.=fileSize/oso- (%h.=setsect '$;, %d!=1; ( %h.=setsect '$&__&'!;\ z!r-0oido~oo/%d/z@ )0 ) okokok
  %%
  )
oz

<<big_file_verifyMainFile>>
%%Check the main-file datestamp against the index file.
ob z.
( oq/.=fileDatestamp/z~v/.=index file did not specify a datestamp./z.ok %m=Warning - this index file has no datestamp-check data.;
, %%File-check data exists - do the check.
  oq/.=pathName/ %q#=file '~; f/ Modify time = /r
  (v'~ok, os %m=The file datestamp does not match the date-check value logged in the index file:;  n.r0a$& oz %m=  Current &'$; %m= Original &'~; oz x3\) )
oz
:
obz^m0
i/^[bq        %d$=##" Big-file section name >  "; %h'=call big_file_simpleQuery; %h'=call WindowAlignTop;/b
i/^[bg        %d$=##" Big-file search string >  "; %h'=call big_file_grepQuery; %h'=call WindowAlignTop;/b
i/^[bw        %h'=call big_file_writeModifiedFile;/
oz
%h'=call AddNewFunctions;

%h'=call big_file_init;
  
