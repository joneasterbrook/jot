%%Reads sections of a large file using hashtables and an index file generated by grep -b <LargeFileName>.

%%
%%    Copyright (C) 2013-2018 Jon. Easterbrook
%%
%%    This file is part of jot (Joy Of Text - a text editor).
%%
%%    jot is free software: you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation, either version 3 of the License, or
%%    (at your option) any later version.
%%
%%    jot is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with jot.  If not, see <https://www.gnu.org/licenses/>.
%%
%%
%%
%%History

%g?
  Usage:
    First create an index file with grep -b
$ grep -b <suitableGrepFilter> LargeFilePathName > LargeFilePathName_index.txt
    Now start the editor with big_file.jot
$ jot /dev/null -in="%r=big_file -file=LargeFilePathName;"
  
  Command-line args:
    -file=<pathName> - Mandatory pathname to big file, index file must be <PathName>_index
    -size=<n> - Optional, defaults to 100,000 - aproximate size of hashtable
    -grep=<grepCommandString> - Optional, grep commands required to extract the index file.
        If -grep=... is specified, a new index file is created using grep.
    -trim=<jotCommandString> - Optional, jot commands required to trim the index file.
    -vlogindex - Defines grep and trim commands and uses these to generate an
        index for the verilog file specified by the -file=... modifier.
    -cdlindex - Defines grep and trim commands and uses these to generate an
        index for the cdl file specified by the -file=... modifier.
                
  In the jot session:
    - If either -grep or -cdlindex is specified, then the session begins by creating a new index file.
    - The session begins with a blank window, sections can be pulled into view using Macro 7 e.g:
> sectionName1{Esc 7}
> sectionName2{Esc 7}
  ...
    - To search, using grep, for some other string in the file use Macro 8 e.g the net MyNet in a cdl file:
> MyNet{Esc 8}

   
  Buffers used:
    . - Normally but not necessarily the destination for sections as they are read.
        Also holds the main hashtable.
    7 - macro 7, launches a query.
    8 - macro 8, launches a net-name grep and loads matching subcircuits.
    9 - macro 9,  write the file back to disc.
    $ - temporary, used for args, setup and queries.
    @ - temporary, used in macro 9 to store hash key index
    * - temporary, used by macro 9 to seek offsets of InText sections.
    # - temporary, used by macro 9 to store names of InText sections.
    + - temporary, used by macro 9 to store seek offsets for InText sections.
    " - temporary, used by macro 9 for progress monitor.
    
  Data objects:
     - destBuf       - Destination buffer - the current buffer when the script was started.
     - pathName      - From -file= qualifier, pathname of large file.
     - index         - From -index= qualifier, pathname of index file.
     - fileSize      - Total size of original file.
     - grep          - From -grep= qualifier, grep commands used to create the index.
     - trim          - From -trim= qualifier, jot commands used to trim the index.
     - progress      - Progress-monitor data.
     - fileDatestamp - The datestamp of the main file when the index was created (as read from the index file).
:

%%Define the big_file functions now.
%g@
<<big_file_simpleQuery>>
%%Function to launch a query.
%%
%%Pick up buffer key and pathname
z$r-0(v/ /e)0r0(v-/ /e-)0 z.oq/destBuf/ozm0on
( %%It may already exist in the text?
  %h.=jump '$_InText;
, %%No, read it now.
  oq/pathName/ 
  %i='~ -section='$ -append;
  %%Read success - add a label  and make it the target of a conventional hash-table entry for the section.
  ono-omr-0b-i/------------------------------------------ /h$r-0
  %%Replace SeekObj with HtabObj pointing at the start of the newly-read section.
  %h.=add '$_InText;
  %%get top of new section at top of view.
  m*?w %h.=jump '$_InText; w
, %%Read failure.
  ok ( %h.=jump '$_InText; wm*w %h.=jump '$_InText; , oq/destBuf/oz %X=Error: Section '$ is not in the index.; ) )


<<big_file_grepQuery>>
%%Macro to grep for sections containing some feature (e.g a net name). and pull all matching sections.
%%
%%Check the datestamp matches that preserved in the index file.
%%
%%Use grep to search.
z.oq/pathName/ %m=grepping file '~ for '$;
%%z.oq/grep/z~r-0n.r0a$& z.oq/pathName/ %m=grepping file '~ for '$;
n.a#z#(%q=windows; i/%e@=grep -b "/, i/%e@=\grep -b "/)i'$ r0i/" / z.oq/pathName/z#i'~ok '#
%m=grep complete.
%%Merge with sections using tabsort.
(oidoo/	%15ld/m)0 z.oq/destBuf/oz %q#=keys; k2 (f/ Seek /-oidoo/	%15ld/)0 z@h# %b=tabsort 1;
%%%%Boil this down to a list of sections in buffer ( # )
%%m0r0bn. (f-'$f-/ Seek 	/ma#m-n.)0 m-0a# m-0(r4(v/ /r)0e-0f1/ Seek 	/e0m)0
%%Purge unwanted sections.
m0r0bn. (f-'$f-/ Seek 	/ma#m-n.)0 m-0a# m-0(r4(v/ /r)0e-0f1/ Seek 	/e0m)0
%%Now pull the sections.
%h'=call big_file_verifyMainFile;
%s=verbose 0;
m-0 (pn.f1/,/a$& %h'=call big_file_simpleQuery;  z@m2m-)0
%s=verbose 3;
onol1o- %m=Read '~ sections.
%%Now return to big-file buffer.
z.oq/destBuf/oz
    

<<big_file_writeModifiedFile>>
%%Macro 9 - write the file back to disc.
%%
%%Check the datestamp matches that preserved in the index file.
%%
%%Arrange the sections we've read into ascending offset-order.
%%
%%Get the InText keys into buffer *, the section keys to buffer @.
z.n.a* %q@=keys; 
( %%InText sections loop.
  %%Pick up the name of the next InText section.
  z@f/Rec:------------------------------/r-0r4(v/ /r)0n.f1/_InText,/a*+&m
  %%Find the seek and limit parameters for this block.
  z. %q$=key '*; kf1/ Seek /-oid  f1/, Bytes /-oidos z* r0oo/	 Seek %15ld/r0 oo/ Bytes %15ld/ b )0
z* %b=tabsort 1; (r\k,)
%%  
%%Now for ( # ) a list of InText sections in order of appearance  in text.
z*m-0n.m0r0a#&z#m-0 (f1/	/e0 z. %q$=key '#_InText; kf1/, line no./-oid z#r0oo/	%15ld/ m)0 %b=tabsort 1; (r\k)0 m0r0b
%%
%%Now move the original big file to <name>_orig
z.oq/pathName/ %d$=%e=mv ;z$r0i'~r0i/ /i'~i/_orig;/ok '$
%%
%%OK to start copying up to the next section in 1000000 byte blocks, when we get to a section in the text substitute the section with text from buffer.
%%
%%
%%Initialize for copying.
%%Set initial seek-point to 0.
ol0 
%%Reset InText index.
z.oq/pathName/ z*m-0  
%%Open the original version of the file.
%i+='~_orig -hold -seek=0 -bytes=0;
%%
%%Set up progress monitor.
n.a"z"
%w 2 "
z.ol0ov/progress/
%%
%%Initialize bucket buffer.
n.a+
%%
%%Suppress normal I/O messages.
%s=verbose 0;
%%
( %%Block/section-copy loop.
  %%Identify next in-text section and it's start point.
  z*r-0n.f1/	 Seek/-oid oso-
  %%Copy blocks up to the start of InText section on completion the only item on the stack is the start offset of the next InText section.
  (ol1000000o> z.oq/pathName/o# %i+='~_orig -hold -block=1000000; %o='~ -append; m-0k0e0 ol1000000o-
    %%Update progress monitor.
    z.w oq/progress/ol1000000o+o#ov/progress/ ol100o*oq/fileSize/o/ z"oo/%2d%%/ )0
  %%Write remaining bytes.
  ( ol0o=\ z.oq/pathName/ %i+='~_orig -hold -block='~; z.oq/pathName/ z+ %o='~ -append; , ) z+m-0k0
  %%
  %%Abstract InText section to $ buffer then write.
  %%Pick up InText section key.
  z*r-0n.f1/	/a$& 
  %%
  %m=Writing InText section '$;
  %%Abstract to $ and write, we need to know what the next InText section name is - that's where the sorted InText table in the ( # ) buffer comes in.
  z. %h.=jump '$_InText; mob z#m-0 ((f'$r-\ f1'$-v/	/)\m)0 (mn.f1/	/a$& ozn. %h.=jump '$_InText;, ozn.m0) a$& oq/pathName/ z$ %o='~ -append;  
  %%
  %%Seek to the start of the next section.
  z*r-0n.f1/	/a$& z.%q$=key '$; kf1/ Seek /-oid f1/, Bytes /-oid o+o# z.oq/pathName/ %i+='~_orig -hold -seek='~ -bytes=0;
  %%
  %%Update progress monitor.
  z.w oq/progress/ol1000000o+o#ov/progress/ ol100o*oq/fileSize/o/ z"oo/%2d%%/
  %%Index to next InText section, if no more then copy remainder of file N.B. The only item on the stack should be the current seek point.
  z*mr
  )0
%%Write out all remaining blocks to end of file.
( z.w oq/pathName/o# %i+='~_orig -hold -block=1000000; %o='~ -append; k? 
  z.w oq/progress/ol1000000o+o#ov/progress/ ol100o*oq/fileSize/o/ z"oo/%2d%%/ )0
%%
%%Restore normal verbosity.
%s=verbose 3;
%%Restore windows.
%q~=window; f/screenHeight = /- oidol4o-z.osok
%w; %w '~; %w 0; w
%%Return to sections of file.
oq/destBuf/oz

<<big_file_init>>
%%Initialization macro.
%%
%%Pick up optional -size=<noOfHashTableEntries> arg.
obo#z$(r-0f/-size=/s/ /n.(f1/ /, r0)a~, ol100000) o#ol20o+
( %h.=create '~;, %x=Disaster: failed to create the hashtable.; ) osoz
%%
%%Declare various data objects:
%h.=data tableSize; ov/tableSize/
%h.=data destBuf;       %%Destination buffer - the current buffer when the script was started.
o#ov/destBuf/
%h.=data pathName;      %%From -file= qualifier, pathname of large file.
%h.=data index;         %%From -index= qualifier, pathname of index file.
%h.=data fileSize;      %%Total size of original file.
%h.=data grep;          %%From -grep= qualifier, grep commands used to create the index.
%h.=data trim;          %%From -trim= qualifier, jot commands used to trim the index.
%h.=data progress;      %%Progress-monitor data.
%h.=data fileDatestamp; %%Datestamp of main file.
%%
%%Pick up mandatory -file=<pathName> arg and check the file exists.
obz$r-0i/ /r- (f/ -file=/s/ /n.(f1/ /, r0)a~ osozov/pathName/, %X=Error: No -file=<pathname> arg - cannot continue.;)
( oq/pathName/ o# %q=file '~; ok, %m=Error: file '~ not found.; )
%%
%%Pick up name of index file or default to <bigFileName>_index
obz$r-0(f/ -index=/s/ /n.(f1/ /, r0)a~osoz ov/index/, oz)
%%
%%Pick up optional -grep=<grepCommandString> arg.
obz$(r-0f/ -grep=/s/ /n.(f1/ /, r0)a~ osozov/grep/, oz)
%%
%%Pick up optional -trim=<jotCommandString> arg.
obz$(r-0f/ -trim=/s/ /n.(f1/ /, r0)a~ osozov/trim/, oz)
%%
%%Pick up the optional -cdlindex qualifier.
obz$(r-0f/ -cdlindex/s/ / 
  %d~="\.SUBCKT "; z.ov/grep/
  %d~=(f/:/-n.f1/.SUBCKT /-(v/ /r)0a%(f1/ /e0,)m)0; z.ov/trim/, oz)
%%Pick up the optional -vlogindex qualifier.
obz$(r-0f/ -vlogindex/s/ / 
  %d~=" *module "; z.ov/grep/
  %d~=; z.ov/trim/, oz)     %%No trimming required.
%%
%%Check for unrecognized qualifier keys.
obz$r-0(v/ /e)0(r\, oz%x=Error: Unrecognized qualifier '$; ) oz
%%
%%Set default index-file name.
ob(oq/index/ok, oq/pathName/ z~n.r0a$&z$r0i/_index/n.r-0a~ osokosozov/index/)oz
%%
%%Set the total size.
oboq/pathName/ %q@=file '~; f/ size = /-b oidosozov/fileSize/
%%
%%If -grep is set then re-make the index file.
z.
ob( oq/grep/ %% -grep=<cmds> was given - rebuild the index now.
  oq/index/os oq/pathName/os %d$=%e=grep -b ; z$r0i'~ok i/ /i'~ok i/ > / i'~ok i/;/ '$
  %%Add datestamp check.
  z.oq/index/ %i@='~; 
  z.oq/pathName/ %q$=file '~; f/ Modify time = /re-0m-k-0mk0 z@h$b
  %%If -trim was given, trim the index now.
  ( z.oq/trim/ z@ '~ ok, ) %o
, )oz
%%
%%If the index file does not exist, exit now.
oboq/index/ o# (%q=file '~; ok, %x=Error: Index file "'~" does not exist.;)oz
%%
%%Read the index file
ob ol0 oq/index/ %i@='~;
(v/Modify time = /n.r0a~&, %d~=Index file did not specify a datestamp.;) z.ov/fileDatestamp/
%%
%%Clear ( $ )in preparation for index-build operation.
%d$=Initial_gumph;
%%
%%Build the hashtable.
z@m-0(v/Modify time = /m,)
(o#oidoso-  (%h.=setsect '$;, %d!=1; ( %h.=setsect '$__'!;\ z!r-0oido~oo/%d/z@ )0 ) o+ f1/:/-n.r0a$& m)0
%%
%%Add the last entry, this requires the total size of the file in order to calculate the section bytecount.
z.oq/fileSize/oso- (%h.=setsect '$;, %d!=1; ( %h.=setsect '$__'!;\ z!r-0oido~oo/%d/z@ )0 ) okokok
okokoz
%%
%%Check for error messages.
m-0 (m %x=Error: there were some errors while building the hashtable from the index file;, )
%%

<<big_file_verifyMainFile>>
%%Check the main-file datestamp against the index file.
ob z.
( oq/fileDatestamp/z~v/Index file did not specify a datestamp./z.ok %m=Warning - this index file has no datestamp-check data.;
, %%File-check data exists - do the check.
  z.oq/pathName/ %q#=file '~; f/ Modify time = /r
  (v'~ok, %m=The file datestamp does not match the check-data from the index file;  n.r0a$& oz %x=  Current:'$, Original: ('~).; ) )
oz
:
%h'=call AddNewFunctions;

%d7=%h\\'=call big_file_verifyMainFile\; %h\\'=call big_file_simpleQuery\;;
%d8=%h\\'=call big_file_verifyMainFile\; %h\\'=call big_file_grepQuery\;;
%d9=%h\\'=call big_file_verifyMainFile\; %h\\'=call big_file_writeModifiedFile\;;

%h'=call big_file_init;
