%%Defines the hot-keys, functions and function mappings for vim-like operation.
%%
  
%%    Copyright (C) 2017-2018 Jon. Easterbrook
%%
%%    This file is part of jot (Joy Of Text - a text editor).
%%
%%    jot is free software: you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation, either version 3 of the License, or
%%    (at your option) any later version.
%%
%%    jot is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with jot.  If not, see <https://www.gnu.org/licenses/>.
%%
%%
%%
  
%%The user may call this script either  as a -startup="fake_vim.jot <filePathName>[ <filePathName2>[ ...]] [<-option1>[ -<option2>[ ...]]
%%   or as a -init="%r=fake_vim.jot <filePathName>[ <filePathName2>[ ...]] [<-option1>[ -<option2>[ ...]]
%%

%w=clear; %w=new -height=20 -delim;
%%Setup.
%h.=create 100;
%%Options and Args first.
%h=data .=Options; z$r-0(f/ -/, r0)n.r0a~z~ r-0(f1/  /e)0r0(v-/ /e-,)i/ / z.ov/.=Options/
%h=data .=Args; z$r-0(v/ /e)0 (rr-0 (f1/ /b(v/ /e)0)0, ) m-0n.m0r0a~&z~m-0 z.ov/.=Args/ %h=create 100 .=Args;
%h=data .=Mode;  ol0ov/.=Mode/    
%%

%g?
%%Mode of operation ( .=Mode ).
  0:jot command mode, 
  1:Vim command mode, 
  2:Vim insert mode, 
  3:vim full-line visual (visual-select) mode.
  4:vim character-level visual (visual-select) mode.
  5:vim block-visual (visual-select) mode.
  
Recognized options:
  - -debug   -- Sets up with a larger console (a smaller main window) and a few other tweaks designed to faciitate debugging.
  - -test    -- For testing - the fake_vim keyboard scanner is not started.
:

%%
%%If startup.jot not already done (fake_vim was started with %st=fake_vim, not %r in an -init sequence), call the standard startup now.
(z'm-0m, %r=startup; )
%%Pick up the cursor keys for the key-map assignment later.
n.a!& z@m-0(f/Arrow}/(f-1/+/\na!+, m) )0 m-0(f/{Page/na!+)0 z. )
%%
%%Read files and create a hashtable for local marks, define the colour tags etc.
oq/.=Args/z~m-0 %h=data .=CurrentBuf; ol65o#ov/.=CurrentBuf/ 
%%File-reading loop.
(n.r0a$& z$o#r-0oo/%%i%c=/o~r0(v-/;/, i/;/) '$ %h=create 100; %b=tagtype -colour=0:7 VisualSel; %b=tagtype -colour=0:6 BraceMatch; osz~mos)0
z.okok
%%
%%ArgStatus keeps track of which file images have actually been visited.
%h.=data .=ArgsStatus; ol1ov/.=ArgsStatus/

%%Jumps is a floating hashtable used for global jumps.
%h=data .=Jumps; n.a~& %h~=create 100; ov/.=Jumps/
%%JumpNo counts no. of jumps already in Jumps object.
%h.=data .=JumpNo; ol0ov/.=JumpNo/
%%DeferredAction - command to be executed after a navigation command.
%h=data .=DeferredAction; ol0ov/.=DeferredAction/
%%Digits - Numeric arg to various navigation etc, commands.
%h=data .=Digits; ol-1ov/.=Digits/
%%
%%Various bits of state to do with find ( {/}, {?}, ... etc)
%%FindOrigLineNo - the line number before the latest find jump.
%h=data .=FindOrigLineNo; ol0ov/.=FindOrigLineNo/
%%FindOrigChrNo - the character (column) number before the latest find jump.
%h=data .=FindOrigChrNo; ol0ov/.=FindOrigChrNo/
%%FindNewLineNo - the line number after the latest find jump.
%h=data .=FindNewLineNo; ol0ov/.=FindNewLineNo/
%%FindNewChrNo - the character (column) number after the latest find jump.
%h=data .=FindNewChrNo; ol0ov/.=FindNewChrNo/
%%LatestFind - the latest character search using {f} and {F}.
%h=data .=LatestFind; %d~=;ov/.=LatestFind/
%%
%%And two bits of state for the find-character-on-line commands {f}, {F}, {t} and {T}
%h=data .=FindCmd; ol0ov/.=FindCmd/
%h=data .=FindChr; ol0ov/.=FindChr/
%%
%%Global Marks
%h=data .=GlobalMarks; %d~=Global-marks buffer; ov/.=GlobalMarks/ %h=create 100 .=GlobalMarks;
%%
%%OriginalLineText and OriginalLineNumber - used by {U} to restore the line to it's original state, set by jumps etc.
%h=data .=OriginalLineText; %d~=; ov/.=OriginalLineText/
%h=data .=OriginalLineNo; ol0 ov/.=OriginalLineNo/
%h=data .=OriginalChrNo; ol0 ov/.=OriginalChrNo/
%%
%%OriginalFocusBuffer, OriginalFocusLineNo and OriginalFocusChrNo - used by {Ctrl+T} to restore focus.
%h=data .=OriginalFocusBuffer; ol0ov/.=OriginalFocusBuffer/
%h=data .=OriginalFocusLineNo; ol0ov/.=OriginalFocusLineNo/
%h=data .=OriginalFocusChrNo; ol0ov/.=OriginalFocusChrNo/
%%
%%Regs - a hashtable for all the vim registers.
%h=data .=Regs; %d~=; ov/.=Regs/ %h=create 100 .=Regs;
%%Populate with blank vim registers.
%%  - Reg % seems to be the pathname of the current file,
%%  - Reg # seems to be the pathname of the previous file,
%%  - Reg / holds the latest search string
%%  - Reg : holds the last-used : command.
%%  - Reg - holds deleted text.
%%  - Reg " holds the last-yanked text.
%%  - Reg 0 to 9 and a to z hold yanked text - selected with {"} command
%d$=%#/?:-"; z$(i/.=Regs|/r2r-b)0m-0 (z.%h=data '$; %d~=; ov'$ z$m)0
%%Set the initial yank reg to 0 .
%h=data .=Regs|YankReg; olc0 ov/.=Regs|YankReg/ %h=data .=Regs|0; n.a~& ov/.=Regs|0/
%%
%%Last-modified line state:
%%  .=LastModifiedLineNo - line number of last modified line
%%
%%YankMode - defines the visual and yank mode:
%h=data .=YankMode; ol0ov/.=YankMode/
%%YankMode values:
%%  0 - Visual mode.
%%  4 - Non-visual Line-oriented yank.
%%  5 - Non-visual Character-oriented yank.
%%
%%VisTopOrBot - 0 if at top of visual field, 1 if at bottom.
%h=data .=VisTopOrBot; ol0ov/.=VisTopOrBot/
%%
%%VisualTop/BotLine/Chr - indicate the current extent of visual-mode area, VisMaxLen is the length of the longest line in the block-visual region.
%h=data .=VisTopLine; ol0ov/.=VisTopLine/  %h=data .=VisTopChr; ol0ov/.=VisTopChr/
%h=data .=VisBotLine; ol0ov/.=VisBotLine/  %h=data .=VisBotChr; ol0ov/.=VisBotChr/
%h.=data .=VisMaxLen; ol0ov/.=VisMaxLen/

%%The tags table.
%h=data .=Tags; n.a~&  ov/.=Tags/
%%

%g$
Command-line args:
$ jot -st="fake_vim [<pathName1>[ <pathName2> [...]]][ -noarrow]"
    - The editor fires up with one window and one active buffer/window on the first pathname file image.
$ jot -st="fake_vim ... -c<cmd1>[ +<cmd2>[ +<cmd3>[...]]]"
    <cmd1> etc. are vaild vim commands, these are executed at startup time.
  
This document defines the design endpoint for fake_vim, with thanks, From:
   http://users.ece.utexas.edu/~adnan/vimqrc.html
  
VIM QUICK REFERENCE CARD
  ** indicates unimplemented functions.
  
Basic movement
  - h l k j                character left, right; line up, downrespectively.
  - {Space} {backspace}    character left and right respectively.
  - b w                    word/token left, right
  - ge e                   end of word/token left, right
  - {  }                   beginning of previous, next paragraph
  - ( )                    beginning of previous, next sentence
  - gm                     middle of line
  - g^                     Go to first nonblank of current line.
  - g$                     Go to last character of line.
  - ^  $                   first, last character of line (^ not implemented)
  - nG ngg                 line n, default the last, first
  - n%                     percentage n of the file (n must be provided) - not implemented - this seems like a perfectly useless command.
  - n|                     column n of current line
  - %                      match of next brace, bracket, comment, #define
  - nH nL                  line n from start, bottom of window
  - M                      middle line of window
  
Insertion & replace -> insert mode
  - i a                    insert before, after cursor
  - I A                    insert at beginning, end of line
  - gI                     insert text in first column
  - o O                    open a new line below, above the current line
  - rc                     replace character under cursor with c
  - grc                    like r, but without affecting layout
  - R                      replace characters starting at the cursor
  - gR                     like R, but without affecting layout
  - cm                     change text of movement command m
  - cc or S                change current line
  - C                      change to the end of line
  - s                      change one character and insert
  - ~                      switch case and advance cursor
  - g~m                    switch case of movement command m
  - gum gUm                lowercase, uppercase text of movement m
  - <m >m                  shift left, right text of movement m
  - n<< n>>                shift n lines left, right
  
Deletion
  - x X                    delete character under, before cursor
  - dm                     delete text of movement command m
  - dd D                   delete current line, to the end of line
  - J gJ                   join current line with next, without space
  - :rd{Rtn}               delete range r lines
  - :rdx{Rtn}              delete range r lines into register x
  
Insert mode
  - ^Vc ^Vn                insert char c literally, decimal value n
  - ^A                     insert previously inserted text
  - ^@                     same as ^A and stop insert -> command mode
  - ^Rx ^R^Rx              insert content of register x, literally
  - ^N ^P                  text completion before, after cursor
  - ^W                     delete word before cursor
  - ^U                     delete all inserted character in current line
  - ^D ^T                  shift left, right one shift width
  - ^Kc1c2 or c1<-c2       enter digraph \c1,c2\
  - ^Oc                    execute c in temporary command mode
  - ^X^E ^X^Y              scroll up, down
  - <esc> or ^[            abandon edition -> command mode
  
Copying
  - "x                     use register x for next delete, yank, put
  - :reg{Rtn}              show the content of all registers
  - :reg x{Rtn}            show the content of registers x
  - ym                     yank the text of movement command m
  - yy or Y                yank current line into register
  - p P                    put register after, before cursor position
  - ]p [p                  like p, P with indent adjusted
  - gp gP                  like p, P leaving cursor after new text
  
Advanced insertion
  - g?m                    perform rot13 encoding on movement m
  - n^A n^X                +n, -n to number under cursor
  - gqm                    format lines of movement m to fixed width
  - :rce w{Rtn}            center lines in range r to width w
  - :rle i{Rtn}            left align lines in range r with indent i
  - :rri w{Rtn}            right align lines in range r to width w
  - !mc{Rtn}               filter lines of movement m through command c
  - n!!c{Rtn}              filter n lines through command c
  - :r!c{Rtn}              filter range r lines through command c
  
Visual mode
  - v V ^V                 start/stop highlighting characters, lines, block
  - o                      exchange cursor position with start of highlighting
  - gv                     start highlighting on previous visual area
  - aw as ap               select a word, a sentence, a paragraph
  - ab aB                  select a block ( ), a block { }
  
Undoing, repeating & registers
  - u U                    undo last command, restore last changed line
  - .  ^R                  repeat last changes, redo last undo
  - n.                     repeat last changes with count replaced by n
  - qc qC                  record, append typed characters in register c
  - q                      stop recording
  - @c                     execute the content of register c
  - @@                     repeat previous @ command
  - :@c{Rtn}               execute register c as an Ex command
  - :rg/p/c{Rtn}           execute Ex command c on range r where pattern p matches
  
Complex movement
  - - +                    line up, down on first non-blank character
  - B W                    space-separated word left, right
  - gE E                   end of space-separated word left, right
  - n_                     down n-1 line on first non-blank character
  - g0                     beginning of screen line
  - g^  g$                 first, last character of screen line
  - gk gj                  screen line up, down
  - fc Fc                  next, previous occurence of character c
  - tc Tc                  before next, previous occurence of c
  - ; ,                    repeat last fFtT, in opposite direction
  - [[ ]]                  start of section backward, forward
  - [] ][                  end of section backward, forward
  - [( ])                  unclosed (, ) backward, forward
  - [{  ]}                 unclosed {, } backward, forward
  - [m ]m                  start of backward, forward Java method
  - [# ]#                  unclosed #if, #else, #endif backward, forward
  - [* ]*                  start, end of /* */ backward, forward
  
Search & substitution
  - /s{Rtn}  ?s{Rtn}       search forward, backward for s
  - /s/o{Rtn}  ?s?o{Rtn}   search fwd, bwd for s with offset o
  - n or /{Rtn}            repeat forward last search
  - N or ?{Rtn}            repeat backward last search
  - # *                    search backward, forward for word under cursor
  - g# g*                  same, but also find partial matches
  - gd gD                  local, global definition of symbol under cursor
  - :rs/f/t/x{Rtn}         substitute f by t in range r x: g-all occurrences, c-confirm changes
  - :rs x{Rtn}             repeat substitution with new r & x
  
Special characters in search patterns
  - .   ^  $               any single character, start, end of line
  - \< \>                  start, end of word
  - [c1-c2]                a single character in range c1..c2
  - [^c1-c2]               a single character not in range
  - \i \k \I \K            an identifier, keyword; excl. digits
  - \f \p \F \P            a file name, printable char.; excl. digits
  - \s \S                  a white space, a non-white space
  - \e \t \r \b            <esc>, <tab>, {Rtn}, {Linefeed}
  - \= * \+                match 0..1, 0..<infinity>, 1..<infinity> of preceding atoms
  - \|                     separate two branches ( Equivalence  or)
  - \( \)                  group patterns into an atom
  - \& \n                  the whole matched pattern, nth () group
  - \u \l                  next character made upper, lowercase
  - \c \C                  ignore, match case on next pattern
  
Offsets in search commands
  - n or +n                n line downward in column 1
  - -n                     n line upward in column 1
  - e+n e-n                n characters right, left to end of match
  - s+n s-n                n characters right, left to start of match
  - ;sc                    execute search command sc next
  
Marks and motions
  - mc                     mark current position with mark c <<MemberOf>>[a..Z]
  - `c `C                  go to mark c in current, C in any file
  - `0..9                  go to last exit position
  - `` `"                  go to position before jump, at last edit
  - `[ `]                  go to start, end of previously operated text
  - :marks{Rtn}            print the active marks list
  - :jumps{Rtn}            print the jump list
  - n^O                    go to nth older position in jump list
  - n^I                    go to nth newer position in jump list
  
Key mapping & abbreviations
  - :map c e{Rtn}          map c -> e in normal & visual mode
  - :map!  c e{Rtn}        map c -> e in insert & cmd-line mode
  - :unmap c{Rtn} :unmap! c{Rtn} remove mapping c
  - :mk f{Rtn}             write current mappings, settings... to file f
  - :ab c e{Rtn}           add abbreviation for c -> e
  - :ab c{Rtn}             show abbreviations starting with c
  - :una c{Rtn}            remove abbreviation c
  
Tags
  Tags have a separate namespace for each buffer.
  - :set tags <pathName1>[,<pathName2>[,...]] (from http://vim.wikia.com/wiki/Browsing_programs_with_tags )
    Sets tag-file pathnames.
  -  ^T  go to the file/code you were editing before the last tag jump
  -  ^]  use word at cursorto lookup function in tags file, edit that file/code
  - :ta t{Rtn}             jump to tag t
  - :nta{Rtn}              jump to nth newer tag in list
  - :ts t{Rtn}             list matching tags and select one for jump
  - :tj t{Rtn}             jump to tag or select one if multiple matches
  - :tags{Rtn}             print tag list
  - :npo{Rtn}  :n^T{Rtn}   jump back from, to nth older tag
  - :tl{Rtn}               jump to last matching tag
  - ^W}  :pt t{Rtn}        preview tag under cursor, tag t
  - ^W]                    split window and show tag under cursor
  - ^Wz or :pc{Rtn}        close tag preview window
  
Scrolling & multi-windowing
  - ^E ^Y                  scroll line up, down
  - ^D ^U                  scroll half a page up, down
  - ^F ^B                  scroll page up, down
  - zt or z{Rtn}           set current line at top of window
  - zz or z.               set current line at center of window
  - zb or z-               set current line at bottom of window
  - zh zl                  scroll one character to the right, left
  - zH zL                  scroll half a screen to the right, left
  - ^Ws or :split{Rtn}     split window in two
  - ^Wn or :new{Rtn}       create new empty window
  - ^Wo or :on{Rtn}        make current window one on screen
  - ^Wj ^Wk                move to window below, above
  - ^Ww ^W^W               move to window below, above (wrap if already at top/bottom window)
  - :vsplit                Vertical split of window.
  
Ex commands ({Rtn})
  - :e f                   edit file f, unless changes have been made
  - :e!  f                 edit file f always (by default reload current)
  - :wn :wN                write file and edit next, previous one
  - :n :N                  edit next, previous file in list
  - :rw                    write range r to current file
  - :rw f                  write range r to file f
  - :rw>>f                 append range r to file f
  - :q :q!                 quit and confirm, quit and discard changes
  - :wq or :x or ZZ        write to current file and exit
  - :<up> :<down>            recall commands starting with current
  - :r f                   insert content of file f below cursor
  - :r!  c                 insert output of command c below cursor
  - :all                   open a window for each file in the argument list
  - :args                  display the argument list
  
Ex ranges
  - , ;                    separates two lines numbers, set to first line
  - n                      an absolute line number n
  - .   $                  the current line, the last line in file
  - % *                    entire file, visual area
  - 't                     position of mark t
  - /p/ ?p?                the next, previous line where p matches
  - +n -n                  +n, -n to the preceding line number
  
Folding
  - zfm                    create fold of movement m
  - :rfo                   create fold for range r
  - zd zE                  delete fold at cursor, all in window
  - zo zc zO zC            open, close one fold; recursively
  - [z ]z                  move to start, end of current open fold
  - zj zk                  move down, up to start, end of next fold
  
Miscellaneous
  - :sh{Rtn}  :!c{Rtn}     start shell, execute command c in shell
  - K                      lookup keyword under cursor with man
  - :make{Rtn}             start make, read errors and jump to first
  - :cn{Rtn} :cp{Rtn}      display the next, previous error
  - :cl{Rtn}  :cf{Rtn}     list all errors, read errors from file
  - ^L ^G                  redraw screen, show filename and position
  - g^G                    show cursor column, line, and character position
  - ga                     show ASCII value of character under cursor
  - gf                     open file which filename is under cursor
  - :redir>f{Rtn}          redirect output to file f
  - :mkview [f]            save view configuration [to file f]
  - :loadview [f]          load view configuration [from file f]
  - ^@ ^K ^_  \  Fn ^Fn    unmapped keys

Buffers used/defined in setup.
  @ - the key-codes to key-name table
  ! - key-name to function map.
  ' - The code repository, adds a few functions specific to vim emulation.
  $ - temporary.
  
Buffers used in operation:
  - $ Arg passing.
  - @ Arg passing VimEx_... interface only,
  - * Used to effect a tidy exit from the jot debugger.
  - " seems to be the last-deleted or yanked text
  - - Seems to be the last deleted text.
  - 0-9, a-z yank registers NB regs 0-9 are lost when changing files, a-z and A-Z are the same 
    but lower case references redefine the reg, upper-case appends.
  - . holds hashtable for data objects:
      - Jumps - a subbuffer with a jump point hashtable, set by {/}, {?}, <n>%, [<n>]G, [<n>]gg
      - JumpNo - an integer holding the current jump number, used to generate a key for Jumps.
      - DeferredAction - some commands are applied after  some  navigation  or
        find commands. The following actions:
           {y}, {c}, {d}, {!}, {<} and {>}
         are deferred until completion of the following navigation commands:
           {/}, {?}, {f}, {F}, {h}, {j}, {k}, {l} and all cursor keys.
      - Digits - Numeric modifier for g command etc.
      - LatestFind - The most recent find command (f, F, t or T)
      - OriginalLineText - The original text at the line that was changed last.
      - OriginalLineNumber - The line number where the most recent change occured.
  - :e  <pathName> - replaces current file image with that of specified file.
  - :args [<arg1>[ <arg2> [...]]] - displays pathname list or defines a new one.
  - :n and :N - switch to next, or previous, file in arg list.
  - :q - in addition to exiting the current file, also closes current window.
  - :buffers - not available with basic versions, displays buffers
  - :buffer n - loads specified buffer into current window - if the buffer needs writing the command fails (use :buffer! n).
  - {0} - is always taken as a digit, never as <<Vim_GotoChr>> for which, in any case, there's {|}
  - {(} and {)} behaviour in vim is a bit difficult to understand for some lines - see note in <<Vim_PrevSentance>>
  - { } - is not mapped - there's already at least two perfectly good ways of moving right.
  - {%} - leaves some informational messages about failures.
  - {^} - (go to begining of line) can't be implemented - conflicts with Escaped characters syntax.
  - {&} - I need to know more about the regular-expressions substitution syntax.
  - {@} - vim eval seems to call vimscript code.
  - {[}  --  move to previous "{...}" section
  - {]}  --  move to next "{...}" section
  - {&}  --  repeat last ex substitution (":s ...") not including modifiers
  - {"}  --  access numbered buffer; load or access lettered buffer
  - {Ctrl+M} --  (CR) move to first non-whitespace of next line
  - {Ctrl+\} --  leave visual mode (go into "ex" mode)
  - {Ctrl+]} --  use word at cursor to lookup function in tags file, edit that file/code
  - {Ctrl+^} --  switch file buffers
  - {g} a graphics-mode modifier for lots of commands.
    ge e                   end of word/token left, right
    0 gm                   beginning, middle of line
    nG ngg                 line n, default the last, first
    gI                     insert text in first column
    grc                    like r, but without affecting layout (i.e tabs)
    gR                     like R, but without affecting layout (i.e tabs)
    g~m                    switch case of movement command m
    g?m                    perform rot13 encoding on movement m
    gqm                    format lines of movement m to fixed width
    gv                     start highlighting on previous visual area
    g0                     beginning of screen line
    g^  g$                 first, last character of screen line
    gk gj                  screen line up, down
  - Commands which don't take a numeric parameter should reset the digits.
  - Insert mode is wrong - {i}, {a}, {I} and {A}
  - Visual mode (highlights selection in reverse video):
    - {o} - switches focus between the start and end of highlighted area.
    - {y} - yanks all of highlighted text without waiting for a navigation command.
  - tab-pages ???

Known behavioural differences, problems and deficiencies:
  - Registers - these seem to be buffers that have had bits ot text moved/copied into them, 
    - The current file image is in register ( % )
    - The next-arg file image is in register ( % )
    - the default register for deleted text is ( - )
    - the default register for yanked text is ( 0 ), this can be changed using {"}
    - {p} (put) will insert the current default register in the current file.
    - View registers with :reg
    - Reg % seems to be the pathname of the current file,
    - Reg # seems to be the pathname of the previous file,
    - Reg / holds the latest search string
    - Reg : holds the last-used : command.
    - Reg 0 to 9 and a to z hold yanked text - selected with {"} command
    - Reg - holds deleted text.
    - Each yank operation appends new text to the selected yank register.
  - :n! and :N!, in vim will restore a new version of the file, in fake_vim these preserve changes.
    Also, :n and :N will trigger a confirmation in real vim if the image has been changed, not in fake_vim.
  - {Ctrl+w} (prefix to various window-control actions in vim) closes the screen in chrome - 
    fake_vim should use {Esc w} instead.
  - Secondary files - {Ctrl+t}, {Ctrl+]}, {Ctrl+^}, behaviour of {Ctrl+t} doesn't seem to match that advertised in documentation.
    - use ctags to compile a tags file.
    - It seems that vim can support more than one active file at a time:
      vi -o t.t l99 x.lis  - Make a change then {Ctrl+w} to switch to the next window - note the [+] flag in the separator bar.
  - {/} and {?}
    - cannot do single-character patterns.
    - Should search to end, then search from start of buffer.
    - Should set jump points if endpoint is on a different line to start point.
  - <<Vim_Up>> and <<Vim_Down>> add a zero entry to the stack.
  
:
z?m0h$m-0

%%Now the new functions, these are appended to buffer ( ' ).
%g@=fake_vim_functions;
  
<<Vim_ExitEditor>>
%%  {% a}  Exit's the editor without writing.
%a;

<<Vim_Up>>
%%  {k}, {UpArrow}   --  move up one line
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, )ol0oso- (y-o~)0 (rr-,) ok %h'call Vim_PostNavigation;
  
<<Vim_Down>>
%%  {Return}, {DownArrow}, {j}, {Ctrl+J} --  move down one line
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, )ol0oso- (y o~)0 (rr-,) ok %h'call Vim_PostNavigation;
  
<<Vim_Left>>
%%  {h}, {LeftArrow}, {Ctrl+H} --  backspace
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, )ol0oso- or? y0 %h'call Vim_PostNavigation;
  
<<Vim_Right>>
%%  {l}, {RightArrow} --  move right one character
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) or? (rr-,) y0 %h'call Vim_PostNavigation;
  
<<Vim_PrevSentance>>
%%  {(} --   move to previous sentence
%%Actually moves to start of current or previous sentance.
%%
%%    Actual vim behaviour is a bit hard to fathom for lines like these,it's a similar story with {)} :
%%
%%1.25 sh.jot
%%  It initially goes to the start of the line , even though it contains two full stops.
%%  Next time it goes to the start of the blank line above - most odd.
%%
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso- 
( %%Sentance loop.
  ( %%2nd. sentance end loop - go back to the end of the sentance before the current sentance.
    ( %%Sentance-end search loop.
      ( %%Sentance-end logic block.
        oc (r\r-\ok)\ %%Not a blank line.
        r-0or(f-1/./-(r\, q-/ 	/) )   %%Found a valid fullstop.
        )\
      m-r0  %%Move back to the previous line.
      )0
    ((q-/ 	/r-)0r-2, m-r0))2
  %%Found the end of the previous but one sentance, now move forwards to the next sentance start.
    r2? ( ocr\r-\ (r\r-\m)0, r-0or((q/ 	/r)0r\m)0 r-)
  o~)0ok
  
<<Vim_NextSentence>>
%%  {)} --   move to next sentence - either 
%%  - A sentance can be terminated by either a full stop or by the next line being entierly blank (not even containing whitespace).
%%  - Lines containing only whitespace are deemed to be part of a sentance.
%%  - Fullstops followed by nonblank characters are not deemed to be the end of a sentance.
%%
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso- 
( %%Sentance loop.
  ( %%Sentance-end search loop.
    ( %%Sentance-end logic block.
      oc (r\r-\ok)\ %%Not a blank line.
      r-0or(f1/./-(r\, q-/ 	/) )   %%Found a valid fullstop.
      )\
    m  %%Move on to the next line.
    )0
  %%Found the end of the current sentance, now move on to the start of next.
    %%Sentance-start search loops.
    ( ocr\r-\ (r\r-\m)0, r-0or((q/ 	/r)0r\m)0 r-)
  o~)0ok
y0 %h'call Vim_PostNavigation;
  
<<Vim_GotoChr>>
%%  {|}  --  move to column zero
%%Move to that column no. specified by numeric parameter.
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) r-0 orr-

<<Vim_YankLine>>
%%  {Y}  --  yank entire current line, do not defer.
oq/.=Mode/
( (ol3o=\ ol4o=\ ol5o=\)\ok  %%In any visual mode, yanks all text in the highlighted area.
  %h'call Vim_YankNow;
  %h'call Vim_ClearVisualTags;
, %%Not in visual mode - the yank operation is deferred until the navigation command completes.
  %%Record current position.
  okonov/.=VisTopLine/ ocov/.=VisTopChr/
  %%Move down by the requested no. of lines.
  oq/.=Digits/ (ol-1o=okol1, ) ol1o-om ol0ov/.=Digits/
  %%Yank now.
  ol4ov/.=YankMode/ %h'=call Vim_YankNow; )

<<Vim_Yank>>
%%  {y}  --  yank command                                                      cursor motion command
oq/.=Mode/
( (ol3o=\ ol4o=\ ol5o=\)\ok  %%In any visual mode, yanks all text in the highlighted area.
  %h'call Vim_YankNow;
  %h'call Vim_ClearVisualTags;
, %%Not in block-visual mode - the yank operation is deferred until the navigation command completes.
  %%Yank start point is here.
  okonov/.=VisTopLine/ocov/.=VisTopChr/
  %%Yank mode and deferred action is set to yank characters.
  ol5ov/.=YankMode/ n. olcyov/.=DeferredAction/ )

<<Vim_YankNow>>
%%Performs the abstraction - called by Vim_Yank in visual mode or Vim_PostNavigation
%%Prepare the buffer relevant to the register entry.
oq/.=Regs|YankReg/ z$m-0k0oo".=Regs|%c" oq'$ z~m-0k0e0 oq/.=CurrentBuf/oz
oq/.=YankMode/
(ol0o=  %%YankMode not set, then assume we're in a visual mode.
  ok %q$=tags; z~m-0k0e0 z$
  ( %%Tag loop.
    %%Pick up the start and end point for this line.
    f/ VisualSel/ f-1/ to /-oidf-1/ chr /-oid f-1/At rec /-oid
    %%Abstract the text.
    oq/.=CurrentBuf/ozono-om orn.oco-o~or a~&+
    %%Tidy up.
    z~r0b z$m  )0
  %%Post-copy cleanup.
  oq/.=Mode/(ol4o=okz~m0j-, ok) oq/.=CurrentBuf/oz %h'=call Vim_ClearVisualTags;
, ol4o=ok %%Yank complete lines.
  mn. oq/.=VisTopLine/ono-om a~&+ 
, ol5o=ok %%Yank characters.
  n. oq/.=VisTopLine/ono-omoq/.=VisTopChr/or a~&+ ) 
%%
%%Announce size of yanked block
z~m0onol1o-m-0 %m='~& line(s) yanked.;
%%Tag the first line of the buffer with the visual-mode tag.
oq/.=YankMode/
( ol0o=ok  %%It's in a visual mode.
  oq/.=Mode/
  ( ol3o=ok z~m-0oxou %b=addtag -text=Visual full-line mode;
  , ol4o=ok z~m-0oxou %b=addtag -text=Visual character mode;
  , ol5o=ok z~m-0oxou %b=addtag -text=Visual block mode; )
, ol4o=ok z~m-0oxou %b=addtag -text=Line mode;
, ol5o=ok z~m-0oxou %b=addtag -text=Character mode;
, ) 
ol0ov/.=Mode/ oq/.=CurrentBuf/oz
%l;
%%Reset yank mode and restore yank register to 0.
ol0ov/.=YankMode/ olc0ov/.=Regs|YankReg/ ok
%%Return to original focus.
oq/.=VisTopLine/ono-om oq/.=VisTopChr/or

<<Vim_PutAfter>>
%%  {p}  --  put buffer after current character/line
oconoboq/.=Regs|YankReg/ z$m-0k0e0oo".=Regs|%c" oq'$ z~ m-0 %q$=tags -here; m+4 
( f1/"Visual full-line mode"/ %%Insert Complete lines after current line.
  osozm h~ ok
  %%Move to start of inserted text.
  ono-om ok (v/ /r)0
, f1/"Visual character mode"/ %%Insert characters lines after current chr.
  osozr h~ ok
  %%Move to start of inserted text.
  ono-om (v/ /r)0
, f1/"Visual block mode"/ %%Insert in block mode.
  %%First measure the longest line.
  z~m-0ol0 (r0oco<okocm, m)0 o~
  %%Add padding blanks.
  m-0(o#r0ocoso-(o~i/ /)0 okm)0 ok
  %%Copy the lines.
  m-0 oq/.=CurrentBuf/o#ozos (i-'~ocmol-1oso-(o~(r, i/ /))0 ok z~m2m- oso#ozos)0 z$okokoz
, f1/"Line mode"/ %%Insert Complete lines after current line.
  osozm h~ ok
  %%Move to start of inserted text.
  ono-o~om ok (v/ /r)0
, f1/"Character mode"/ %%Insert characters lines after current chr.
  osozr h~ ok
  %%Move to start of inserted text.
  ono-om o~or
, %%Something went wrong - maybe no tag in YankReg.
  okoz
  %%Return to starting position.
  ono-om (v/ /r)0 )

<<Vim_PutBefore>>
%%  {P}  --  put buffer before current character/line
oconoboq/.=Regs|YankReg/ z$m-0k0e0oo".=Regs|%c" oq'$ z~ m-0 %q$=tags -here; m+4 
( f1/"Visual full-line mode"/ %%Insert Complete lines before current line.
  osozr-0 h~ ok
  %%Move to start of inserted text.
  ono-om ok (v/ /r)0
, f1/"Visual character mode"/ %%Insert characters lines before current chr.
  osoz h~ ok
  %%Move to start of inserted text.
  ono-om or
, f1/"Visual block mode"/ %%Insert in block mode.
  %%First measure the longest line.
  z~m-0ol0 (r0oco<okocm, m)0 o~
  %%Add padding blanks.
  m-0(o#r0ocoso-(o~i/ /)0 okm)0 ok
  %%Copy the lines.
  m-0 oq/.=CurrentBuf/o#ozos (i-'~ocmol-1oso-(o~(r, i/ /))0 ok z~m2m- oso#ozos)0 z$okokoz
, f1/"Line mode"/ %%Insert Complete lines before current line.
  osozr-0 h~ ok
  %%Move to start of inserted text.
  ono-om ok (v/ /r)0
, f1/"Character mode"/ %%Insert characters lines before current chr.
  osoz h~ ok
  %%Move to start of inserted text.
  ono-om or
, %%Something went wrong - maybe no tag in YankReg.
  okoz
  %%Return to starting position.
  ono-om (v/ /r)0 )

<<Vim_MarkPos>>
%%  {m}<Chr>  --  mark current line and position                                    mark character tag (a-z)
%%Local marks a-z, global marks A-Z
obz$m-0k0ogoo/%lc/ 
( q-/a-z/oz  %h=addjump LocalMarks_&'$;, q-/A-Z/oz  %h=addjump .=GlobalMarks_&'$;
, oq/.=CurrentBuf/oz %m=Invalid mark tag.;)
  
<<Vim_MoveToMark>>
%%  {'}  --  move to marked line, first non-whitespace                         character tag (a-z)
obz$m-0k0ogoo/%lc/ 
( q-/A-Z'"<>^[]/oz %h=jump .=GlobalMarks_&'$;, q-/a-z/oz %h=jump LocalMarks_&'$;
, oq/.=CurrentBuf/oz %m=Invalid mark tag.;) 
r-0(v/ /r)0
  
<<Vim_MoveToMarkCol>>
%%  {`}  --  move to marked line, memorized column                             character tag (a-z)
obz$m-0k0ogoo/%lc/ 
( q-/A-Z'"<>^[]/oz %h=jump .=GlobalMarks_&'$; obz$(v/[/oz(r, m), v/]/oz(r-, ), oz)
, q-/a-z/oz %h=jump LocalMarks_&'$;
, oq/.=CurrentBuf/oz %m=Invalid mark tag.;)
  
<<Vim_ReplaceChr>>
%%  {r}  --  replace single character at cursor                                replacement character expected
%%Note `[ is a special case - it the tag points not to the first inserted character but one character before it.
ob z$m-0k0ogoo/%lc/ oq/.=Digits/ol-1ov/.=Digits/ol-1(o=okol1,)ol0oso- osoz (ei'$o~)0
  
<<Vim_ChangeView>>
%%  {z}  --  position current line                                             CR = top; "." = center; "-"=bottom
%%%%First, if a numeric parameter is given, go to that line.
%%oboq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, )
%%Now get the single-character arg, should be one of {LF} ( = 10 ), { . }, { - }, { h } pr { l }
obz$m-0k0og
%%Now parse the result and shift accordingly.
( ol10o= %%It's {CR} - align to top.
  okoz onofo-owr-0
, ol46o= %%It's {.}  (ASCII code 46) - align to centre.
  ok  %q$=window; f/currently buffer ( /f1/), /-oid osoz ol2o/ofo+onoso- ow r-0
, ol45o= %%It's {-} align to bottom of window.
  ok %q$=window; f/currently buffer ( /f1/), /-oid osoz ofo+onoso- ow r-0
, ol108o= %%It's  {l} - scroll left.
  oko#oz %q$=buffer; f/ leftoffset = /-oid oq/.=Digits/ol-1ov/.=Digits/(ol-1o=okol1, ) o+osoz %b=leftoffset '~; 
, ol104o= %%It's  {h} - scroll right.
  oko#oz %q$=buffer; f/ leftoffset = /-oid oq/.=Digits/ol-1ov/.=Digits/(ol-1o=okol1, ) o-osoz %b=leftoffset '~; 
, %%None of the above - continue without complaint.
  okoz
  )
  
<<Vim_Ex_split>>
%% {Esc w s} or {:split} - Called by Vim_Ex_Something, horizontal split, adds another window, new window looking at the current buffer.
%%First calculate the height of each new window.
ob %q@=window; f/ Console area /m-f1/  win:/-oidol2o+ f-/ screenHeight = /-oidol1o- oso/
%%Create each shorter version of original windows.
m-0f/  win:/m- %w=clear; (z@mf1/  win:/f1/ ( /-oicz$m-0k0 oo/%%W%c=/r0 o#oo/new -height=%d -delim;/ '$ z@)0
%%Create a new floating window.
z$m-0k0 oo/%%W=new -height=%d -delim;/ '$ oz
  
<<Vim_Ex_vsplit>>
%% {:vsplit} - Called by Vim_Ex_Something, vertical split, adds another, slimmer, window, new window looking at the current buffer.
%%First calculate the width of each new window.
ob %q@=window; f/ Console area /m-f1/  win:/-oidol2o+ f-/ screenWidth = /-oidoso/ f-/ screenHeight = /-oidol1o- 
%%Create each slim version of original windows.
m-0f/  win:/m- %w=clear; 
%%Only the first slice has the window height.
z@mf1/  win:/f1/ ( /-oicz$m-0k0 oo/%%W%c=/r0 oo/new -height=%d /r0 o#oo/-width=%d -delim;/ '$ z@
%%Following slices have no height.
(z@mf1/  win:/f1/ ( /-oicz$m-0k0 oo/%%W%c=/r0 o#oo/new -width=%d -delim;/ '$ z@)0
%%Create a new floating window.
z$m-0k0 oo/%%W=new -width=%d -delim;/ '$ oz
%%There seems to be a bug causing slices to not be cleared automatically.
%l;
  
<<Vim_Ex_on>>
%% ^[wo or :on{Rtn}        Called by Vim_Ex_Something, make current window one on screen
ob %q$=window; f/screenHeight = /- oid ol21o- %w=clear; %w=new -height='~ -delim; oz %s=console 10;  %w=refresh; 
%%ob %q$=window; f/screenHeight = /- oid ol1o- %w=clear; %w=new -height='~ -delim; oz %s=console 10;  %w=refresh; 
  
<<Vim_WindowDown>>
%% {Esc w j} --  move to window below.
%%
%%First find the current window.
ob %q@=window; z$m-0k0 oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 
%%Now move to the next window, exit if already at end window, and pick up the key.
m 
( f1/ ( / r-0f1/ win:/-oid %w=new -winno='~ -freeze=0; f1/ ( /-oico#
  %%If there are earlier windows showing that buffer then make sure they're frozen.
  (z@m- (f1'$\, r-0f1/ win:/-oid %w=new -winno='~ -freeze=1;) )0, )
%%Now switch to new buffer.
oz
  
<<Vim_WindowUp>>
%% {Esc w k} --  move to window above.
%%
%%First find the current window.
ob %q@=window; z$m-0k0 oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 
%%Now move to the previous, exit if already at first window, and pick up the key.
m- 
( f1/ ( /r-0f1/ win:/-oid %w=new -winno='~ -freeze=0; f1/ ( /-oic m-
  %%Freeze any earlier windows matching this buffer.
  (f1'$r-0f1/ win:/-oid %w=new -winno='~ -freeze=1; m-, m-)0, )
%%Now switch to new buffer.
oz
  
<<Vim_WindowUpWrap>>
%% {Esc w w} --  move to window above (wrap to bottom window if already at top)
%%
%%First find the current window.
ob %q@=window; z$m-0k0 oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 
%%Now move to the previous, or bottom window if already at first window and pick up the key.
m- (f1/ ( /r-0, f/  Console area /m-) f1/ win:/-oid %w=new -winno='~ -freeze=0; f1/ ( /-oic m-
%%Freeze any earlier windows matching this buffer.
(f1'$r-0f1/ win:/-oid %w=new -winno='~ -freeze=1; m-, m-)0
%%Now switch to new buffer.
oz
  
<<Vim_WindowDownWrap>>
%% {Esc w W} --  move to window below (wrap to top window if already at bottom)
%%
%%First find the current window.
ob %q@=window; z$m-0k0 oo/ ( %c ), /z@ (f'$ f1/, frozen/m)0 
%%Now move to the next window, or top window if already at last window and pick up the key.
m (f1/ ( /, f-/  screenWidth = /m) r-0f1/ win:/-oid %w=new -winno='~ -freeze=0; f1/ ( /-oico#
%%If there are earlier windows showing that buffer then make sure they're frozen.
(z@m- (f1'$\, r-0f1/ win:/-oid %w=new -winno='~ -freeze=1;) )0
%%Now switch to new buffer.
oz
  
<<Vim_Ex_e>>
%%  {:e} <pathName> Called by Vim_Ex_Something, open specified file in a new buffer.
ob z@k(v/ /e)0oo/%%i%c=/r0i/;/ '@
  
<<Vim_Ex_new>>
%% Called by Vim_Ex_Something, split horizontally creating an empty window.
%%Pick up buffer key.
ob z$m-0k0 oo/.%c/
%%Calculate size of each split-screen.
%q@=window; f/ screenHeight = /-oid ol1o-ol2o/o#
%%Set up window macrocommand.
z$r-0 i/%w=clear; %w/ r?oo/=new -height=%d -delim;/r-r  i/  %w/r?oo/=new -height=%d -delim;/ '$ oz

<<Vim_GotoLineNoLast>>
%%  {G}  --  goto line number prefixed, or goto end if none
on oq/.=Digits/ol-1ov/.=Digits/ (ol1o<ok m0m-, ono-om) 
%%If the line number has changed then add original to Jumps list.
on(o=ok, oq/.=JumpNo/o~o#ov/.=JumpNo/ obosz$m-0k0oo/Jump_%d/oz ono-onosom oq/.=Jumps/ %h~=newjump '$; okono-om)
  
<<Vim_GotoLineNoFirst>>
%%  {gg}  --  goto line number prefixed, or goto begining if none
on oq/.=Digits/ol-1ov/.=Digits/ (ol1o<ok m-0, ono-om) 
%%If the line number has changed then add original to Jumps list.
on(o=ok, oq/.=JumpNo/o~o#ov/.=JumpNo/ obosz$m-0k0oo/Jump_%d/oz ono-onosom oq/.=Jumps/ %h~=newjump '$; okono-om)
  
<<Vim_WordEndPrev>>
%%  {ge}  --  end of [previous] word
%%Behaviour seems to be - go back to the end of the previous string of alphanumerics or non-alphanumerics except whitespace.
%%Pick up any numeric arg.
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso-
%%Word shift the specified number of times.
( (r2r-, m-r0) (q-/A-Za-z0-9_/ (q-/ 	/r-)0, (q-/A-Za-z0-9_ 	/\r-)0 ) r- o~)0 ok
%%If there's a defered action then do it now.
y0 %h'call Vim_PostNavigation;
  
<<Vim_FileFromCursor>>
%%  {gf} --  open file which filename is under cursor
  
<<Vim_ShowAscii>>
%%   {ga} --  show ASCII value of character under cursor
  
<<Vim_ShowCursorPos>>
%%  {g Ctrl+g} --  show cursor column, line, and character position
  
<<Vim_SearchWordCurPrev>>
%% {#}  --  Search backwards for word under cursor.
  
<<Vim_SearchWordCurFor>>
%%  {*}  --  Search forwards for word under cursor. 
  
<<Vim_SearchPartCurPrev>>
%% {g#}  --  Search backwards for partial match to word under cursor.
  
<<Vim_SearchPartCurFor>>
%%  {g*}  --  Search forwards for partial match to word under cursor. 
  
<<Vim_DefineLocalSym>>
%%  {gd}  --  Local definition of symbol under cursor.
  
<<Vim_DefineGlpobalSym>>
%%  {gD}  --  Global definition of symbol under cursor.
  
<<Vim_VisualModeLine>>
%% {V}  --  Start visual mode, select to nearest line.
%%Reset if already in visual mode.
oq/.=Mode/
( ol3o=ok  %%YankMode already set - exit visual mode.
  ol0ov/.=Mode/
, %%Not in visual mode - set it up now.
  okol3ov/.=Mode/
  ono#ov/.=VisTopLine/ov/.=VisBotLine/  oco#ov/.=VisTopChr/ov/.=VisBotChr/ ol1ov/.=VisTopOrBot/ )
%h'call Vim_ClearVisualTags;
  
<<Vim_VisualModeChr>>
%% {v}  --  Start visual mode, select to nearest character.
%%Reset if already in visual mode.
oq/.=Mode/
( ol3o=ok  %%YankMode already set - exit visual mode.
  ol0ov/.=Mode/
, %%Not in visual mode - set it up now.
  okol4ov/.=Mode/
  ono#ov/.=VisTopLine/ov/.=VisBotLine/  oco#ov/.=VisTopChr/ov/.=VisBotChr/ ol1ov/.=VisTopOrBot/ )
%h'call Vim_ClearVisualTags;

<<Vim_VisualModeBlock>>
%% {Ctrl+V}  --  Start block-visual mode.
%%Reset if already in visual mode.
oq/.=Mode/ 
( ol3o=ok  %%It's already in visual block mode - do nothing except resetting the tags and pointers.
  ol0ov/.=Mode/
, %%Not in visual mode - set it up now.
  okol5ov/.=Mode/
  ono#ov/.=VisTopLine/ov/.=VisBotLine/  oco#ov/.=VisTopChr/ov/.=VisBotChr/ ol1ov/.=VisTopOrBot/ )
%h'call Vim_ClearVisualTags;

<<Vim_ClearVisualTags>>
%%Removes any instance of a VisualSel tag - only called by VimVisualModeChr, VimVisualModeLine or VimVisualModeBlock.
oconob %q$=tags; 
(f/VisualSel/f-1/ At rec /-oidosozono-om obz$f1/, chr /-oidosf/ to /-oido~osoz oso#oro-ou %b=remove_tag -colour VisualSel; obz$m)0
%%Return to original position.
ozono-omor  %w=refresh; 

<<Vim_Digit0>>
%%  {0} -- numeric precursor to other commands
%%NB. {0} is a special case among the digits - a leading {0} meaning go to colomn 0.
oq/.=Digits/ (ol-1o=okozr-0, ol10o*ov/.=Digits/)

<<Vim_Digit1>>
%%  {1} -- numeric precursor to other commands
oq/.=Digits/ (ol-1o=okol1, ol10o*ol1o+) ov/.=Digits/

<<Vim_Digit2>>
%%  {2} -- numeric precursor to other commands
oq/.=Digits/ (ol-1o=okol2, ol10o*ol2o+) ov/.=Digits/

<<Vim_Digit3>>
%%  {3} -- numeric precursor to other commands
oq/.=Digits/ (ol-1o=okol3, ol10o*ol3o+) ov/.=Digits/

<<Vim_Digit4>>
%%  {4} -- numeric precursor to other commands
oq/.=Digits/ (ol-1o=okol4, ol10o*ol4o+) ov/.=Digits/

<<Vim_Digit5>>
%%  {5} -- numeric precursor to other commands
oq/.=Digits/ (ol-1o=okol5, ol10o*ol5o+) ov/.=Digits/

<<Vim_Digit6>>
%%  {6} -- numeric precursor to other commands
oq/.=Digits/ (ol-1o=okol6, ol10o*ol6o+) ov/.=Digits/
  
<<Vim_Digit7>>
%%  {7} -- numeric precursor to other commands
oq/.=Digits/ (ol-1o=okol7, ol10o*ol7o+) ov/.=Digits/
  
<<Vim_Digit8>>
%%  {8} -- numeric precursor to other commands
oq/.=Digits/ (ol-1o=okol8, ol10o*ol8o+) ov/.=Digits/
  
<<Vim_Digit9>>
%%  {9} -- numeric precursor to other commands
oq/.=Digits/ (ol-1o=okol9, ol10o*ol9o+) ov/.=Digits/
  
<<Vim_HomeCursor>>
%%  {H}  --  home cursor - goto first line on screen
%%If n is given goto nth. line from top of screen or end of screen if n exceeds screen size..
%%
%%Pick up numeric arg, if not given, it defaults to 0
oq/.=Digits/ol-1ov/.=Digits/ (ol-1o=okol1, )(ol1o<okol1, )
%%Check size of window, if offset is too big defailt to (window size)-1
obos %q$=window; f/currently buffer ( /-oid (o<, okf-/ /-oid) osoz
%%Do it
ofono-o+ol1o-om y0 %h'call Vim_PostNavigation;
  
<<Vim_MidCursor>>
%%  {M}  --  goto middle line on screen
ob %q$=window; f/currently buffer ( /-oidosoz ol2o/ ofo+ono-ol1o+om r-0
  
<<Vim_EndCursor>>
%%  {L}  --  goto last line on screen
%%If n is given goto nth. line from bottom of screen or top of screen if n exceeds screen size.
%%
%%Pick up numeric arg, if not given, it defaults to 0
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol0, )
%%Check size of window, if offset is too big defailt to line 1
obos %q$=window; f/currently buffer ( /-oid (o<, okf-1/ /-oid)ol0oso-o~? osoz
%%Do it
obz$f-1/ /oidosoz ofo+onoso-o~?o- om y0 %h'call Vim_PostNavigation;
  
<<Vim_JoinNext>>
%%  {J}  --  join current line with next line
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso- (j(v/ /e)0(v-/ /, i/ /) o~)0
  
<<Vim_FindNextPrompt>>
%%  {/}  --  search forward                                                    search string, ESC or CR
%%  /<string> Optionally followed by "/o" where o is a numeric offset no. of lines below the found substring.
%%Pick up the search substring, split off the offset arg (nb - the search string might be digits).
z$m-0k0 %s=prompt /; %s=verbose 3; g  %s=verbose 1; %s=prompt > ; 
k-i"%%/"b (f1"/"r0(q-/-0-9/r-)0 (v-"/"r-2v/\/r0, rv"/"e, ) b(v/ /e)0, ) oq/.=CurrentBuf/oz 
%h'call Vim_FindNext;
  
<<Vim_FindPrevPrompt>>
%%  {?}  --  search backwards                                                    search string, ESC or CR
%%  ?<string> Optionally followed by "?o" where o is a numeric offset no. of lines below the found substring.
%%Pick up the search substring, split off the offset arg (nb - the search string might be digits).
z$m-0k0 %s=prompt ?; g %s=prompt > ; k-i"%%?"b (r0(q-/-0-9/r-)0 (v-"?"r-2v/\/r0, rv"?"e, ) b(v/ /e)0) oq/.=CurrentBuf/oz 
%h'call Vim_FindPrev;
  
<<Vim_FindNext>>
%%Performs a forwards search, the ( $ ) buffer contains the following:
%%line 1 - the original direction key - either ( / ) or ( ? ) prefixed by %%
%%line 2 - search string.
%%Line 3 - the offset parameter.
%%
%s=system 1;
%%Save original line and chr no.
onov/.=FindOrigLineNo/ ocov/.=FindOrigChrNo/
%%Save search args.
z$m-0n.m0r0a~&ov/.=LatestFind/ 
%%Update regs.
z$m-0mr-0n.r0a~& z.ov".=Regs|/" z$r-0
%%Prepare the %F command, extract post-find offset and execute.
(rr-r-0i/%f= -rex / (v"\/"e, r)0 r0(v-"/"e-,)i/;/ (mq/-0-9/i/m/,) %s=system 0;  oq/.=CurrentBuf/oz ol1ou ('$, ) )
%%Save the find command and the new coordinates.
onov/.=FindNewLineNo/ ocov/.=FindNewChrNo/ oq/.=CurrentBuf/oz 
%%If the found substring is in a different line then note the original line no.
onoq/.=FindOrigLineNo/
( o=ok, ok
  %%Go back to original position.
  oq/.=FindOrigLineNo/ono-om oq/.=FindOrigChrNo/or
  %%Set Jump_ no. and save original coordinates as a JumpHTabObj.
  oq/.=JumpNo/o~o#ov/.=JumpNo/ z@m-0k0ol100o% oo/.=Jumps|Jump_%d/  oq/.=CurrentBuf/oz  %h=addjump '@; )
%%Now set the note point and move back to the new position.
n. oq/.=FindNewLineNo/ono-om oq/.=FindNewChrNo/or
%s=system 0;
y0 %h'call Vim_PostNavigation;
  
<<Vim_FindPrev>>
%%Performs a backwards search, the ( $ ) buffer contains the following:
%%line 1 - the original direction key - either ( / ) or ( ? ) prefixed by %%
%%line 2 - search string.
%%Line 3 - the offset parameter.
%%
%s=system 1;
%%Save original line and chr no.
onov/.=FindOrigLineNo/ ocov/.=FindOrigChrNo/
%%Save search args.
z$m-0n.m0r0a~&ov/.=LatestFind/ 
%%Update regs.
z$m-0mr-0n.r0a~& z.ov".=Regs|?" z$r-0
%%Prepare the %F command, extract the post-find offset and execute.
(rr-r-0i/%f-= -rex / (v"\?"e, r)0 r0(v-"?"e-,)i/;/ m(q/-0-9/i/m/,) %s=system 0;  oq/.=CurrentBuf/oz ol1ou ('$, ) )
%%Save the find command and the new coordinates.
onov/.=FindNewLineNo/ ocov/.=FindNewChrNo/ oq/.=CurrentBuf/oz 
%%If the found substring is in a different line then note the original line no.
onoq/.=FindOrigLineNo/
( o=ok, ok
  %%Go back to original position.
  oq/.=FindOrigLineNo/ono-om oq/.=FindOrigChrNo/or
  %%Set Jump_ no. and save original coordinates as a JumpHTabObj.
  oq/.=JumpNo/o~o#ov/.=JumpNo/ z@m-0k0ol100o% oo/.=Jumps|Jump_%d/  oq/.=CurrentBuf/oz  %h=addjump '@; )
%%Now set the note point and move back to the new position.
n. oq/.=FindNewLineNo/ono-om oq/.=FindNewChrNo/or
%s=system 0;
y0 %h'call Vim_PostNavigation;
  
<<Vim_SearchAgain>>
%%  {n}  --  repeat last search
%%Pick up find string.
oq/.=LatestFind/z~ m-0n.m0r0a$&
%%Check direction and call VimFindNext or VimFindNext appropriately.
m-0(v"%%/"%%The original find was forwards - do a forwards search.
  oq/.=CurrentBuf/ozok %h'call Vim_FindNext;?
, %%The original find was backwards - do a backwards search.
  oq/.=CurrentBuf/ozok %h'call Vim_FindPrev;?
  )
    
<<Vim_SearchAgainRev>>
%%  {N}  --  repeat last search, but in opposite direction of original search
%%Pick up find string.
oq/.=LatestFind/z~ m-0n.m0r0a$&
%%Check direction and call VimFindNext or VimFindBack appropriately.
m-0(v"%%/" %%The original find was forwards - do a backwards search.
  oq/.=CurrentBuf/ozok (%h'call Vim_FindPrev;, )
, %%The original find was backwards - do a forwards search.
  oq/.=CurrentBuf/ozok %h'call Vim_FindNext;?
  )
  
<<Vim_FindNextChr>>
%%  {f}  --  find character after cursor in current line                       character to find
%%Set up command and find characters.
ol102 ov/.=FindCmd/ ogov/.=FindChr/
%%Do it.
%h'call Vim_Find;
  
<<Vim_RevFindRpt>>
%%  {,}  --  repeat last {f}, {F}, {t} or {T}, in opposite direction 
%m=VimRevFindRpt;
  
<<Vim_FindPrevChr>>
%%  {F}  --  backwards version of "f"                                          character to find
%%Set up command and find characters.
ol70 ov/.=FindCmd/ ogov/.=FindChr/
%%Do it.
%h'call Vim_Find;
  
<<Vim_FindChrBefore>>
%%  {t}  --  same as "f" but cursor moves to just before found character       character to find
%%Set up command and find characters.
ol116 ov/.=FindCmd/ ogov/.=FindChr/
%%Do it.
%h'call Vim_Find;
  
<<Vim_FindChrBeforePrev>>
%% {T}  --  backwards version of "t"                                          character to find
%%Set up command and find characters.
ol84 ov/.=FindCmd/ ogov/.=FindChr/
%%Do it.
%h'call Vim_Find;
  
<<Vim_Find>>
%%Generalist entry point for {f}, {F}, {t} and {T} and {;}  --  repeat last find command
%%Pick up repeat-count arg.
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso- 
%%Pick up command and search characters.
oq/.=FindChr/ oq/.=FindCmd/
( ol102o=ok %% ( f ) command.
  obz$m-0k0osoo/%c/oz (f1'$ o~)0ok 
, ol70o=ok  %% ( F )
  obz$m-0k0osoo/%c/oz (f-1'$ o~)0ok (v'$, r)
, ol116o=ok  %% ( t )
  obz$m-0k0osoo/%c/oz ((rv'$)?f1'$ o~)0ok (v'$r-?, )
, ol84o=ok  %% ( T )
  obz$m-0k0osoo/%c/oz ((rv'$, r-)f-1'$ o~)0ok (v'$r-?, )
  )
y0 %h'call Vim_PostNavigation;
  
<<Vim_a_Commands>>
%%Vim commands begining with a lower-case a
%%
%%In vim command mode, {a} enters insert mode after current character.
%%In visual mode {aw} selects a word.
%%In visual mode {as} selects a sentance.
%%In visual mode {ap} selects a paragraph.
%%In visual mode {ab} selects a ( ) block.
%%In visual mode {aB} selects a { } block.
%%
oq/.=VisTopLine/
( ol0o=  %%Not in vim visual mode - it's an insert-after-current-character operation then.
  %%  --  enter insertion mode after current character                      text, ESC
  ocr-0n.r0a~& ov/.=OriginalLineText/ onov/.=OriginalLineNo/ o#ov/.=OriginalChrNo/
  r-0ol1o+or (r-, m-r0) %h=addjump .=GlobalMarks_[; (r, m) %h=addjump .=GlobalMarks_]; %s=commandmode 2;  %m=-- INSERT -- (to exit type {Esc i}; 
, obz$m-0k0og
  ol119o=  %% {aw} -- select word in visual mode.
, ol115o=  %% {as} -- select sentance in visual mode.
, ol112o=  %% {ap} -- select paragraph in visual mode.
, ol98o=   %% {ab} -- select ( ) block in visual mode.
, ol66o=   %% {aB} -- select { } block in visual mode.
  )
  
<<Vim_InsertHere>>
%%  {i}  --  enter insertion mode before current character                     text, ESC
ocr-0n.r0a~& ov/.=OriginalLineText/ onov/.=OriginalLineNo/ o#ov/.=OriginalChrNo/
r-0or (r-, m-r0) %h=addjump .=GlobalMarks_[; (r, m) %h=addjump .=GlobalMarks_];  %s=verbose 0; %s=commandmode 12;  %m=-- INSERT -- (to exit type {Esc i});
%h'call Vim_InsertMode;
  
<<Vim_EnterOrSwap>>
%%  {o}  --  open line below and enter insertion mode                          text, ESC
oq/.=YankMode/ol0
( o=%%We're not in insert mode then inser below current line.
  ocr-0 %d~=; ov/.=OriginalLineText/ onol1o+ov/.=OriginalLineNo/ ov/.=OriginalChrNo/
  r0b- %h=addjump .=GlobalMarks_[; m %h=addjump .=GlobalMarks_]; %s=commandmode 2;  %m=-- INSERT -- (to exit type {Esc i};
, %%We're in visual mode - swap top and bottom.
  oq/.=VisTopOrBot/o!ol1o&o#ov/.=VisTopOrBot/ 
  %%Now go to Top or Bottom endpoint as appropriate.
  (ol0o=oq/.=VisTopChr/oq/.=VisTopLine/, oq/.=VisBotChr/oq/.=VisBotLine/) ono-omor )
  
<<Vim_InsertChr>>
%%  {s}  --  substitute single character with new text                         text, ESC
ocr-0n.r0a~& ov/.=OriginalLineText/ onov/.=OriginalLineNo/ o#ov/.=OriginalChrNo/
r-0or(r-, m-r0) %h=addjump .=GlobalMarks_[; (r, m)e? %h=addjump .=GlobalMarks_];%s=commandmode 2;  %m=-- INSERT -- (to exit type {Esc i};
  
<<Vim_InsertAtEoL>>
%%  {A}  --  enter insertion mode after end of line                            text, ESC
ocr-0n.r0a~& ov/.=OriginalLineText/ onov/.=OriginalLineNo/ o#ov/.=OriginalChrNo/
r-0orr0(r-, m-r0) %h=addjump .=GlobalMarks_[; (r, m) %h=addjump .=GlobalMarks_]; %s=commandmode 2;  %m=-- INSERT -- (to exit type {Esc i};
  
<<Vim_DelToEoLInsert>>
%%  {C}  --  change to end of line                                             text, ESC
ocr-0n.r0a~& ov/.=OriginalLineText/ onov/.=OriginalLineNo/ o#ov/.=OriginalChrNo/
r-0ore0(r-, m-r0) %h=addjump .=GlobalMarks_[; (r, m) %h=addjump .=GlobalMarks_]; %s=commandmode 2;  %m=-- INSERT -- (to exit type {Esc i};
  
<<Vim_NonBlankInsert>>
%%  {I}  --  enter insertion mode before first non-whitespace character        text, ESC
ocr-0n.r0a~& ov/.=OriginalLineText/ onov/.=OriginalLineNo/ o#ov/.=OriginalChrNo/
okr-0(v/ /r)0 (r-, m-r0) %h=addjump .=GlobalMarks_[; (r, m) %h=addjump .=GlobalMarks_]; %s=commandmode 2; %m=-- INSERT -- (to exit type {Esc i};
  
<<Vim_InsertAbove>>
%%  {O}  --  open line above and enter insertion mode                          text, ESC
ocr-0n.r0a~& ov/.=OriginalLineText/ onov/.=OriginalLineNo/ o#ov/.=OriginalChrNo/
r-0b-m-r0 %h=addjump .=GlobalMarks_[; m %h=addjump .=GlobalMarks_];%s=commandmode 2;  %m=-- INSERT -- (to exit type {Esc i};
  
<<Vim_InsertOvertype>>
%%  {R}  --  replace mode - replaces through end of current line, then inserts text, ESC
ocr-0n.r0a~& ov/.=OriginalLineText/ onov/.=OriginalLineNo/ o#ov/.=OriginalChrNo/
r-0or(r-, m-r0) %h=addjump .=GlobalMarks_[; (r, m) %h=addjump .=GlobalMarks_]; %s=commandmode 6;  %m=-- REPLACE --  (to exit type {Esc i};
  
<<Vim_DelAllLineInsert>>
%%  {S}  --  substitute entire line - deletes line, enters insertion mode      text, ESC
ocr-0n.r0a~& ov/.=OriginalLineText/ onov/.=OriginalLineNo/ o#ov/.=OriginalChrNo/
okr-0e0m-r0 %h=addjump .=GlobalMarks_[; m %h=addjump .=GlobalMarks_]; %s=commandmode +2;  %m=-- INSERT -- (to exit type {Esc i};
  
<<Vim_RestoreLine>>
%%  {U}  --  restores line to state when cursor was moved into it
%%Actual behaviour is to return to the line where the last change occured and restore that line.
oq/.=OriginalLineText/ oq/.=OriginalLineNo/ono-ome0i'~ok oq/.=OriginalChrNo/r-0or

<<Vim_CmdMode>>
%%  {Q}  --  leave visual mode (go into "ex" mode)
%%  All commands entered will be interpreted as though they had the ( : ) prefix.
%m=Sorry, the Q function is not available in jot emulation;
  
<<Vim_WordStartNext>>
%%  {w}  --  move foreward one word
%%Behaviour seems to be - go forwards to the start of the next string of alphanumerics or non-alphanumerics except whitespace.
%%Pick up any numeric arg.
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso-
%%Word shift the specified number of times.
( (rr-, m) (q/ 	/ (q//r)0, q/A-Za-z0-9_/ (q//r)0, (q//\r)0 ) ((rr-, m)q/ 	/r)0 o~)0 ok
%%If there's a defered action then do it now.
y0 %h'call Vim_PostNavigation;
  
<<Vim_WordStartPrev>>
%%  {b}  --  back word
%%Behaviour seems to be - go back to the start of the current or previous string of alphanumerics or non-alphanumerics except whitespace.
%%Pick up any numeric arg.
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso-
%%Word shift the specified number of times.
( (r-r, m-r0) (q-/ 	/r-)0 (q-/A-Za-z0-9_/ (q-//r-)0, (q-//\r-)0) o~)0 ok
%%If there's a defered action then do it now.
y0 %h'call Vim_PostNavigation;
  
<<Vim_WordEndNext>>
%%  {e}  --  end of word
%%Behaviour seems to be - go forwards to the end of the current or next string of alphanumerics or non-alphanumerics except whitespace.
%%Pick up any numeric arg.
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso-
%%Word shift the specified number of times.
( (r2r-, m) ((rr-, m)q/ 	/r)0 (q/A-Za-z0-9_/ (q//r)0, (q/A-Za-z0-9_ 	/\r)0 ) r- o~)0 ok
%%If there's a defered action then do it now.
y0 %h'call Vim_PostNavigation;
  
<<Vim_BlankStartPrev>>
%%  {B}  --  move back one Word
%%Behaviour seems to be - go back to the start of the current or previous string of whitespace characters.
%%Pick up any numeric arg.
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso-
%%Word shift the specified number of times.
( (r-r, m-r0) (q-/ 	/ ((r-r, m-r0) q-//r-)0, ) (q-//\r-)0 o~)0 ok
%%If there's a defered action then do it now.
y0 %h'call Vim_PostNavigation;
  
<<Vim_BlankEndNext>>
%%  {E}  --  move to end of Word
%%Behaviour seems to be - go forwards to the end of the current or next string of non-whitespace characters.
%%Pick up any numeric arg.
oq/.=Digits/ol-1ov/.=Digits/os (ol1o<okol1, ) ol0oso-
%%Word shift the specified number of times.
( (r2r-, m) (q/ 	/ ((rr-, m)q//r)0, ) ((rr-, m)q//\r)0 r- o~)0 ok
%%If there's a defered action then do it now.
y0 %h'call Vim_PostNavigation;
  
<<Vim_BlankStartNext>>
%%  {W}  --  foreward Word
%%Behaviour seems to be - go forwards to the start of the next string of whitespace characters or non-whitespace characters.
%%Pick up any numeric arg.
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso-
%%Word shift the specified number of times.
( (rr-, m) (q/ 	/\ (q//\(r, m))0, ) ((rr-, m)q//r)0 o~)0 ok
%%If there's a defered action then do it now.
y0 %h'call Vim_PostNavigation;
  
<<Vim_SqMatchRight>>
%%  {]}  --  move forwards to matching ( ] ) in "[...]" section                                  "]"
v/]/(r, m), ol0(v./*.f.*/.,v/"/r(f1/"/v-/*/r)0r,v/'/f1/'/,q/[/ol1o-r,q/]/\(r,m,okol-1?\),o~r)0ok
  
<<Vim_SqMatchLeft>>
%%  {[}  --  move back to matching ( [ ) in "[...]" section                                      "["
v/[/(r-,m-r0), ol0(v.*/.f-./*.,v/"/(r-f-1/"/v-/*/)0r-,v/'/f-1/'/r-,q/]/ol1o-r-,q/[/\(r-,m-r0),o~r-)0ok
  
<<Vim_ChangeCommand>>
%%  {c}  --  change command                                                    cursor motion command
%%These makes the move indicated by the cursor-move command, removes all the intervening text and enters insert mode.
%% {c}<movementCmd> command - marks extent and goes into insert mode, text is overwritten up to the mark
%%after the mark, new text is simply inserted.
%%In the event of a move up or down it removes all of both lines.
olccov/.=DeferredAction/ n.
  
<<Vim_Delete>>
%%  {d}  --  delete command.
%%In command mode, the delete action is deferred until the movement completes, 
%%In visual mode the text is deleted immediately.
%%
 oq/.=Mode/
( (ol3o=\ ol4o=\ ol5o=\)\ %%It's in one of the visual modes.
  %%In one of the three visual modes.
  ok %q$=tags; m0
  ( %%Tag loop.
    %%Pick up the start and end point for this line.
    f-/ VisualSel/ f-1/ to /-oidf-1/ chr /-oid f-1/At rec /-oid
    %%Delete the text.
    oq/.=CurrentBuf/ozono-om orn.oco-o~or a%+
    %%If in line or character-visual mode and we've just deleted text at the start of the line, then join with next line up.
    ( oq/.=Mode/ol5o=ok, ok ob z$f1/ chr  0 /ozj-, )
    %%Index to the next entry.
    z$m- )0
  %%Tidy up.
  ok ol0ov/.=Mode/ oq/.=CurrentBuf/oz %h'=call Vim_ClearVisualTags;
, %%In command mode set up the deferred command.
  olcdov/.=DeferredAction/ n. )
  
<<Vim_ReduceIndent>>
%%  {<}  --  unindent command - reduces indentation text from this point to the point defined by the following command.
olc<ov/.=DeferredAction/ ocr-0n.or
  
<<Vim_IncreaseIdent>>
%%  {>}  --  indent command - increases indentation text from this point to the point defined by the following command.
olc>ov/.=DeferredAction/ ocr-0n.or
  
<<Vim_DelToEoL>>
%%  {D}  --  delete to end of line
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso-  n.(r (r0o~m)0a%+, r-a%-ok)
  
<<Vim_DelNextChr>>
%%  {x}  --  delete single character
n.(r, r-)a%+
  
<<Vim_DelPrevChr>>
%%  {X}  --  delete backwards single character
n.(r-a%-, )
  
<<Vim_QickSave1>>
%%  {Z}  -- first half of quick save-and-exit                                 "Z"
%o
  
<<Vim_CliCmdToBuf>>
%%  {!}  --  shell command filter                                              cursor motion command, shell command
n. obz.olc!ov/.=DeferredAction/
  
<<Vim_Eval>>
%%  {@}  --  vi eval                                                           buffer name (a-z)
%%Use text in specified register as a command string.
%%Pick up register key.
ob z$m-0k0ogoo/%lc/j- oz
%%Copy register contents to $ buffer.
oq/Registers/  oq/.=CurrentBuf/oz m-0 (v'$\m)0 
(v'$r2n.r0a$&osozok, ok oq/.=CurrentBuf/oz %m=Error: That register is not defined.; )
%h'call Vim_ActionIndirect;
  
<<Vim_GotoEoL>>
%%  {$}  --  move to end of line
r0
  
<<Vim_SubsAgain>>
%%  {&}  --  repeat last ex substitution (":s ...") not including modifiers

%m=<<Vim_SubsAgain>>;
  
<<Vim_FirstNonBlank>>
%%  {^}  --  move to first non-whitespace character of line
%%The control character in the Q command is {Tab}
r-0(q/ 	/r)0
  
<<Vim_FirstNonBlankOdd>>
%%  {_}  --  similar to "^" but there's some wierd subtlety in the way it uses the numeric prefix
%%Actual behaviour seems to be to move down n lines then go to first nonblank - identical to {+} ???.
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso-  ol1oso- (mo~) ok (q/ 	/r)0
  
<<Vim_FirstNonBlankPrev>>
%% {-}  --  move to first non-whitespace of previous line
%%The control character in the Q command is {Tab}
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso- (m-o~) ok (q/ 	/r)0
  
<<Vim_FirstNonBlankNext>>
%% {+}  --  move to first non-whitespace of next line
%%Actual behaviour seems to be to move down n lines then go to first nonblank.
%%The control character in the Q command is {Tab}
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso- (mo~) ok (q/ 	/r)0
  
<<Vim_ParaStart>>
%%  "{"  --  move to previous blank-line separated section
%%The control character in the Q command is {Tab}
r-0 (rq/ 	/)0 (r, (m-(q//r)0r\)0) (m- (q//r)0 r)0 r-0
  
<<Vim_ParaEnd>>
%%  "}"  --  move to next blank-line separated section
%%The control character in the Q command is {Tab}
r-0 (rq/ 	/)0 (r, (m(q//r)0r\)0) (m (q//r)0 r)0 r-0
  
<<Vim_TagFromCurrWord>>
%%  {Ctrl+]} Picks up tag-name below cursor and jumps to definition.
oc (q-/a-zA-Z0-9_/r-)0 n.(q//r)0a@& oco-or
%h'call Vim_GotoTag;
  
<<Vim_GotoTag>>
%%Open the file and go to the specified line.
z. (%h=jump Tag_&'@; f/	/-n.f1//a$& %i*='$; z.rn.f1//a$& )
%%The key is either a regular expression or a line number.
(z$ q/0-9/ oid ono-om  %%That was a line number.
, %%Regular expressions need a little tarting up.
  v"/"e r-0(q/()*;/(v-/\/, i/\/)r, r)0 r0v-./\;".e-4 oq/.=CurrentBuf/oz  
  %%Go
  %f= -rex '$;)
%q$=window; f/currently buffer ( /-oid  oq/.=CurrentBuf/oz  %w=refresh; ol2o/ onofo-oso- ow
  
<<Vim_Ex_Something>>
%%  {:}  --  :<something>                                                        ex command
%%Now, some functions take an optional numeric arg (eg: :po ), if given save value in Digits object.
obz@m-0k0 %s=prompt :; g k- %s=prompt > ; (f1/ /b-, ) r-0(oidobosz.ov/.=Digits/oz, ) oz 
%%Update regs.
z@n.r0a~& z.ov".=Regs|:"
oq/.=CurrentBuf/oz  
(obz' %q=keys -key=Vim_Ex_&'@; oz %h'call Vim_Ex_&'@;, oz %m=Unknown extended command :&'@;)
%%(obz' %q=key Vim_Ex_&'@; oz %h'call Vim_Ex_&'@;, oz %m=Sorry - :&'@&nocando;)
%%
%%Full list of extended commands from the help documentation:
%%  :rd{Rtn}               delete range r lines
%%  :rdx{Rtn}              delete range r lines into register x
%%  :reg{Rtn}              show the content of all registers
%%  :reg x{Rtn}            show the content of registers x
%%  :rce w{Rtn}            center lines in range r to width w
%%  :rle i{Rtn}            left align lines in range r with indent i
%%  :rri w{Rtn}            right align lines in range r to width w
%%  :r!c{Rtn}              filter range r lines through command c
%%  :@c{Rtn}               execute register c as an Ex command
%%  :rg/p/c{Rtn}           execute Ex command c on range r where pattern p matches
%%  :rs/f/t/x{Rtn}         substitute f by t in range r x: g-all occurrences, c-confirm changes
%%  :rs x{Rtn}             repeat substitution with new r & x
%%  :marks{Rtn}            print the active marks list
%%  :jumps{Rtn}            print the jump list
%%  :map c e{Rtn}          map c -> e in normal & visual mode
%%  :map!  c e{Rtn}        map c -> e in insert & cmd-line mode
%%  :unmap c{Rtn}          remove mapping c
%%  :unmap! c{Rtn}         remove mapping c
%%  :mk f{Rtn}             write current mappings, settings... to file f
%%  :ab c e{Rtn}           add abbreviation for c -> e
%%  :ab c{Rtn}             show abbreviations starting with c
%%  :una c{Rtn}            remove abbreviation c
%%  :set tags <pathName1>[,<pathName2>[,...]] (from http://vim.wikia.com/wiki/Browsing_programs_with_tags )
%%  :ta t{Rtn}             jump to tag t
%%  :nta{Rtn}              jump to nth newer tag in list
%%  :ts t{Rtn}             list matching tags and select one for jump
%%  :tj t{Rtn}             jump to tag or select one if multiple matches
%%  :tags{Rtn}             print tag list
%%  :npo{Rtn}  :n^T{Rtn}   jump back from, to nth older tag
%%  :tl{Rtn}               jump to last matching tag
%%  ^W}  :pt t{Rtn}        preview tag under cursor, tag t
%%  ^Wz or :pc{Rtn}        close tag preview window
%%  ^Ws or :split{Rtn}     split window in two
%%  ^Wn or :new{Rtn}       create new empty window
%%  ^Wo or :on{Rtn}        make current window one on screen
%%  :vsplit                Vertical split of window.
%%  :e f                   edit file f, unless changes have been made
%%  :e!  f                 edit file f always (by default reload current)
%%  :wn :wN                write file and edit next, previous one
%%  :n :N                  edit next, previous file in list
%%  :rw                    write range r to current file
%%  :rw f                  write range r to file f
%%  :rw>>f                 append range r to file f
%%  :q :q!                 quit and confirm, quit and discard changes
%%  :wq or :x or ZZ        write to current file and exit
%%  :<up> :<down>          recall commands starting with current
%%  :r f                   insert content of file f below cursor
%%  :r!  c                 insert output of command c below cursor
%%  :all                   open a window for each file in the argument list
%%  :args                  display the argument list
%%  :rfo                   create fold for range r
%%  :sh{Rtn}  :!c{Rtn}     start shell, execute command c in shell
%%  :make{Rtn}             start make, read errors and jump to first
%%  :cn{Rtn} :cp{Rtn}      display the next, previous error
%%  :cl{Rtn}  :cf{Rtn}     list all errors, read errors from file
%%  :redir>f{Rtn}          redirect output to file f
%%  :mkview [f]            save view configuration [to file f]
%%  :loadview [f]          load view configuration [from file f]
%%  :e  <pathName> - replaces current file image with that of specified file.
%%  :args [<arg1>[ <arg2> [...]]] - displays pathname list or defines a new one.
%%  :n and :N - switch to next, or previous, file in arg list.
%%  :q - in addition to exiting the current file, also closes current window.
%%  :buffers - not available with basic versions, displays buffers
%%  :buffer n - loads specified buffer into current window - if the buffer needs writing the command fails (use :buffer! n).
%%  :reg -- display registers (fake_vim only - for debugging).
%%  :state -- display internal state (fake_vim only - for debugging).
  
<<Vim_Ex_ta>>
%%Called by Vim_Ex_Something, jumps to specified tag-index point.
%%  :ta <tagName>
%%Pick up tag name.
obz@k(v/ /e)0oz
%h'call Vim_GotoTag;
  
<<Vim_Ex_set>>
%%Called by Vim_Ex_Something, currently, only :set tags is supported in fake_vim
%%  :set tags <pathName1>[,<pathName2>[,...]] (from http://vim.wikia.com/wiki/Browsing_programs_with_tags )
obz@k(v/ /r)0 (v/.=tags/e4, %m=Sorry nocando only ":set tags" is allowed at present.;)
%%Pick up the list of files and read each of them into the tags buffer.
r-0(f/ /e)0 m-0(f/,/eb)0 m-0
oq/.=Tags/z@ ( %i.= -append '@; z@m)0 z.m-0(v/!/k, m)0
%%oq/.=Tags/z@ ( %i.='@ -append; z@m)0 z.m-0(v/!/k, m)0
%%Create the hashtable entry for every tags-file entry.
m-0 (n.f1/	/a$& %h=addjump Tag_&'$; m)0
%%Tidy up and return to original buffer.
okoz
  
<<Vim_Ex_reg>>
%%Called by Vim_Ex_Something, :reg -- display registers.
oboq/.=Regs/z~ %q$=keys; okk2
m-0(f/ YankReg,/k,)
m-0(e23i/"/f1/, (DataObj) Buffer "/s/ /r0e-m)0
m-0 i/--- Registers ---/b- p0
oz 
  
<<Vim_Ex_state>>
%%Called by Vim_Ex_Something,   :state  -- Displays all of fake_vim state
z-m-0k0
i/fake_vim state report:/b
oq/.=Regs/z~ %q$=keys; k2(i/    /e12m)0 z-i/  .=Regs|...:/bh$b
oq/.=Options/z~m-0z- i/  .=Options = /i'~b
oq/.=Args/z~m-0z- i/  .=Args = /i'~b
oq/.=CurrentBuf/ oo/  .=CurrentBuf =  %c/b
oq/.=ArgsStatus/ oo/  .=ArgsStatus = %d/b
oq/.=JumpNo/ oo/  .=JumpNo = %d/b
oq/.=Jumps/z~ %q$=keys; k2(i/    /m)0 z-i/  .=Jumps|...: /h$b
oq/.=DeferredAction/ oo/  .=DeferredAction = %d/b
oq/.=Digits/ oo/  .=Digits = %d/b
oq/.=FindOrigLineNo/ oo/  .=FindOrigLineNo = %d, /r0 oq/.=FindOrigChrNo/ oo/  .=FindOrigChrNo = %d/r0
  oq/.=FindNewLineNo/ oo/  .=FindNewLineNo = %d/r0   oq/.=FindNewChrNo/ oo/  .=FindNewChrNo = %d/b
oq/.=LatestFind/z~m-0z- i/  .=LatestFind = /i'~b
oq/.=FindCmd/ oo/  .=FindCmd = %c/  oq/.=FindChr/ oo/  .=FindChr = %d/b
%%  oq/.=GlobalMarks/z~ %q$=GlobalMarks; k2(i/    /m)0 z-i/  .=GlobalMarks_...:/h$b
oq/.=OriginalLineNo/ oo/  .=OriginalLineNo = %d/r0  oq/.=OriginalChrNo/ oo/  .=OriginalChrNo = %d/r0 oq/.=OriginalLineText/ oo/  .=OriginalLineText = '~/b
oq/.=OriginalFocusBuffer/ oo/  .=OriginalFocusBuffer = %c/r0  oq/.=OriginalFocusLineNo/ oo/  .=OriginalFocusLineNo = %d/r0  oq/.=OriginalFocusChrNo/ oo/  .=OriginalFocusChrNo = %d/b
oq/.=YankMode/ oo/  .YankMode = %d/r0 oq/.=VisTopOrBot/ oo/  .VisualTopOrBot = %d/r0 
oq/.=VisTopLine/ oo/  .=VisTopLine = %d/r0  oq/.=VisTopChr/ oo/  .=VisTopChr = %d/b
%%w %s=prompt Hit {return} to continue; g %s=prompt > ;
%q$=window; f/ screenHeight = /-oid %w-=new -height='~ -popup;
oq/.=CurrentBuf/oz
  
<<Vim_Ex_po>>
%% :[<n>]po  :n^T           jump back from, to nth older tag
%m=Jump back to place before tag jump.;
  
<<Vim_Ex_q>>
%%  :q - Abandon session.
%%Check that all args have been looked at.
oboq/.=Args/z~m0onz.osokosoz oq/.=ArgsStatus/os (o< ok %m=Error: More files to be looked at.;, ok %a; )
  
<<Vim_Ex_q!>>
%%  :q! - Abandon session without asking silly questions.
%b=unrestricted; %a;
  
<<Vim_Ex_n>>
%%  :n - switch to next file in args list
%%oq/.=CurrentBuf/o~ oz
%%Check Args.
oq/.=CurrentBuf/o# oq/.=Args/z~ osol64o-ono-om (mon, osozokok %m=Error: Already at last item in args list.; x\)
%%Make this file current.
ol64o+o# ov/.=CurrentBuf/ oz okok
  
<<Vim_Ex_N>>
%%  :N - switch to previous file in args list
%%Check Args.
oq/.=CurrentBuf/o# oq/.=Args/z~ osol64o-ono-om (m-on, osozokok %m=Error: Already at first item in args list.; x\)
%%Make this file current.
ol64o+o# ov/.=CurrentBuf/ oz okok
  
<<Vim_Ex_n!>>
%%  :n! - switch to next file in args list - identical to :n in fake_vim
%h'call Vim_Ex_n;
  
<<Vim_Ex_N!>>
%%  :N! - switch to previous file in args list - identical to :N in fake_vim
%h'call Vim_Ex_N;
  
<<Vim_Ex_args>>
%%  :args[ <arg>] - display [or redefine] the list of args (pathnames of files to edit).
obz@r-0
( m\  %%No args on command line, simply list the args ( 64 is ascii code for A) - 1.
  o#oq/.=CurrentBuf/ol64o-oq/.=Args/ z~m-0n.m0r0a$& z$okol1o-m-0om i/[/r0i/]/ m-0(ji/ /)0 p-1 z$ok oz
, %%Redefine current file pathname.
  (v/ /e)0(f1/  /e)0 o#z$m-0k0oo/%c	/ oq/.=Args/m-0f'$-e0i'@ z.o#ov/.=Args/
  %%Now read the file.
   oq/.=CurrentBuf/oz r-0n.r0a$&z$ok i/%i/f1/	/s/=/r0i/;/ '$ %b=writeifchanged; ok  )
  
<<Vim_Ex_marks>>
%%  :marks - list marks held in current buffer.
oq/.=CurrentBuf/oz %q$=keys; k2i/Global marks:/b oq/.=CurrentBuf/oz   %q@=keys; k2i/Local marks:/bm0h$ %w=refresh;  z. %q$=keys; k2(f1/GlobalMarks_/m,k)0 z@m0h$m-0 %w=refresh; 
%s=prompt Hit {Return} to continue.; g %s=prompt > ; %s=commandmode 2; %m=;  oq/.=CurrentBuf/oz 
  
<<Vim_Ex_ju>>
%h'call Vim_Ex_jumps;
  
<<Vim_Ex_jumps>>
%%  :jumps - list jumps in this and other buffers.
%%A jump point is the starting point of a {/}, {?} {G}, {gg}, <n>{%} commands.
%%These are only recorded if the end point is on a different line.
oq/.=Jumps/ %q@=keys; (f1/Jump_/-e-0f/(/n.f1/line no./-a$f/,/n.f/no./-a$f/, Rec:/s/  /m, k)0 
%b=sort; ol1m0 (f1/,/-e-0o#oo/%4d/o~m-)0 i"Jump  Line Col text"b- okok %w=refresh; 
%s=prompt Hit return to continue.; g %s=prompt > ; oz
  
<<Vim_AccessBuffer>>
%%  {"}  --  access numbered buffer; load or access lettered buffer            1-9, a-z, A-Z seem to append to lower-case regs?
%%Pick up and check the register ID.
%d$=.=Regs|; z$ogoo/%lc/r-0 (q/a-z/cr-, )(q/0-9A-Z/, %m=Error: Invalid Register ID; ) 
%%Set the YankReg value and, if necessary, create and initialize the data object.
oico#ov/.=Regs|YankReg/ z$m-0k0oo/.=Regs|%c/(oq'$, %h=data '$; n.a~& ov'$) 
oq/.=CurrentBuf/oz
  
<<Vim_ChangeCase>>
%%  {~}  --  reverse case of current character and move cursor forward
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso- (o~c)0
  
<<Vim_DoBackspace>>
%% {Backspace} Moves back n characters in vim command mode, erases previous character in vim insert mode.
ob %q$=system; f/ Command mode = / r0(v-/0/oz %h'call Vim_Left;, oze-? y0)
  
<<Vim_RptLastChange>>
%%  {.}  --  repeat last text-changing command
%m=Sorry: Nocando.;
  
<<Vim_PageUp>>
%%  {Ctrl+B}, {PageUp} --  back (up) one screen
%%The control character in the Q command is {Tab}
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso- (m-0 o~)0 (q/ 	/r)0 %h'call Vim_PostNavigation;
  
<<Vim_PageDown>>
%%  {Ctrl+F}, {PageDown} --  foreward (down) one screen
%%The control character in the Q command is {Tab}
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso- m*(q/ 	/r)0 %h'call Vim_PostNavigation;
  
<<Vim_PageHalfDown>>
%%  {Ctrl+D} --  down half screen
%%Moves such that line, at the end of the original view, goes to the centre of the new view, 
%%new current line is always set to line at the top of the new view. 
%%
%%First get the available size of the current window = (Total window height) - (delimiter line, if present) - (header line, if present).
ob %q$=window; f/ currently buffer ( /-oid (f1/with an end delimiter line/ol1o-, ) oso#ozos %q$=buffer; f/ Header = /-(v/(null)/, ol1o-) osozo#o# 
%%Now calculate how many lines to move down in order to bring the original bottom line to the centre of the window.
ol2o/o+ onofo-o-om %w=refresh;  
%%Finally, go back up to the top of the window.
ol0oso-om (q/ 	/r)0 %h'call Vim_PostNavigation;
  
<<Vim_PageHalfUp>>
%%  {Ctrl+U} --  up half screen
%%Moves such that line, at the top of the original view, goes to the centre of the new view, 
%%new current line is always set to line at the end of the new view. 
%%
%%First get the available size of the current window = (Total window height) - (delimiter line, if present) - (header line, if present).
ob %q$=window; f/ currently buffer ( /-oid (f1/with an end delimiter line/ol1o-, ) oso#ozos %q$=buffer; f/ Header = /-(v/(null)/, ol1o-) osozo#o# 
%%Now calculate how many lines to move up in order to bring the original top line to the centre of the window.
ol2o/ol0oso-onofo-o- om %w=refresh;  
%%Finally, go back up to the top of the window.
on (q/ 	/r)0 %h'call Vim_PostNavigation;
  
<<Vim_ScrollUpOrMove>>
%%  {Ctrl+E} --  scroll text up (cursor doesn't move unless it has to)
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso- (ofol1owof(o=m-,) oko~)0
%%oboq/.=Digits/(ol1o<okol1, ) osozol0oso- (ofol1owof(o=m-,) oko~)0
  
<<Vim_ScrollDownOrMove>>
%%  {Ctrl+Y} --  scroll text down (cursor doesn't move unless it has to)
oq/.=Digits/ol-1ov/.=Digits/ (ol1o<okol1, ) ol0oso- (ofol-1owof(o=m,) oko~)0
%%oboq/.=Digits/(ol1o<okol1, ) osozol0oso- (ofol-1owof(o=m,) oko~)0
  
<<Vim_ShowEditStatus>>
%%  {Ctrl+G} --  show status
ob %q$=buffer; 
f/  pathName = /-b-k-0i/"/r0i// 
(f/ SameSinceIO = FALSE/m-0r0i/ [Modified]/, ) 
o#oz%q~=file; (f/writable by this UID = yes/z$, z$i/[readonly]/) ok
m-0f/  LineNumber = /-oid m-0r0oo/ line %d/
o#ozoconm0(r, m-)onosono-om osor z$m-0r0o#oo/ of %d/
f/ LineNumber = /-oidol100o*oso/ m-0r0oo/ --%d%%--/
m-0f/ CurrentChr = /-oid m-0r0oo/ col %d/
oz %m='$;
  
<<Vim_Refresh>>
%%  {Ctrl+L} --  refresh screen
%l;
  
<<Vim_NextLineStart>>
%%  {Ctrl+M} and {Ctrl+J} --  {CR} and {LF} move to first non-whitespace of next line
m(v/ /r)0 y0
  
<<Vim_XON>>
%%  {Ctrl+Q} --  XON
%%Ignore these it's just {Ctrl+q} and {Ctrl+s}
%m=VimXON;
  
<<Vim_XOFF>>
%%  {Ctrl+S} --  XOFF
%%Ignore these it's just {Ctrl+q} and {Ctrl+s}
%m=VimXOFF;
  
<<Vim_DoNothing>>
%%  {Ctrl+R} --  does nothing (variants: redraw; multiple-redo)
%m=VimDoNothing;
  
<<Vim_RestoreFocus>>
%%  {Ctrl+T} --  go to the file/code you were editing before the last tag jump
%%and {Esc t}
%%and :<n>po
oq/.=OriginalFocusChrNo/ oq/.=OriginalFocusLineNo/ oq/.=OriginalFocusBuffer/ (ol0o=\oz ono-om or ok, okokokoz %m=No moves to mark have been performed.;)
  
<<Vim_ExitVisualMode>>
%%  {Ctrl+\} --  leave visual mode (go into "ex" mode)
 ol0ov/.=YankMode/
  
<<Vim_SwitchFileBufs>>
%%  {Ctrl+^} --  switch file buffers
%m=Vim_SwitchFileBufs;
  
<<Vim_DoPercent>>
%%  {%}  --  match nearest [],(),{} on line, to its match (same line or others)
%%Actual behaviour is:
%%    - If a numeric parameter is given then go to the linenumber corresponding to that percentage.
%%    - If not already on a { ( [ ] } or ) search forwards on the line for next ( { or [
%%    - Then search forwards or backwards, through any number of lines, for matching brace including the contents of strings and comments, 
%%    - in the event of a mismatch return to starting position.
%%
%%If percentage line no. specified go to that line.
oq/.=Digits/
( ol-1o=\ %%Percentage line no. was given.
  (m0ono*ol100o/ono-om)?
  %%
, %%Matching braces.
  ok
  %%Note starting point.
  oconol0
  %%If not on an open/close brace find next open brace in line.
  (q/{[()]}/, (rq//\)0 q//, r-0okokr-0or %m=Fail - no initial brace found on this line.; ) 
  %%If on an open brace then search forwards, through any number of lines for the matching close brace.
  %%The three types of brace each has a type code - () - type 1, {} - type 2 and [] - type 3.
  ( q/{[(/ %%Initially at an open brace, search forwards for matching close brace.
    %%Place brace type-code on the stack behind the brace counter.
    ( q/{[(/  %%It's an open brace, add the type code and decrement brace count.
      ol1o- (v/(/ol1, v/{/ol2, ol3)os (r, m)
    , q/}])/\(r, m)  %%Not a close brace, move to next character
    , %%It is a close-brace character, if the type codes don't match exit now.
      os ( (v/)/ol1, v/}/ol2, ol3) (o=, (oko~os)0 p okono-omor %m=Fail - bracket-type mismatch.; ) ) ok
      %%If it's the final end-brace exit now.
      o~ (r, m) )0
  , %%Initially at a close brace - search back for matching open brace.
    %%Place brace type-code on the stack behind the brace counter.
    ( q/}])/  %%It's a close brace, add the type code and decrement brace count.
      ol1o- (v/)/ol1, v/}/ol2, ol3)os (r-, m-r0)
    , q/{[(/\(r-, m-r0)  %%Not an open brace, move to next character
    , %%It's an open-brace character, if the type codes don't match exit now.
      os ( (v/(/ol1, v/{/ol2, ol3) (o=, (oko~os)0 p okono-omor %m=Fail - bracket-type mismatch.; ) ) ok
      %%If it's the final open-brace exit now.
      o~ (r-, m-r0) )0
  , %%Mismatch or no initial open-brace found on line - return to starting point.
    %%Unwind all type codes - the top of stack tells us how many.
    ok (o~osok)0
    %%Return to start point.
    ono-omor
    )
  %%Clear brace-depth counter (now zero) and starting point off the stack.
  ok okok )
  
<<Vim_DebugKey>>
%%  {Esc x} - Inserts/removes debug mode for specified key.
%%
obn.a$& z$
%s=prompt Specify a vim command: ; g %s=prompt > ;
%%Translate bytes to a series of hex values.
z$m-(oicoo/%02X /rr-)0
%%Look up keycode.
(%h^=jump '$; (mv/t/e, i/t/), %m=Error: Failed to find keycodes entry for &'$;)
p oz
  
<<Vim_QuitDebugger>>
%% {Esc q} - exit the jot debugger, returning to vim-style command mode.
%s=trace 0; %s=commandmode 0;
  
<<Vim_ActionIndirect>>
%%There's a vim command in the ( $ ) buffer - execute now.
%%
r-0(v/:/rb, v/^/eoicol64o-oo/%c/r0i/            /, (q/0-9/rb)0 ,)
%%Now y, c, < and > are the valid prefix commands for {/} and {?}
r-0((q/yc<>/r, )q"/?"ri/*/, )
%%Write then run the script.
%o=./fake_vim_indirect_command.jot;
oz ( %r= -asConsole ./fake_vim_indirect_command.jot;, %m=Error: Something failed in the processing of your indirect command.; )
%%oz ( %r=./fake_vim_indirect_command.jot -asConsole;, %m=Error: Something failed in the processing of your indirect command.; )
  
<<Vim_Undo>>
%%  {u}  --  undo
kh!

<<Vim_PostNavigation>>
%%This function is called after navigation commands e.g:  {/}, {?}, {f}, {F}, {h}, {j}, {k}, {l} and all cursor key functions, including PageUp/Down.
%%The DeferredAction state is set by {y}, {c}, {d}, {!}, {<} and {>} commands.
%%If the navigation command was prefixed by one of these, the deferred action applies to all text between the start and end points.
%%
%%Remove any BraceMatch colour tags.
%%Note current position.
oconob %q$=tags; 
%%Seek and destroy instances of BraceMatch colour tags.
( f/colour is BraceMatch/ o#f-1/ to /-oidos f-/ chr /-oidos f-1/ At Rec /-oidos ozono-omoroco-o~ou %b=remove_tag -colour BraceMatch; z$m)0
%%Return to original position.
ozono- omor
%%
%%If in visual mode, update the selection highlighting.
oq/.=Mode/
( (ol3o=\ol4o=\ol5o=\)\ok %%Yes we're in visual mode.
  %%Remove all tags.
  oconob %q$=tags; (f/VisualSel/f-1/ At rec /-oidosozono-om obz$f1/, chr /-oidosf/ to /-oido~osoz oso#oro-ou %b=remove_tag -colour VisualSel; obz$m)0 ozono-omor
  %%Calculate lines range.
  ( oq/.=VisTopLine/ on 
    ( o= %%Top and Bot lines are the same - compare Top and Bot Chrs and set Top or Bot parameters as appropriate.
      okoq/.=VisTopOrBot/ (ol0o=onov/.=VisTopLine/ ocov/.=VisTopChr/, onov/.=VisBotLine/ ocov/.=VisBotChr/ )
    , ono<\ %%We're above the previous top of the visual region.
      okoq/.=VisTopOrBot/( ol0o=onov/.=VisTopLine/ ocov/.=VisTopChr/, onov/.=VisBotLine/ ocov/.=VisBotChr/ )
    , %%We're below the previous top of visual region.
      okoq/.=VisTopOrBot/( ol1o=onov/.=VisBotLine/ ocov/.=VisBotChr/, onov/.=VisTopLine/ ocov/.=VisTopChr/ ) ) ok
      %%Tag all untagged lines in the range - first set up line counter and go to the top line.
    oq/.=VisTopLine/o# oq/.=VisBotLine/o~o- 
    %%If there's been a crossover swap and redo the calculation of the counter.
    ol0 o<\ oq/.=VisTopLine/oq/.=VisTopChr/oq/.=VisBotLine/oq/.=VisBotChr/ ov/.=VisTopChr/ov/.=VisTopLine/ ov/.=VisBotChr/ov/.=VisBotLine/ oq/.=VisTopOrBot/o!ol1o&ov/.=VisTopOrBot/
    )2?
  osono-om
  oq/.=VisTopChr/
  ( %%Tagging loop.
    %%If we're in Mode 5 (block-visual mode) set up the current chr to left-top chr no, for other visual modes set it to 0.
    oq/.=Mode/ol5 (o=okokoq/.=VisTopChr/, ok)
    %%If we're at the last line, or in block-visual mode ( {Ctrl+v} ) set the end chr to VisualBotChr, otherwise line length.
    osol-1 (((o=\os, os\) (oq/.=Mode/ol5o=\ok, ok\))\ oq/.=VisBotChr/, ox)
    %%In Mode 3 (visual full-line mode) set the tag start to chr 0, tag end to last chr.
    oq/.=Mode/ol3 (o=okokokol0r0ocr-0, ok)
    %%Set up substring and add tag ... then set up the current chr for the next line.
    osoroco-ou %b=addtag VisualSel; mo~ ol0)0 ok
  %%Finally, return cursor to correct end point.
  oq/.=VisTopOrBot/ol1 (o=okoq/.=VisBotChr/ oq/.=VisBotLine/, okoq/.=VisTopChr/ oq/.=VisTopLine/) ono-omor
, %%We're not in any visual mode.
  ok )
%%
%%Get the deferred command.
oq/.=DeferredAction/ ol0ov/.=DeferredAction/
( ol0  o=   %%No deferred action.
, olcy o=   %%It's a {y} command - abstract to current yank register. 
  %h'call Vim_YankNow;                         
, olcY o=   %%It's a {Y} command - abstract to current yank register.
  %h'call Vim_YankNow;
, olcc o=   %%It's a {c} command - delete the text then go to insert mode.
  a%+ %h'call Vim_InsertMode;
, olcd o=   %%It's a {d} command - delete the text.
  a%+
, ol33o=    %%It's a {!} command - copy text and send it to the CLI????
  a$ z$i/%e=/ oq/.=CurrentBuf/oz  '$
, olc> o=   %%It's a {>} command - indent all the selected lines???
  a$z$m-0(i/        /m)0 on oq/.=CurrentBuf/oz h$ ol1oso-om
, olc< o=   %%It's a {<} command - un-indent all the selected lines???
  a$z$m-0((v/ /e)8?m)0 on oq/.=CurrentBuf/oz h$ ol1oso-om
 ) ok
%%
%%If we've ended up on some sort of brace character, highlight the matching brace.
(q/({[<>]})/ %%We're on a brace character - find it's matching open/close brace.
  %%Save current position.
  ocon
%%    v/(/ %h'=call ParenMatchRight; (v/)/ %b=addtag BraceMatch; , ) ono-omor
%%  , v/)/ %h'=call ParenMatchLeft;  (v/(/ %b=addtag BraceMatch; , ) ono-omor
%%  , v/{/ %h'=call CurlyMatchRight; (v/}/ %b=addtag BraceMatch; , ) ono-omor
%%  , v/}/ %h'=call CurlyMatchLeft;  (v/{/ %b=addtag BraceMatch; , ) ono-omor
%%  , v/[/ %h'=call SquareMatchRight;(v/]/ %b=addtag BraceMatch; , ) ono-omor
%%  , v/]/ %h'=call SquareMatchLeft; (v/[/ %b=addtag BraceMatch; , ) ono-omor
%%  , v/</ %h'=call AngleMatchRight; (v/>/ %b=addtag BraceMatch; , ) ono-omor
%%  , v/>/ %h'=call AngleMatchLeft;  (v/</ %b=addtag BraceMatch; , ) ono-omor
  v/(/ %h'=call ParenMatchRight; (v/)/ %b=addtag BraceMatch; , ) ono-omor
, v/)/ %h'=call ParenMatchLeft;  (v/(/ %b=addtag BraceMatch; , ) ono-omor
, v/{/ %h'=call CurlyMatchRight; (v/}/ %b=addtag BraceMatch; , ) ono-omor
, v/}/ %h'=call CurlyMatchLeft;  (v/{/ %b=addtag BraceMatch; , ) ono-omor
, v/[/ %h'=call Vim_SqMatchRight;(v/]/ %b=addtag BraceMatch; , ) ono-omor
, v/]/ %h'=call SquareMatchLeft; (v/[/ %b=addtag BraceMatch; , ) ono-omor
, v/</ %h'=call AngleMatchRight; (v/>/ %b=addtag BraceMatch; , ) ono-omor
, v/>/ %h'=call AngleMatchLeft;  (v/</ %b=addtag BraceMatch; , ) ono-omor
, )

<<Vim_InsertMode>>
%%This function emulates the vim insert mode, if character is a control character, it is passed on to Vim_InsertEscapeCmd to process.
%%
%%Read next character - {Ctrl+c} exits insert mode, if it's an {Esc} then pass it on to Vim_InsertEscapeCmd.
ol2ov/.=Mode/
( %%Character loop.
   %w=refresh;  og 
  ( %%Character block.
    ol3o=     %% {Ctrl+c} - exit now.
    okx2
  , ol10o=    %% {Return} break the line here.
    okby0
  , olx7Fo=   %% {Backspace} - erase character to left or join line with previous.
    ok(e-, j-) y0
  , ol27o=    %% {Esc} fake_vim cannot detect individual escapes - assume it's an escape sequence.
    %h'call Vim_InsertEscapeCmd;?
  , oo/%lc/rr-y0) )0
%s=commandmode 0;
%s=verbose 1;
%m=Returned to vim command mode.;
%m=;
ol1ov/.=Mode/
  
<<Vim_InsertEscapeCmd>>
%%This function preocesses and dispatches a single escape sequence in fake_vim insert mode.
%%
%%Initialize ( $ ) buffer with the trigger character (always {Esc}.
obz$m-0k0osoo/%02X /oz 
( %%Part-command block - some vim command sequences are more than one character, this loop checks and assembles the complete command string.
  %w=refresh; og obosz$r0oo/%02X /oz
  %h^=testkey -type '$;
  ol4o=ok  %%Yes it's a call object.
  %h^=call -oneline '$;?
, ol1o=ok  %%It's a data object, that's OK - read another byte.
  x-
, %%Invalid command - report it.
  z$m-0n.r0a@& z@r-0(oixol32o<olx40o+oo/^%lc/, oo/%lc/err-)0 
  %m=Error: Unrecognized vim sequence &'$& ( &'@& ); oz )

<<Vim_ExitVimMode>>
%%Exits any vim mode and returns to jot command mode.
%s=commandmode 0;
%s=verbose 3;
%x=Returning to jot command mode.;

<<Vim_KeyboardScanner>>
%%Enter vim mode
%%N.B. This is the vim command-key scanner it is launched from the normal jot command scanner.
%%All other functions defined here are driven by this function.
%%
%%Clears the stack and returns to current buffer when returning to vim_mode.
%%
%%If there is a saved window configuration restore it now.
%d$=fake_vim_window; %h'=call WindowRestore;
%%( %h'=testkey WindowConfig_default; oq/'=WindowConfig_default/ %d$=; ok %h'=call WindowRestore;, )
%%First ensure we're in the right buffer.
o@ oq/.=CurrentBuf/oz
%s=commandmode 0;
%s=verbose 1;
%m=Returned to vim mode.;
%m=;
ol1ov/.=Mode/
( %%Vim command loop - first clear the ( $ ) buffer.
  obz$m-0k0e0oz 
  ( %%Part-command block - some vim command sequences are more than one character, this loop checks and assembles the complete command string.
    %w=refresh; og obosz$r0oo/%02X /oz
    %h^=testkey -type '$;
    ol4o=ok  %%Yes it's a call object.
    %h^=call -oneline '$;?  %%Returned from vim function.
  , ol1o=ok  %%It's a data object, that's OK - read another byte.
    x-
  , %%Invalid command - report it.
    z$m-0n.r0a@& z@r-0(oixol32o<olx40o+oo/^%lc/, oo/%lc/err-)0 
    %m=Error: Unrecognized vim sequence &'$& ( &'@& ); oz ) )0

<<Vim_SwitchMode>>
%%  {Esc i}  Outcome depends on current mode of operation.
%%
oq/.=Mode/
( ol0o=ok  %%This should never happen when the Vim_KeyboardScanner command scanner is active.
  %x=Returning to jot command mode.;
, (ol1o=ok, ol3o=ok, ol4o=ok , ol5o=ok) %%It's currently in Vim command mode or one of the visual-select modes - exit to jot mode.
  %d$=fake_vim_window; %h'=call WindowSave;
  %%Set the window size.
  ob %q$=window; f/screenHeight = /- oid (oq/.=Debug/okol20, okol1)o- %w=clear; %w=new -height='~ -delim; oz
  (%q=windows; , %s=mousemask 0;)
  %s=commandmode 0;
  %s=verbose 3; 
  %m=Was in vim command mode, returning to jot command mode; oq/.=CurrentBuf/oz 
  ol0ov/.=Mode/
  x3
, ol2o=ok  %%It's in vim insert mode - exit to vim command mode.
  %s=commandmode 0;
  %s=verbose 1; 
  %m=Was in vim insert mode, returning to vim command mode;
  r-? ol1ov/.=Mode/ x4 )

fake_vim_functions:
%%%h'=call AddNewFunctions;
%%This avoids the possibility of AddNewFunctions redefining itself.
z'm-0f/<<addNewFunctions>>/mn. (v/<</\m)0a#&
'#
  
%%Define keycodes
%g$
^[i         %h'=call Vim_KeyboardScanner;      %% {Esc i}       Switch from jot-style sanity to vim emulation.
1B 69       %h'=call Vim_SwitchMode;           %% {Esc i}       Switch from vim insert or visual modes back to command mode and from vim command mode to jot-style sanity.
1B 49       %h'=call Vim_ExitVimMode;          %% {Esc I}       Switch from any vim mode to jot-style sanity.
1B 71       %h'=call Vim_QuitDebugger;         %% {Esc q}       Similar to <<ExitDebugger>> except that it also resets commandmode.^[q           
1B 78       %h'=call Vim_DebugKey;             %% {Esc x}       Adds/removes trace command from requested key callback.
68          %h'=call Vim_Left;                 %% {h}           move left one character
6C          %h'=call Vim_Right;                %% {l}           move right one character
20          %h'=call Vim_Right                 %% { }           move to first non-whitespace character of line
6B          %h'=call Vim_Up;                   %% {k}           move up one line
10          %h'=call Vim_Up;                   %% {Ctrl+P}      move up one line
6A          %h'=call Vim_Down;                 %% {j}           move down one line
0E          %h'=call Vim_Down;                 %% {Ctrl+N}      move down one line
28          %h'=call Vim_PrevSentance;         %% {(}           move to start of previous sentence
29          %h'=call Vim_NextSentence;         %% {)}           move to start of next sentence
63          %h'=call Vim_ChangeCommand;        %% {c}           change command                                                    cursor motion command
6D          %h'=call Vim_MarkPos;              %% {m}           mark current line and position                                    mark character tag (a-z)
27          %h'=call Vim_MoveToMark;           %% {`}           move to marked line, first non-whitespace                         character tag (a-z)
60          %h'=call Vim_MoveToMarkCol;        %% {'}           move to first nonblank in marked line                             character tag (a-z)
72          %h'=call Vim_ReplaceChr;           %% {r}           replace single character at cursor                                replacement character expected
75          %h'=call Vim_Undo;                 %% {u}           undo
7A          %h'=call Vim_ChangeView;           %% {z}           position current line                                             CR = top; "." = center; "-"=bottom
47          %h'=call Vim_GotoLineNoLast;       %% {G}           goto line number prefixed, or goto end if none
48          %h'=call Vim_HomeCursor;           %% {H}           home cursor - goto first line on screen
4D          %h'=call Vim_MidCursor;            %% {M}           goto middle line on screen
4C          %h'=call Vim_EndCursor;            %% {L}           goto last line on screen
4A          %h'=call Vim_JoinNext;             %% {J}           join current line with next line
2F          %h'=call Vim_FindNextPrompt;       %% {/}           search forward                                                    search string, ESC or CR
3F          %h'=call Vim_FindPrevPrompt;       %% {?}           search backward                                                   search string, ESC or CR
6E          %h'=call Vim_SearchAgain;          %% {n}           repeat last search
4E          %h'=call Vim_SearchAgainRev;       %% {N}           repeat last search, but in opposite direction of original search
74          %h'=call Vim_FindChrBefore;        %% {t}           same as "f" but cursor moves to just before found character       character to find
54          %h'=call Vim_FindChrBeforePrev;    %% {T}           backwards version of "t"                                          character to find
66          %h'=call Vim_FindNextChr;          %% {f}           find character after cursor in current line                       character to find
46          %h'=call Vim_FindPrevChr;          %% {F}           backwards version of "f"                                          character to find
3B          %h'=call Vim_Find;                 %% {;}           Repeats "f", "F", "t", or "T" command
2C          %h'=call Vim_RevFindRpt;           %% {,}           reverse direction of last "f", "F", "t", or "T" command
61          %h'=call Vim_a_Commands;           %% {a}           vim commands begining with a lower-case a
69          %h'=call Vim_InsertHere;           %% {i}           enter insertion mode before current character                     text, ESC
6F          %h'=call Vim_EnterOrSwap;          %% {o}           open line below and enter insertion mode, or swap top & bot in insert mode
73          %h'=call Vim_InsertChr;            %% {s}           substitute single character with new text                         text, ESC
41          %h'=call Vim_InsertAtEoL;          %% {A}           enter insertion mode after end of line                            text, ESC
43          %h'=call Vim_DelToEoLInsert;       %% {C}           change to end of line                                             text, ESC
49          %h'=call Vim_NonBlankInsert;       %% {I}           enter insertion mode before first non-whitespace character        text, ESC
4F          %h'=call Vim_InsertAbove;          %% {O}           open line above and enter insertion mode                          text, ESC
52          %h'=call Vim_InsertOvertype;       %% {R}           replace mode - replaces through end of current line, then inserts text, ESC
53          %h'=call Vim_DelAllLineInsert;     %% {S}           substitute entire line - deletes line, enters insertion mode      text, ESC
70          %h'=call Vim_PutAfter;             %% {p}           put buffer after cursor
50          %h'=call Vim_PutBefore;            %% {P}           put buffer before cursor
51          %h'=call Vim_CmdMode;              %% {Q}           leave visual mode (go into "ex" mode)
55          %h'=call Vim_RestoreLine;          %% {U}           restores line to state when cursor was moved into it
67 67       %h'=call Vim_GotoLineNoFirst;      %% {gg}          goto line number prefixed, or goto top if none
67 65       %h'=call Vim_WordEndPrev;          %% {ge}          end previous word
67 66       %h'=call Vim_FileFromCursor;       %% {gf}          open file which filename is under cursor
67 61       %h'=call Vim_ShowAscii;            %% {ga}          show ASCII value of character under cursor
67          %h'=call Vim_ShowCursorPos;        %% {g}           show cursor column, line, and character position
23          %h'=call Vim_SearchWordCurPrev;    %% {#}           Search backwards for word under cursor.
2A          %h'=call Vim_SearchWordCurFor;     %% {*}           Search forwards for word under cursor. 
67 23       %h'=call Vim_SearchPartCurPrev;    %% {g#}          Search backwards for partial match to word under cursor.
67 2A       %h'=call Vim_SearchPartCurFor;     %% {g*}          Search forwards for partial match to word under cursor. 
67 64       %h'=call Vim_DefineLocalSym;       %% {gd}          Local definition of symbol under cursor.
67 44       %h'=call Vim_DefineGlpobalSym;     %% {gD}          Global definition of symbol under cursor.
77          %h'=call Vim_WordStartNext;        %% {w}           move foreward one word
62          %h'=call Vim_WordStartPrev;        %% {b}           back word
65          %h'=call Vim_WordEndNext;          %% {e}           end of current or next word
57          %h'=call Vim_BlankStartNext;       %% {W}           foreward Word
42          %h'=call Vim_BlankStartPrev;       %% {B}           move back one Word
45          %h'=call Vim_BlankEndNext;         %% {E}           move to end of Word
64          %h'=call Vim_Delete;               %% {d}           delete command                                                    cursor motion command
44          %h'=call Vim_DelToEoL;             %% {D}           delete to end of line
78          %h'=call Vim_DelNextChr;           %% {x}           delete single character
58          %h'=call Vim_DelPrevChr;           %% {X}           delete backwards single character
79          %h'=call Vim_Yank;                 %% {y}           yank command                                                      cursor motion command
59          %h'=call Vim_YankLine;             %% {Y}           yank entire line
5A          %h'=call Vim_QickSave1;            %% {Z}           first half of quick save-and-exit                                 "Z"
7C          %h'=call Vim_GotoChr;              %% {|}           move to column specified by numeric arg, defaults to zero
30          %h'=call Vim_Digit0;               %% {0}           numeric precursor to other commands                               [additional numbers (0-9)] command
31          %h'=call Vim_Digit1;               %% {1}           numeric precursor to other commands                               [additional numbers (0-9)] command
32          %h'=call Vim_Digit2;               %% {2}           numeric precursor to other commands                               [additional numbers (0-9)] command
33          %h'=call Vim_Digit3;               %% {3}           numeric precursor to other commands                               [additional numbers (0-9)] command
34          %h'=call Vim_Digit4;               %% {4}           numeric precursor to other commands                               [additional numbers (0-9)] command
35          %h'=call Vim_Digit5;               %% {5}           numeric precursor to other commands                               [additional numbers (0-9)] command
36          %h'=call Vim_Digit6;               %% {6}           numeric precursor to other commands                               [additional numbers (0-9)] command
37          %h'=call Vim_Digit7;               %% {7}           numeric precursor to other commands                               [additional numbers (0-9)] command
38          %h'=call Vim_Digit8;               %% {8}           numeric precursor to other commands                               [additional numbers (0-9)] command
39          %h'=call Vim_Digit9;               %% {9}           numeric precursor to other commands                               [additional numbers (0-9)] command
21          %h'=call Vim_CliCmdToBuf;          %% {!}           shell command filter                                              cursor motion command, shell command
40          %h'=call Vim_Eval;                 %% {@}           vi eval                                                           buffer name (a-z)
24          %h'=call Vim_GotoEoL;              %% {$}           move to end of line
25          %h'=call Vim_DoPercent;            %% {%}           match nearest [],(),{} on line, to its match (same line or others)
26          %h'=call Vim_SubsAgain;            %% {&}           repeat last ex substitution (":s ...") not including modifiers
5F          %h'=call Vim_FirstNonBlankOdd;     %% {_}           similar to "^" but uses numeric prefix oddly
2D          %h'=call Vim_FirstNonBlankPrev;    %% {-}           move to first non-whitespace of previous line
2B          %h'=call Vim_FirstNonBlankNext;    %% {+}           move to first non-whitespace of next line
3A          %h'=call Vim_Ex_Something;         %% {:}           Any command beginning with a colon ( : ) e.g. :q
22          %h'=call Vim_AccessBuffer;         %% {"}           access numbered buffer; load or access lettered buffer            1-9,a-z
7E          %h'=call Vim_ChangeCase;           %% {~}           reverse case of current character and move cursor forward
7F          %h'=call Vim_DoBackspace;          %% {Backspace}   Moves back n characters in vim command mode, erases previous character in vim insert mode.
2E          %h'=call Vim_RptLastChange;        %% {.}           repeat last text-changing command
3C          %h'=call Vim_ReduceIndent;         %% {<}           unindent command                                                  cursor motion command
3E          %h'=call Vim_IncreaseIdent;        %% {>}           indent command                                                    cursor motion command
18          %h'=call Vim_ExitEditor;           %% {Ctrl+X}      Exit immediately.
02          %h'=call Vim_PageUp;               %% {Ctrl+B}      back (up) one screen
06          %h'=call Vim_PageDown;             %% {Ctrl+F}      foreward (down) one screen
04          %h'=call Vim_PageHalfDown;         %% {Ctrl+D}      down half screen
15          %h'=call Vim_PageHalfUp;           %% {Ctrl+U}      up half screen
05          %h'=call Vim_ScrollUpOrMove;       %% {Ctrl+E}      scroll text up (cursor doesn't move unless it has to)
19          %h'=call Vim_ScrollDownOrMove;     %% {Ctrl+Y}      scroll text down (cursor doesn't move unless it has to)
07          %h'=call Vim_ShowEditStatus;       %% {Ctrl+G}      show status
08          %h'=call Vim_Left;                 %% {Ctrl+H}      backspace
0C          %h'=call Vim_Refresh;              %% {Ctrl+L}      refresh screen
0D          %h'=call Vim_NextLineStart;        %% {Ctrl+M}      (CR) move to first non-whitespace of next line
0A          %h'=call Vim_NextLineStart;        %% {Ctrl+J}      (LF) move to first non-whitespace of next line
11          %h'=call Vim_XON;                  %% {Ctrl+Q}      XON
12          %h'=call Vim_DoNothing;            %% {Ctrl+R}      does nothing (variants: redraw; multiple-redo)
13          %h'=call Vim_XOFF;                 %% {Ctrl+S}      XOFF
14          %h'=call Vim_RestoreFocus;         %% {Ctrl+T}      go to the file/code you were editing before the last tag jump
1B 74       %h'=call Vim_RestoreFocus;         %% {Esc t}       go to the file/code you were editing before the last tag jump ({Ctrl+T} is an alternative for chromebooks.)
1C          %h'=call Vim_ExitVisualMode;       %% {Ctrl+\}      leave visual mode (go into "ex" mode)
1D          %h'=call Vim_TagFromCurrWord;      %% {Ctrl+]}      use word at cursor to lookup function in tags file, edit that file/code
1E          %h'=call Vim_SwitchFileBufs;       %% {Ctrl+^}      switch file buffers
76          %h'=call Vim_VisualModeChr;        %% {v}           Start visual mode, select to nearest character.
56          %h'=call Vim_VisualModeLine;       %% {V}           Start visual mode, select to nearest line.
16          %h'=call Vim_VisualModeBlock;      %% {Ctrl+V}      Start visual mode, select block.
17 73       %h'=call Vim_Ex_split;             %% {Ctrl+W s}    split window
17 6E       %h'=call Vim_Ex_new;               %% {Ctrl+W n}    create new empty window
17 6F       %h'=call Vim_Ex_on;                %% {Ctrl+W o}    make current window one on screen
17 6A       %h'=call Vim_WindowDown;           %% {Ctrl+W j}    move to window below
17 6B       %h'=call Vim_WindowUp;             %% {Ctrl+W k}    move to window above
17 77       %h'=call Vim_WindowUpWrap;         %% {Ctrl+W w}    move to window above (wrap if already at top/bottom window)
17 57       %h'=call Vim_WindowDownWrap;       %% {Ctrl+W W}    move to window below (wrap if already at top/bottom window)
7B          %h'=call Vim_ParaStart;            %% {             move to previous blank-line separated section
7D          %h'=call Vim_ParaEnd;              %% }             move to next blank-line separated section
1B 64       %h'=call Vim_StartDebugger;        %% {Esc d}       Enters the jot debugger loop.
:
%%Removed to avoid collision with jump-to-mark
%%  60 5B       %h'call Vim_ReturnInsStart;       %% {`[}          Return to start of previous insert-mode operation.
%%  27 5D       %h'call Vim_ReturnInsEnd;         %% {']}          Return to end of previous insert-mode operation.
%%Append new entries to the function map.
obz^m0h$
%%Remove {Esc i n} and {Esc I n}.
m-0(f/^[in  /k)0
oz

%%fake_vim initialization.
%g#=fake_vim initialization;
%%
%%Setup window and command mode.
%%  %h'call Vim_Ex_on; 
%%
%%do options
oq/.=Options/z~r-0 (f1/ -test /ol1, ol0) %h=setdata -new .=Test;        %%The fake_vim keyboard scanner will be started by the test script.
oq/.=Options/z~r-0 (f1/ -debug / ol1, ol0) %h=setdata -new .=Debug;     %%Redefine windows and start up in debug mode F002 (trace and stop at each command line).  
%%  
( oq/.=Debug/ol1o=ok
  %w=clear; %w=new -height=20 -delim;
  %s=commandmode 0;   %%All characteters are treated as escape sequences.
  %s=prompt > ;       %%Make OG prompts visible.
%%  %s=verbose 3;       %%Normal prompting.
%%  %s=trace 7002;      %%Trace each new command line.
, %%Not -debug setup for normal operation.
  ok %s=commandmode 0;  %%All characteters are treated as escape sequences.
%%  %s=verbose 0; %m=;  %%Suppress prompts.
%%  %s=prompt;          %%Suppress prompting.
  )
  
%%Do the CLI args  -c<cmd&arg1>[ ... -c<cmd&arg2> [ ... ]]; - execute the specified commands in sequence.
( r-0f1/ -c/ %%One or more startup commands were given, split and construct the startup command file.
  %%Trim and insert linebreaks after all {:} commands.
  r-0(f/ -c/(v-/ /e-)0e3b)0 m-0(f/ +/(v-/ /e-)0e2b)0 m-0(mj-,)
  %%Do control characters.
  m-0 (v/^/ (e(q/a-z/cr-, )oicol64o-oo/%c/v/^/)0m, m)0
  %%For {:}, {/} and {?} commands split the command part from the argument (if any), other commands merge onto one line.
  m-0 (q":/?"r(f1/ /(v/ /e)0, r0)bm, m)0
  %%Set pathname and write the script.
  %b=pathname fake_vim_startup_commands.jot; %o;
  %%Run the script.
  oq/.=CurrentBuf/ozok
  ( %r= -asConsole ./fake_vim_startup_commands.jot;, %m=Error: Something failed in the processing of your -c ... commands.; )
, %%No -c commands - launch now.
  oq/.=CurrentBuf/ozok )
fake_vim initialization:
'#
  
%g#=Setup fake_vim keys;
%%Copy the actions for all arrow keys and any others selected in the ( ! ) buffer.
%%Now set up the vim key mappings hashtable - Vim_SwitchMode must be the first entry.
obz^ %h=create 1000; m-0f/Vim_SwitchMode/r-0
%%Add all entries.
( %%Ensure all part-completed command strings are registered as data objects.
  r-0r3n.(r-0a$&v/ / (v/ /e)0b %h=code '$; x, %h=data '$;? r3n.)0
  %%Index to next string and repeat.
  m )0
%%
%%Copy the actions for all arrow keys and any others selected in the ( ! ) buffer - these were saved immediately after running the normal startup script.
z^m0r0bon z!
m-0 ( f/{UpArrow}/s/%h'call Vim_Up;/, )
m-0 ( f/{DownArrow}/s/%h'call Vim_Down;/, )
m-0 ( f/{RightArrow}/s/%h'call Vim_Right;/, )
m-0 ( f/{LeftArrow}/s/%h'call Vim_Left;/, )
m-0 ( f/{PageUp}/s/%h'call Vim_PageUp;/, )
m-0 ( f/{PageDown}/s/%h'call Vim_PageDown;/, )
z^m0h!
%%Register the cursor-control and any function-key mappings.
%%Again, ensuring all part-completed command strings are registered as data objects.
z^ono-om ( ( (v/^/eoicolx40o-, oic) oo/%02X / v/  /\)0 r-0r3n. (r-0a$&v/ / (v/ /e)0b %h=code '$; mx, %h=data '$;? r3n.)0 )0
oz
Setup fake_vim keys:
'#
  
%%Final initialization.
r-0y0
%%Set up the fake_vim windows.
%s=guardband 5;
%s=console 25;
ob %s=system 1; %q$=window; f/screenHeight = /- oid (oq/.=Debug/okol20, okol1) o- %w=clear; %w=new -height='~; %l; oz
%d$=fake_vim_window; %h'=call WindowSave;
%%
%%Start the fake_vim keyboard scanned, except in test mode.
%%%h'=call Vim_KeyboardScanner;
( oq/.=Test/ol0o=ok %h'=call Vim_KeyboardScanner;, ok)
