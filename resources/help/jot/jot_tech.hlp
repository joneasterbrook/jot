

{{{ JOT Technical Guide
1 JOT Technical Guide
---------------------
  This guide is rather more technical in nature. It goes into some details  of
  the design and  internals  of  the  editor,  it's  command  structure,  it's
  primitive commands and installation. For a general user guide take a look at
  `jot user guide` and `jot walkthrough`.

{{{ About jot commands
1.1 About jot commands
----------------------
  There are two clearly identifiable groups  of  jot  commands  -  those  text
  manipulation and those for interfacing with the  operating  system  and  for
  internal housekeeping.
  
  The basic text manipulation commands are all single  characters,  e.g.  `F`-
  find, `S` - substitute, `I` - insert, `M`  -  move  (up/down),  `R`  -  move
  right. There is also an important group of  commands  to  do  with  creating
  programme structures e.g. `(` - block start, `)`  -  block  end  and  `,`  -
  introduces a logical else clause. Most commands set  a  success/fail  status
  flag - a fail will result in an interruption in the programme flow within  a
  block. 
  
  The housekeeping commands can be for probing and  setting  system  state  or
  calling system services. These are generally prefixed with a percent (  %  )
  character e.g:
    - `%I` - input - reads a file from the filing system,
    - `%O` - output - writes a file to the filing system,
    - `%Q` - query - returns reports or values reflecting the  internal  state
      of the editor,
    - `%S` - System settings and services - these affect all buffers.
    - `%B` - Buffer settings and services -  these  affect  only  the  current
      buffer.

}}}
{{{ About command parameters
1.2 About command parameters
----------------------------
  Numeric parameters are generally specified in decimal e.g:
> m123
  
  String  parameters  may  use  any  non-alphanumeric  ASCII  character  as  a
  delimiter provided the delimiter does not occur in  the  string.  Note  that
  most (see `Q`) of these commands will accept ISO-8859-x or UTF-8  characters
  in the parameter string but only ASCII characters may be used as delimiters.
   
  If there is no further text on the command line then the string may be  left
  unterminated. These examples all find the next instance of the string £1234:
> f/£1234/
> f/£1234
> f@£1234@
> f"£1234"
  
  Most commands that accept a string parameter will also accept a reference to
  a buffer by replacing the string and delimiters with '<key> in  the  command
  line (e.g. F'@ ) in this case the string used is the entire current line  of
  the secondary buffer. The input parameters to many of the  percent  commands
  (mainly those which take pathNames) may also be defined indirectly  in  this
  way (e.g. %ia='$; %qb=file '$ ) but the destination  buffer  cannot  be  the
  same as the pathName buffer. Where this type of indirection is  used,  there
  is an upper limit of 1024 on the allowable length of parameter strings.
  
  The indirect reference can be to a buffer on the operand stack  (see  `about
  the operand stack`). 
  
  In this example, the value of env FRED is used to define a search string:
> %q~=env FRED; mz. f'~
 
  All references to numerical items on the stack  cause  the  to  item  to  be
  removed, references to buffers on the stack do not  delete  the  buffer.  In
  this example, the top item on the stack contains a numerical value  used  to
  set the size of a hashtable:
> %h=create '~;
  
  In jot's direct insert mode (see `command-mode vs. insert mode`), you cannot
  enter commands. You can only type text straight onto the screen or fire  off
  the editor functions attached to hot-keys and control  keys.  If  an  editor
  function requires an parameter it will prompt you for it. Type it  into  the
  console area and hit {Return}. See `%s=commandmode` for details about  jot's
  type-into screen mode.

}}}
{{{ About parameters to macros and jot scripts
1.3 About parameters to macros and jot scripts
----------------------------------------------
  The `%R` command picks up any parameters from the command  line  and  copies
  them to the $ buffer where they can be examined by the script.
  
  The `cli.jot` script, for example, take an ordinary CLI command executes  it
  and returns the result in the @ buffer. For example:
> %r=cli ls -l;
  On completion the @ buffer contains a directory listing  of  your  PWD.  The
  <<`Do`>> function is just a wrapper for the %R command.
  
  The native jot language does not define how parameters find their  way  from
  the keyboard via the console area to macros  or  functions  (see  `hashtable
  call`). For the most important of these Macro1 to Macro9 the startup  script
  (See `about startup scripts`) arranges for parameters to be copied into  the
  ( $ ) buffer.
  
  It's a similar story for  the  more  complex  functions  held  in  the  code
  repository (see `calling subroutines by name`) The `FindSequence`  function,
  for example, takes a list of words from the command line - these are  picked
  up from console area and  copied  to  the  $  buffer  and  the  FindSequence
  function picks them up from there.
  
  When in insert mode (see `Command-mode vs. insert mode`) the startup  script
  arranges for the correct prompt to appear -  see  `translation  of  keyboard
  events to actions`

}}}
{{{ About text buffers
1.4 About text buffers
----------------------
  In jot, a text buffer is an internal data structure containing an  image  of
  some text. Each buffer is identified by a single-character buffer  key.  The
  following buffers are accessible but some are used by command file  scripts.
  Buffers may contain a file image, fragments of text or jot command strings -
  otherwise known as macro commands.
   
    - ( . ) is the primary buffer, this contains an image of the file you gave
      on the shell command line.
     
    - ( A ) to ( Z ) available without restriction, note that these  are  case
      insensitive i.e. a and A are the same buffer.
     
    - ( 0 ) to ( 9 ) user-defined functions attached to Numeric keypad keys  0
      to 9 ({Esc 0} to{Esc 9} for those lacking a numeric keypad) but, if  you
      don't want to use these as macros, they  are  available  for  any  other
      purpose.
      
    - ( $ ) used to pass parameters to function keys, scripts and macros.
     
    - ( ^ ) set up by startup script - defines function-key mapping.
    
    - ( ' ) Set up by startup script - hosts  the  code  repository  and  it's
      hashtable. It's hashtable is also used to hold bits  of  global  data  -
      like the jump addresses for `ViewSave` and `ViewRestore`.
      
    - ( : ) Set up by the startup script, is the help repository - see  `about
      help files`.
    
    - ( $ ! " # % & ( ) * + - . / ; < = > ? @ [ \ ] _ ) are all available  but
      may be used by scripts or functions hence they can only be relied on for
      temporary storage.
      
    - The ( ! $ % ; @ ) buffers are used by the standard setup script, so they
      may contain something after the startup has run - but may  be  redefined
      without causing problems.
    
    - The buffers ( ^ ' : ) are defined by  the  standard  setup  script  (see
      above), changing these may cause things to not work properly.
    
    - The ( & ) buffer is dedicated to the document-processing utility  -  see
      `text document preparation`.
      
    - The ( = ) buffer is available but cannot be used as a destination buffer
      for the `%Q`,  `%F`  and,  possibly,  other  percent  commands  with  an
      optional buffer-key, since it would confuse the command parser.
      
    - The ( ; ) buffer is used to display help pages but it can  be  used  for
      temporary storage, the syntax gets a bit  messy  when  used  in  percent
      commands since the semicolon is used to terminate percent commands.
      
    - The ( ? )  buffer  is  defined  by  many  scripts  to  give  brief  help
      information on the script.
      
  See `A`, `H` and `about command parameters`.

}}}
{{{ Translation of keyboard events to actions
1.5 Translation of keyboard events to actions
---------------------------------------------
  Like most modern editors jot attaches editor functions to  various  function
  keys, escape sequences and and various combinations of the Shift,  Ctrl  and
  Alt keys with function and other keys. The key-to-function translation table
  is held in the text buffer ( ^ )  defined  at  startup  time  -  see  `about
  startup scripts`.
  
  As a function key is pressed, signals trickle through various layers of  the
  OS (maybe xkb followed by terminfo) until they reach the editor in the  form
  of a keycode or an escape sequence.
    - Simple ASCII characters are a keycode byte indicating the ASCII code,
    - unicode characters appear as a series of bytes  indicating  their  UTF-8
      sequence,
    - simple function keys and mid-keypad keys appear as a single-byte keycode
      as defined in ncurses.h and
    - keys modified by Ctrl, Shift and/or Alt, use this scheme:
        - {F1-12}                  yields key_f1-key_f12,
        - {Shift F1-12}            yields key_f13-key_f24,
        - {Ctrl F1-12}             yields key_f25-key_f36,
        - {Ctrl+Shift F1-12}       yields key_f37-key_f48,
        - {Alt F1-12}              yields key_f49-key_f60,
        - {Shift+Alt F1-3}         yields key_f61-key_f63,
        - {UpArrow}, {DownArrow}, {LeftArrow}, {RightArrow}, {Insert}, {Home},
          {Delete}, {End}, {PageUp} and {PageDown} Keycodes  for  all  of  the
          above are defined in ncurses.h
    - The following keys, however, usually generate unique key sequences  (but
      even uniqueness is not guaranteed) determined by your OS  configuration.
      Furthermore some  may  be  hardwired  as  system  shortcuts  (especially
      {Ctrl+Alt+F1-12}) and some combinations of {Up/DownArrow}.
        - {Shift+Alt F3-12}
        - {Ctrl+Alt F1-12}
        - {Ctrl+Shift+Alt F1-12}
        - {<AnyModifier>+<AnyMid-keypadKey>}
      The point to note about system-defined escape sequences is that they are
      liable to change from one linux to another.  It's  not  even  guaranteed
      that these will yield any usable key code at all and sometimes they have
      been known to collide with other keycodes/escape sequences from the same
      system. See `define_keymap.jot` for details of how to redefine  the  jot
      key mapping for your system. The  `curses_keys_<TERM>.jot`  in  the  jot
      distribution was set up using a Fedora-27 with TERM set to xterm.
  
  After a key event is received,  jot  will  attempt  to  match  the  received
  keycode with codes in the ^ buffer (see `startup.jot`). Some keys  return  a
  simple numerical  value,  others  return  an  escape  sequence  -  an  {Esc}
  character followed by a few ordinary  printable  characters.  Alternatively,
  the user may type in {Esc} followed by two or more characters -  essentially
  another form of escape sequence.
  
  Where a parameter is required, e.g. for the <<Do>> function the script  name
  parameter is represented in the function definition by a  pair  of  adjacent
  hash characters. For in a  typical  linux  installation  this  key  will  be
  defined by this entry in the ^ buffer:
X010A   %r=##"Command file pathName> ";
  
  In command mode, the name of the script is typed in *before*  hitting  {F2},
  thus the function key doubles up as a delimiter for  the  parameter  string,
  saving you the bother of hitting {Return}.
  
  In insert mode, however, it is necessary to prompt for the pathname and  the
  prompt is, of course, the string following the double hash.  If  the  prompt
  string is omitted then no prompt is issued.
  
  The startup script builds the key translation table in buffer ( ^  )  -  see
  `startup.jot`.
  
  In the normal startup script, for example, we find this  definition  of  the
  <<Remove>> function (this removes the currently-selected substring):
<<Remove>>(s/ /e-)
  
  Then, further along in the startup.jot script we see this:
<<Remove>>            {Shift+F5}
  This says that the <<Remove>> function should be activated by  pressing  the
  F5 function key while the Shift key is held down.
  
  In the curses_keys_xterm script we find this line:
X0119                        -- {Shift+F5}
  In the WindowsNT_keys script we find this line - functionally similar but  a
  different keycode.
X374                         -- {Shift+F5}
  these give the specific key code for {Shift+F5}.  Finally,  looking  in  the
  key-translation buffer ( ^ ) of a linux session we should see this:
X0119   (s/ /e-)
  The sequence of events is thus:
    - You select a substring,
    - you press {Shift+F5},
    - the system detects this event and generates a binary the code determined
      by terminfo to be 0x119,
    - jot translates the code 0x119 to the escape sequence {Esc 0 1 1 9},
    - jot matches the internally-generated escape sequence and finds  the  jot
      command sequence (s/ /e-) by searching the ( ^ ) buffer,
    - jot then executes that little bit of code and, finally,
    - you see the substring disappear from the screen

}}}
{{{ About startup scripts
1.6 About startup scripts
-------------------------
  As we hit keys, various layers of hardware and the operating system  perform
  a translation from electrical impulses in the keyboard to keycodes that  can
  be understood by whatever software is reading them - in this case jot.
  
  For windows the situation appears to be  that  all  flavours  of  NT-windows
  running on any machine connected to  any  compatible  keyboard  will  always
  yield the same keycodes.
  
  For linux, the recent history of unix intrudes, as  video  terminals  became
  popular a great many firms entered the  market  with  competing  and,  well,
  incompatible devices which all had to be connected to unix servers. This was
  the necessity that gave birth to the invention of termcaps. Later there  was
  terminfo - an improved version of termcaps.
  
  With termcaps/info it became possible for many users,  all  connected  to  a
  unix server using a variety of terminals and for the system  to  communicate
  reliably with all of them. But only if each  has  properly  announced  which
  terminal type they have by setting their $TERM env.
  
  However ... most linux installations run on PCs with only one  keyboard  and
  only one monitor but the unix distros have provided a plethora  of  terminal
  types and many distros set up the default TERM to xterm. But no! ... not all
  distros  provide  a  complete  description  of  the   capabilities   of   an
  IBM-compatible keyboard and worse yet, not all agree on what keycodes result
  from various combinations of function and control keys.
  
  This is resolved in the  startup  script  (See  `startup.jot`),  which  runs
  different keycode-setup  scripts  according  to  your  curses  version  (see
  `WindowsNT_keys.jot` and `curses_keys_<TERM>.jot`).
  
  The mapping of function key events to  editor  functions  is  determined  in
  various layers of OS and, in particular your terminfo file and, finally,  by
  the editor startup file. See also `X-windows setup`
  
  The approximate sequence of events, in the `startup.jot` file is:
    - The appropriate curses_keys_<TermName>.jot script is run - this  defines
      the mapping of keycodes (either numerical keycodes or escape  sequences)
      to the names printed on the keycaps. This table is set up in the (  @  )
      buffer.
    - The startup script then defines functions in the code repository  buffer
      ( ' ).
    - The startup script then defines the mapping of functions to key names in
      buffer ( ! ).
    - If you have specified a function and keymap  modification  script  using
      the -keyfuncs=<pathName> qualifier then  that  script  is  run  at  this
      point.
    - The startup script merges the keycodes map, the functions  map  and  the
      functions to create the key translation table in buffer ( ^ ) - this  is
      used to map hotkeys function keys and escape sequences  to  actual  code
      and function calls.

}}}
{{{ About jot streams
1.7 About jot streams
---------------------
  Jot is normally used to edit text files held on the filing system but it can
  pick up text from the stdin stream (see `-`) and it can direct text  to  the
  stdout stream when `-tty` is set.
  
  Currently the `-` qualifier is only required by the windows version, and the
  incoming stream is detected automatically by the linux version.
  
  In normal usage, the `P` command prints line in the console area.  When  the
  editor is stared in stream-out mode the printed lines are  sent  to  stdout,
  where they can be directed to a  file  or  piped  to  another  process.  The
  stream-out operation  is  detected  automatically  when  stdout  is  set  to
  anything except your  xterm  (or  windows  console).  e.g  (this  matches  a
  specific class of error message with the function name):
$ jot message.log -quiet -tty -init="t(f/warning: unused variable/onf-/in function/n.r2f1/:/aa&ono-omhapm)0 %a" | cat
  This would also cause it to enter stream-out mode:
$ jot message.log -q -tty -in="t(f/warning: unused variable/onf-/in function/n.r2f1/:/aa&ono-omhapm)0 %a" > errors.lis
  
  Note the use of the -tty and -quiet qualifiers in these two examples -  -tty
  this prevents xterm escape sequences appearing in stdout, -quiet  suppresses
  many normal messages that would otherwise appear in the output stream.
  
  In stream-out mode the records selected by the `P` command is sent off  down
  stdout where it can be piped  off  to  some  other  process.  This  mode  of
  operation  is  used  in  the  99  bottles  of   beer   demonstration.   (see
  `http://99-bottles-of-beer.net`)
  
  99 bottles of beer is a simple drinking song:
  
	99 bottles of beer on the wall, 99 bottles of beer.
	Take one down and pass it around, 98 bottles of beer on the wall.
	   ...   
	2 bottles of beer on the wall, 2 bottles of beer.
	Take one down and pass it around, 1 bottle of beer on the wall.
	  
	1 bottle of beer on the wall, 1 bottle of beer.
	Take one down and pass it around, no more bottles of beer on the wall.
	  
	No more bottles of beer on the wall, no more bottles of beer.
	Go to the store and buy some more, 99 bottles of beer on the wall.
  
  The object of the exercise is to write some code in your favourite  language
  to generate the lyrics correctly - this is one way of doing it in jot:
  
	cat - | jot /dev/null -tty -obey << EndOfJotCommands
	i/$ bottles of beer on the wall, $ bottles of beer./b
	i/Take one down and pass it around, $ bottles of beer on the wall./b2
	m-0nm2aaha99
	m-0ol99(f/$/o#oo/%d/)2 (ol1o-(f/$/o#oo/%d/)3)98
	(f-0/1 bottles/-e-)3 (f/$/s/no/)3l0c
	mki/Go to the store and buy some more, 99 bottles of beer on the wall./m-0b-p0
	%a
EndOfJotCommands

}}}
{{{ About help files
1.8 About help files
---------------------
  The help files are structured in a similar fashion to occam folded files.
  
  The top help file normally contains only file folds. If,  for  example,  the
  JOT_RESOURCES env is set  to  /home/my_home/resources,  there  should  be  a
  top-level helpfile help.hlp in the help subdirectory:
    /home/my_home/resources/help/help.hlp
  Inside that file we might find this line:
    [unix]unix - Notes on a few unix commands.
  When When a user queries this help entry (by moving the cursor to  somewhere
  in the line and hitting F1) the [unix]unix element is transformed  into  the
  path:
    /home/my_home/resources/help/unix/unix.hlp
    
  Within the child help files are folded sections like this:
> {{{ Section name
>   Section text.
>   ...
> }}}
  
  These help sections are nestable.
  
  The help files can be typed in manually, but it is easy to make mistakes  in
  the fold  nesting.  It  is  recommended  that  help  files  be  prepared  as
  plain-text documents with the section hierarchy defined  by  section  header
  levels (i.e. the section levels indicated by  the  section  numbers)  -  see
  `text document preparation`.
  
  There are some text-processing scripts to help with this:
    - `doc2fold.jot` - Creates a help file from a text document.
    - `fold2doc.jot` - reverse of doc2fold - only use  this  when  the  source
      text is not available.
    - `updatehelp.jot` - pushes simple modifications to a help  fold  back  to
      the helpfile.
    - `findhelp.jot` <word> - searches all help entries for the given word.

}}}
{{{ About long lines
1.9 About long lines
---------------------
  The maximum length line that can be displayed properly  is  limited  by  the
  display window. When the editor has to display a longer line  the  behaviour
  is as follows:
   
    - If current character and all of any selected substring are in within the
      terminal width then the line, the current character  and  the  substring
      are displayed normally. Any text to the right of the window right margin
      is silently ignored.
       
    - If the current character or some part of the selected substring is at or
      beyond the terminal width then the line is displayed in the console area
      of the screen.
       
    - If a LeftOffset is set for the buffer  (see  `%b=leftoffset`)  then  the
      left margin of the display is aligned to somewhere right  of  the  first
      character. If the current  character  or  some  part  of  the  currently
      selected substring falls outside the defined screen  area  then,  again,
      the relevant section of the record is displayed in the console area.
      
    - When a script or macro has to ensure that the current  character  is  in
      view use %q=inview - see `Query inView`.
      
    - The <<CellLeft>> and <<CellRight>> actions  (normally  {Shift+LeftArrow}
      and {Shift+RightArrow} respectively), will check  for  visibility  using
      %q=inview and will adjust leftoffset accordingly.
      
    - The     <<ViewLeft>>     and     <<ViewRight>>     actions     (normally
      {Ctrl+Shift+LeftArrow} and {Ctrl+Shift+RightArrow} respectively), can be
      used to manually adjust leftoffset.

}}}
{{{ About the jot console and display windows
1.10 About the jot console and display windows
----------------------------------------------
  In jot documentation, a window  is  a  viewing  area  of  the  terminal.  By
  default, the startup script creates a single window which displays  whatever
  happens to be the current buffer. The area at the bottom of  the  screen  is
  the console area, used to display system messages etc. and prompts for  your
  typed-in commands. In the event of a long line with  the  current  character
  being off to the right of the screen then the console area is used to repeat
  an appropriate section of the line.
  
  The standard startup script (see `about  startup  scripts`)  will  use  your
  screen dimensions to calculate the size of a single window that will leave a
  one-line console area at the bottom of the  screen.  It  also  sets  up  the
  screen, using the `%L` command. it also uses  the  `%s=console`  command  so
  that various message can temporarialy encroach into the  window  area.  When
  this happens, the window will be restored to it's  full  size  on  the  next
  command - or by hitting {return}. If the temporary  display  overwrites  the
  current line in the display window then the current line is repeated in  the
  console area.
  
  When the console area is set up with two or more lines, lines of text scroll
  up the console up to the bottom line of the last window. If the  console  is
  set up with one line but allowing it to temporarialy encroach  upwards  into
  the windows area (see `%s=console`  for  details),  then  the  console  will
  borrow lines up to the specified limit.
  
  For debugging scripts, especially when  using  `the  jot  debugger`,  it  is
  useful to set up windows for a fairly large console window. For normal usage
  a one-line console area is useful since this maximizes the text view.
  
  The  size  of  a  window  can  be  adjusted  with  the  `WindowStretch`  and
  `WindowShrink` functions. The view can be adjusted left, right  up  or  down
  with the functions - see `ViewUp`, `ViewDown`,  `ViewLeft`  and  `ViewRight`
  respectively.
  
  It is possible to split the viewing area between more than one  window  with
  one or more windows dedicated to displaying specified  buffers.  The  screen
  may be split either vertically or horizontally  -  see  `about  multi-window
  working`   and   `WindowOne`,   `WindowHorizSplit`   and   `WindowVertSplit`
  functions.

}}}
{{{ About Tabular text
1.11 About Tabular text
-----------------------
  Jot supports text two types of text containing tabs - normally the ascii  VT
  character, here referred to as tab. The first form uses tabs simply to align
  text into predefined columns, the  second  form  aligns  tab-delimited  text
  cells. Cells often contain numerical data, so the  text  is  right-justified
  and over-long strings are truncated to maintain the tabular structure.
  
  See  `%b=tabstops`,  `%b=tabcells`  and  `%b=tabsort`.  It  also   generates
  tab-separated tables (see `Query dir`).
  
  When viewing tabular data it is often useful to have a header  line  showing
  the meaning of each column - the window headers provided by `%b=header` will
  follow tabstops set in the text body eg:
$ jot ${JOT_RESOURCES}/consumertrends2012q3cvmnsa_tcm77-292466.tsv \
    -in="m+13 %b=header '.; %b=tabcells -1; wol12ow"
  
  The header is also useful for wide blank-separated tables eg:
$ pmap -XX <anyValidPid> | jot -in="m %b=header '.;"
  
  In addition to `%b=tabstops` and `%b=tabcells`, there are two  more  options
  for representing tabular text. 
    - By default, jot will treat tabs as it does any other control  characters
      and will represent them with tildes ( ~ ) -  not  a  especially  helpful
      option for most uses - but it is sometimes useful to see where they are.
    - The following scripts will reformat documents, guided by temporary tabs:
      `autotab.jot`     `autotabdp.jot`     `autotabjust.jot`      `retab.jot`
      `retabhere.jot`
  
  If the width of the table execeeds that of your  window,  you  can  set  the
  leftoffset - see `about long lines` and `%b=leftoffset` this  is  all  taken
  care of by the <<`WordRight`>> and <<`WordLeft`>> functions.
  
  A good example is the output of the linux dumpkeys command  -  the  keycodes
  section consists of 256 entries per line with  20  or  more  characters  per
  entry, to view these with a header showing the modifier values try this:
$ sudo dumpkeys -f | jot -in="(f/ /s/\t/(v//e)0)0m-0 %b=tabstops -1; \
  ol0z\$m-0k0(i/\t/)3 (o#oo/\t%2X/r0o~ol256o<)0 z.%b=header '$;"
  
  You may then navigate the table using `WordLeft`, `WordRight`, `WordUp`  and
  `WordDown`  -  {Shift+LeftArrow},  {Shift+RightArrow},  {Shift+UpArrow}  and
  {Shift+DownArrow} respectively.
  
  As with linear text, if the current character ends up  outside  the  visible
  area of the screen (i.e. left of the buffers leftoffset setting, or right of
  the right margin), the relevant section is repeated  in  the  console  area.
  Also, if any part of the cell is out of the viewing area or the tabstops are
  set to narrow to properly display a cell, the cell  text  is  truncated  and
  displayed prefixed with a pling ( ! ) character. The section of text is also
  repeated in the console area - see `about long lines`.
  
  While the %b=tabstops command affects only the way tables are represented on
  the screen in the current edit  session,  There  are  scripts  available  to
  permanently change the text file  -  see  `autotab.jot`,  `autotabjust.jot`,
  `autotabdp.jot` and `retab.jot`.

}}}
{{{ Of Mice and Menus
1.12 Of Mice and Menus
----------------------
  Jot offers a Text-based User Interface (TUI) which can  support  mouse-click
  and menu-driven applications. Although the plain-text menus might look quite
  crude and clonky by modern standards but that doesn't make them less  useful
  than their slick counterparts. Take a look at the coding of  `menu.jot`  and
  `linkdocs.jot` for examples of how this might be done.
  
  - Firstly, to enable mouse events, the  mousemask  must  be  set  up  -  see
    `%s=mousemask`.
    
  - It  is  usual  to  highlight  clickable  target  points  with  an   easily
    identifiable visible marker, in jot this requires  the  application  of  a
    colour tag (see `%b=addtag`). If  popup  menus  are  being  used  this  is
    essential in order to avoid confusion as the popup overwrites normal text.
  
  - Mouse-clicks trigger the delivery of an escape sequence in much  the  same
    way as a function key - these are picked up and are  normally  set  up  to
    call a mouse-event handler function - see `translation of keyboard  events
    to actions`.
  
  - The mouse-event handler must first identify the buffer,  column  and  line
    number ( X and Y) where the mouse cursor was pointing at the time  of  the
    mouse event. This information is provided by th `OP` command.
  
  - Having determined the mouse-event coordinates, we now have to identify the
    correct action associated with the identified mouse event  and  the  event
    location. A  text  tag  is  assigned  to  the  clickable  region  and  the
    mouse-event  handler  checks  the  event  point  for  text  tags   -   see
    `%b=addtag`. Following a mouse event, the event-point text can be  checked
    for text tags using the `query tags` using the -here qualifier  to  select
    the correct text region.
    
    For menus, there will be a wide range of follow-on actions, then  the  tag
    is effectively a callback selector -  see  `menu.jot`  for  examples.  For
    hypertext applications  the  tag  simply  gives  the  link  destination  -
    possibly in the form of a hashtable key - see `linkdocs.jot`.

{{{ About Mouse Events
1.12.1 About Mouse Events
-------------------------
  By default, any mouse activity (movements, clicks, drags etc.)  are  ignored
  since in X the default mouse functions (selections) are  reasonably  useful.
  If however, some application needs to handle  mouse  events,  these  can  be
  enabled. An example of a script that does this would be `linkdocs.jot`.
  
  Jot is normally driven by keyboard events with mouse-button events disabled.
  When mouse events are enabled, these are treated  as  keyboard  events  with
  special mouse event codes prefixed with 'M@. In linux,  it  is  possible  to
  select mouse events in the `%s=mousemask` command, in  windows  this  either
  enables or disables all mouse events.
  
  The normal startup sequence defines four functions
M0040   <<CopyFromMouse>>    -- {Button2Up}
M0080   <<NoteFromMouse>>    -- {Button2Down}
M0200   <<FocusToMouse>>     -- {Button2DoubleClick}
M4000   <<InsertHereMouse>>  -- {Button3Click}
  these are intended to be demonstrators rather than useful functions - enable
  them for use with the mousemask command:
> %s=mousemask 42A0
  
  To integrate these in a useful way - e.g. for mouse clicks to perform useful
  processing some metadata is often required - e.g. to perform a jump to  some
  place in another buffer on a mouse click we might  need  a  hash-table  key.
  This key can be associated with a launch point by adding a text tag  in  the
  launch point with the`%b=addtag` command using the -text=<string> modifier.
  
  See also `OP`, `%s=mousemask`, `%s=setmouse` and `%b=addtag`

}}}
{{{ About Menus
1.12.2 About Menus
------------------
  Menus are normally but not exclusively driven by  mouse  events  -  normally
  clicks. Menu items are normally highlighted by choosing a  different  colour
  pair for them - see `%b=tagtype` and `%b=addtag`.
  
  For menus each menu item  will  require  a  different  callback  -  this  is
  normally determined by tagging menu items with a text tag (see  `%b=addtag`)
  that identifies the callback. Alternatively, the click-event  handler  might
  simply pick up the visible text  from  the  menu  buffer  and  identify  the
  follow-on action from that.
  
  Popup menus can be set up using popup windows - see the -popup option of the
  `%W` command.

}}}
}}}
{{{ About unicode
1.13 About unicode
------------------
  Back in the days of teletypewriters and paper tape it was all so  easy.  The
  American Standard Code for Information Interchange (ASCII)  would  represent
  every character you could ever want with just  7  bits  -  so  long  as  you
  weren't  a   mathematician,   an   engineer   or   anyone   working   in   a
  non-english-speaking part of the world.
  
  Mapping the 7-bit ASCII code to 8-track paper tape code left one  extra  bit
  which was sometimes used for checking  -  early  modems,  electro-mechanical
  tape punches and readers were not especially reliable. Since that time,  the
  8-bit unit (one byte) has become the industry-standard unit for organization
  of computer memory. 
  
  Modern computer hardware is much less error prone and, where  error-checking
  schemes are employed, nowadays they are  usually  cyclic-redundancy  systems
  that can detect and correct multiple errors. Also modern modern transmission
  protocols include error detection and correction. So the 8-th.  bit  is  not
  required as a check for storage or transcription errors.
  
  Unicode (or Universal Character Set - UCS) - an  industry-standard  encoding
  scheme for most characters in  the  alphabets  of  most  written  languages,
  including many symbols used in mathematics and  engineering.  The  range  of
  characters is  so  vast  that,  in  practice,  it  is  necessary  to  encode
  characters as  sequences  of  one-byte  tokens.  Some  tokens  indicate  the
  existence of yet more tokens to come, in UTF-8, UTF-16 and UTF-7. In  common
  with many mail  and  unix  systems  jot  uses  UTF-8  to  represent  unicode
  characters. 
  
  It's important to note that whereas UCS is basically a vast  character  set,
  UTF-8, UTF-16, UTF-7 ... are  coding  schemes  designed  for  efficient(ish)
  transmission, storage and handling of characters belonging to  that  set  by
  encoding them as sequences of bytes in the range 128-255.
   
  UTF-8 is a back-compatible expansion of the usual  8-bit,  non-parity  ASCII
  character set utilizing the, now redundant, 8th. bit and two or  more  bytes
  to yield an encoding space for many thousands  of  unique  character  codes.
  These can be used to represent all  of  the  unicode  characters.  Both  the
  windows and linux versions of jot support UTF-8 encoding.
  
  UCS-2 is an early attempt at  a  unicode  encoding  scheme  -  unfortunately
  whereas UCS-2 can address a character space of 64K characters (at most,  and
  in practice far less) the full chinese character set has in  excess  of  70K
  characters. This resulted in UTF-16 and UTF-32, UTF-32 abandons all pretence
  of packing efficiency and just gives each character 32 bits (a full word  in
  most modern computers). UTF-16, like UTF-8 is a variable-length scheme which
  can address most of the current unicode characters.
  
  While ICS-2 and UTF-16, may not be actually obsolete they were never  really
  much good. Consequently jot offers only very limited support for UCS-2, it's
  slightly more intelligent younger  sibling  UTF-16  or  it's  obese  brother
  UTF-32. UTF-16 is essentially UCS-2 with  some  complicated  variable-length
  coding.
  
  Jot makes  no  attempt  to  make  sense  of  any  of  these  encodings.  The
  recommended solution for UCS-2, UTF-16 and UCF-32 is to convert  them  using
  iconv (linux) or a similar windows file-format converter. The  filing-system
  explorer `get.jot` automatically uses iconv to read these formats  as  UTF-8
  but to be consistent with the jot policy of not making  unrequested  changes
  to files, the pathname is changed in the editor session.
  
  Various earlier schemes, designed for users working in their own  languages,
  allows an additional character space (theoretically  up  to  a  further  128
  characters) by setting the parity bit. This scheme, enshrined  in  microsoft
  code pages, became popular because it  allowed  several  sets  of  non-roman
  alphabets with the minimum of fuss and still preserves the ancient principle
  of one byte  equals  one  character  -  very  important  for  developers  of
  text-handling tools. This is fine for those, like most of us, who never have
  to write in more than one non-roman alphabet in any one document. There  are
  now various ISO-8859-x standards covering these character sets.

{{{ Practicalities of unicode etc. and jot
1.13.1 Practicalities of unicode etc. and jot
---------------------------------------------
  The linux version of jot of jot can read  and  manipulate  files  containing
  mixed UTF-8 and ISO-8859-x character encodings.  For  correct  rendering  of
  ISO-8859-x you must have your locale set correctly - see `-locale`. Any text
  entered will be encoded in UTF-8. Also, some care is required in the  choice
  of terminal - a recent version of xterm is a usually a good bet.
  
  With appropriate unicode support jot should, in theory, be  usable  for  any
  left-to-right written language. Support for right-to-left languages (Hebrew,
  Arabic etc.) may be possible later.
  
  The windows version can properly display files containing  either  UTF-8  or
  those containing ISO-8859-x - but  not  both  in  the  same  document.  This
  version  requires  the  correct  code-page  setting  for  the  file  -   see
  `%b=codepage` and `-Codepage`, by default  it's  set  to  codepage  65001  -
  that's UTF-8 to you and me. Again, any  text  entered  will  be  encoded  in
  UTF-8.
  
  The linux version can only read and display UTF-8 but, if it is required  to
  view or modify a UTF-n file there is a little script `iconv.jot`  which,  as
  it's name suggests, uses the unix utility iconv to  transform  the  file  to
  something that can be read, it will also write the  file  in  it's  original
  format.
  
  In general, jot represents unicode as strings of UTF-8 bytes. The exceptions
  to this are:
    - the OIC flavour of the `OI` command and
    - the `Q` command.
  
  To enter  UTF-8  characters  into  the  command  line  use  the  jot  script
  uc_basic.jot - this recognizes sequences of keystrokes and converts them  to
  the relevant UTF-8 byte sequence. To generate the euro symbol  (  €  ),  for
  example:
> {Esc u = E}
  In command mode, `uc_basic.jot` translates  this  sequence  on  the  command
  line, so start off by loading the basic unicode:
> uc_basic{F2}
  Then, for example, to search for the the string "cost €123.456", type:
> cost {Esc u = E}123.456F8
  The uc_basic.jot script added the u=E escape string to your key translations
  list and it substituted the UTF-8 encoding for € in the command line.
  
  Many IBM-compatible keyboards supplied in non-english-speaking parts of  the
  world, have non-roman characters. Assuming your system is set up  correctly,
  in linux, these keystrokes are converted to the correct  UTF-8  sequence  by
  the OS. If, for whatever reason, your linux  locale  (or  Windows  codepage)
  does not match your keyboard, you can specify a different  locale  with  the
  `-locale` (or `-Codepage`) qualifier. If you have some ISO-8859-x encoded in
  a different locale, you can change the locale of a buffer with the `-locale`
  CLI modifier.
  
  To suppress conversion of unicode, turn off unicode support for that  buffer
  with the `%b=unicode` [0|1] command. Turning unicode support off (%b=unicode
  0;) displays each non-ASCII byte as a tilde ( ~ ), unicode  support  can  be
  restored with %B=unicode 1;

}}}
{{{ Unicode - the gruesome details
1.13.2 Unicode - the gruesome details
-------------------------------------
  Internally, jot stores characters in whatever way as they  were  transported
  and then stored in the filing system. This is  important  because  it  means
  that files written by  jot  will  preserve  the  original  encoding  of  the
  original. To be quite clear on this, jot does *not* plant  BOMs  (byte-order
  marks) or change any character encoding except when explicitly requested  or
  for characters you have  changed  or  inserted  in  your  edit  session.  By
  default, the latter end up as UTF-8.
  
  When jot reads a UCS-2, UTF-16 or UTF-32 file, jot saves the BOM (which is a
  two or four-byte prefix added by microsoft and most other windows tools), it
  saves the BOM internally and re-prefixes the text as it is written back out.
  
  For example, the UTF-8 encoding for the euro sign ( € ) is E2, 82, AC -  jot
  will recognize these characters as UTF-8 and convert  them  to  the  correct
  coding for the euro symbol for display on the  screen.  It's  left  to  your
  terminal emulator to correctly interpret the UTF-8  string  to  present  the
  correct image on the screen.
  
  Note that the `R` and `OR` commands will  normally  traverse  the  specified
  number of characters irrespective of  how  many  bytes  have  been  used  to
  represent each character. Similarly the  `E`  command  normally  erases  the
  specified number of  characters  irrespective  of  their  byte  count.  This
  behaviour is modified by the `%b=unicode` command, which can be used to turn
  off all unicode support - with unicode disabled, R, OR and E commands  count
  bytes not characters. Erasing bytes belonging to  UTF-8  characters  is  not
  recommended - there is no guarantee that the line will display properly when
  unicode-support is turned back on.

}}}
}}}
{{{ About Journal Files
1.14 About Journal Files
------------------------
  Jot's journal files are designed to recreate a session in the  event  of  an
  abnormal exit. The journal file, along with a cache  of  files  and  queries
  read by the original session, can be used to retrace all your activity in  a
  recovery session so that you end up with an editing environment identical to
  that before the abnormal exit. In the future, journal  files  might  provide
  the basis for some sort of undo function - although it would be rather  slow
  by modern standards.
  
  By default no journal is maintained - the editor is not particularly  crashy
  and modern computers and power grids are generally reasonably reliable.  The
  endurance of battery-powered devices is also quite  good  these  days.  From
  time to time however, a can't-happen event demonstrates how these need to be
  reclassified as infrequent events and it's pretty distressing to  see  hours
  of work wiped out like that.
  
  When the CLI qualifier `-journal` is set, jot maintains a history  file  and
  snapshots of all the files it reads - these files are  normally  deleted  as
  the next session starts.
  
  In the event of a crash the journal files remain and the original session is
  re-created by reading in snapshots of the original files and re-running  the
  interactive commands.
  
  The process for a session editing myfile.txt is described below.
   
    - 1 Start the editor with journal files enabled:
$ jot myfile.txt -journal [ -<any other valid args>]
 
    - 2 After crashing,  restart  the  editor  but  run  the  recovery  script
      recover.jot - any other args will be ignored, the recovery process  will
      restart with your original arg list:
$ jot myfile.txt -st=recover
  
    - 3 If there are problems, then edit the command script recover_now.jot in
      your current directory and re-run the recovery using that:
$ jot myfile.txt  -init="%r=./recover_now.jot -asConsole"
  
  See `about not losing your work` and `recover.jot` for full details  of  the
  journal/recovery process.

}}}
{{{ About Tagged Text
1.15 About Tagged Text
---------------------
  Tags are used  to  mark  sections  of  text  with  some  special  attribute.
  Typically, this will be display colour but tags are also used internally  to
  identify and to protect hash-table target  points  or  to  add  metadata  to
  points in the text. The metadata is in the form of a text string, this is an
  essential ingredient in jot mouse and menu-driven interfaces where  the  tag
  metadata is used to identify a mouse-event callback.
  
  Those familiar with vim and Emacs tags (of the sort generated  by  exuberant
  ctags), should note that jot tags are nothing to do with that.  In  jotspeak
  these are index files - see `about index files`.
  
  Each colour tag indicates a colour pair (i.e. a foreground and a  background
  colour) to be associated with the tag see `%b=tagtype`. The tags  are  added
  to test with the `%b=addtag` command.
  
  The colours associated with the tags are defined in the `%b=tagtype` command
  - this associates a colour pair with  a  user-supplied  name  which  can  be
  referenced by  the  `%b=addtag`  command.  The  names  must  not  exceed  12
  characters.
  
  The `%b=addtag` command adds a pair of tags into the internal record data  -
  one identifies a start point and another the end of the tagged substring.
  
  The tag definitions are associated with the buffer and are displayed by  the
  `query buffer` query. The tags can be listed using the `query tags` query.
  
  For windows there is no limit on the number of named tags you can  define  -
  although there seems little point in going beyond the 256 unique colour pair
  combinations that are possible with windows.
  
  For linux, there are only  64  possible  colour-pair  combinations  and  the
  curses system allows only 63 user-defined colour pairs.  The  63-colour-pair
  limit is a system limit - the total number of colour pairs  in  all  buffers
  cannot exceed this.
  
  This is what happens if the text is changed  on  a  line  containing  tagged
  text:
    - If a change is made after (i.e. right-of) the tagged text  there  is  no
      effect on the tagging.
    - If the change happens before (i.e. left-of) the  tagged  text  any  tags
      then the tags are shifted left or right as appropriate.
    - If text is inserted deleted or substituted in a  tagged  substring,  the
      extent (n. of characters) of the tag remains unaffected but text covered
      is changed.
    - If the record is broken mid tag (e.g. by a B  or  A  command)  then  the
      extent of the tag is reduced to match the new record length.
    - If a new colour tag starts inside the scope of some outer colour tag the
      display effect is not guaranteed but, with the current  version  of  the
      editor, the inner tag is invisible even if it's end point is  after  the
      end of the first tag.

}}}
{{{ About the Operand Stack
1.16 About the Operand Stack
----------------------------
  The operand stack allows  simple  arithmetic  operations  and  tests  to  be
  performed on objects (typically integer  quantities)  held  in  a  push-down
  stack. It can also hold real numbers and temporary buffers  created  by  the
  system query commands. The full range of operations is described  in  `Stack
  Operations`.
  
  The underlying C-language type for integer values is  long  long,  for  real
  values it's double.
  
  For the benefit  of  those  not  familiar  with  the  notion  of  stacks  in
  computing. Stacks are analogous  to  those  spring-loaded  plate  stacks  so
  beloved of institutional caterers. As clean plates are delivered, the  stack
  gets pushed down, as plates are taken off the next one pops up.  Note  that,
  when plates are added individually, the last one on is the first one  off  -
  this is a key property  of  computer  stacks  -  sometimes  known  as  LIFOs
  (Last-In First-Out).
  
  And so it is, with our operand stack, new values are 'pushed' onto the stack
  and later 'popped' off for processing. Each item on the jot stack is wrapped
  up in a little data structure called a stack frame, which play the  part  of
  plates in the above description. Many common arithmetic  operations  require
  two operands, for these, the top two operands are removed and the result  is
  pushed onto the stack.
  
  A stack frame can be detached from the stack, assigned  a  name  and  loaded
  into a hash table (see `about hashtables`),  from  there  it  can  later  be
  referenced by the same name and restored to the stack.
  
  Essentially the stack objects can interact with the text and the system  the
  following ways (see `Stack operations` for the full list):
    - Integer or real numbers picked up from the text (e.g. with `oi`),
    - Integers or real-number literals from the command line (see `OL`),
    - Integers generated by the random-number generator (see `OA`),
    - Integers describing the current focus  point  (i.e.  buffer  i.e.,  line
      number `ON` and character number`OC`),
    - Integers, Reals or Buffers held by hashtable data  objects  (see  `Using
      hashtable data`)
    - A temporary buffer created for as a destination buffer for  any  command
      that directs it's output to a buffer eg: %q~=date;.
    - Arithmetic and logical operations can be performed on  numerical  values
      (see `O+`, for example.
    - Values and strings can be written to the buffer text (see `OO`).
    - Numerical values can be extracted by indirect references - eg: %w '~;  -
      sets the window size to an integer picked up from the stack. If the  top
      stack frame is a buffer, then the current character of that buffer  must
      be pointing to one or more digits for conversion to  an  integer  -  see
      also `About command parameters`.
      
  If performing a straightforward text abstraction  (e.g.  `A`~)  or  maybe  a
  query to stack with %q~=... (see `%Q`), a new buffer  stack  frame  will  be
  created at the top of the stack. If, however, you  are  doing  a  cumulative
  abstraction (i.e. a~+,a~- or a~. - see `A`) then the item at the top of  the
  stack must be a buffer stack frame.
      
  Jot supports the usual arithmetic and logical operations and can use  values
  in the stack to control programme flow or values can be written to the text.
  Addition, for example, pops the top two values and  pushes  their  sum  back
  onto the stack (see `O+`).
  
  All arithmetic and comparison operations will  work  with  integer  or  real
  values, for mixed operations integers are first converted to reals  and  the
  results of such arithmetic is always real. Any attempt to perform arithmetic
  on a buffer-type will fail.

}}}
{{{ About Hashtables
1.17 About Hashtables
---------------------
  Each buffer can have an associated hashtable. Hashtables are  referenced  by
  keyword - the keyword can be any unique string and each hashtable entry  may
  point to one of the following classes of data object:
    - A pointer to some point in the text - a FindObj,
    - a stack-frame image - a DataObj,
    - a file section (a seek offset and a byte count) - a SetsectObj, 
    - a file  section  (a  pathName,  seek  offset  and  a  byte  count)  -  a
      SetfsectObj,
    - a (stack) data object DataObj - interchangeable with the stack  and  may
      be an integer or real value or a sub-buffer,
    - a deleted object - a ZombieObj.
  Any number of these five types of entry may coexist in the  same  hashtable.
  Note also, the buffer-type data entries may each support child hashtables.
  
  The FindObj is essentially an index which allows fast references to  indexed
  text. Hashtables are a useful alternative to searching with the `F`  command
  when the buffer is extremely large or when a macro makes many references  to
  moderately large buffer making the searching a significant proportion  of  a
  macros execution time (see `hashtable jump`)
  
  The DataObj is a stack-frame (see `about the operand stack`) that  has  been
  detached from the top of the stack and can be copied back to  the  stack  as
  required, this works for any stack-frame type -  integer,  float  or  buffer
  (see `hashtable data`, `OV` and `OQ` commands). Data objects can be  swapped
  between the stack and the hashtables, note that the data-object buffers  can
  also have hashtables, leading to the possibility of unlimited hierarchies of
  hashtables.
  
  For data objects assigned to one of the main buffers, the syntax  is  pretty
  simple - to extract the value of an object  named  "fred"  hanging  off  the
  current buffer it would be:
> ov/fred/
  
  But to access an object named 'fred' hanging  off  data-object-buffer  named
  'jim', which is itself hanging off another data-object-buffer named  'brian'
  hanging off the primary buffer ( . )  -  we  might  just  plod  through  the
  hierarchy - first making the parent buffer current then  descending  to  the
  child ... etc.:
> z.oq/brian/z~ oq/jim/z~ oq/fred/
  
  That's pretty painful - so there is a path-specification syntax designed for
  delving into buffer hierarchies, without having to change buffers:
    [<bufferKey>=][<PathElement1>[|<pathElement2>[| ... ]]]
  This is how we might use this syntax to access  the  object  "fred"  in  the
  hierarchy described above:
> oq/.=brian|jim|fred/
  
  While this syntax simplifies  usage,  it  still  requires  three  relatively
  expensive hashtable operations to locate the data. Note that that,  although
  some path depth may be desirable - possibly  essential  for  some  recursive
  functions, it can get expensive and programmers should maybe strive too keep
  their data structures as flat as possible.
  
  The SetsectObj is intended for the handling of very large files, it  defines
  the byte-offset and  byte-count  of  sections  of  files  -  see  `hashtable
  setsect`, `hashtable setfsect` and the -section=<hastableKey> section of the
  `%I` command.
  
  The SetfsectObj is similar to SetsectObj except  that  it  also  includes  a
  pathname and is intended for support of collections of files  -  see  `about
  large collections of files`
  
  Typically what happens is the text is first scanned to identify  the  target
  points, and create hashtable entries. When queried, the editor  picks  up  a
  reference to the original target point an restores the editor focus to  that
  at the time when the entry was created.
  
  The ZombiObj exists because the gnu hashtables do  not  support  removal  of
  entries. When a `hashtable delete` request is made, the hashtable  entry  is
  left in place but the object it points to becomes a zombie.
  
  When a buffer object is duplicated on the stack it is said to be cloned. The
  original and the clone are identical and point have  pointers  to  the  same
  underlying data structure.
  
  Note that stack-based buffer that has already been used to define  one  data
  object cannot be used to define another. This restriction is, hopefully, not
  very onerous since the same data can be accessed via the first data  object.
  The restriction comes about because, put simply, an object can only have one
  parent tree. In practice, as the hash-table trees are deleted, a data object
  shared between two different trees would acquire an undefined status.
  
  When a hashtable is destroyed by `hashtable destroy` or it's  parent  buffer
  is cleared (eg by the `A`, `%D`, `%Q`, `%I`, ... commands), then all of it's
  it's objects and any descendants are also destroyed. There may be clones  of
  destroyed buffers on the stack or the current buffer may be  a  clone  of  a
  buffer previously dangling off a destroyed hashtable. These remain effective
  and usable - but their hashtable path is removed as their parent buffers  no
  longer exist.
  
  For more details on hashtables, take a look at `Using Hashtables`.

}}}
{{{ About project files
1.18 About project files
------------------------
  Jot can be used to maintain a  stand-alone  file  or,  for  big  complicated
  projects, a suite of files  including  source,  documentation  and  whatever
  other text files that might constitute a code-development project.
  
  Project files should be placed in a dedicated  directory  (the  project-file
  directory) with a  startup  file  containing  all  project-specific  startup
  commands. The actual project files are usually ignored by the  editor,  they
  may be  used  for  storing  informal  project-specific  notes,  to-do-lists,
  checklists etc.
  
  An example project directory, startup file and project files are to be found
  at ${JOT_RESOURCES}/ide/... this directory was set up as an example for  the
  `ide.jot` script. It has the following subdirectories:
    - hello - a work directory for the hello project,
    - ed - a work directory for testing a development version of jot.
    - tree - a work directory containing a a simple suite of source files  for
      demonstration and testing of ide.jot and
    - projects - the project-file directory, this contains the following:
      - ide_hello - the project file for the hello.c project using ide.jot
      - ide_jot - the project file for jot development using ide.jot
      - ide_tree - the project file for the simple tree project using ide.jot
      - jot - the non-ide project file for jot development and
      - startup.jot - contains project-specific jot commands for all  projects
        in this project directory.
        
  Th example projects in  ${JOT_RESOURCES}/ide/projects  are  structured  such
  that the work directory sits alongside the projects directory,  in  practice
  the work area can be anywhere convenient to you.
        
  To initiate a project session, first cd to the projects directory then start
  the  editor  with  the  appropriate  project  file.  The  projects-directory
  startup.jot will set up the session using commands specified for your chosen
  project file. Note that  the  contents  of  the  project  file  are  usually
  ignored, you can use the project file for informal  notes,  tests,  examples
  checklists and to-do lists.

}}}
{{{ About index files
1.19 About index files
----------------------
  Index files contain pointers to specific points in one or  more  text  files
  and are used to facilitate rapid and convenient context changes.
  
  Jot supports two types of index files - the native jot format which is  used
  to drive the `%I` command with a seek and section-size specification and the
  vim-style tags file generated by the ctags unix command.
  
  The native-jot index files are optimised for navigating *very* large  files,
  where it would be impossible, or very inconvenient, to load and  search  the
  whole file - see `about large files`. The native-jot  index  form  has  also
  been adapted for use with large collections of files eg the source-file tree
  for a complicated programming project -  see  `about  large  collections  of
  files`.
  
  Jot also supports the  vim-style  tags  files,  these  can  be  conveniently
  generated by generated by ctags.
  
  The native-jot indexes supported  by  the  jot  scripts  `big_file.jot`  and
  `multi_file.jot` are significantly faster for very large  files  since  they
  use a filing-system seek to access the files and only read the  sections  of
  interest. The downside is  that  writing  modified  versions  of  the  files
  requires special care. Writing is supported by  big_file.jot,  the  modified
  file will usually require re-indexing as the seek points will have changed.
  
  In contrast, vim-style tags files read the entire file to a buffer making it
  easy to write an updated version but, because it needs to search the  entire
  file for each new section heading, it can be slow if there are any very  big
  files in the tree - this is most unlikely for normal source-code trees.

}}}
{{{ About Large Files
1.20 About Large Files
----------------------
  A working definition of a very large file is one big enough  to  exceed  the
  capacity of a text editor as supported by our system. That definition  takes
  into account various system configuration  and  tuning  considerations  like
  memory size swap size disc bandwidth cache size and all that sort of stuff.
  
  The main problem with *very* large text files is not changing them but  just
  viewing them. Although These files are generally both generated and read  by
  machine they are presented in a text form because people  need  to  work  on
  them when something goes wrong.
  
  These files are frequently used as intermediaries in CAD design flows  using
  design systems from rival vendors. Many are based on spice  netlists  and  a
  spice netlist of just a section of a modern chip is  never  going  to  be  a
  small file.
  
  So the way jot approaches  this  problem  is  to  acknowledge  that  nobody,
  pondering the problem of "what went wrong" or "why am I  seeing  that  error
  report" or "why that timing violation" is ever going to want to look at  all
  xxxGb of a file - only the bits that an investigation leads to. So we need a
  method that lets us pull in the relevant  bits  of  information.  There  are
  several qualifiers to the %I command that allow us to pull in selected parts
  of a big file and make it viewable - even  if  not  editable.  In  any  case
  modifying these files wouldn't do us much good  -  we'd  be  corrupting  the
  design flow.
  
  The `%I` command has a number of qualifiers that are designed to  facilitate
  the reading big files by the spoonful but this is of little  use  unless  we
  already know which bits to read and precisely where they  are.  In  %I,  the
  -hold, -bytes and -block qualifiers can be used to read large files  by  the
  spoonful (or, indeed, by the  bucketful)  for  filtering  or  generating  an
  index, as in the `big_file.jot` script. This  script  gives  a  more-or-less
  normal editing environment for specified sections of large files.

}}}
{{{ About Large Collections of Files
1.21 About Large Collections of Files
-------------------------------------
  Many modern editors offer methods of  maintaining  source-code  trees  using
  some sort of index file. In vim and Emacs thes index files are  called  tags
  files but in jotland we like to keep things simple, and jot index files  are
  just called index files.
  
  When working on some big complicated project, involving lots of source files
  or maybe, after downloading some source-code, one of the first  things  many
  of us like to do is to browse the source code to get some  idea  of  how  it
  works. 
  
  Unfortunately, the more complicated systems consist of  a  large  number  of
  source files and, without some  prior  knowledge  of  how  the  sources  are
  structured, it can  be  difficult  to  see  what's  going  on.  The  scripts
  `multi_file.jot` and `ctags.jot` are designed to help with this problem.
  
  These scripts each support  a  separate  index-file  format,  multi_file.jot
  supports one based on an extension of the form used  for  large  files  (see
  `about large files`) and ctags.jot supports vim-style tags files  which  can
  be conveniently generated by Exuberant Ctags.

}}}
}}}
{{{ Jot Programming
2 Jot Programming
-----------------
 
{{{ Success, Failure and Errors
2.1 Success, Failure and Errors
-------------------------------
  Most commands set a success/failure flag. Failures are quite normal in JOT -
  many commands are used simply to locate structures in  the  text  and  these
  failures are normally handled in the command sequence. One may, for  example
  want to test if the cursor is at the end of a record, then we might use  the
  move right (`R`) command and check it's status - a failure can  only  happen
  when the cursor is at the end of a line.
  
  Errors are more serious (typically a syntax error in your coding or  an  I/O
  operation that failed), these result in an immediate exit from  the  command
  sequence with a message in the console area. By default,  errors  will  stop
  execution of the current command sequence with a message  indicating  what's
  gone wrong - these can be suppressed using `%s=verbose` or `-quiet`.
  
  There is a message associated with failures too but these are suppressed  by
  default. If a command sequence  ends  with  the  error  flag  set  then  the
  termination message "{Command-sequence failed.}" is  issued  with  a  simple
  diagnostic indicating which command failed.
  
  If a command fails and no command is found to handle the failure,  then  the
  block or macro fails, if the failing command was not in  a  block  or  macro
  then a message like this appears at the console:
> {Command-sequence failed.}...<failingcommand>...
  
  See `%s=verbose` for details on controlling the level of error reporting.
  
  Failing commands are handled as follows:
   
     - If the next command is the ignore-failures command `?`, the failure  is
       ignored and processing continues.
        
     - If  a  failure  handler  exists  (see  the  `,`  command),   then   the
       failure-handler code is executed
       
     - If there is no failure handler, then the current block exits (see  `Jot
       command structure` and `(` `)` ).
        
       If the block was an infinite loop i.e. '( ... )0' then the  loop  exits
       without passing on the failure, all other types of blocks fail.
       
     - The reverse status command `\` reverses the  status  of  the  preceding
       command you can also reverse the status of a command that's already had
       it's status reset by the  `?`  command  -  in  this  case  the  command
       *always* fails - which can sometimes be useful.

}}}
{{{ Jot command structure
2.2 Jot command structure
-------------------------
  Jot allows users to construct macro-commands  which  can  apply  tests  make
  decisions and return results - they can also, of course, alter your text.
  
  Most commands are capable of failure, by looking at the status returned by a
  command we can often deduce something useful about the  text  we're  working
  on. If, for example, the `r` command fails it can only mean that the  cursor
  is already at the end of a line, if `f`/<string>/ fails then it  means  that
  string does not exist. When writing a macro-command these failures  are  not
  so much disasters as potentially useful results.
  
  Jot  commands  are  organized  into  blocks  bounded  by   round   brackets.
  Optionally, the sequence of commands within a block may be broken by commas,
  the sequence following the comma take control if a  failure  occurs  in  the
  sequence before the comma -  giving  us  an  if-else  structure.  Since  the
  else-sequence might fail successive commas can be deployed giving us  an  if
  ... elseif ... elseif ... structure. Ultimately, if the last sequence in the
  block fails then the *entire* block returns a failure. Blocks may be  nested
  to any number of levels.
  
  Jot blocks, like most jot commands, can be given a repeat count. As with jot
  commands this may be infinite the repeat count for a block must be a decimal
  literal immediately after the end brace. As with other jot commands  for  an
  infinitely repeating block, set the repeat count to zero. In the event of an
  unhandled failure occurring in a repeated block, the block exits immediately
  even if it has not gone through all it's iterations. In these  circumstances
  a   block   with   a   finite   repeat   count   returns   a   failure,   an
  infinitely-repeating block always returns success.
  
  A sequence of commands can be enclosed within parenthesis (see `(`  and  `)`
  ), this has the following effects:
   
    - The block can be used to define the  extent  of  `success,  failure  and
      errors` - in the phrase (r, m) ... , for example, if the r command fails
      (because we're at the end of a line), then it moves to the next line.
      
    - The block can repeat commands for a predefined number  of  iterations  -
      for example, the phrase (mi/#/)10 will insert a # at the  start  of  the
      next 10 lines. If a command in this type of block should fail, then  the
      loop exits early and the block sets the failure flag.
      
    - The block can be repeated to exhaustion - i.e. until something  fails  -
      for example l0(q/A-Z/c, r)0 will  change  the  case  of  all  upper-case
      characters on the line. In this case, a failing command will also  cause
      the block to exit, but the failure flag is reset.
      
    - The block's status can be handled like the status of any other command:
     
      - ( ... )? and ( ...  )123?  -  resets  the  failure  flag  following  a
        failure.
       
      - ( ... )\ and ( ... 123)\ reverse the status on exit.
      
      - ( ... )?\ and ( ... )123?\ - these blocks will always fail.
       
      - ( abc ) def , ghi - if the '( abc )' block fails then commands ghi are
        executed, otherwise it takes commands def.
        
    Here's a few examples:
      - ( ... , )0 - this block will loop indefinitely.
      - ( ... ,) and ( ... )? - these two have an identical effect,

{{{ Finite Repeat Block Example
2.2.1 Finite Repeat Block Example
---------------------------------
  (f/fred/s/bill/)23 - is  a  finite  repeat  block,  it  seeks  the  next  23
  occurrences of fred and substitutes bill. If there are less then 23 freds in
  the text then the F command fails and so to  does  the  complete  block.  If
  there are more than 23 then, on completion, there will still be some  fred's
  left.

}}}
{{{ Conditional Repeat Block Example
2.2.2 Conditional Repeat Block Example
--------------------------------------
  (f/fred/s/william/)0 - is a conditional repetitive block, the thing keeps on
  finding freds and substituting williams until all  freds  have  been  found,
  then the `F` command fails, the block exits but in this case the block exits
  successfully.

}}}
{{{ Status Checking Example
2.2.3 Status Checking Example
-----------------------------
  (f1/fred/s/bill/, f1/jim/s/dave/) - If the current line has a fred at or  to
  the right of the current character, it will get changed to bill. If there is
  no fred then the failed f1 command leaves the  current  character  unchanged
  and searches the line for jim, if found then it gets changed to dave.

}}}
}}}
{{{ About macros
2.3 About macros
----------------
  Any buffer can hold sequence of commands, the commands in the buffer can  be
  executed as a macro command. Macro commands can  call  other  macros  -  but
  recursive macro calls (where a macro, or one of it's children, calls itself)
  are not allowed. The command to run a macro is a single quote ( ' ) followed
  by the buffer key.
  
  To run a macro place the macro-buffer key it in a command string prefixed by
  a single quotemark ( ' ) e.g:
> %d3=f/my_string/
  this macro is run as follows:
> '3 

}}}
{{{ Calling subroutines by name
2.4 Calling subroutines by name
-------------------------------
  Jot offers a primitive form of subroutine support, Sequences of commands may
  be entered in a buffer  and  then  referenced  using  the  `hashtable  call`
  command.
  
  Code  can  be  designed  to  operate  only  on  the   stack   resulting   in
  procedure-like behaviour. There  is  no  formally-defined  parameter-passing
  mechanism - programmers may use the stack or global buffers. But, it  should
  be noted, that there is no protection of stack objects - programmers must be
  very careful to maintain strict discipline in their stack operations.  Also,
  the only way back to the calling macro is to reach the  end  of  the  called
  sequence - there is no return command.
  
  The code repository set up by `startup.jot` is in the '  buffer.  The  first
  line of the code is, by convention, assumed to be the routine  name  and  is
  ignored by the %h=call command. 
  
  Where there are many routines defined by  the  normal  startup  script  (see
  `startup.jot`) saved in a buffer, there is no explicit mark denoting the end
  of each. Instead, the first line of the next  routine  is  used  as  an  end
  marker. The %h=call behaviour detects the end of a routine by  checking  for
  the existence of tags  on  each  record.  Any  tag  is  assumed  to  be  the
  hash-table target for the next routine in the repository. This  very  simple
  approach breaks if, for any reason, other tags have been added - so  do  not
  apply the `jot.jot` to the code repository.

}}}
{{{ About metasyntax
2.5 About metasyntax
---------------------
  The following metasyntax has been used in this user guide:
    - a '$' in the first column represents a CLI prompt, the following text is
      something for you to type in response to whatever prompt your CLI uses.
      
    - a '>' in the first column represents a jot prompt, the following  string
      is something you type to the editor.
      
    - A key name in curly  brackets  indicates  that  this  is  a  button,  or
      sequence of buttons to press e.g:
> fred{F8}        - type the word 'fred' then hit the F8 function key
> fred{Shift+F8}  - type 'fred' then hold the Shift key and hit F8
> fred{Ctrl+F8}   - type 'fred' then hold the Control key and hit F8
> fred{Alt+F8}    - type 'fred' then hold the Alt key and hit F8
> 7 12{Esc b x} - type 7 a blank then 12 then hit the Escape key followed by
      the letter b followed by the letter x.
    
    - Anything else in angle brackets is intended to represent some  class  of
      command or command argument. e.g. <failingCommand> denotes some  command
      that failed, <n> any number, <alphaString> - any number of  alphabetical
      characters.
      
    - Something in double angle brackets  (e.g.  <<this>>)  represents  a  jot
      function defined in the startup file - normally you will  be  given  the
      key bindings to type in. You will see these mentioned in the user  guide
      ${JOT_HOME}/docs/jot_ug.html    and    in    the     startup     scripts
      ${JOT_HOME}/coms/startup.jot and ${JOT_HOME}/coms/curses_keys_<TERM>.jot
      
    - Something  in  square  brackets  is  optional  [   -bells][   -whistles]
      indicating that it's valid to give -bells and/or -whistles  or  neither.
      In some cases they are nested - e.g.: [ -bells[ -whistles]]  -  in  this
      case valid usage would be give -bells, -bells and -whistles or neither.
    
    - A list of things, separated by vertical bars ( | ) are valid options, in
      some cases you must give at least on of them  -  the  accompanying  text
      should clarify this.

}}}
{{{ Percent-command syntax
2.6 Percent-command syntax
--------------------------
  Typical syntax of a percent command (for details see `percent commands`):
%da=f/example/;
  The first character after '%' is the command character,  'd'  in  this  case
  defines a buffer. As with many percent commands, the  next  character  is  a
  buffer key. The text following the '=' is normally a string argument for the
  command.
  
  For most of these commands, all or part of the  text  following  the  equals
  sign ( = ) may contain an indirect reference to the  current  line  of  some
  other buffer e.g:
%d$=dir /home
%q~=dir '$
  or, more usefully:
%q$=env JOT_HOME; m
%q~=dir '$
  The main exception is `%E` - the single-quote character (  '  )  being  very
  important in unix shell commands so any ' characters are passed  through  to
  the CLI unchanged.
 
  Historically, these commands occupied a complete command line on  their  own
  with no terminating character. This made it difficult to incorporate percent
  commands in command sequences, so now they may be terminated by a  semicolon
  ( ; ) and other commands may follow, in the same line. The  only  exceptions
  are comments - where all text to the right of the %% is ignored.
  
  Unfortunately, the string argument may contain semicolons or  apostrophes  -
  these are quite commonly occurring characters in various  percent  commands.
  Semicolons and apostrophes in the command text can be escaped  by  prefixing
  with a backslash ( \ ) thus:
> %da=123\;456\\;789;
  this should result in buffer ( A ) being set to  "123;456\;789".  Sometimes,
  of course we might want to use an apostrophe as an apostrophe  -  then  this
  too can be escaped with a backslash:
> %x=The system\\'s broken - sorry!
  
  Now that's OK for programming jot code, unfortunately users  will  sometimes
  want to define parameters  containing  semicolons.  All  parameters  to  jot
  function-key functions pass through a a %d - users would find  it  to  be  a
  real drag having to remember to escape these every time they are entered. To
  avoid this, there is an explicit command terminator syntax that's  only  for
  picking up parameters: " -hereEndsThePercentCommand;".
  
  A function requiring a parameter that might include a semicolon  might  pick
  it up in buffer ( $ ) like this:
    %d$=##" Insert string> " -hereEndsThePercentCommand; ...
    
    - A semicolon escaped by a backslash works in %E:
> %ea=( cd JOT_RESOURCES} \; ls -l ); f/ t.t/

}}}
{{{ Using Hashtables
2.7 Using Hashtables
--------------------
  Hashtables offer a good way of  rapidly  accessing  data  objects  scattered
  around in an unstructured mass. Although initially introduced to the  editor
  as a way of finding predetermined points in a large file image  (see  `Using
  Hashtables to Locate Text`), their range has been expanded  to  calling  jot
  functions (see `calling subroutines by name`), fast access  of  large  files
  (see `about large files`), accessing large collections  of  moderately-sized
  files (see `about large collections of files`) and storage and retrieval  of
  generic data (see `using hashtable data`).
  
  All %h commands can refer to hashtables belonging to other buffers e.g.  the
  command "%hz=jump fred;'" will search for an entry "fred" in  the  hashtable
  associated with buffer z, whereas "%h=jump fred;" will search the  hashtable
  in the current buffer. 

{{{ Using Hashtables to Locate Text
2.7.1 Using Hashtables to Locate Text
-------------------------------------
  The `hashtable add` and  `hashtable  jump`  commands  provide  a  method  of
  indexing and rapidly returning to sections on the text image.
  
  Internally, this works by storing internal memory addresses of text  targets
  in the hashtable. The hashtable entry points to a  record  descriptor  which
  remains constant even if text has been added or removed in the buffer and  a
  target-point tag is inserted in the record metadata.
  
  The target is the selected substring at the time when the  hash-table  entry
  was first created. Now future changes to the  text  may  change  the  record
  containing the target but the target  substring  must  match  the  hashtable
  entry. In this context there are two important classes of change to consider
  - changes which only move the target to a new location and changes that
  delete the target string.
  
  The `hashtable jump` command returns to same focus point as when  the  entry
  was created with the `hashtable new` or `hashtable add`  commands.  It  also
  maintains the original line number - this might now be wrong  since  changes
  to the target buffer may have altered the  actual  line  number  -  but  the
  linenumber entry in the hashtable is out of date. If this is a problem  then
  use the `hashtable fix` command to update line numbers held in hashtables.
  
  When the context switch happens, the line number in the target buffer is set
  to the line number at the time when the entry was created. This may  now  be
  incorrect if records have been  added  or  deleted  between  the  hash-table
  target points.
  
  The editor automatically adjusts hashtable entries when changes  have  moved
  the target. It offers several options for situations when the target  string
  has been deleted.
  
  The simplest method is to  make  the  target  buffer  readonly  (the  buffer
  containing the  target  string  -  see  `%b=readonly`).  Making  the  buffer
  ReadOnly is a simple and totally effective but it is quite restrictive.
  
  Another option is to automatically destroy the hashtable when target records
  are deleted - this is appropriate when the usage  implies  that  any  change
  requires a hashtable rebuild - see `hashtable create`.
  
  Another option is to protect records  containing  the  target  strings  from
  deletion - see `hashtable create`.
  
  Another option is for the hashtable target points to be adjusted to point to
  the next available point in the text - see adjust in `hashtable create`.
  
  Finally, the default option,  is  to  just  remove  the  hash-table  entries
  pointing to deleted targets, this is the default behaviour - see  delete  in
  `hashtable create`.
  
  For examples of %h=jump - look at ${JOT_HOME}/coms/qr.jot (see `qr.jot`).

}}}
{{{ Using Hashtable data
2.7.2 Using Hashtable data
--------------------------
  The primary focus for arithmetic and logical operations is  the  stack  (see
  `about the operand stack`) - values and strings can be placed on the  stack,
  manipulated and either written to some buffer or used to  control  programme
  flow. The `hashtable data` command is essentially the declaration of a  data
  object. The value of this object can be copied to and from the  top  of  the
  stack.
  
  Once defined by the hashtable data command, a value can  be  assigned  using
  the `OV` command which pops the stack and  copies  the  value  to  the  data
  object.
  
  Note that the hashtable data command does not require the specification of a
  data type - the type of data (an integer value, a real value or a string) is
  defined at the time when a value is assigned. In  fact  it  is  possible  to
  change the type of a data object any number of times.
  
  The value can be retrieved using the `OQ` command, essentially  the  reverse
  of OV, the value is copied to a new stack frame and pushed onto the stack.

}}}
}}}
{{{ The jot debugger
2.8 The jot debugger
--------------------
  The editor has various features designed for  the  monitoring  of  execution
  flow and the location and analysis of bugs. There  are  various  methods  of
  probing the internal state of the editor and various methods  for  selecting
  break points. It supports a simple single-step debugger with various options
  for controlling the step range and the amount of  information  displayed  at
  each step - see `About jot debugging`. The break point can be defined in the
  following ways:
    - explicitly by inserting the `T` command in the code what this does is to
      set the trace vector (see `%s=trace` and `%s=tracedefault`),
    - by setting the command counter - see `%s=commandcounter` or
    - by selecting one of a set of predefined event classes - see `%s=trace`.
    
  The T command is easily inserted into the source code of any  script,  macro
  or command line. Where this is not selective enough, the T  command  can  be
  made conditional e.g.: ... (v/fred/t, ) ... will only trigger the trap  when
  the text at the current character matches the string "fred".
  
  The command counter method is useful when a  data-sensitive  failure  occurs
  deep into many re-iterations of programme loops. In order to use this method
  successfully it is first necessary to identify the command count just before
  the point of failure. The `%s=verbose` command  can  be  used  to  call  for
  failure reports from all failing commands,  along  with  associated  command
  counts. Under these  circumstances  many  thousands  of  messages  might  be
  generated but, normally,  it  is  only  the  last  two  or  three  that  are
  significant. It's a good plan to reduce the size of the display window  (see
  `WindowShrink`) in order to maximize the size of the  console  area  of  the
  screen. It may even be necessary to run in -tty mode  so  that  all  of  the
  messages can be scanned.
  
  Finally, one can set a breakpoint to go off every time  a  particular  event
  occurs:
    - a new line is read from the command stream,
    - a new script has started (see `%R`),
    - a new macro-command has been called,
    - A Ctrl+C interrupt has been received,
    - a command failure has occurred or
    - every new command.

}}}
{{{ Jot for experienced ecce users
2.9 Jot for experienced ecce users
-----------------------------------
  The first, most obvious difference between jot and ecce is  that  jot  is  a
  screen editor - it maintains a window as an accurate reflection of the  what
  the file image is currently looking like.
  
  The next significant  difference  is  that,  whereas  ecce  would  only  use
  printing characters for controlling the editor, jot also  utilizes  function
  keys and, where available, the numeric and mid keypads.
  
  Internally, the structure is  quite  different,  ecce  used  the  buffer-gap
  structure which made good use of simple memory schemes available  in  1960's
  minicomputers. In contrast jot uses  a  less  efficient  but  more  flexible
  record-descriptor structure better suited to  modern  approaches  to  memory
  management.
  
  Comparing the command set of ecce with jot, we see a few old favourites have
  been culled (D, T, U  have  been  abolished  or  reassigned  new  meanings).
  However, for the percent commands, the cull is more like a total bloodbath -
  only %A, %C, %I and %O remain in anything like their original forms.
    - `A` - can now abstract to the nearest character (see `N`), and  has  new
      '+', '-', '.', '*' and '&' qualifiers.
    - `B`, `C` - identical.
    - D Abolished.
    - `E`, `F`, `G` - pretty much unchanged.
    - `H` - has new '*' qualifier.
    - `I`, `J`, `K` and `M` - unchanged.
    - L - abolished - use `R`- instead.
    - `N` has new '.' qualifier for abstraction to nearest character.
    - `M` - has new '*' qualifier (move window).
    - O - Reassigned - now prefix for `stack Operations`.
    - `P`, `Q`, `R` and `S` - unchanged.
    - `T` Reassigned as Trace point, traverse replaced by f/<string>/- .
    - U - abolished.
    - `V` - unchanged.
    - `W` - new command - refresh Window.
    - `X` - was macro-X call, now eXits or repeats selected block.
    - `Y` - was macro Y call, now Y command (move in column).
    - `Z` - was macro Z call, now zoom (i.e. change current buffer).
    - `%A` - Now accepts exit status and exit message.
    - `%C` - essentially unchanged.
    - `%D` - Reassigned, now defines a one-line macro/text buffer.
    - `%F` - Reassigned - now regular-expression search.
    - `%G` - Reassigned - now defines (Gets) multi-line macro/buffer.
    - `%H` - New Command - for hashtable maintenance.
    - `%I` - unchanged, new options.
    - `%L` - Reassigned - (case sensitivity set by %S)  now  defines  terminal
      line length.
    - `%M` - Reassigned prints message to console area.
    - %N - Abolished.
    - `%O` - Still writes file image to filing system but with new options.
    - `%Q` - Reassigned - now system Query.
    - `%R` - Reassigned - now Run a command script (file).
    - `%S` - Replaced by `Z` command, %S now System interaction.
    - %T - Abolished.
    - `%U` - Reassigned - (now use %S to set case  sensitivity)  now  reverses
      last substitution.
    - `%W` - Reassigned - now assigns buffers to windows.
    - `%X` - Reassigned - now prints specified message in the console area and
      eXits.
    - %Z - Abolished.

}}}
}}}
{{{ Editor commands
3 Editor commands
-----------------
  JOT has the  following  commands,  meta-commands  and  modifiers,  most  are
  capable of failing in some way, failures normally result in the  raising  of
  the failure flag (see  `success,  failure  and  errors`),  this  can  affect
  execution flow:
    - `A` - Abstract (remove or copy) all Text From Note Point (see `N`).
    - `B` - Break Line At Current Character e.g. b2
    - `C` - Change Case e.g. c5
    - `E` - Erase bytes [defaults to 1] e.g. e5
    - `F` - Find Substring e.g. f/fred/
    - `G` - Get (read) Some Lines From Terminal e.g. g3
    - `H` - Here (copy Text Buffer Here) e.g. hq
    - `I` - Insert Substring e.g. i/fred/
    - `J` - Join This Line With Next/previous Line(s) e.g. j-3
    - `K` - Kill (delete) record(s) e.g. k
    - `M` - Move To A New Line e.g. m
    - `N` - Note This Point In Text For A Later Abstract Operation e.g. n
    - O - `Stack Operations`
    - `P` - Print Line(s) e.g. p9
    - `Q` - Qualify (tests next chr. for membership of string) e.g. q/a-zA-z/
    - `R` - Move Cursor Right e.g. r
    - `S` - Substitute current substring for given string e.g. s/fred/
    - `T` - enter (Trace) debug (single-step) mode e.g. t
    - `V` - Verify (tests immediate for match with substring) e.g. v/fred/
    - `X` - eXit or re-iterate current (or selected parent) block.
    - `Y` - Move Cursor In Y Axis e.g. y3
    - `Z` - Zoom to Another Buffer e.g. zq
    - `(` - Block start e.g. (f/fred/s/jim/)0
    - `)` - Block end e.g. (f/fred/s/jim/)0
    - `,` - Else clause e.g. f/fred/, f/jim/.
    - `\` - Reverse status of previous command e.g. v/fred/\
    - `?` - Ignore status of previous command e.g. f/fred/?.
    - % - Mainly housekeeping - see `percent commands`

{{{ R
3.1 R
-----
R[n] - shift Right by n characters (bytes if unicode support is turned 
  off - see `Unicode - the gruesome details`).
   
  Move character pointer n[1] places to the right, it  fails  and  raises  the
  failure flag if there is an attempt to go past the  end  of  the  line.  For
  non-unicode characters one byte is equivalent to one character. For  unicode
  characters, if unicode support has been turned  off  (see  the  `%b=unicode`
  command) the current-character pointer may be left pointing to a mid-unicode
  byte. See also `OR` command and `about unicode`.

}}}
{{{ M
3.2 M
-----
M[[=|-]n]|[*[-]] - Move to start of specified line.
    - M moves forwards by one line.
    - M<n> Moves forwards by n lines.
    - M* Moves forwards sufficient lines to view next page on screen.
    - M- moves back by 1 line.
    - M-<n> moves back by n lines.
    - M*- (or M-*) Moves back  sufficient  lines  to  view  previous  page  on
      screen.
    - M0 moves to last line of file.
    - M-0 move to first line of file.
    - M=<n> moves to absolute line no. n
     
  The command raises the failure flag if there is an attempt to move past  the
  last line or before the first line of the file.

}}}
{{{ X
3.3 X
-----
X[-][n] - eXit or re-iterate current, or selected parent block.
  
  - X[n] exits the current (or selected outer) block.
  - X-[n] - returns control to the  beginning  of  the  current  (or  selected
    outer) block.
  - X0 exits from all blocks.
  
  The X command with  a  +ve  argument  causes  the  selected  block  to  exit
  immediately, with a negative argument it causes to selected block to  repeat
  from the start.
  
  In  all  cases,  the  decimal  numeric  arg  <n>  specifies  the  block   to
  exit/repeat. It defaults to 1 (the current or innermost) block, 2  specifies
  it's parent block, a 3 the parent's parent block etc. A  zero  indicates  an
  exit from all blocks. It's a similar scheme for X-n except that these repeat
  the block from the start - similar to the continue statement in C  but  with
  the significant difference that the block need not have  a  repeat  counter.
  The X command does not affect the current value of the block-repeat counter.
  
  In this context a block means any code-sequence enclosed by round braces and
  the current macro or function call. The range of the X command is limited to
  the current macro-command or function. Other than returning a  status  value
  the X command cannot affect blocks in the calling code sequence.
  
  On exit the status is always set to success,  a  backslash  (  \  )  can  be
  appended to force the status to failure.

}}}
{{{ Y
3.4 Y
-----
Y[[=|-]n]|[*[-]] - move in column (Y axis) by [n] lines.
Y0 - Reset the column traversed by subsequent Y commands.

  Similar to the `M` command except that it up and down in a column of text.
  
  If it passes through a line that is  too  short  to  maintain  the  columnar
  movement, the cursor is left at the end of the line but the original  column
  number remains stored internally. If some subsequent invocation of Y  passes
  through lines of  sufficient  length,  the  original  columnar  movement  is
  restored.
  
  The special case y0 will reset the internally-stored column number. It  does
  not affect the cursor position but causes the *next* y command  to  redefine
  the column number.

}}}
{{{ E
3.5 E
-----
E[-][<n>] - Erase n bytes to the right [ or left] of the cursor.
   
  Erase next[previous] n[1] bytes. If n is finite and would cause  the  cursor
  to go out of bounds the failure flag is  raised.  With  a  positive  arg,  E
  deletes the bytes from the currently-selected character  and  characters  to
  it's right. With a negative arg, it deletes bytes  from  characters  to  the
  left of the current chr.
  
  The programmer must be aware that one byte is  not  necessarily  a  complete
  character - see `about unicode`.

}}}
{{{ P
3.6 P
-----
P[-][<n>] - print line(s).
   
  Prints (displays in the console area) the next[/previous] n[1] lines.  If  n
  is specified, and is greater than 1, or less than -1, then the current  line
  is set to the last line printed. If the value of n  would  cause  it  to  go
  outside the range of the current buffer then the failure flag is raised.

}}}
{{{ W
3.7 W
-----
W - redraw Window.
   
  Forces a redrawing of the Window - by default the  window  is  only  redrawn
  when it re-prompts for a new command  string  (at  a  breakpoint  or  normal
  command-entry prompt) - this command can be included in a complicated  macro
  or command script to allow the user to review progress or for debugging.

}}}
{{{ F
3.8 F
-----
F[-][range][<delim><string><delim>|'<key>][-][rpts] - Find
   
  Search text for specified string. If found the substring is highlighted  and
  becomes the selected substring. -  see  `About  the  current  character  and
  substrings`
  
  The F command takes parameters which specify the search string, a range  and
  repeat count.
  
  By default JOT starts off  in  it's  case  insensitive  mode,  this  can  be
  modified by the '%S=case' command.
  
  If there is no currently-selected no substring, the  search  starts  at  the
  current character. If there is a substring, the search starts one characters
  after (or one character before, in the case of F-) the start of the  current
  substring.
  
  For unsuccessful forwards-looking multi-line searches the current  character
  is  left  at  the  start  of  the  last  searched  line.  For   unsuccessful
  backwards-looking searches current character is  left  at  the  end  of  the
  last-searched line.
  
  For unsuccessful single line searches (i.e. when the range parameter is  set
  to 1) the current character pointer is left unchanged for both forwards  and
  backwards-looking searches.
   
  Parameters:
  
    - 1 Direction, a '-' will cause it to search back towards the start e.g.
        f-/abc/
  
    - 2 Range  specifies  the  max.  no.  of  lines  to  search  (defaults  to
      unlimited). e.g. f3/abc/ -  this  will  search  the  next  three  lines,
      including any of the current line to the right of the cursor.
  
    - 3 The string can be a literal string delimited by  any  non-alphanumeric
      ASCII character that does not appear in the string  e.g.  f"abc",  also,
      the ' character cannot be used - see `about  command  parameters`.  N.B.
      unicode characters cannot be used as delimiters.
      
      The second delimiter may be omitted is there are no further commands  or
      modifiers on the command line - e.g. f/monday
      
      Alternatively, the '<key> form will search for a match  to  the  current
      line of the nominated buffer e.g. f'@ - see `about command parameters`.
      
      Finally, if no find string is specified,  then  it  uses  the  last-used
      literal search string.
      
   e.g: in the following, the first command finds the next occurrence  of  the
   string 'fred', the next find locates the string indicated  by  the  current
   record of the $ buffer and, finally, it locates the next  instance  of  the
   string 'fred'.
> f/fred
> f/'$
> f
      
    - The optional hyphen after the search string causes the current-character
      pointer to be left after the end of the substring. By default it is left
      at the first character of the substring.
> f/fred/-
  
    - 4 The final parameter is used to repeat the search. e.g.  f/abc/23  will
      stop at the 23rd. occurrence of "abc".
      
  See  also  `%F`  -  regular-expression  search  and  `%S`  to  change   case
  sensitivity.

}}}
{{{ T
3.9 T
------
T - Trace
  
  This sets the trace vector to the  value  specified  by  the  default  trace
  vector. By default the trace vector is  0  (no  tracing  activity)  and  the
  default trace vector is set to  Trace_Stack,  Trace_Print,  Trace_Break  and
  Trace_AllCommands this means:
    - It will report the stack contents at each trace point,
    - it will print the current line of the  current  buffer  at  every  trace
      point,
    - it will enter an execution breakpoint at every trace point and
    - the trace point will be every command.
  
  Alternatively, the trace vector can be set explicitly  with  the  `%s=trace`
  command. The default trace vector can be redefined with `%s=tracedefault`.
  
  See also `about jot debugging` and `the jot debugger`.

}}}
{{{ Q
3.10 Q
------
Q[-][<delim><string><delim>|'<key>] -  Qualify
  Tests for existence of any of a specified set of characters in substring.
  
  The argument string can contain any ASCII and unicode characters but, for  a
  range of character codes (see below), ASCII and unicode should not be  mixed
  in the same range.
   
  The character at [or before] the current character position referred to here
  as the "match character") is compared to the character set specified by  the
  string parameter, if one of the specified set of characters matches then the
  command returns successfully, otherwise if reports a failure. The Q  command
  is invariably case sensitive and has no effect on the text file image.
  
  If, instead of the <delim><string><delim> syntax, the '<key> syntax is used,
  then the qualifying string is in the current line of the specified buffer.
  
  The string may be a simple list of all allowable characters, or may  specify
  a range of ASCII characters ordered by their ASCII codes, to  match  to  the
  literal '-' character it should be the first  or  last  in  the  string  for
  example:- Q/0123456789/ Will match to any digit. Q/0-9/ Will do the same but
  saves typing. Q/0-9+-/ Will match to any digit or the '+' or '-' characters.
  Q/0-9A-Fa-f/ Will match to any Hex digit.
  
  If the character set includes  unicode  and  the  match  character  is  also
  unicode, then the character and the string are both converted to native  UTF
  and the comparison is done in UTF. This is one of the  few  instances  where
  jot operates on full-width unicode - see `practicalities of unicode etc. and
  jot`.

}}}
{{{ V
3.11 V
-----
V[-][string] - Verify string.
   
  Verify - tests text at current character position for match with string.
  
  If the given string matches the substring to the right of  the  cursor  then
  the substring is highlighted and becomes the `About  the  current  character
  and substrings`. If not then the failure flag is raised. Correspondingly, V-
  verifies the text to the left of the cursor.

}}}
{{{ C
3.12 C
------
C[-][n] - Change case.
   
  Change case of next [/previous] n characters. If n is  specified  and  would
  cause the cursor to go out of bounds the failure flag is raised.
  
  Note that the C command has no affect on unicode characters.

}}}
{{{ I
3.13 I
------
I[-][string][n] - Insert substring
  Inserts specified substring before current character.
    
  The optional '-' parameter only affects the position of  the  substring  end
  pointer on completion - normally the cursor is immediately after the end  of
  the inserted substring I- causes it to be at the start.

}}}
{{{ S
3.14 S
------
S[-][<delim><string><delim>|'<key>] - Substitute
  Replace the currently-selected string with the given string.
   
  If a substitute  string  is  defined  then  this  is  replaces  the  current
  substring,  if  no  substitute  string  is  specified  then  the  last  used
  substitute string is used.
  
  When the '<key> syntax is used, the substituted string  is  taken  from  the
  current line of the specified buffer.
  
  This command normally only fails when the current buffer does not  currently
  have a valid substring `About the current character  and  substrings`  (e.g.
  following a F, T V or a previous S command) - when it fails the failure flag
  is raised.

}}}
{{{ B
3.15 B
------
B[-][n] - Break line.
   
  Where n is an optional (defaults to  1)  repeat  count,  on  completion  the
  character pointer is left at the beginning of the second line (i.e. it still
  points to the same character), except if a negative repeat count is entered
  - zeros are not allowed for break counts.
  
  A negative repeat count will break the line the same  number  of  times  but
  will leave the character pointer at the end of the first half line.

}}}
{{{ G
3.16 G
------
G[<n>] - Get 
  Read a new line(s) of text or single character from the keyboard.
   
  Use this to key in new text above the current line, the parameter  sets  the
  number of lines to be input or you may terminate with a control+C or a colon
  ':' at the beginning of an otherwise empty line.
  
  By default it prompts with "> " but you may define the prompt  string  using
  `%s=prompt`.
  
  If a linecount is specified and an early exit is forced,  then  the  failure
  flag is raised.
  
  See also the `%G` command, which reads lines  from  the  current  script  or
  macro and the `OG` command, which reads single characters to the stack.

}}}
{{{ J
3.17 J
------
J[-][n] - Join
  Joins current line with next (or previous) line.
    
    - J Joins the current line with the next line
    - J- Joins the current line with the previous line
    - J<n> joins the next n+1 lines
    - J-<n> joins the previous n+1 lines
    
  If join runs out of lines (because it's at the start/end of the buffer) then
  the failure flag is raised.

}}}
{{{ K
3.18 K
------
K[-][n] - Kill i.e. delete line(s).
   
  This completely removes lines and there is no way of getting them back. If n
  is specified and finite and it runs out of lines to kill, then  the  command
  fails. K0 deletes the current line and all subsequent lines, K-0 deletes the
  current line and all previous lines.
  
  K- deletes the current line and leaves the cursor at  the  begining  of  the
  line above, similarly K-n deletes the current line and  up  to  (n-1)  lines
  above leaving the cursor at the begining of the line above the last  deleted
  line. If the first line was deleted, then the cursor is left at the begining
  of the line following the original current line.
  
  Note that there must always be at least one line in a  buffer.  To  maintain
  this situation, an instruction to kill the last record in  the  buffer  will
  only erase all the text leaving an empty record - it will also fail.

}}}
{{{ N
3.19 N
------
N[.] Note
  Note = Note line [and character] number for later abstract.
  
  This sets the start point of one or more lines of text  to  be  moved  by  a
  later abstract `A` command. 
  
  Without the ( . ) modifier, complete lines are  removed  by  the  subsequent
  abstraction. 
  
  With the ( . ) modifier, all lines and characters are abstracted between the
  current character position when the N command was given to that at the  time
  of the A command.
  
  See also `A` and `H` commands.

}}}
{{{ A
3.20 A
------
A<key>[+|-|.][*|&] - Abstract
  Abstracts (moves) text from note point to current character (see  `N`)  into
  the nominated buffer.
   
  If the whole-line abstraction flag is  set  (see  `N`  command),  then  only
  complete lines are moved.
  
  The optional '+' qualifier places the abstracted text after the end  of  any
  preexisting text in the destination buffer, '-' similarly places  it  before
  the start '.' places at the current character in the destination buffer.  If
  none of these qualifiers are specified then the buffer is cleared before the
  new text is abstracted. The current  character  pointer  of  the  buffer  is
  always left at the beginning of the of the last line of abstracted text.
  
  The optional * qualifier replaces the abstracted  text  with  an  equivalent
  number of spaces, this feature is useful when editing tables  and  pictorial
  text.
  
  The optional & qualifier copies the text without changing the original. This
  is essential if abstracting from a readonly buffer - see `%b=readonly`.
  
  The two valid optional qualifiers must follow the buffer key but not in  any
  particular order.
  
  If the abstraction fails (typically because no note-point is set)  then  the
  failure flag is raised.
  
  See also `H` and `N` commands.

{{{ Abstraction options
3.20.1 Abstraction options
--------------------------
  Abstraction in jot is similar to ecce - by default, the n (note) and  the  a
  (abstract) commands abstract only complete lines.
  
  By default jot abstracts complete lines - like ecce. By adding the .  option
  to the note command it abstracts to the nearest character.
  
  Cumulative abstraction - by default the destination buffer is first  cleared
  of any preexisting text only  the  abstract  appears  in  the  buffer  after
  abstraction.
    - The + qualifier adds the now text to the end of any preexisting text  in
      the destination buffer.
    - The - qualifier prepends  the  abstracted  text  to  the  start  of  any
      preexisting text.
    - The .  qualifier  inserts  the  new  text  at  the  destination  buffers
      current-character point.
   
  Non-destructive abstraction. By default text  is  removed  from  the  source
  buffer. For non-cumulative abstraction  it's  easy  enough  to  restore  the
  abstract it immediately after but this process sets an internal  marker  tag
  indicating that the buffer has been modified - this is not  always  helpful.
  The '&' qualifier will abstract without changing the source text or  setting
  the marker tag.

}}}
}}}
{{{ H
3.21 H
------
H<key>[<count>][*] - copy Here
  Contents of specified buffer (the source buffer) is copied to current buffer
  (the destination buffer) either to the current character position  or  above
  the current line.  There  is  a  status  flag  in  the  source  buffer  that
  determines which.
  
  If the source buffer was itself defined by  abstraction  part  lines  (using
  `N`.) then the buffer is inserted at the current character.  If  the  source
  buffer was defined in any other way (abstraction with  N,  `%I`  or  a  `%Q`
  query) then the source text is inserted immediately above the current line.
  
  The status flag is invisible except in the "wholeRecords" line of  a  `query
  buffer` report.
  
  The effect of the optional count is to insert the text that many times.
  
  The effect of the optional * qualifier is to overlay the original text  with
  the new. This feature is intended  for  maintenance  of  column  spacing  in
  whitespace-delimited tables and line-drawings.
  
  See also `N` and `A` commands.

}}}
{{{ Z
3.22 Z
------
Z<key> - Zoom (change focus to nominated buffer)
  
  Changes the current buffer to the one identified by the buffer key.
  
  The the key for the  current  buffer  is  displayed  in  the  editor  prompt
  following the line number, it is also be displayed in the  window  separator
  lines (see `%w` command).
  
  See also `OB` and `OZ`

}}}
{{{ (
3.23 (
------
( - Block start
   
  The block of commands must be terminated by a ')', it may contain any number
  of valid jot commands, including sub blocks. See also `)` and  `jot  command
  structure`.

}}}
{{{ )
3.24 )
------
)[<n>] - Block end.
   
  This terminates the current block, if a repeat count ( <n>  )  is  specified
  then the block is repeated that many times or until the block fails, if  the
  repeat count is zero then the block only exits when something in the command
  sequence fails but, overall, a zero-repeat block never fails.
  
  If repeat count finite or  not  given,  then  any  failure  in  the  command
  sequence is passed on upwards. See also `(` and `jot command structure`.

}}}
{{{ ,
3.25 ,
------
(<anyNumberOfCommands>, <failureHandler>) - Failure handler.
   
  The commands following the comma are only executed when some earlier command
  has failed. When a  command  fails,  control  is  transferred  to  the  code
  following the comma - the failure handler. A single block can containing any
  number of failure handlers, each picking up the failure condition  from  the
  previous - this is effectively an if, else-if, else-if ... structure.

}}}
{{{ \
3.26 \
------
<cmd>\ - Reverse status of command or block.
   
  If the previous command failed and raised the failure flag, then this resets
  it, correspondingly, if the previous command did not fail then  the  failure
  flag is raised.
  
  Note, \ only applies to the command or block *immediately* before it.
  
  If, for example, we want to insert abc in any case except  when  it  already
  exists:
(v/abc/\i/abc/,)
  
  This is also useful for inverting the status of blocks, e.g.:
(f1/fred/\ f1/jim/ f1/bill/\)\
  The block will succeed if the current line contains either if the substrings
  "fred", "jim" or "bill".

}}}
{{{ ?
3.27 ?
------
 <validCommand or block>? - ignore status of command or block.
   
  This has the effect of lowering the failure flag irrespective of the outcome
  of the previous command.
  
  Note, ? only applies to the command or block *immediately* before  it.  Thus
  in the sequence m99p? the ignore-failure  command  applies  only  to  the  p
  command - not m99.
  
  You can also follow ? with \ to ensure that a command *always* fails -  this
  is useful when a failure handler needs to exit a repeated block.
  
  See also `\`, `Jot command structure` and `success, failure and errors`.

}}}
{{{ Stack Operations
3.28 Stack Operations
---------------------
  The editor maintains an evaluation stack  used  for  numerical  and  logical
  operations.
  
  A stack frame may contain one  of  three  datatypes,  an  integer  value,  a
  floating-point quantity or a buffer. All buffers on  the  stack  are  tagged
  with the buffer key '~'), as values are retrieved, there is a  simple  check
  to ensure compatibility with the  expected  datatype,  in  the  event  of  a
  mismatch, execution halts with an error message.
  
  If a stack-based buffer is the current buffer, numeric values may  be  added
  to the stack without  affecting  the  status  of  the  buffer.  You  cannot,
  however, return to the buffer with  a  Z~  or  OZ  command  (and,  also  the
  `hashtable jump` command) unless the buffer is at the top of the stack. This
  command sequence, for example, will fail:
%q~=date; m(oidr)3 z.z~
  But this one's OK:
%q~=date; m(oidr)3 z.(oo/%d:/r0)3z~
  
  The stack size is by default limited to 100  slots  (see  `-stacksize`)  any
  push operation will fail abruptly if there are already  100  on  the  stack.
  Similarly, any pop operation will fail if there are no values on the stack.
  
  The arithmetic operations (O+, O-, O*, O/, O=. O<  and  O>)  work  for  both
  integer or real (floating-point) quantities. If one item is integer and  the
  other is real then the integer operand is first converted to  real  and  the
  result, where applicable, is also real.
   
    - `O+` - Add.
    - `O-` - Subtract.
    - `O*` - Multiply.
    - `O/` - Divide.
    - `O%` - remainder
    - `O~` - increment - add 1 to item at top, fail if result=0.
     
    - `O|` - OR - performs bitwise OR of top two items in stack.
    - `O&` - AND - performs bitwise AND of top two items in stack.
    - `O!` - NOT - bitwise NOT.
     
    - `O?` - dump contents of stack - stack contents are not changed.
    - `O#` - duplicate top of stack.
    - `O=` - fail if top two items on stack not equal, top item is destroyed.
    - `O<` - test that item at top greater than next one down
    - `O>` - test that item at top less than next one down
     
    - `OB` - push pointer to current buffer onto stack.
    - `OE` - push Extent of current record/substring onto stack.
    - `OF` - push line no. of First line in window.
    - `OC` - push current chr. no. onto stack.
    - `ON` - push current line no. onto stack.
    - `OP` - push mouse cursor Position no. onto stack.
    - `OU` - set sUbstring length from stack.
    - `OA` - push rAndom number onto stack.
    - `O.` - set current line number to <top of stack>.
    - `OL`<n>[.<n>] - Literal integer [real] value is pushed onto stack.
    - `OI`[C|D|O|X|F] - formatted conversion from text - result to stack.
    - `OG` - character input - prompts and reads one character from keyboard.
    - `OO` - formatted Output - pop value, using given string.
    - `OV` - Value - defines hashtable data item from stack.
    - `OQ` - Query, query a hashtable value and push value onto stack.
     
    - `OR` - index Right (left if -ve) by no. of characters popped off stack.
    - `OM` - Move (backwards if -ve) no. of lines popped off stack.
    - `OZ` - Zoom (change to buffer) key popped off stack.
     
    - `OK` - Kill - delete top of stack.
    - `O@` - reset stack and random number generator.
    - `OS` - Swap 1st and 2nd items of stack.
     
    - `OW` - scrolls Window view by no. lines set in top of stack.
    
    - See also `query stack`
    
    - A few other %Q queries also push values onto  the  stack  -  see  `query
      Time`, `query cputime`, `query pid` and `query inview`.

{{{ OL
3.28.1 OL
---------
OL<intVal> - push an integer Literal onto stack.
  or
OL<floatingPointValue> - push a floating-point Literal onto stack.
 
  The specified value is placed on the top of the stack. e.g:
> ol123
  This pushes the number 123 onto the top of the stack.
  
  The literal can be modified by prefixing with x or o to specify the  integer
  in Hex or Octal respectively. eg:
> ol1024
> olx100
> olo400

  Note that the usual C-language format 0xnnn or 0onnn are not supported  here
  as these are syntactically indistinguishable from an OL0 followed by an X or
  another O command.
  
  For floating-point (real) values the only permissible syntax is  <nnn>.<mmm>
  eg:
> ol1234.56789
  
  The OL command is sometimes followed by `OV`. This combination  is  used  to
  set a data object to a literal value.  See  `about  hashtables`  and  `using
  Hashtable data`

}}}
{{{ O&
3.28.2 O&
---------
o& - bitwise AND
  
  The top two items in the stack must be integers. These are removed  and  the
  bitwise AND of the two values is added.
   
}}}
{{{ O|
3.28.3 O|
---------
o| - bitwise OR
  
  The top two items in the stack must be integers. These are removed  and  the
  bitwise OR of the two values is added.
   
}}}
{{{ O!
3.28.4 O!
---------
o! - bitwise NOT
  
  The item at the top of the stack must be an integer. It is replaced  by  the
  bitwise NOT of the original bit pattern - i.e. 0's are changed  to  1's  and
  1's are changed to 0's.
   
}}}
{{{ O?
3.28.5 O?
---------
O? - List contents of stack.
  
  This is useful for debugging - dumps the entire contents of the stack to the
  console - see also `query stack`.

}}}
{{{ OG
3.28.6 OG
---------
OG - reads one character from console and pushes character onto stack.
  
   This prompts using the prompt string defined by `%s=prompt` and  reads  one
   character that is pushed onto the stack as a wide-format unicode  character
   (see `about unicode`).
   
   If unicode-support is disabled (see `%b=unicode`) then  unicode  characters
   arrive as a series of values in the range  128-255  requiring  multiple  OG
   calls. Jot does not offer any  method  of  determining  where  one  unicode
   character ends and the next begins when a series of unicode characters  are
   entered in this way.

}}}
{{{ OO
3.28.7 OO
---------
OO<delim><formatString><delim> - Output using sprintf format string.
  
  Output the value at top of stack using the format string. 
  
  If the current buffer has a substring following a  command  that  defines  a
  substring (eg: F, S, I, OI or a previous OO command), then the substring  is
  replaced by the sprintf output. This sequence will first insert 999 and then
  immediately change it to 123:
> ol123 ol999 oo/%d/ oo/%d/
  this will give both numbers - the r-r removes the substring  marker  without
  affecting the cursor position:
> ol123 ol999 oo/%d/ r-r oo/%d/
  
  When writing unicode characters, the %c format  string  *must*  have  the  l
  (long-format) modifier to convert the wide-format unicode eg:
> ol65r0boo/%c simple ASCII character/r0
> ol163r0boo/but the unicode %lc requires the l modifier with %%c/
  Note that the `OG` command can add a unicode character too the stack.
  
  For numeric values the use of this modifier is recommended but a  simple  %d
  seems to work on most systems for integers of not more then  32  bits  eg  -
  this generally seems to work;
> ol123456789r0boo/%d/
  but use %ld to avoid truncation:
> ol123456789123456789r0boo/%ld/
  
  On completion, the current character points  to  the  end  of  the  inserted
  substring.
  
  Examples:
> ol12345 oo"The number you first thought of is %-10d"
> %q~=buffer; f/pathName = /-bza oo/The pathname is %s/ok
> off za oo/%8f/
> oo/%lc/ - used to print a long-format unicode character.

}}}
{{{ OQ
3.28.8 OQ
---------
OQ<delim><key><delim> - Value, push value from hashtable onto stack.
  
  The delimitedKey must match the key used to create a  hashtable  entry  with
  the `hashtable data` command. The OV operation pops the stack and copies the
  top frame value to the hash-table entry, deleting any previously-held  value
  associated with that hashtable entry. A copy  of  the  frame  can  later  be
  returned to the top of stack with the `OQ` command.
  
  In the event of an unmatched hashtable key or an empty stack, the OV command
  fails. Note that there is no typing in the `hashtable data`  command  so  OV
  just takes whatever datatype happens to be at  the  top  of  the  stack  and
  copies it to the data object.
  
  If the top item on the stack is a buffer, then a complete copy  of  all  the
  buffer records is made and associated with the data object, ignoring most of
  the other buffer attributes like PathName, header or Footer.
  
  For example:
> %h=data fred;  %%Creates the entry associated with the keyword 'fred'
> ol123
> ov/fred/       %%Moves the top stack frame (integer 123) to the hashtable.
...
> oq"fred"       %%Queries (restores) the stack frame 'fred'.
> ol456
> ov,fred,       %%Redefines  the value of the data object 'fred'.

}}}
{{{ OV
3.28.9 OV
---------
OV<delim><key><delim> - Query - pops stack and sets value in hash-table.
  
  The key must match one used to create a data entry with the `hashtable data`
  command with a value previously  defined  with  the  `OV`  command.  The  OQ
  command copies the contents of the hashtable data entry associated with  the
  hashtable key to the top of stack.
  
  In the event of an unmatched hashtable key or no value associated  with  the
  entry or, less likely, a full stack, the OQ command fails.
  
  If the data object holds a buffer, then a complete copy of  all  the  buffer
  records is made and placed on the top  of  the  stack,  ignoring  the  other
  attributes like PathName, header or Footer.

}}}
{{{ O+
3.28.10 O+
---------
O+ - Add
  
  Replace top two values with their sum.
  
  If either of the two values is a real number then the result is real, if one
  is integer then it is first converted to real.
  
  There is no checking for arithmetic overflows.

}}}
{{{ O-
3.28.11 O-
---------
O- - Subtract
  
  The value at the top of the stack is subtracted from the next value, the top
  two items are replaced by the result.
  
  If either of the two values is a real number then the result is real, if one
  is integer then it is first converted to real.
  
  There is no checking for arithmetic overflows.

}}}
{{{ O*
3.28.12 O*
---------
O* - Multiply
   
  Replace top two values with their product.
  
  If either of the two values is a real number then the result is real, if one
  is integer then it is first converted to real.
  
  There is no checking for arithmetic overflows.

}}}
{{{ O/
3.28.13 O/
---------
O/ - Divide
  
  The top item on  the  stack  is  the  denominator,  the  next  item  is  the
  numerator, both  items  are  removed  from  the  stack  and  the  result  of
  numerator/denominator is then added to the stack.
  
  If either of the two values is a real number then the result is real, if one
  is integer then it is first converted to real.
  
  There is no checking for arithmetic overflows but this command will fail  if
  the denominator (the 1st. item in the stack) is 0.

}}}
{{{ O%
3.28.14 O%
----------
O% - remainder.
  
  The top item on  the  stack  is  the  denominator,  the  next  item  is  the
  numerator, both items are removed  from  the  stack  and  the  remainder  of
  numerator/denominator is then added to the stack.
  
  If either or both items are real, the reals are first converted  to  integer
  the result is always integer.
   
  There is no checking for arithmetic overflows but this command will fail  if
  the denominator (the 1st. item in the stack) is 0.

}}}
{{{ O=
3.28.15 O=
----------
O= Test for numerical equality
  
  The top two items must be either integer or real, they are compared and  the
  top item is removed, if they  are  equal  the  command  status  is  Success,
  otherwise it's Fail.
  
  If either item is a real number  it  is  converted  to  integer  before  the
  comparison. This conversion does not apply to the value left behind  on  the
  stack.

}}}
{{{ O~
3.28.16 O~
----------
O~ Increment value in top of stack.
   
  The item at the top of the stack must be an integer, for any other type  the
  the operation fails. The modified value is checked  and  fails  the  failure
  flag is raised if the result is zero.

}}}
{{{ O>
3.28.17 O>
----------
O> - Greater than.
  
  The top two items compared and the top item is removed, if the top  item  is
  greater than the next, then the command  status  is  Success,  otherwise  it
  Fails.
  
  If both of the operands are floating-point values,  then  a  floating  point
  comparison is used.  Similarly,  if  both  items  are  integer,  an  integer
  comparison is performed. If only one of the operands is floating point, then
  a  floating-point  comparison  is  performed,   using   the   floating-point
  conversion of the integer value. This conversion does not affect  the  value
  left behind on the stack.

}}}
{{{ O<
3.28.18 O<
----------
O< - Less than.
  
  The top two items compared and the top item is removed, if the top  item  is
  less than the next, then the command status is Success, otherwise it's Fail.
  
  If both of the operands are floating-point values,  then  a  floating  point
  comparison is used.  Similarly,  if  both  items  are  integer,  an  integer
  comparison is performed. If only one of the operands is floating point, then
  a  floating-point  comparison  is  performed,   using   the   floating-point
  conversion of the integer value. This conversion does not affect  the  value
  left behind on the stack.

}}}
{{{ OB
3.28.19 OB
----------
OB - save Buffer key
  
  The ASCII value of the current buffer identification key is  placed  on  the
  stack (see also `OZ`).

}}}
{{{ OE
3.28.20 OE
----------
OE - push Extent of current substring or record.
  
  This command pushes the length, in  characters,  of  the  currently-selected
  substring onto the stack. If no substring is currently selected,  it  pushes
  the total length of the current record onto the top of the stack. 
  
  The result is negative if the current-character pointer follows the selected
  substring (as would be the case after the `S` command, for example). Jot has
  two forms of substring yielding +ve and -ve results:
    - Positive, where the current character is  the  first  character  of  the
      substring typically the result of a `F` command.
    - Negative, where the current character is immediately after the substring
      typically the result of the `S` command.
  
  If unicode support is turned off off (see `%b=unicode`) then it  pushes  the
  number of bytes in the currently-selected substring. 
  
  See also `OU`, `about unicode`, `%b=tabstops`, `about tabular text`,  `query
  inview` and `uc_basic.jot`.
  
  The substring-length calculation disregards  any  leftoffset  setting  -  it
  always assumes all characters  are  fully  visible.  See  also  `about  long
  lines`.

}}}
{{{ OF
3.28.21 OF
----------
OF - push line no. of First line of current buffer in window.
  
  This command will  search  all  currently  displaying  windows,  from  first
  (left/topmost)  to  last  window  (right/bottommost)  until  it  finds   one
  displaying the current buffer. It then calculates the  line  number  of  the
  topmost line displayed in the window. In most cases it's much  simpler  than
  that - usually there's only one window set up to display the current  buffer
  but see `%W` for details.
  
  This information can be used to control the view e.g.  it  can  be  used  to
  return to a previously displayed view - see also `OW`.
  
  Note that the line number returned is the line number at the time  when  the
  display was last updated. If your code contains anything that  might  change
  the display you should first refresh the display with the `W` command.

}}}
{{{ OU
3.28.22 OU
----------
OU - set sUbstring length from stack.
  
  The length of the currently-selected substring is set to the value currently
  at the top of the stack. A zero can be used to remove the substring  setting
  in that buffer. 
  
  With unicode support turned on (see `%b=unicode`) this value is  interpreted
  as a character count, otherwise 's taken as a byte count.
  
  A negative substring indicates that the  current  character  is  immediately
  after the selected substring (e.g. after a f/.../- os s/.../  command,  doc.
  Otherwise the value is positive indicating that the current character is the
  first character of the substring (e.g. after a F/.../ or S-/../ command).
  
  See also `OE`.

}}}
{{{ OZ
3.28.23 OZ
----------
OZ - Zoom.
  
  The value at the top of the stack is removed and used to  specify  a  buffer
  key, this is used to specify the new current buffer (see also `OB`).
  
  Unlike the `Z` command, oz does not transliterate to uppercase and an  error
  will result if there happens to be a lower-case acsii alpha character at the
  top of the stack.

}}}
{{{ OP
3.28.24 OP
----------
OP - push mouse Position onto stack.
  
  This places coordinates of the last-detected  mouse-click  onto  the  stack.
  Readback  of  mouse-click  coordinates  is  enabled  by  the  `%s=MouseMask`
  command.
  
  On completion, the top of the stack holds the following:
    - buffer key on display in the window receiving the last mouse click
    - the line number and
    - the character number for the mouse-click point.
    
  If the last-clicked mouse event has not been  enabled  (see  `%s=MouseMask`)
  then OP places three zeros on the stack.
  
  See also `About mouse events`, `%s=mousemask`, `%s=setmouse` and `%b=addtag`

}}}
{{{ ON
3.28.25 ON
----------
ON - save line Number
  
  The current line number is placed on the stack (see also `OM`).

}}}
{{{ OM
3.28.26 OM
----------
OM - Move
  
  The value at the top of the stack is removed and used to specify a  relative
  move forwards (+ve.) or backwards (-ve) by no. of lines.
  
  If the move is out of bounds (i.e. before the start or after the end of  the
  current buffer) then the cursor is left at the start of the  first  or  last
  line as appropriate and the command fails.
  
  n.b. With a zero at the top of the stack, OM just moves to the start of  the
  current line (see also `ON`).

}}}
{{{ OA
3.28.27 OA
----------
OA - rAndom
  
  A randomly-generated number is pushed onto the top of the stack. In reality,
  of course, this  is  a  pseudo-random  number.  That  means  it  runs  to  a
  predictable repeatable sequence depending on  how  the  pseudorandom  number
  generator is seeded (see `O@`).

}}}
{{{ O.
3.28.28 O.
----------
O. - Set line number.
  
  The value at the top of the stack is removed and used to  specify  the  line
  no. of current line from top of stack.
  
  N.B.  This  has  no  effect   on   the   cursor,   it   only   changes   the
  internally-maintained line number. This is displayed in the JOT prompt,  and
  the line number in `M`+ operations and `ON` etc.

}}}
{{{ OC
3.28.29 OC
----------
OC - save Chr no.
  
  Place current character no. (i.e. number of  characters  from  beginning  of
  line to the current cursor position) onto the stack (see also `OR`).
  
  If unicode support has been turned off (see  `%b=unicode`)  then  OC  counts
  bytes not characters, including all bytes in any unicode characters.

}}}
{{{ OR
3.28.30 OR
----------
OR - shift Right by character count (byte count if unicode support is turned 
  off - see `Unicode - the gruesome details`) shifts left for negative values.

  
  Item at top of stack is removed and used  to  shift  the  current  character
  pointer. Cursor moves cursor right (+ve.) or left (-ve.) by no. bytes at top
  of stack.
   
  If the move is out of bounds (before the start  or  after  the  end  of  the
  current line) then the operation  fails  and  the  cursor  is  left  at  the
  start/end of the line as appropriate (see also `OC`).

}}}
{{{ OI
3.28.31 OI
----------
OI[C|D|O|X|F] - formatted Input conversion (of string at current character).
  
  OI<chr> uses the character (C, D, O, X or F) as a format specifier and  uses
  it to extract a value from the  string  at  the  current  character  in  the
  current buffer.  The  result  is  pushed  onto  the  stack.  Note  that  the
  interpretation of the format-selection character (C, D, O, X or F)  is  case
  insensitive - so c, d, o, x or f will do just as well.
  
  Each of these  variants  converts  characters  beginning  with  the  current
  character and proceeding  to  the  right.  The  current  character  is  left
  pointing to the character to the right of the last converted  character  and
  all the converted characters are highlighted as a substring. 
  
  In the event of there being no valid characters  the  current  character  is
  left unchanged, nothing is added to the stack and the command fails.
    - OIC converts one character immediately  to  the  right  of  the  current
      character to  it's  unicode  code  (in  the  range  1-to-127  for  ASCII
      characters and 256-to-... for unicode characters -  this  one  does  not
      skip whitespace characters.
    - OID converts a string of numeric characters to decimal.
    - OIO converts value in an octal string and
    - OIX converts value in a hexadecimal string.
    - OIF converts real-number value in a string.
  OID, OIO, OIX and OIF all skip past any leading whitespace before converting
  digits.

}}}
{{{ OK
3.28.32 OK
----------
OK - Kill top item on stack
  
  The item at the top of the stack is removed and it's  value  is  lost.  Note
  that the OK command will fail if the stack is empty or the item at  the  top
  of the stack is a buffer and this happens to be the current buffer or if  it
  is marked as write-if-changed (see `%b=writeifchanged`).

}}}
{{{ O@
3.28.33 O@
----------
O@ - Reset stack
  
  Reseeds the random number generator (see `OA`) and then destroys  all  items
  currently in the stack. If the item at the top of the stack  is  an  integer
  type then this is is used to reseed the generator, otherwise  it's  reseeded
  with 1.
  
  The O@ command will work it's way down the stack, deleting entries, starting
  with the top item in the stack. If it encounters a buffer, it might fail  at
  this point if this buffer is the current buffer.

}}}
{{{ OS
3.28.34 OS
----------
OS - Swap
  
  The items in the top and next-but-one slots in the stack swap places.
  
  OS will fail if there are less than two items on the stack.

}}}
{{{ O#
3.28.35 O#
----------
O# - Duplicate
  
  The item at the top of the stack is copied and  placed  above  the  original
  item. 
  
  If the top item on the stack is a buffer, the O# operation does not copy the
  buffer records etc.  it  simply  constructs  another  pointer  to  the  same
  internal data. This is in contrast to `OV` and `OQ` which do make new copies
  of buffer data.
  
  O# will fail if the stack is already full.

}}}
{{{ OW
3.28.36 OW
----------
  The screen display is scrolled by the number of lines indicated by  the  top
  of stack - a positive value scrolls up the screen, negative scrolls down.

}}}
}}}
{{{ Percent Commands
3.29 Percent Commands
---------------------
  See also `percent-command syntax`
    - `%%` - Comment line.
    - `%A` - Exit without writing file.
    - `%B` - set Buffer attributes.
    - `%C` - Exit writing new file.
    - `%D` - Define a buffer from console.
    - `%E` - Execute following CLI command line.
    - `%P` - Pipe a message to interactive session.
    - `%G` - Get - Define a complete buffer from current command file.
    - `%H` - Hashtable maintenance.
    - `%I` - Secondary input file.
    - `%L` - set line Length and redraws all windows and slices.
    - `%M` - Message.
    - `%O` - Output current buffer as specified file.
    - `%Q` - system Query.
    - `%R` - Run a command file.
    - `%S` - define System settings (case sensitivity, insert mode ...).
    - `%U` - Undo last substitution.
    - `%W` - Set up a screen window.
    - `%X` - eXit current macro with a user-defined error message.
    - `%~` - Insert or display control character.

{{{ %A
3.29.1 %A
---------
%A[[<status>]=<message>] - Abandon = Exit without writing file.
  
  This exits the editor, no files are written out.
  
  The message defaults to "Edit abandoned", it  is  written  to  stdout  after
  closing the screen management system.
  
  By default, the exit status code is set to 1, any value in the  range  0  to
  255 can be supplied in decimal.
  
  If some buffer has been marked as `%b=writeifchanged`, and  the  buffer  has
  been changed, then the editor will refuse to exit until that buffer has been
  written. A suitable message appears if this happens - see `freeall.jot`.

}}}
{{{ %C
3.29.2 %C
---------
%C[=<message>] - Close = Exit writing new file.
  
  The file spec. is initially determined by the arguments given to the  editor
  image (see `-to`) and may be further redefined by the `%b=pathname` command.
  By default the file will have the same pathname as the original.
  
  The command fails if there is an attempt to %C from any  buffer  other  than
  the main buffer . - to write out some other buffer use `%O`.
   
  The message defaults to "Normal exit", it is written to stdout after closing
  the screen management system. For %C, the exit status is always set to 0.
  
  If  some  buffer  (other  than  the  main  buffer)  has   been   marked   as
  `%b=writeifchanged`, and the buffer has been changed, then the  editor  will
  refuse to exit until that buffer has been written or the writeifchanged lock
  is removed - see `freeall.jot`.

}}}
{{{ %E
3.29.3 %E
---------
%E=<CliCommand>  - executes a CLI command
%E<key>=[|]<CliCommand> - executes CLI command and catches the output.
%E<key>=[&]<CliCommand> - interactive CLI command.
  
  If a destination buffer is specified with the optional <key> qualifier, then
  the stdout stream of the child  process  is  picked  up  and  saved  in  the
  specified buffer. If no destination buffer is specified the  child's  stdout
  goes to the screen.
  
  Since the single quote character ( ' ) is so important  to  shell  commands,
  the usual '<bufferKey> syntax is not allowed for %e -  see  `percent-command
  syntax`.
  
  The command is passed to the CLI, the return status is checked and  used  to
  set the failure flag.
  
  If the CLI Command is prefixed with a pipe or vertical bar ( | ),  then  the
  contents of the current buffer is output to the stdin of the  command.  This
  feature allows users to use external  co-processors  for  handling  specific
  tasks - e.g. sorting, numerical processing.
  
  If the CLI command is prefixed with an ampersand ( & ) and the subprocess is
  inherently interactive, communicating via it's std and stdout  (eg:  gdb  or
  sh) then jot maintains an input and output pipe to the process. New commands
  and input can be supplied to the subprocess via the `%P` command. For linux,
  the child process is killed when the destination buffer is destroyed  or  as
  the session exits. 
  
  For linux the parent session normally  kills  the  child  by  sending  it  a
  SIGTERM but some processes my need to so some tidying up before they exit  -
  such processes  can  be  terminated  by  specifying  an  -exit=<exitCommand>
  qualifier to the `%P` command then these commands are sent  instead  of  the
  SIGTERM signal.
  
  For windows, the user requires a special privilege to kill a process -  even
  if it's a process they've created  in  the  same  session.  If  the  session
  attempts to exit with active child processes it will hang while  the  system
  waits for the child to terminate. The solution is to either explicitly  send
  the child the correct command for it to terminate itself or, use the  -exit=
  qualifier to the `%P` command.
  
  The simple form of  %E  (no  pipe)  will  return  a  success/failure  result
  reflecting the cli command's exit status - any nonzero exit code  is  deemed
  to be a failure, zero is deemed to be success.

}}}
{{{ %P
3.29.4 %P
---------
%P[<key>]=<command>; - Pipe a command to remote session.
%P[<key>]= -exit=<command>; - Set a termination command for a remote session.
  
  The remote session must have been previously set up  by  the  `%E`  command,
  with the & modifier to create a persistent interactive session. The  message
  is sent to the remote process's stdin and it is also appended to the  buffer
  text.
  
  The message is automatically suffixed with a newline character (  \n  ),  if
  the remote process responds by sending characters to it's stdout then  these
  are picked up and also appended to the buffer text. If there is  some  delay
  in the remote process response this is picked  up  asynchronously  when  the
  remote  process  responds  ie.   without   blocking   the   editors   normal
  command-driven activity.
  
  The -exit= option is used to terminate the child process at some later time.
  This option only useful in windows or for certain linux process that do  not
  respond well to the SIGTERM signal. In these cases it  is  necessary  for  a
  child process to terminate itself. The command string is saved  and  as  the
  session terminates or the buffer is destroyed, the exit command is  sent  to
  the child process.

}}}
{{{ %F
3.29.5 %F
---------
%F[<key>]=[<REx>] - search forwards in buffer using regular expression.
%F-[<key>]=[<REx>] - search back in buffer using regular expression.
  
  When a match is found, the first record of the destination buffer is set  to
  the complete matched substring. Subsequent records of the destination buffer
  are set to substrings matching parenthesized sub-expressions.
  
  If the  optional  regular  expression  <REx>  is  not  specified,  then  the
  last-specified REx is re-used.
  
  The underlying system call  only  searches  forwards  hence,  for  backwards
  searches, when a matching line of text is found, the system call is repeated
  until there are no more valid matches. Hence reverse regex searches  can  be
  quite inefficient for cases where there are many possible matches on a line.
  
  Briefly, it supports most of the  usual  regular-expression  constructs  but
  some of the more complex ones may  be  missing,  for  details  look  at  the
  documentation of the regex library routine:
    http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html   -
    Circumflex '^' and dollar sign '$', respectively, at the start or end of
      the RE, will anchor the body of the RE to the start or end of the  match
      string.
    - Bracketed expressions - '[' ... ']', the expression  inside  a  pair  of
      matching square brackets - see below.
    - Sub-expression grouping, enclosing expressions in matching round  braces
      '(' and ')', creates a result for each such subexpression. Each of these
      is assigned a separate record in  the  destination  buffer  and  may  be
      referred to by  number  in  some  later  expression  (see  subexpression
      references, below).
    - Alternation  within  sub-expressions  the  vertical  bar  character  '|'
      indicates an alternative subexpression. (<subexpr1>|<subExpr2> ... )
    - Subexpression references - \n (where n is a decimal) refers to the value
      extracted for that subexpression.
    - Numeric quantifiers -  specifying  that,  for  a  match,  the  preceding
      subexpression should be reiterated a given number of times.
    - Range quantifiers, a comma-separated pair of  decimal  values  in  curly
      braces '{'m, n'}' where m specifies the minimum number of repeats, n the
      maximum.
    
  Bracketed expressions - anything in matching square brackets [ ... ]
    - A set of equally  acceptable  characters,  special  characters  must  be
      escaped with a backslash.
    - A range of characters <ch1>-<ch2> in the ASCII/POSIX collating sequence.
    - A circumflex '^' - the negation character, matches to any character  not
      in the expression e.g. [^a-zA-Z] matches to any non-alpha character.
    - Character-class expressions of the form [ ... [:<classexpr>:] ... ]  the
      following character class expressions are allowed: alnum, cntrl,  lower,
      space, alpha, digit, print, upper, blank, graph, punct, xdigit.

}}}
{{{ %M
3.29.6 %M
---------
%M[<bufferKey>]=<message> - prints Message in console area.
  
  Prints the message in the  console  area  and  continues.  If  the  optional
  bufferKey is given then the message is also copied as a new line at the  end
  of the specified buffer. 
  
  The message may contain an indirect reference to any buffer or the  stack  -
  see `about command parameters` e.g:
ob %q~=date; t2/, /b %m=This is the time '~; osozok

}}}
{{{ %X
3.29.7 %X
---------
%X=<message> - eXit current command sequence, macro or script displaying the
  message in the console area.
  
  Prints the message to the  console  area  then  abruptly  exits  of  current
  command sequence. e.g:
> %x=File 'n is of the wrong type.

}}}
{{{ %S
3.29.8 %S
---------
%S=<attribute> [<value>] - set the value of a System attribute.
   
  This group of commands control various system attributes affecting behaviour
  in any buffer.
  
  Briefly, these are the valid attribute keys:
    - `%s=case` [0|1|+1] - Sets case sensitivity for F, and V commands.
    - `%s=system` [0|1] - system mode on/off - preserves search & insert strings.
    - `%s=commandmode` [+][<bitMask>] - to select screen-edit mode.
    - `%s=commandcounter` - Sets the command-counter stop-point.
    - `%s=trace` - set Trace, prefix with '+' to XOR with current value
    - `%s=tracedefault` - set default trace bitmask see also `T` command.
    - `%s=setenv` <envName> <envValue> - sets an environmental variable.
    - `%s=verbose` - to change verbosity level.
    - `%s=console` <n> - sets an upper limit on console-area expansion.
    - `%s=commandstring` - redefines console-input string.
    - `%s=recoverymode` - disables I/O used in journal-recovery procedure.
    - `%s=copy` - copies currently-selected text to the system paste buffer.
    - `%s=paste` - imports text from the system paste buffer to the  text.
    - `%s=setmouse` - Sets the mouse-event coords to the current cursor position.
    - `%s=guardband` - Makes a few lines above or below cursor visible.
    - `%s=mousemask` - Enables mouse events.
    - `%s=tab` - defines the tab character in tabular text.
    - `%s=prompt` - defines the prompt string for `G` commands.
    - `%s=on_key` - defines a command sequence to be run after every keyboard-initiated command.

{{{ %S=case
3.29.8.1 %S=case
----------------
%S=case [0|1|+1] - set case sensitivity attribute.
   
  This sets case sensitivity for the `F` and `V` commands - 1 makes them  case
  sensitive, 0 makes them case-insensitive (e.g. f/Fred/ will match  to  fred,
  FRED or Fred equally well). If no valid value is given,  it  defaults  to  0
  (i.e. insensitive to case). The value +1 reverses the current setting.

}}}
{{{ %S=system
3.29.8.2 %S=system
------------------
%s=system [0|1];
  
   In system mode the usual behaviour of saving search  and  substitute/insert
   strings is suspended. This is used in functions which use the `F`, `S`  and
   `I` commands and maintains the original state of these  strings  after  the
   function has completed.

}}}
{{{ %S=commandmode
3.29.8.3 %S=commandmode
-----------------------
%s=commandmode [+][<hexBitMask>] - sets command-mode attribute.
   
  Bits are assigned as follows:
    - 01 - Temporary, Insert mode reverts to command mode when any function or
           cursor-control key is hit.
    - 02 - InsertMode (until next %S=commandmode or a Ctrl+C interrupt).
    - 04 - Overtype - when in insert mode overwrites preexisting text.
    - 08 - EscapeAll - all keyboard input is taken as escape strings.
    - 10 - EscapeCtrl - any control character (ASCII characters in the range 0
      to 31) will be treated as initiating an escape sequence.
           
  Various useful combinations are available:
    - %s=commandmode 0; - the default setting, sane command mode - your typing
      appears in the console, it can supply a parameter to some jot  function.
      To insert to the text use the `Insert` and `Enter` functions.
    - %s=commandmode 2; - normal insert mode -  your  typing  appears  on  the
      screen at the current-character position indicated by the jot cursor.
    - %s=commandmode 6; -  insert-overtype  -  similar  to  %s=commandmode  2;
      except that typed input overwrites any preexisting text.
    - %s=commandmode 8; - EscapeAll - all  your  typing  is  taken  as  escape
      sequences - similar to vi/vim command mode.
    - %s=commandmode 10; - EscapeCtrl - any control character (ASCII codes  in
      the range 0 to 31) is treated as the start of an escape sequence.
    - %s=commandmode 12; As above but with insert mode  -  control  characters
      initiate escape-sequences  and  non-control  characters  appear  at  the
      current-character position.
    - Other combinations may do something useful but there's no guarantees.

}}}
{{{ %S=CommandCounter
3.29.8.4 %S=CommandCounter
--------------------------
%s=commandcounter 123456789; - sets the endpoint for the command counter.
  
  This command is only really useful for debugging and in the journal-recovery
  process. It specifies how many commands that should be  allowed  to  execute
  normally before a trace event is triggered - see `the jot debugger`.
  
  As each command is processed a  counter  is  incremented.  This  counter  is
  normally set to 0 every time a new command line is read  from  the  console.
  When the initial setting is defined with %s=SetCommandCounter it is  instead
  set to run for the specified number of commands and then execution  proceeds
  in whatever trace mode you  have  previously  selected.  Typically  it  will
  proceed in single-step mode.
  
  In a normal session,  execution  can  be  continued  under  control  of  the
  debugger - see `about jot debugging`. In a  recovery  session,  the  command
  counter is used to simulate a {Ctrl+c} interrupt at exactly the  same  point
  as one was received in the original session - see `about journal files`.
  
  For break point activation the command counter is designed to to be used  in
  conjunction with the trace mask (see  `the  jot  debugger`,  `%S=trace`  and
  `%S=tracedefault`).
  
  The trace mask determines the trace trigger and action. When  this  internal
  counter reaches zero, the trace action is enabled when nonzero, the  counter
  is decremented.
  
  Note that the counting only applies to the command sequence initiated by the
  *next*  command  line.  For  subsequent  command  lines,  the   counter   is
  initialized to zero, as usual.

}}}
{{{ %S=trace
3.29.8.5 %S=trace
-----------------
%s=trace [+-][<XXXX>] - Trace = Set [modify] trace mode, in hexadecimal.
   
  The optional + qualifier sets the specified bits, the optional  -  qualifier
  unsets the specified bits.
  
  The screen window is only redrawn when the Trace_Break bit is set.
  
  %S=trace sets a mask which controls the user-script debugging  facility  for
  the editor - see also `%S=tracedefault` and the `T` command.
  
  The trace action may optionally be delayed by setting an internal counter  -
  see `%S=commandcounter`.
  
  The trace mode bitmask has the following control  bits  which  can  be  ORed
  together:
    - 0001 Trace_AllCommands: Each new command is triggers a trace event.
    - 0002 Trace_CommandLines: Each new command line triggers a trace event.
    - 0004 Trace_AllFailures: Any failing command triggers a trace event.
    - 0008 Trace_FailNoElse: Any failing command with no local else sequence.
    - 0010 Trace_FailBlocks: Trace on exit from any failing block.
    - 0020 Trace_FailMacros: Trace on exit from any failing macro.
    - 0040 Trace_Interrupt: Trace on A {Ctrl+C} interrupt.
    - 0080 Trace_Recovery: Enables normal debugging in recovery mode.
    - 0400 Trace_DumpSeq: Dumps compiled commands.
    - 0800 Trace_Backtrace: Dumps a backtrace at each trace event.
    - 1000 Trace_Stack: Dumps contents of the stack at each trace event.
    - 2000 Trace_Print: Prints the current line of the current buffer.
    - 4000 Trace_Source: Displays the command line at each trace event.
    - 8000 Trace_Break: Break at selected trace point, halts and prompts for a
      debug command.
     
  One group of bits  (Trace_AllCommands,  Trace_CommandLines,  Trace_Failures,
  and Trace_Interrupt) define the  trace  points.  The  other  group  of  bits
  (Trace_Backtrace, Trace_Stack, Trace_Print,  Trace_Source  and  Trace_Break)
  determine the action to  be  taken  at  a  trace  point.  The  other  one  -
  Trace_Recovery is used in recovery scripts only - see `about journal files`.
  
  Trace_AllCommands and Trace_CommandLines perform  the  selected  trace-point
  actions at every command or at the start of a new command line respectively.
  Trace_Failures performs the trace-point actions after a failing command.
  
  Trace_Interrupt changes normal {Ctrl+c} behaviour - {Ctrl+c} normally  exits
  everything and returns to the normal jot prompt. With Trace_Interrupt set it
  enters the interactive jot debugger - note that, by  default,  Trace_Int  is
  not set up the  `T`  command,  you  have  to  set  Trace_Interrupt  in  your
  `%s=tracedefault`  setting  and  your  %s=trace  settings  -  see  `the  jot
  debugger`.
  
  The Trace_Stack bit directs a stack dump to the console, this will not be of
  much help unless the console area of the screen is reasonably large or there
  is not much on the stack.
  
  The Trace_Print bit prints the current  line  of  the  current  buffer  just
  before execution of the command.
  
  The Trace_Break bit triggers a break at the trace point, it  prompts  for  a
  command with 'Debug Command>' any valid JOT command string may  be  entered.
  If a hexadecimal value is entered with a leading zero, then this sets a  new
  value for the trace mode - in  particular  0  will  exit  trace  mode.  Just
  hitting the return key advances to the  next  break  point.  Note  that  the
  debugger does not attempt to restore the original  context.  Note  also  the
  debugger interface does not handle hotkeys.
  
  The Trace_Recovery bit causes trace points to behave  normally  in  recovery
  mode. By default, a trace break in recovery will read instructions from  the
  recovery file, these are  identical  to  those  given  while  debugging  the
  original session. With the Trace_Recovery bit  set,  debugger  commands  are
  read from the console, as normal, so you can debug the recovery script.  Not
  though, if the original session had debugger interaction then  what  happens
  next is anyone's guess but the end result is  unlikely  to  be  an  accurate
  reproduction of the original session state.
  
  In order to enter the debugger while  processing  a  recovery  file,  it  is
  necessary to edit  the  recovery  file  inserting  a  suitable  %s=trace  or
  %s=tracedefault command in the script. A typical  useful  setting  might  be
  0X8041:
> %s=tracedefault 8041;
  
  Setting the Trace_Backtrace bit causes a backtrace  to  be  issued  at  each
  trace  point  -  not   particularly   useful   for   Trace_AllCommands   and
  Trace_CommandLines but can be most useful when combined with Trace_Failures.
  Even so, it is not a good idea to run the editor with Trace_Failures  turned
  on - it's not unusual  for  simple  keyboard-driven  functions  to  generate
  several failures - all appropriately handled.
  
  If a macro buffer is redefined and reused part-way  through  execution,  the
  compiled code will execute normally but the original  source  is  no  longer
  available to the debugger for display. When this happens, the  situation  is
  detected  and  instead  of  echoing  the  original  source,  it  displays  a
  disassembly of the compiled code. For example:
$ jot t.t -in="%w; %w 9; %w 0; %s=trace 4001; %da=zai/%ga/bi/mm-/bi/:/bi/ \\\'a/b2; 'a"
  In this -init sequence the buffer ( A ) is initially defined as a macro that
  redefines the same macro buffer with source-code tracing turned on.
  
  If no trace action is specified then, appropriately, it does nothing at each
  trace point.
  
  The `T` command simply sets the trace value to the  current  default  value,
  initially  set  to  B001  (Trace_Stack  |  Trace_Print   |   Trace_Break   |
  Trace_AllCommands) but can be redefined using the '%s=tracedefault' command.
  Another useful setting is B002 - this displays the same  at  each  stop  but
  only stops at the start of each new command line.
  
  See also `%s=tracedefault` and `about jot debugging`.

}}}
{{{ %s=tracedefault
3.29.8.6 %s=tracedefault
------------------------
%S=tracedefault [+-][<hexValue>]
  
  This defines the value to be  assigned  to  the  trace  vector  by  the  `T`
  command. By default this is:
     Trace_Stack | Trace_Print | Trace_Break | Trace_AllCommands
     
  The optional + qualifier sets the specified bits, the optional  -  qualifier
  unsets the specified bits in the mask.
  
  In contrast to %s=trace, which sets the trace mask  with  immediate  effect,
  %s=tracedefault specifies a trace mask to be applied at the next break point
  (breakpoints are set by the `T`, by the `%s=commandcounter` commands and  bu
  Ctrl+C interrupts).
     
  See also `%s=trace` and `about jot debugging`.

}}}
{{{ %s=setenv
3.29.8.7 %s=setenv
------------------
%s=setenv <envName> <envValue>
   
  This sets an environmental variable in your session. It does not, of course,
  change the environment in your shell but only for your  editor  session  and
  any child processes it might spawn.

}}}
{{{ %s=verbose
3.29.8.8 %s=verbose
-------------------
%S=verbose <x> - sets the verbosity bit mask in hex.
  
  The verbosity bit mask currently has four recognized bits:
   
    - 1 (Bit 0) NonSilent - when set, normal error messages are delivered.
    
    - 2 (Bit 1} PromptUser - when set, prompts user for command input.
     
    - 4 (Bit 2) QuiteChatty - when set it reports  a  few  more  failures  and
      briefly explains what is wrong, it is recommended to allow  at  least  5
      lines in the console area for this.
      
    - 8 (bit 3) PrintLine - causes the current line of the current  buffer  to
      be written to the console area, in addition to the other messages.
      
    - 16 (bit 4) ReportCommandCount -  also  reports  command  counter  -  see
      `%s=commandcounter` and `about jot debugging`.  When  ReportCommandCount
      and QuiteChatty are both set, the failure reports are augmented with the
      current state of the command counter.  Setting  ReportCommandCount  will
      also cause user-defined messages (see `%M`) to  be  augmented  with  the
      command counter state. The command counter can be used to  set  a  break
      point in some later run - see `%s=commandcounter`).
     
    - 32 (Bit 5) AnnoyingBleep - error messages are accompanied by a bleep.
    
    - 64 (Bit 6) DebugMessages - enables whatever debugging messages may  have
      been accidentally left in your version of jot.
    
  These bits are combined to achieve a desired effect e.g.
> %s=verbose 3;   - (default state) for normal prompting and error reporting.
> %s=verbose 23;  - for normal prompts and reporting with bleeping.
> %s=verbose 1f;  - for normal prompts and comprehensive reporting.

}}}
{{{ %s=console
3.29.8.9 %s=console
-------------------
%s=console <0>|<noOfLines>;
  
  This sets an upper limit on  the  expansion  of  the  console  messages.  By
  default messages are restricted to any spare terminal lines at the bottom of
  the display (see `about the jot console and display windows`), setting  this
  limit allows messages to encroach  upwards  into  the  window  area  of  the
  terminal.
  
  If set to 0 (the default state), then the  console  area  is  fixed  at  the
  number of lines left below the windows. The startup script sets the  windows
  to leave a 2-line console area.
  
  If the console expansion area is set to more than the number of lines  below
  the windows, then the console area will expand upwards to a total size limit
  specified in the %s=console command. The Additional console lines are erased
  on the next editor action (a new command string, an escape sequence or  just
  by hitting {return}.

}}}
{{{ %s=guardband
3.29.8.10 %s=guardband
----------------------
%S=guardband[ <n>]
  Sets an n-line guardband. A band  of  n  lines  is  maintained  between  the
  current line of text and the top or bottom of the display. The value may  be
  0 - this is also the default.
  
  In the event of the total guardband exceeding the window size,  the  current
  line is centred.
   
  With a 3-line guardband, for example, it always displays the 3  lines  above
  and below the current record.

}}}
{{{ %s=tab
3.29.8.11 %s=tab
---------------
%s=tab [<chr>]
  This defines the character to be used as a cell separator for tabular  text.
  It defaults to VT (vertical Tab). This  can  be  set  to,  pretty-much,  any
  normal ASCII character but not unicode characters.

}}}
{{{ %S=CommandString
3.29.8.12 %S=CommandString
-----------------------------
%s=commandstring <CommandString>
  This inserts the specified command string  back  into  the  console  command
  buffer. This makes it possible to modify the console  input  using  ordinary
  editor commands and then execute the modified command sequence.
  
  This is used for command-line editing  (see  `about  command  editing`)  and
  systematic modification of keyboard input - take a  look  at  `uc_basic.jot`
  this uses %s=commandstring to substitute unicode escape sequences for  UTF-8
  byte sequences.

}}}
{{{ %s=MouseMask
3.29.8.13 %s=MouseMask
----------------------
%s=mousemask[=<HexValue>]
  
  This enables the detection and handling of  selected  mouse  events  -  e.g.
  left-button clicks etc. When enabled by %s=MouseMask, mouse  events  can  be
  picked up and handled  in  the  same  way  as  as  escape  sequences.  Also,
  mouse-click coordinates can be picked up by the `OP` command.
  
  By default, all mouse actions are disabled (the mouse mask is set to 0),  if
  %s=mousemask is given with no value then all mouse events are picked  up  by
  the editor (and normal X mouse actions are disabled).  If  a  hex  value  is
  given then that value is passed to the curses mousemask() function. For full
  details refer to curses.h and the mousemask (3NCURSES) man page.
  
  The problem with enabling all mouse events is that it  replaces  the  really
  useful X-windows selection actions - so only set the  mouse  mask  when  you
  really need to define mouse functions. The  standard  setup  defines  a  few
  mouse-action functions.
  
  The problem is not so acute for windows users since windows offers virtually
  no worthwhile mouse functions for console terminals.
  
  In any case, normal service can be restored by resetting the mousemask to 0:
> %s=mousemask 0;
  
  See also `About mouse events`, `OP` and `%b=addtag`

}}}
{{{ %S=RecoveryMode
3.29.8.14 %S=RecoveryMode
-------------------------
%s=recoverymode <value>
  
  Used when recovering a session from  journal  files.  In  order  to  prevent
  corruption of existing files %o  operations  are  disabled  and  %I  and  %E
  operations read from the journal area - see `about journal files`

}}}
{{{ %S=copy
3.29.8.15 %S=copy
-----------------
%s=copy
    
  Copies text into the system paste buffer. The start point is set by the  'N'
  (Note) command, the end point is set by the current  character  position  at
  the time when the %s=copy command is invoked. As  with  the  'A'  (Abstract)
  command, the start and end point must be in the same buffer and, if the  end
  point is before the start point the start and end points  are  automatically
  reversed.
  
  In windows, the system buffer used is the 'clipboard', in linux %s=copy  and
  %s=paste both use the X paste buffer N.B. not the selections buffer.
  
  In order to minimize the number of statically-linked libraries in the  linux
  version, this command is not available in the linux executables supplied  in
  the download - see `Unix and linux setup`.

}}}
{{{ %S=paste
3.29.8.16 %S=paste
------------------
%s=paste
  
  Copies the contents of the system paste buffer into the  current  buffer  at
  the current-character position.
  
  In order to minimize the number of statically-linked libraries in the  linux
  version, this command is not available in the linux executables supplied  in
  the download - see `Unix and linux setup`.

}}}
{{{ %s=prompt
3.29.8.17 %s=prompt
-------------------
%s=prompt[ <promptString>]; - set prompt string.
  
  Sets the prompt for the `G` command.
  
  If the prompt string is not given, then the G-command prompt reverts to it's
  default ( > ).

}}}
{{{ %s=on_key
3.29.8.18 %s=on_key
-------------------
%s=on_key[ <JotCommandSequence>]
  
  Defines a Jot command sequence to be performed after any normal  interactive
  command.
  
  Typically, the on_key sequence will be just be some  housekeeping  operation
  or an interface for some application that driven by changes in the text.

}}}
{{{ %s=setmouse
3.29.8.19 %s=setmouse
---------------------
%s=setmouse
  
  Initializes the mouse position to  the  current  character  in  the  current
  buffer - see `OP`, `Query tags` and `query window`.
  
  Useful  for  emulating   mouse   clicks   for   applications   designed   as
  mouse/touch-pad interfaces in non-mouse environments (see `qr.jot`) and  for
  testing scripts using the OP command for the window query.

}}}
}}}
{{{ %B
3.29.9 %B
---------
%b=<attributeName>[ <value>] - set some attribute of the current buffer.
  - `%b=unrestricted` - sets the buffer write-access attribute.
  - `%b=readonly` - sets the buffer write-access attribute.
  - `%b=leftoffset` <n> - sets the buffers left-offset attribute.
  - `%b=tabstops`[ <n1>[ <n2>[ <n3>[ ...]]]]  -  controls  display  of  simple
    tabular text.
  - `%b=tabcells`[ <n1>[ <n2>[ <n3>[ ...]]]] -  controls  display  of  tabular
    text.
  - `%b=header` <headerText> - defines a static header line for display.
  - `%b=footer` <footerText> - defines text for window-separator line.
  - `%b=unicode` {0|1} - Disables|Enables unicode support in this buffer.
  - `%b=pathname` <pathName> - (re)defines pathname.
  - `%b=sameflag1` - sets the user change-control flag.
  - `%b=tagtype` - defines a named metadata tag.
  - `%b=addtag` - Adds a metadata tag to the text.
  - `%b=remove_tag` - Removes instances of a named tag
  - `%b=sort` - sorts text in buffer.
  - `%b=tabsort` - sorts tabular text in buffer.
  - `%b=codepage` - Sets code page for buffer (windows only).

{{{ %B=unrestricted
3.29.9.1 %B=unrestricted
------------------------
%b=unrestricted - sets the buffer write-access attribute.
   
  This returns the readonly and  writeifchanged  status  of  the  buffer  (see
  `%b=readonly` and `%b=writeifchanged`) to their default settings.

}}}
{{{ %B=readonly
3.29.9.2 %B=readonly
--------------------
%b=readonly[ 0|1] - sets the buffer write-access attribute.
  
  The default state for buffers is that they may be modified. If this  command
  is applied with no value specified or is specified as  1  then  the  current
  buffer is set to a readonly  state.  It  can  be  viewed  but  not  altered,
  sections of text may be abstracted provided the & qualifier  is  given  (see
  the `A` command).
  
  See also the `%B=unrestricted` command.

}}}
{{{ %b=writeifchanged
3.29.9.3 %b=writeifchanged
--------------------------
%b=writeifchanged[ 0|1] - sets the buffer write-access attribute.
 
  The default state for buffers is that any changes are lost if the session is
  terminated without explicitly saving (see the `%O` command). If this command
  is applied with no value or the value is specified as 1 then the buffer must
  be saved if some changes have been made.
  
  In this state the buffer may be modified but  if  there  is  an  attempt  to
  overwrite or to exit the editor without first  saving.  Then  a  warning  is
  issued and the editor session remains live. It is , of course,  possible  to
  reset this lock and exit normally to discard changes.
  
  The motivation for this one is that jot encourages users  to  edit  multiple
  files in one session - it's just a bit too easy to forget and  exit  without
  saving something important.
  
  If, after you've checked the locked buffers, you  still  want  to  exit  the
  session anyway, the `exit.jot` script might help.
  
  See also the `%B=unrestricted` command.

}}}
{{{ %b=leftoffset
3.29.9.4 %b=leftoffset
----------------------
%b=leftoffset <n> - sets the buffers left-offset attribute.
   
  Sets the text column to appear in the leftmost column  of  the  window  when
  displaying this buffer.
  
  By default, the left offset is 0. This may be increased to  display  records
  longer than the width of the current window. See `about long lines`. If  the
  given value is negative, this is silently ignored and the leftoffset is  set
  to 0.
  
  See also `about long lines` and `query inview`  -  this  verifies  that  the
  current character is visible with the current leftoffset setting.

}}}
{{{ %b=tabstops
3.29.9.5 %b=tabstops
--------------------
%b=tabstops[ <n1>[ <n2>[ <n3>[ ...]]]] - controls display of simple tabular text.
   
  By default, tabs and other control characters are rendered as a tilde '~' on
  the screen - see `about tabular text`. If tabStops have been defined  for  a
  buffer containing tabular text then each tab is  replaced  by  one  or  more
  blanks in the display. When correctly set up, the  tabular  text  is  neatly
  aligned with that of other records in the buffer.
  
  Each entry in the %b=tabStops command is a number  indicating  the  absolute
  column number to be assigned to the following text - hence  tabStops  should
  always be an ascending sequence of column numbers. If a tab  is  encountered
  that is already beyond (i.e. to the right of) it's assigned column then  the
  tab character is simply rendered as a single blank.
  
  Use %b=tabcells for buffers containing simple tabular text - indented source
  code,  simple  tables,  formatted  letter  headings  etc.  For  tables  with
  wildly-varying cell lengths use `%b=tabcells` which will  truncate  overlong
  cells to maintain the columns.
  
  The %b=tabstops command will delete any  preexisting  tabstops  or  tabcells
  settings, if no tabstops are given, then the buffer  reverts  to  displaying
  tabs as tildes ( ~ ).
  
  If the first tabstop is any negative number, then this is taken as a request
  for automatically-assigned tabstops - any other values in the  command  line
  are  ignored.  With  automatically  assigned  tabstops  the  window  manager
  analyses the position of all tab characters currently in  view  and  assigns
  the smallest tabstops  compatible  with  displaying  tabular  data  in  neat
  columns. Currently, the maximum number of of automatically-assigned tabstops
  is limited to 100.
  
  The tabstops are displayed in the `query buffer` report.

}}}
{{{ %b=tabcells
3.29.9.6 %b=tabcells
--------------------
  Each  tab-delimited  item  of  text  is  said  to  be   a   cell.   If   the
  manually-defined tabcell is insufficient to display all of a cell, then  the
  cell text is truncated and an exclamation point  (  !  )  is  added  to  the
  righthand end of the truncated text.
  
  The %b=tabcells command will delete any  preexisting  tabstops  or  tabcells
  settings, if no tabcells are given, then the buffer  reverts  to  displaying
  tabs as tildes ( ~ ).
  
  In the event of there being a record with more then the number of predefined
  tabcells, then additional tabcells are assigned by adding the tab spacing to
  the previous tabcell entry.
  
  If the first tabcell is any negative number, then this is taken as a request
  for automatically-assigned tabcells - any other values in the  command  line
  are  ignored.  With  automatically  assigned  tabcells  the  window  manager
  analyses the position of all tab characters currently in  view  and  assigns
  the smallest tabcells  compatible  with  displaying  tabular  data  in  neat
  columns. Currently, the maximum number of of automatically-assigned tabcells
  is limited to 100.
  
  The tabcells are displayed in the `query buffer` report.

}}}
{{{ %b=header
3.29.9.7 %b=header
------------------
%b=header[ <headerText>] - defines or removes a static header line.
  
  If the headerText string is given, this is displayed in reverse video at the
  top of any window displaying the current buffer. The header is static in the
  sense that it is fixed to the top line of the window and text  scrolls  past
  it. When you define a buffer string it occupies one of the  lines  requested
  in the `%W` command, leaving you with  one  less  line  for  viewing  buffer
  images. If no headerText string is given then any previously defined  header
  line is removed. By default, buffers have no header line.
  
  If the buffer has TabStops set (see `%b=tabstops`)  then  any  tabs  in  the
  header text will be treated in the same way as those in the main body of the
  buffer. The upshot of this is that the text can contain column headings  for
  buffers containing tabular entries (e.g. images of spreadsheets etc.).

}}}
{{{ %b=footer
3.29.9.8 %b=footer
------------------
%b=footer some text;
  
  By default, the reverse-video separator at the end of a window contains  the
  current buffer's pathname (if defined) and  the  buffer  key.  This  command
  replaces the pathname with some text of your own choosing.
  
  As with long pathnames, the text may be truncated to fit.

}}}
{{{ %b=unicode
3.29.9.9 %b=unicode
-------------------
%b=unicode {0|1}
  This controls unicode support for the current buffer.
  
  Any value other than 0 restores the default  mode  of  operation  -  unicode
  characters are rendered normally.
  
  The value 0 turns off unicode support, in this state each byte of  UTF-8  is
  represented on the screen by a tilde ( ~ ).
  
  Disabling unicode support affects the rendering of characters on the  screen
  any non-ASCII or ASCII control characters bytes are displayed as a tilde ( ~
  ) and also affects several commands:
    - `R` - counts bytes not characters.
    - `OR` - counts bytes not characters.
    - `OE` - returns the byte count not character count.
    - `OC` - returns byte count not character count.
    - `OU` - expects to be given a byte count not a character count.

}}}
{{{ %b=pathname
3.29.9.10 %b=pathname
---------------------
%b=pathname <pathName> - (re)defines pathname.
   
  This sets the default pathname to be used when this buffer is later  written
  to the filing system.

}}}
{{{ %b=sameflag1
3.29.9.11 %b=sameflag1
---------------------
%b=sameflag1 - sets the user change-control flag.
   
  Sets the user flag SameFlag1 - this remains true until there is some  change
  to the buffer text. This flag can be tested if ever a macro needs to  detect
  changes that have occurred since the flag was set.

}}}
{{{ %b=tagtype
3.29.9.12 %b=tagtype
--------------------
%b=tagtype <tagName> colour <foregroundColourNo> <backgroundColourNo>
  
  Currently the only tag types allowed are colour tags  but  it  is  envisaged
  that this might be extended in the future.
  
  This either defines a new colour pair or redefines  one.  Colour  pairs  are
  defined in terms of the foreground and background colour and are  referenced
  by the pair number.
  
  The tag name can then be used to tag text with colour using the  `%b=addtag`
  command - see also `about tagged text`.
  
  Colours are identified by number in the range 0-to-7 - in linux these are:
    - 0 Black
    - 1 Red
    - 2 Green
    - 3 Yellow
    - 4 Blue
    - 5 Magenta
    - 6 Cyan
    - 7 White
    
  in windows:
    - 0 Black
    - 1 Blue
    - 2 Green
    - 3 Cyan
    - 4 Red
    - 5 Magenta
    - 6 Yellow
    - 7 White
  In windows, adding 8 gives a more intense colour.
  
  e.g. To define a colour tag "fred" as yellow forground on a blue  background
  in linux:
%s=colourpair fred 3 4;
  in windows
%s=colourpair fred 6 1;
  or, for a brighter yellow:
%s=colourpair fred 14 1;

}}}
{{{ %b=addtag
3.29.9.13 %b=addtag
-------------------
%b=addtag {<tagName>|-text=<textString>};
  
  - In the %b=addtag <TagName> form:
      The TagName must match a previously defined tag type (see  `%b=tagtype`)
      or the command fails.
      
      Applies the named tag to the currently-selected substring in  text.  The
      named tag type and it's colour pairs must  first  be  defined  with  the
      `%b=tagtype` command - see also `about tagged text`.
      
      If, at "addtag" time, there  is  a  selected  substring,  two  tags  are
      applied - one at the start of the currently-selected substring  and  one
      at it's end. If there is no selected substring then no end-tag is  added
      the tagging continues through to the end of the line.
  
  - In the %b=addtag -text=<textString> form:
      The text string, which may be  of  any  length,  is  added  to  the  tag
      descriptor. This string can be used for any  purpose  but  is  primarily
      intended for use as a hashtable key. The string is only visible  in  the
      `query tags` report.
      
    Tags persist until removed  with  the  removed  with  the  `%b=remove_tag`
    command or the text is deleted.
    
    See also `About mouse events`, `%b=remove_tag`, `%s=mousemask` and `OP`

}}}
{{{ %b=remove_tag
3.29.9.14 %b=remove_tag
-----------------------
%b=remove_tag <type> <name|key|text>
  
  The current character must be at the start-point of the tag to be deleted.
  
  This command uses the details given and the  current-character  position  to
  uniquely identify one tag and then removes it from the internal record  data
  structure. In the event of there being two or more identical  tags  matching
  the description, it randomly selects one of the matching  tags  and  deletes
  only that one.
  
    - The tag type field must be one of colour, text or target.
    - the name field for a colour tag must match the colour-tag  name,  for  a
      text-tag it must match the first whitespace-separate  word  of  the  tag
      text and, for a hash-table target, the name must  match  the  hash-table
      key.
    - the current character and substring length  select  the  start  and  end
      point of the tag.
  
  The tags were originally created by the  `%b=addtag`,  `hashtable  new`  and
  `hashtable add` commands - see `about tagged text`.
  
  Where precise details of the tag is not  known,  use  the  `query  tags`  to
  extract the necessary information from the internal data set.
  
  In the event of there being no tag exactly matching the details  given  then
  the command fails without affecting any tags.

}}}
{{{ %B=sort
3.29.9.15 %B=sort
-----------------
%b[<destBuf>]=sort [<sliceColumn1>][ <sliceColumn2>[ <sliceColumn3> ...]]]
  Performs an alphabetical sort of all records in the buffer, by  default  the
  records are sorted by the strings starting at the  first  character  (column
  0). For tabular text, other columns  (slices)  may  be  specified,  to  sort
  tab-separated tabular text use `%B=tabsort`
   
  Each parameter is taken as a slice definition (i.e. a  vertical  slice  down
  the tabulated text), the following forms are supported:
    - <firstChrNo>-<lastChrNo> - counting from the  first  character  in  each
      record (chr no. 0), this defines a slice of the buffer to be used in the
      sort comparison.
    - <firstChrNo>+<width> - defines the start  character  and  width  of  the
      slice - minimum sensible width is 1.
  
  The sort function (a  version  of  quicksort)  compares  pairs  of  records,
  initially from slice slice1. If they are found to be identical, it  tries  a
  comparison from slice slice2, then slice3 etc... If no slices are  specified
  it performs just one comparison on each complete record.
  
  Note that left to the user to ensure that  each  record  has  at  least  the
  number of columns specified - otherwise results are unpredictable.
  
  The sort function modifies the current buffer and writes a sort summary into
  the nominated destination buffer.

}}}
{{{ %B=TabSort
3.29.9.16 %B=TabSort
--------------------
%b=tabsort <tab1>[ <tab2> [<tab3> ...]]] - sort buffer holding tabular text.
  
  Each tab entry is an integer in the range 0 to n-1 where n is the number  of
  columns in the table.
   
  Similar to the  `%b=sort`  command,  tabsort  sorts  records  by  values  of
  unaligned tab-separated fields, the delimiter character defaults to an ascii
  VT ( 0xB ) character but can be redefined with the `%s=tab` command.
  
  Shorter fields always rank higher in a  strcmp  string  comparison  so  some
  additional whitespace padding may be required.

}}}
{{{ %b=codepage
3.29.9.17 %b=codepage
---------------------
%b=codepage <codepage>
   
  This modifier is only available in the windows version. By default jot  uses
  the 65001 (UTF-8).
  
  This sets the codepage which is  only  relevant  to  unicode  -  see  `about
  unicode`, `Practicalities of unicode etc. and jot`

}}}
}}}
{{{ %Q
3.29.10 %Q
----------
%Q[<bufferKey>]=<query>
   
  Query this command offers a few selected peepholes  into  selected  internal
  editor states and the system environment.
   
  In most cases the target buffer, indicated by <bufferKey>, is the buffer  to
  receive the  result.  The  exceptions  are  dir,  file,  SameFlag1  and  the
  hashtable queries. In all cases the first line of output  to  the  nominated
  buffer is the original %q command. Valid queries are:
  
  %q~=... is a special case, the ~ buffer is created on the stack - see `about
  the operand stack`.
    - `query system` - Returns current system settings to specified buffer.
    - `query linux` fails if not running under linux.
    - `query windows` fails if not running under windows.
    - `query hashtables` - Summary report on all hashtables.
    - `query wd` -  Returns  users  current  working  directory  to  specified
      buffer.
    - `query window` -  Reports  window  allocation  parameters  to  specified
      buffer.
    - `query backtrace` reports command-script calls
    - `query time` - pushes time in seconds since start of unix epoch.
    - `query cputime` - pushes on stack current cputime from system (n.b. this
      is a real (floating-point) value.
    - `query pid` - pushes on stack current process ID.
    - `query date` - Reports current data and time to specified buffer.
    - `query env`  -  Reports  value  of  specified  environment  variable  to
      specified buffer.
    - `Query stack` - Dumps stack contents to specified buffer.
    - `Query tabstops` - Fails if no tabstops set in current buffer.
    - `Query buffer` - Reports buffer status to specified buffer.
    - `Query samesinceio` - Fails if current buffer  has  been  changed  since
      last read or written.
    - `Query samesinceindexed` - Fails if  current  buffer  has  been  changed
      since last hash-table entry was added.
    - `Query sameflag1` - Fails if current buffer has been changed since  user
      flag 1 was last reset.
    - `Query case` - Fails if case sensitivity is off.
    - `Query inview` - Fails if current character of current buffer is out  of
      view.
    - `Query version` - Reports jot version to buffer, if specified or else as
      a message to the console area.
    - `Query dir` - Reports contents of to buffer if specified or fails if not
      a valid directory.
    - `Query file` - Reports system file data to buffer if specified, fails if
      not a valid pathname.
    - `Query keys` - Writes a diagnostic dump of  buffer  hash-table  keys  to
      specified buffer.
    - `Query tags` - lists the tags (hash-table target points and colour tags)
      in current buffer.
    - `Query heap` - in linux sends heap-status to the nominated buffer.
    - `Query history` - Dumps command history to specified buffer.
    - `Query keys` - Lists details of all hashtable entries..
    - `Query key` <string> - Lists only hashtable entry specified by <string>.
    - `Query verify` - Checks consistency of current  buffer's  internal  data
      structures.

}}}
{{{ Query system
3.29.11 Query system
--------------------
%q<key>=system
  
  Reports current state of system settings to nominated buffer followed  by  a
  list of primary buffers i.e. not stack-based or data-object buffers.
	          Trace vector = <hex value> - of trace vector - (see `%S=trace`)
	      Case sensitivity = <hex value> - case sensitivity vector - (see `%S=case`)
	          Command mode = <hex value> - the command-mode vector (see `%S=commandMode`)
	 Table-entry separator = <hex value> - the character used to separate  entries
                                        in tabular text (see `%S=tab`).
	   Hold screen on exit = {On|Off}    - Set by `-hold` CLI qualifier.
	Buffers:
	  buffer <key1>                   - First in list of defined buffers.
	  buffer <key2>
	  ...
	Data-object buffers:
	  data obj <path> 
	  ...
  
  The list of buffers contains all primary  buffers  that  have  been  created
  thus-far in the session, including some with lower-case alpha keys (i, t and
  p) - these are set up and used internally and  are  not  accessible  to  the
  user.

}}}
{{{ Query linux
3.29.12 Query linux
-------------------
%q=linux
  
  Used to test the underlying OS, this  one  fails  for  anything  other  than
  linux.

}}}
{{{ Query windows
3.29.13 Query windows
---------------------
%q=windows
  
  A simple test the underlying OS, this one fails for anything other than some
  flavour of NT-windows.
  
  Note - this has nothing  to  do  with  the  `query  window`  command,  which
  generates a window-assignments report.

}}}
{{{ Query hashtables
3.29.14 Query hashtables
------------------------
%q<key>=hashtables
  
  Searches all active  buffers,  for  each  of  those  with  a  hashtable.  It
  generates a one-line list of all the buffers referenced by the  hashtable  -
  see `about hashtables`.

}}}
{{{ Query wd
3.29.15 Query wd
----------------
%q<key>=wd
  - Returns the users current working directory.
     
}}}
{{{ Query window
3.29.16 Query window
--------------------
%q<key>=window - reports window assignments.
   
  Lists  screen  size,  details  of  all  allocated  windows  and  number   of
  unallocated lines on the screen.
  
  Then follows a screen dump - the current contents of the screen is copied to
  the end of the  report.  Note  that  the  screen  dump  does  not  show  any
  highlights, reverse video, colour tags or the cursor position.
  
  Note - this has nothing to do with the `query windows` command, which  is  a
  simple go-nogo test on your OS architecture.

}}}
{{{ Query Time
3.29.17 Query Time
------------------
%q=time - pushes seconds since beginning of unix epoch onto the stack.
  
  This uses the system clock to calculate how many seconds have elapsed  since
  the begining of unix time (zero o'clock on the first of January  1970).  See
  also `query cputime`.

}}}
{{{ Query cputime
3.29.18 Query cputime
---------------------
%q=cputime - pushes to stack, time elapsed since last query cputime.
  
  This uses the system clock to measure the time interval  between  calls.  It
  calculates gives a floating-point value calculated from the  system  seconds
  and nanoseconds elapsed-time counters. Each time it's  called  it  subtracts
  the previous values of these counters from their current values and converts
  the difference to a floating-point number, which is pushed onto  the  stack.
  It is envisaged that this may be useful for some future profiling tool.  See
  also `query time`.

}}}
{{{ Query date
3.29.19 Query date
------------------
%q<key>=date - reports date and time.
   
  Returns the current date and time in the form dd/mm/yy, hh:mm:ss
         
}}}
{{{ Query env
3.29.20 Query env
-----------------
%q<key>=env <name> - reports value of nominated env variable.
   
  Returns the current value of the specified variable in the users env.
      
}}}
{{{ Query pid
3.29.21 Query pid
-----------------
%q<key>=pid - Query the ID of the ediors process.
  
  This reports just the process-ID number of the editor process.

}}}
{{{ Query stack
3.29.22 Query stack
-------------------
%q<key>=stack
  - reports state of stack.
   
  Returns the current state of the stack in decimal hex and character format -
  see also `O?`.
      
}}}
{{{ Query tabstops
3.29.23 Query tabstops
----------------------
%q=tabstops
  
  This is a quick test to identify buffers which have been set up for  tabular
  text. The command succeeds if  tabstops  are  set  in  the  current  buffer,
  otherwise it fails.

}}}
{{{ Query backtrace
3.29.24 Query backtrace
-----------------------
%q<key>=backtrace
  
  Lists macros, functions and scripts in the active call stack - for debugging
  only. 
  
  When called from a  normal  interactive  command  line  it,  unsurprisingly,
  doesn't report very much. When called from a debugger break point prompt, it
  shows all the call frames that led to  the  breakpoint.  It  also  dutifully
  reports the debugger as a frame in the call stack.
  
  In addition to the various scripts, macros and function calls you may notice
  a few lower-case alpha macros you don't recognize:
    - i - the initialization commands passed in via the CLI qualifier `-init`
    - c - the normal interactive command buffer.
    - d - the debuggers own command buffer,
  
  See also `bt.jot`

}}}
{{{ Query buffer
3.29.25 Query buffer
--------------------
%q<key>=buffer
  - reports internal state of buffer.
   
  Returns the state of  the  current  buffer  in  tabular  form  N.B.  if  the
  nominated buffer is the current buffer  this  command  will  fail  and  will
  return an empty report. e.g:
> %qa=buffer
  In buffer A it inserted the following text:
	buffer
	                  key = .                    The key for the buffer.
	             pathName = t.t                  The pathname of the file read into the buffer.
	     currentDatestamp = 2011/10/04, 16:27:16 The file's datestamp at the time of the query.
	          SameSinceIO = TRUE                 This flag is set true when the file was originally read and reset by  a change to any text in the buffer.
	     SameSinceIndexed = FALSE                This flag is set true by adding some hashtable entries and reset by  a change to any text in the buffer.
	    SameSinceCompiled = FALSE                This flag is set TRUE when a new hash-table entry is added.
	            SameFlag1 = FALSE                This flag is set by the `%b=sameflag1` command and reset by a change to any text in the buffer.
	            NoUnicode = FALSE                Unicode support is enabled (controlled by `%b=unicode` command)
	           lineNumber = 1                    The normal line number of the record.
	           CurrentChr = 0                    The current character position, in this case it is the leftmost character of the record.
	      SubstringLength = 0                    The length of the currently-selected substring - in this case none is selected.
	         wholeRecords = TRUE                 Indicates that, if inserted into text it will not break lines.
	          predecessor = =                    When called as a macro, this indicates the parent macro.
	             editLock = Unrestricted         Other options are WriteIfChanged and ReadOnly.
	           LeftOffset = 0                    See `%b=leftoffset`
	    CurrentRec length = 209                  Indicates the current character in the current record, counting from the leftmost ( 0 )
	 CurrentRec protected = 0                    Indicates that the current record of the buffer is a hash-table target and has been protected.
	     ProtectedRecords = 0                    Indicates that the buffer contains at least one protected record.
	               Header = "A"~"B"~"C" ...      See `%b=header`
	             FileType = ascii                Currently the only valid entries are ascii or binary.
	                        No tag types         If the buffer had tag types defined then these would be listed here (see `About Tagged text`).
	        HashTableMode = 0                    Valid modes are 0 (No hashtable), 1 (ProtectEntries), 
	                                               2 (AdjustEntries), 3 (DeleteEntries) and 4 (DestroyHashtables)
	                                               see `hashtable create` for details.
	             TabStops = 17 41 62 89 172 ...  Indicates columns in tabular text - see `about tabular text`.
	                 htab = FALSE                Indicates that there is no hash table associated with this buffer.

}}}
{{{ Query samesinceio
3.29.26 Query samesinceio
-------------------------
%q=samesinceio
  - tests state of SameSinceIO flag in current buffer.
   
  Use this command to test for changes to the buffer since it was last read or
  written back to the filing system.
   
  Command exits with failure if  the  buffer  has  been  changed  in  any  way
  compared to the  version  on  the  filing  system,  exits  with  success  if
  unchanged. 
  
  Text buffers  which  are  not  images  of  files  are  always  created  with
  samesinceio set false.

}}}
{{{ Query samesinceindexed
3.29.27 Query samesinceindexed
------------------------------
%q=samesinceindexed
  - tests state of buffers SameSinceIndexed flag.
   
  Use this command to test for changes to the the buffer since making the last
  hash table entry.
   
  Command exits with failure if the buffer has been changed in any  way  since
  it was indexed with the `%H` commands, exits with success if unchanged. Note
  that text buffers which have  not  been  indexed  are  always  created  with
  samesinceindexed set false.

}}}
{{{ Query sameflag1
3.29.28 Query sameflag1
-----------------------
%q=sameflag1
  - tests state of buffers SameFlag1 flag.
   
  Use this command to test for changes to the buffer since the flag was set.
   
  Command exits with failure if the buffer has been changed in any  way  since
  the SameFlag1 was set (see `%b=sameflag1`), exits with success if unchanged.
  Note that text buffers  are  initially  created  with  samesinceindexed  set
  false.

}}}
{{{ Query case
3.29.29 Query case
------------------
%q=case
  -  Success if case sensitivity is on.
   
  This simply sets the failure flag - it fails if case sensitivity is off.

}}}
{{{ Query inview
3.29.30 Query inview
--------------------
%q=inview
  - Success if current character is visible on the screen, adds other  details
    to stack.
  
  Verifies that current character is  visible  with  the  current  setting  of
  leftoffset - see `%b=leftoffset` and `about long lines`.  This  query  works
  independently of the display management, the consequence of this is that  it
  is not necessary  to  update  the  display  (see  the  `W`  command)  before
  launching the query.
 
  This query always pushes three values onto the stack:
    - perceived current character offset - i.e. if tabstops are set,  it  take
      these into account.
    - width of the screen and
    - the current buffer's leftoffset,
    - for a tabcells buffer (see `about tabular text`) the  query  fails  when
      the current character is in a truncated part of the cell text - even  if
      it's cell is somewhere between the screen margins.
  
  This command fails if the current character is outside the visible area. i.e
  if the current character is off to the right of the screen  when  leftoffset
  has been set too low or left of the left margin when the leftoffset has been
  set to high.
  
  The values placed on the stack are designed to be a  useful  starting  point
  for calculation of a revised  leftoffset  -  for  an  example  look  at  the
  definition of `WordLeft` and `WordRight` in the standard startup script.

}}}
{{{ Query commandmode
3.29.31 Query commandmode
-------------------------
%q=commandmode
  - Success if editor is in command mode.
  
  This does not affect any buffers or the stack - it  just  returns  a  status
  result - Success indicates that the editor is indeed in command  mode,  fail
  indicates that it is in insert mode.

}}}
{{{ Query version
3.29.32 Query version
---------------------
%q[<key>]=version
  - reports editor version and, where appropriate, curses version.
   
  This delivers a brief informational message about the editor  version  build
  date and host system. If the buffer key is given this message goes  to  that
  buffer otherwise it goes to the console area of the screen. A typical report
  looks like this:
version
jot for chrome v2.0, built 27/12/16 16:59:42 using crouton  ncurses 6.0.20150808
  
  The  majority  of  the  reply  is  defined  by   the   compile-time   string
  VERSION_STRING. This is typically defined with using the output of the uname
  command.
  
  The  final  section   is   obtained   by   calling   the   curses   function
  curses_version().

}}}
{{{ Query dir
3.29.33 Query dir
-----------------
%q[<key>]=dir [<fmt1> [<fmt2> [ <fmt3> ... ]]]<path>
  - reports contents of directory.
  
  If the specified pathname does not exits or does not point to  a  directory,
  then the command fails. If no destination buffer is specified then  the  dir
  query will only verify the path.
  
  If the destination buffer is specified (i.e. if the optional buffer  key  is
  given) then the dir query lists the contents of the nominated  directory  to
  the nominated buffer. Note that the order is just as returned by the  filing
  system - you will need to use `%b=sort` to get them in order.  This  command
  will always check that the path exists and  destination  node  really  is  a
  directory and will fail if this is not  so.  If  no  destination  buffer  is
  specified this query will only check that the given path  exists  and  is  a
  directory.
  
  If any format specifiers are included then the relevant information is added
  to  the  file  entries.  The  following  format  specifiers  are   currently
  supported:
    - -mtime - the file's modification time in the form yyyy/mm/dd-hh:mm:ss
    - -utime - the file's usage time in the form yyyy/mm/dd-hh:mm:ss
    - -ctime - the file's creation time in the form yyyy/mm/dd-hh:mm:ss
    - -uid - the uid of the file's owner (not available in Windows version),
    - -gid - the gid of the file's owner (not available in Windows version),
    - -size - the file size in bytes,
    - -mode - file permissions, in  windows  it  only  indicates  Readonly  or
      Writable,
    - -inode - the file's inode number (not available in Windows version),
    
  In the report sent to the specified destination buffer,  the  optional  data
  fields are separated from the file names by a tab (VT)  character.  To  make
  this a bit easier on the eye run the `autotab.jot` script.

}}}
{{{ Query file
3.29.34 Query file
------------------
%q[<key>]=file [<pathName>]
  - reports on state of file.
  
  The file query will always check that the pathName exists and will  fail  if
  this is not the case. If no destination buffer is specified, this  check  is
  all it does.
  
  If no file name is specified then the pathName  of  the  current  buffer  is
  used. If no pathname is specified and the destination buffer is the same  as
  the current buffer then this command fails without completing the report.
  
  When the destination buffer is specified, the file query lists various  bits
  of system information about the  specified  file.  Note  that  there  is  no
  stripping of additional whitespace following the delimiter blank  after  the
  file keyword.
  
  The following report is written to the destination buffer:
	file <pathName>
	                 Name = "<pathName>"
	                inode = <inodeNumber>
	                 Mode = <modeInOctal>
	                  uid = <userID>
	                  gid = <groupID>
	                 size = <fileSizeInBytes>
	 writable by this UID = <yes|no>
	            directory = <1_IfDirectory_0_IfNot>
	          Access time = <fileAccessTime>
	          Modify time = <fileModifyTime>
	        Creation time = <fileCreationTime>
  All datestamps are in the following format: YYYY/MM/DD, HH:MM:SS

}}}
{{{ Query keys
3.29.35 Query keys
------------------
%q[<destinationBuffer>]=keys
  
  This dumps all the keys associated with the current buffer to  a  report  in
  the nominated destination  buffer  it  fails  if  there  is  no  hash  table
  associated with the current buffer. If no destination  buffer  is  specified
  then it simply returns the status result. In addition to listing each key in
  full, it also the first 30 characters of the text associated with the key.
  
  The keys are part of the internal  hash-table  data  structure.  While  this
  query may be useful for diagnosis of problems with  macros  -  it's  primary
  purpose is the detection of errors in the editors internal  hash-table-entry
  handling operations.

}}}
{{{ Query key
3.29.36 Query key
-----------------
%q[<destinationBuffer>]=key <hTabKey>;
  
  This reports on the specified hash-table entry the report  is  sent  to  the
  specified buffer. If the key has not been set up in that hash table then the
  command fails.

}}}
{{{ Query tags
3.29.37 Query tags
------------------
%q<destinationBuffer>=tags[ -here]
  
  In the  internal  data  structure,  each  record  has  any  number  of  tags
  associated with it. These tags are used  to  maintain  hashtables,  optional
  text colours and user-specified metadata in the form of text  strings.  This
  query lists the tags (hash-table target points, colour tags and  text  tags)
  in current buffer the report goes to a nominated destination buffer.
  
  The optional qualifier -here will return  only  those  tags  active  at  the
  current character. Currently, this is the only mechanism for  extraction  of
  user-specified metadata from the record. One useful application for this  is
  storage of hash-table keys  associated  with  the  text  -  especially  when
  combined with a mouse-event handler. The `linkdocs.jot`  and  `bookings.jot`
  scripts are examples of this.

}}}
{{{ Query heap
3.29.38 Query heap
------------------
%q=heap
  - reports heap statistics.
  
  Reports raw data from the mallinfo routine (see the mallinfo man page).

}}}
{{{ Query history
3.29.39 Query history
---------------------
%q<buf>=history
  - reports command history.
   
  Reports all entries in the history  buffer  in  chronological  order  -  the
  report is directed to the nominated buffer. The size of the  history  buffer
  is limited but can be changed with the `-history` cli qualifier. This report
  is used in the command-edit screen - see `about command editing`.
   
  N.B. The history maintained for the history query is entirety independent of
  the history file in the journal area - see `about journal files`.

}}}
{{{ Query verify
3.29.40 Query verify
--------------------
%q=verify
   - Verify integrity of current buffer's internal data structures.
  
  This command performs a few simple checks aimed at detection  of  errors  in
  the internal record structures. The main test is to ensure that  the  string
  length of each record is never longer than the allocated string  size.  This
  situation should *never* occur, if it were to, the editor would crash before
  long as other internal data gets corrupted.
  
  If the verbosity level is more than 1 (See `%S=verbose`) then  the  contents
  of the buffer are echoed to the console area.

}}}
}}}
{{{ %H
3.30 %H
------------
  The  %H  command  is  used  for  maintenance  of  hashtables  -  see  `about
  hashtables`
  
%H[<key>]=create <n>[ <path>] {-delete|-destroy|-protect|-adjust}
  - Creates a new hashtable. See `hashtable create`
    
%H[<path>]=add <hashTableKey> - Create a hashtable entry.
  See `hashtable add`
    
%H[<path>]=new <hashTableKey> - Create a new hashtable entry, fails if path 
  does not define a unique name. See `hashtable new`
  
%H[<path>]=data <hashTableKey> - creates a hashtable object which can hold a 
  stack frame - see `hashtable data`.
  
%H[<path>]=setsect <hashTableKey> - creates a hashtable object for use in a 
  %i=<pathName> ... -section; command - see `hashtable setsect`
  
%H[<path>]=setfsect <hashTableKey> - creates a hashtable object for use in a 
  %i= ... -fsection; command - see `hashtable setfsect`
  
%H[<path>]=delete <hashTableKey> - Removes specified hash-table entry.
  See `hashtable delete`
  
%H[<bufferKey>]=jump <hashTableKey>
  - Search for a match to path - see `hashtable jump`.
      
%H[<key>]=call <hashTableKey> -  Search for routine then run it.
  See `hashtable call`
  
%H[<path>]=fix - resets line numbers for referencing hashtables.
  See `hashtable fix`
  
%H[<path>]=destroy[ -all] -  Destroys the hashtable.
  See `hashtable destroy`
  
%H[<path>]=testkey [<string>] -  Verifies the hashtable entry exists.
  See `hashtable testkey`
  
%q[<destBufKey>]=keys - lists all keys in the hash table associated with
      this buffer - see `Query keys` for details  it  fails  if  there  is  no
      hashtable associated with the buffer.
      
    - %q[<destBufKey>]=key <keyString> - reports details of that key - if  the
      key is not defied in the hashtable then the command fails.
      

{{{ Hashtable create
3.30.1.1 Hashtable create
--------------------------
%H[<bufferKey>]=create <size>[ <path>] [-delete|-destroy|-protect|-adjust]; - Create a new hashtable.
   
  Create an empty hashtable in specified buffer, or  the  current  buffer,  if
  none specified. The size parameter specifies the size  of  the  table.  Take
  care to not underestimate the required size. The value can be  specified  on
  the command line or picked up from the top of the stack.
  
  If the buffer already has a hashtable and the new size is  sufficient,  then
  this is destroyed and it's mode and entries are copied to the new hashtable,
  if the new size is insufficient then the command fails. As the hashtable  is
  copied over, any zombies are removed (zombies are  entries  that  have  been
  deleted with the `hashtable delete` command). This behaviour is intended  to
  allow purging and re-sizing while preserving existing entries.
  
  If the size is set to 0 or any negative value then any preexisting  hastable
  is destroyed and no new  hashtable  is  created  -  the  overall  effect  is
  identical to `hashtable destroy`.
  
  The optional path parameter  defines  the  hashtable  pathname  (see  `about
  Hashtables`), by default, the hashtable is create  in  the  current  buffer.
  When a valid path is set the hashtable is created in the specified buffer or
  sub-buffer, sub-sub-buffer ... etc. to any depth.
  
  The hashtable contains pointers to various classes  of  object  (see  `about
  hashtables`):
  
   - 'target strings' in your text - allowing fast access to sections of text,
   
   - data objects (see `hashtable data`), which can be copied to and from  the
     stack and
     
   - file-section objects (see `%I`)
   
  There are several options regarding behaviour when the targeted strings  are
  to be deleted (see `about hashtables`). Essentially these are:
  
    - -adjust - When  any  target  string  is  deleted  the  relevant  entries
      targeting hashtables are silently redirected to some nearby point.  This
      is the default mode of operation.
      
    - -delete - When any target string  is  changed  the  relevant  hash-table
      entries are marked as deleted.
      
    - -destroy - When any target string is deleted the targeting hashtable  is
      silently destroyed and all of it's target tags are  removed.  Any  other
      changes in the vicinity of the hashtable target points cause the targets
      to be adjusted.
      
    - -protect - Any record containing  a  target  string  is  protected  from
      deletion Any other changes in  the  vicinity  of  the  hashtable  target
      points cause the targets to be adjusted.

}}}
{{{ Hashtable add
3.30.1.2 Hashtable add
-----------------------
%H[<bufferKey>]=add <hashtableKey> - adds a hashtable key.
   
  Adds a new jump entry (see `hashtable jump`)  to  the  hash  table  for  the
  specified or, current buffer, if none is specified.  The  hash  table  entry
  will store the exact location  of  the  current  character  in  the  current
  buffer. In the event of a collision (i.e. the  key  already  exists  in  the
  hashtable) the original value is silently replaced by  the  new  value.  See
  `about hashtables`.

}}}
{{{ Hashtable new
3.30.1.3 Hashtable new
-----------------------
%h[<bufferKey>]=new <hashtableKey> - adds a new hashtable key.
   
  Similar to add (above) except  that,  in  the  event  of  a  collision,  the
  original entry is unchanged and the command fails. See `about hashtables`.

}}}
{{{ Hashtable jump
3.30.1.4 Hashtable jump
------------------------
%h[<bufferKey>]=jump <hashtableKey> - performs a hashtable lookup and jump.
   
  The hash table in the specified buffer  (or  the  current  buffer,  if  none
  specified) is searched. If the key exists then the focus is restored to  the
  point at which the key was entered. If  the  key  is  not  found,  then  the
  command fails - see `about hashtables`.

}}}
{{{ Hashtable data
3.30.1.5 Hashtable data
------------------------
%h[<bufferKsy>]=data <HashtableKey; - creates a hashtable entry for storage of generic data.
  
  This creates a hashtable entry which can be used  for  storage  of  a  stack
  frame. The command creates a blank entry and does not affect  the  state  of
  the stack. The data value can be refined with the  `OV`  command  and  later
  retrieved using the `OQ` commands. 
  
  Note the absence of any typing with this command, any  of  the  three  valid
  stack datatypes (integer value, floating-point value or buffer) may be  used
  with any data object and the datatype is allowed to change. In this example,
  the data object fred is first set to an integer, then a float and,  finally,
  a buffer - it's all allowed.
> %h=create 100;
> %h=data fred;
>ol123456789 ov/fred/
> ol123.456 ov/fred/
> %d~=Hello world; ov/fred/

}}}
{{{ Hashtable setsect
3.30.1.6 Hashtable setsect
---------------------------
%h[<bufferKey>]=setsect <hashtableKey>; - creates a hashtable entry for use in %i;
  
  This takes the top two items on the stack and creates a hashtable entry  for
  use by the -section=<key> qualifier of the `%I`  command.  This  is  a  rare
  example of a magic command in jot -  it  is  designed  for  use  by  scripts
  reading index tables for large files and is only useful  for  this  purpose.
  (see `about large files`).
  
  Another unusual feature of this command - although it uses two values at the
  top of the stack, it does not remove them.  This  feature  is  designed  for
  scripts which calculate section byte counts by subtracting seek neighbouring
  seek points.

}}}
{{{ Hashtable setfsect
3.30.1.7 Hashtable setfsect
----------------------------
%h[<bufferKey>]=setfsect <hashtableKey>; - creates a hashtable entry for use in %i;
  
  This takes the top three items on the stack and creates  a  hashtable  entry
  for use by the -fsection=<key> qualifier of the `%I` command. It is designed
  for use by scripts reading index tables for large numbers of  files  and  is
  probably only useful for this purpose.  (see  `about  large  collections  of
  files`).
  
  Another unusual feature of this command,  similar  to  `hashtable  setsect`,
  although it uses three values at the top of the stack, it  does  not  remove
  them. This feature is designed for the computational convenience of  scripts
  calculating section byte counts by  subtracting  the  previous-section  seek
  point from the current-section seek point.
  
  Note that consecutive setfsect calls referring to the same pathname will all
  share the same internally-held copy  of  the  pathname.  This  behaviour  is
  designed  to  minimize  memory  usage  by  the  internal  data   structures.
  Fortunately most practical  indexation  methods  will  generate  index  file
  structured in this way.

}}}
{{{ Hashtable delete
3.30.1.8 Hashtable delete
--------------------------
%h[<bufferKey>]=delete <hashTableKey>;
  
  This changes the state of the selected key to a  sort  of  half-dead  zombie
  state. Unfortunately it is not possible to delete keys from hashtables built
  using the gnu-library hashtables. So we do the next-best thing.
  
  The hash key can be re-assigned - this, for example, will work:
> %h=add fred;
> %h=delete fred;
> %h=data fred;
  
  The zombies are removed  if  the  hashtable  is  rebuilt  -  see  `hashtable
  create`.

}}}
{{{ Hashtable call
3.30.1.9 Hashtable call
------------------------
%h[<bufferKey>]=call <functionName>
   
  The buffer indicated by the key must be a code  repository  (  see  `calling
  subroutines by name` ). The `startup.jot` script, for example,  defines  and
  creates hash-table entries for a number of routines in the ' buffer.
  
  In the event of the named subroutine is not in the  specified  buffer,  then
  the call fails silently.
  
  Note that %h=call does not pass parameters into the routine. The way this is
  done with escape sequences is a little bit of code  immediately  before  the
  call that copies parameters into the ( $ )  buffer  -  see  `translation  of
  keyboard events to actions`

}}}
{{{ Hashtable fix
3.30.1.10 Hashtable fix
-----------------------
%h[<bufferKey>]=fix
  This corrects the linenumbers held in  any  hashtable  it  also  resets  the
  linenumber of the first line to 1 and returns to the first line.
  
  If records are added or removed after the  buffer  has  been  indexed  in  a
  hashtable, the linenumbers held in the hashtable may be incorrect. This  can
  result in errors when using these linenumbers to calculate  offsets  between
  indexed records. The fix operation assigns the new, correct, linenumbers  in
  the referencing hashtables and resets the buffer so that any errors  in  the
  line numbering are resolved.

}}}
{{{ Hashtable destroy
3.30.1.11 Hashtable destroy
---------------------------
%h[<bufferKey>]=destroy[ -all]
  
  This removes the entire hashtable, destroying all entries. The optional -all
  qualifier will destroy all hash tables in all buffers - N.B.  including  any
  system hashtables like the code-repository functions set up in  the  (  '  )
  buffer.

}}}
{{{ Hashtable testkey
3.30.1.12 Hashtable testkey
---------------------------
%H[<bufferKey>]=testkey [<string>]

  By default this tests the hashtable of  the  current  buffer.  The  optional
  bufferKey specifies some other buffer's hashtable to be tested. 
  
  The %h=testkey command verifies the hashtable  contains  at  least  one  key
  matching the given string. This is used to find out if a hashtable has  been
  set up and, if a search string is given, that at least one key  matches  the
  string.
  
  If the string parameter is not  given,  then  this  command  checks  that  a
  hashtable exists.
  
  This command does not write any report, it simply returns a Success or  Fail
  status.

}}}
}}}
{{{ %D
3.30.2 %D
----------
%D<key>=<string> - Defines the specified buffer directly from the console.
  
  The first parameter is the buffer identifier key - a single  character  used
  to reference the buffer. Note that, unlike most other percent commands,  any
  indirect references in the  string  are  not  resolved  at  %D  time  -  see
  `percent-command syntax` for details. This anomalous behaviour  is  designed
  to facilitate the definition of macro commands.
  
  One particularly important variant is %d~=...; -  this  creates  a  one-line
  buffer on the top of the stack and is often followed by  the  `OV`  command.
  This combination is used to set a data object to a string value. See  `about
  hashtables` and `using Hashtable data`
  
  Whereas %D will define a single-line buffer (usually a macro) `%G` is useful
  for defining any-number of lines.

}}}
{{{ %G
3.30.3 %G
---------
%G - Get = Reads in an buffer from current command stream or macro.
  
  This is similar to the `G` command, except that whereas G always takes input
  from the console, %G will take from whatever command input currently active
  - typically a script.  Thus  %G  is  a  handy  way  for  scripts  to  define
    multi-line macros.
  
  Whereas %G defines any number  of  records  `%D`  is  a  convenient  way  of
  defining a single-line macro.

}}}
{{{ %I
3.30.4 %I
----------
%I[<bufferKey>][=<pathName>][ -seek=<ByteNo>][ -bytes|-block=<bytes>|-records=<n>]|
  [ -section|-fsection][ -insert | -append][ -hold][ -binary[=<recordSize>]]
    - Input (read) a secondary file.
  
  This loads the file to buffer specified by the buffer identifier key. If  no
  key is given, it reads to the current buffer.
  
  The pathname defaults to the pathname of the currently-edited file.  If  the
  new filename is incompletely specified then the missing fields are filled in
  using the current-buffer's pathname. Note  that  this  behaviour  can  cause
  difficulties. If the new file is in your pwd and the current file is in some
  other directory, you must prefix the name with the path "./". If the  target
  file has no name extension and the current file does, you must change  focus
  to a buffer with no pathname set.
  
  Briefly %I has the following optional qualifiers several dedicated  in  some
  way to the loading of sections of large files - see `about large files`:
    - -seek - specifies a byte-offset section start point,
    - -bytes - specifies a section length in bytes,
    - -section - loads a named section, previously defined in a hashtable,
    - -fsection - as -section but object also specifies pathname,
    - -append - adds the section to the end of an existing file image,
    - -insert - inserts the text at the current-character position,
    - -hold - holds the file-handle open for reading multiple sections,
    - -records - limits the number of records (lines) read from the file,
    - -binary - loads the (possibly binary) file in the form of a Hex dump
  
  The -bytes qualifier gives it an end count which restricts the read to  that
  many bytes. It can be combined freely with the  -hold,  the  -seek  and  the
  -binary options. The -block qualifier is similar  in  that  it  specifies  a
  limit on the number of bytes but, with -block, blocks of data are read  into
  one record of the specified size. This feature is designed to speed  up  the
  movement of large blocks of data by bypassing all the normal record-building
  activity associated with normal reads. The -records=<n>  qualifier  sets  an
  upper limit on the number of records to be read.
  
  The -seek can be used for reading sections of file, provided you know  where
  the desired section is and how big it is. It can be useful for  reading  the
  important bits from large files.
  
  The -section qualifier sets the seek and limit from the top two items on the
  stack. This is designed to  be  used  in  conjunction  with  the  `hashtable
  setsect` command. Unlike the -fsection variant, -section  assumes  that  the
  pathname is known and constant. It is therefore more suitable for situations
  where only one file is required - typically a very large file  containing  a
  great many sections.
  
  The -hold qualifier causes the file handle associated with the buffer and to
  be left open, this is to facilitate reading of files in blocks.  The  actual
  file handle is associated with the buffer and therefore cannot  be  used  to
  read into other buffers. This option is intended to be used  in  conjunction
  with the -section option, on very large files.
  
  The -fsection qualifier  is  very  similar  to  -section,  except  that  the
  hashtable object it accepts is the form created by the `hashtable  setfsect`
  command. These objects are created by the `hashtable setfsect` command. Like
  the  setsect  object,  this  contains  a  seek-offset  byte  count   and   a
  section-length bytecount but it also contains the pathname of the file to be
  read. This  makes  the  -fsection  variant  suitable  for  situations  where
  sections are distributed over a large number of files.
  
  The -binary option reads the file and displays it in the form of a hex dump.
  The optional recordSize value specifies how many Hex pairs to place in  each
  line,  defaults  to  16.  To  view   ascii   characters   use   the   script
  `hex2ascii.jot`, this annotates  each  line  of  hex  dump  with  the  ascii
  translation.
  
  The -insert qualifier  causes  the  file  image  to  be  inserted  into  the
  current-character position of the buffer. By default the buffer  is  cleared
  and the new file completely defines the buffer text. The  -append  qualifier
  is similar except that the new records are  delivered  to  the  end  of  the
  current buffer without changing the current view.
  
  If the buffer has already been reading a file with -hold, the  new  pathname
  is ignored and the old file handle is reused. To prevent this  happening  it
  is necessary to perform a read without the -hold qualifier - something  like
  this should do the trick:
> %iz=/dev/null -append;

}}}
{{{ %L
3.30.5 %L
----------
%L [<width>x<height>] - Sets the terminal line length and number of lines.
  
  This is a throwback to the  days  of  VT200-series  terminals,  the  DECCOLM
  function allowed 80/132 switches.
  
  More typically, in an  xterm  environment  the  xterm  size  is  changed  by
  dragging the window boundaries. After this, %l  can  be  used,  without  the
  terminal-size parameter, after changing the xterm dimensions. It reads  back
  the new screen height and width henceforth these  new  values  are  used  in
  internal calculations involving screen dimensions.
  
  If a terminal size is specified, each of the given dimensions should be less
  that the than or  equal  to  the  corresponding  dimensions  of  the  actual
  terminal you are using - if not then %L fails and both are set to the actual
  screen size.
  
  After a %L operation, all windows remain valid except any where the right or
  bottom margin exceeds the relevant new terminal dimension.  If  this  should
  happen the %L sets the failure flag and the offending windows are tagged  as
  Void. Use the `WindowOne` function to re-assign the window.
  
  This command also completely redraws all windows on the screen, hence it  is
  useful if, for whatever reason, the screen happens to get messed up.

}}}
{{{ %O
3.30.6 %O
----------
%O[<pathName>][ -append]  - Output current buffer as specified file.
  
  The current buffer is written out using the given pathname.
  
  The -append qualifier adds the contents of the buffer  to  the  end  of  the
  file. Whether or not the -append qualifier is given, if the  file  does  not
  exist, then a new one is created.
  
  The pathName defaults to the pathname of the current buffer. If the new file
  name is incompletely specified then the missing fields are filled  in  using
  the current pathname.

}}}
{{{ %R
3.30.7 %R
----------
%R=[pathname][ -asConsole][ <Arg1>[ <Arg2>[ ...]]] - Run a command file.
  
  If no path is explicitly specified, then JOT first  searches  your  PWD,  if
  it's not found there, it  searches  the  directory  ${JOT_HOME}/coms  -  see
  `installation`.
  
  Any parameters will be copied into the ( $ ) buffer to be picked up by  your
  script.
  
  The file contains editor commands, these are all executed in the same way as
  with console input, the default file name is startup.jot.
  
  In the event of an un-trapped error (i.e.  a  command  failed  and  no  else
  clause applies), then execution of the script is  normally  terminated.  The
  -asConsole qualifier changes this behaviour.
  
  When the -asConsole qualifier is  given,  the  behaviour  is  more  like  an
  interactive session:
    - Errors are reported normally then, instead of abandoning the script, the
      error is changed to an  ordinary  command  failure  so  that  processing
      resumes at the else block or the next line of the script.
    - The script may contain escape sequences - in practice the only ones that
      are likely to contain these are recovery scripts -  see  `about  journal
      files`.
    - While the script is active  all  console  reads  (e.g.  commands  and  g
      command input) are from this script.
    - The principal purpose for -asConsole  operation  is  to  allow  recovery
      scripts to behave as the  original  interactive  session  -  see  `about
      journal Files`.
  
  Command files may be nested to a depth of 20.

}}}
{{{ %U
3.30.8 %U
----------
%U - Undo = Undo last substitution.
  
  The current substring (irrespective of whether selected by `F`, `V`, `I`  or
  `S`) is replaced by the last specified search string. Normally,  of  course,
  this would have been set as a result of a S (substitute) command,  following
  a F (Find) command, hence the substitution is undone.
  
  If the original find substring had a different case pattern to the  replaced
  substring (i.e. the find was done in case-insensitive mode)  then  the  undo
  will not reflect the original case pattern.

}}}
{{{ %W
3.30.9 %W
----------
%W[<key>]=[ -winno=<n>][ -key=<NewKey>][ -popup][ -delim]
            [ -height=<height>][ -width=<width>[+<guard>]]]]      
            [ -delete|-insert|-freeze=[0|1]]
Historical syntax:
%w <height>[ <key>];
            
  The %W command controls the display which may be split into  any  number  of
  windows, limited by the overall  size  of  your  terminal.  Windows  may  be
  defined as a number of screen lines or may be vertical  slices  of  <height>
  lines and <width> columns. Windows may be assigned to  specific  buffers  or
  can be left unassigned - in which case they display the current buffer.
  
  The window command indirectly defines the height of the  console  area,  the
  window size and the total height of all  the  windows  together  define  the
  console area height. The console area can be set to expand upwards into  the
  window area - see the `%s=console` command.
  
  The window configuration can be modified by specifying a  particular  window
  deleting it or specifying a  new  <width>,  <height>  or  <windowKey>  of  a
  specific window.
  
    - Set up next <height> lines as a screen window or
> %W<key>= -width=<width>[+<guard>]
    - set up another vertical slice in the previously defined window or
> %W<key>= -popup [ -width=<width>][ -height=<height>]
    - defines a popup window (only appears when buffer contains text) or
> %W;
    -  with no arguments, all screen windows are cleared
> %W <height>[ <key>];
  This is a historical syntax, still supported but deprecated. If, when  using
  the historical syntax, a -height=<height> qualifier is  included,  then  the
  height specified here overrides the earlier specification. 
  
  New windows, or vertical slices of windows,  are  added  in  sequence  by  a
  series of %W commands, typically the first  will  be  %W;  -  to  clear  all
  windows.
  
  Note that the qualifiers must always follow whitespace  -  this  is  correct
  syntax:
> %wz= -height=11;
  this will fail:
> %wz=-height=11;
  
  - <height> - Specifies the number of screen lines to allocate  to  the  next
    window. These are allocated sequentially starting from the top  line.  New
    windows are added below any preexisting ones. Note that  n  specifies  the
    total size of the window, if you later request a delimiter line (%w 0;  ),
    this replaces the bottom line of your window and if you specify  a  header
    line to be associated with a buffer (see `%b=header`) then  this  replaces
    the top line of your window. eg:
> %w 20;
  or, here we take the window size off the stack:
> %w '~;
    
  - The -delim option requests that the last line of the window be filled with
    a delimiter line. The  window  delimiter  is  in  reverse  video  and,  by
    default, set to the pathname and the buffer key - see `%b=footer`.
    
    An obsolete method of requesting a delimiter line was %w=0; after  the  %w
    used to define the window - this is deprecated but still supported for the
    benefit of old scripts.
    
  - The optional -width=<width> modifier specifies the  width  of  a  vertical
    slice of the window. When mixed with  %W=<height>  ...  this  becomes  the
    leftmost slice in a new window of that height. When the  window-height  is
    set to 0, then a new slice of the specified  width  is  added  to  earlier
    slices.
    
    By default, the left margin of the second and subsequent slices will  abut
    the right margin of the predecessor slice. The  +<guard>  modifier  (where
    <guard> is a small integer) will insert that many  blank  columns  between
    the slice and it's predecessor slice.
  
  - The optional <key> parameter specifies which buffer is  to  be  associated
    with the screen window, if this is not given then the  current  buffer  is
    displayed in the window - a floating window. 
    
    In the event of there  being  more  than  one  floating  window,  or,  one
    floating window and the current window is attached  to  a  static  window,
    then the  floating  window  is  left  displaying  whatever  buffer  it  is
    currently displaying or, at the start of day, it displays blank lines.
    
  - When  the  optional  -winno=<windowNo>  modifier  is  given,  rather  than
    creating a new window, the  command  will  modify  the  attributes  of  an
    existing window. The <windowNo> refers to the target window's position  in
    the window list. This is the same as  the  order  that  the  windows  were
    originally created and appears at the head of the report generated by  the
    `Query window` command.
    
    The  -winno=<windowNo>  qualifier  can  be  combined  with  the  following
    modifiers to modify the relevant attributes of the target window:
      - -height=<height> - to set the window height - for slices see below,
      - -width=<width> - to specify a new slice width,
      - -key=<NewKey> - to specify a new buffer association for the window.
      - -delete - deletes the selected window from the window list.
      - -insert -  inserts  the  newly-specified  window  above  the  selected
        window.
      - -freeze=[0|1] - forces the window in/out of frozen mode - see below.
      
    When it is required to change the height of an existing group  of  slices,
    this can be  accomplished  by  changing  only  the  height  of  the  first
    (leftmost) slice in the group. Any attempt to change the height  of  other
    members of the group will fail.
        
  - The -freeze=1 modifier forces the selected window to be frozen -  even  if
    there are no duplicate views in other windows. The -freeze option  can  be
    applied to any window and it will remain displaying whatever was displayed
    as the %w ... -freeze command was issued. Note that the  -freeze  modifier
    is ignored for popup windows. The -freeze=0 modifier unfreezes the window.
    
    Note that jot does not maintain a record of the state of  frozen  windows.
    It simply avoids updating them as  the  state  of  the  underlying  buffer
    changes. Any subsequent `%W` or `%L` command will clear  the  window  and,
    should a `%E` corrupt the display by scrolling into the frozen section  of
    the display, then the %E output will replace the original view.
  
  - When the -popup option is given, a buffer key must be given. Popup windows
    can be used to display information or to provide some sort of  menu-driven
    interface. These are  visible  only  when  the  associated  buffer  has  a
    nonblank first line.
    
    Popups overwrite rectangular sections of the display, in order  to  ensure
    that the popup becomes visible the popup window should  be  defined  after
    the definition of the underlying windows.
    
    There is no limit to the number  of  popups  but  since  each  requires  a
    dedicated buffer and it is quite easy to share them between  a  number  of
    activities it is recommended practice to use as few as possible.
    
    For -popup windows, the height and -width dimensions specify  the  maximum
    size that the window can be allowed to grow to - if unspecified the  popup
    may grow to fill the entire terminal screen. The top-left character of the
    popup is normally aligned to  the  top  left  character  position  of  the
    screen. If a negative width is specified  then  the  top  right  character
    position of the popup is aligned to the top-right  character  position  of
    the screen.
    
    Note that, by default, the popup appears in the same colour pair and  font
    as the surrounding text with no delimiter  markers.  It  is  left  to  the
    programmer to make suitable arrangements for the popup stand out from  the
    surrounding text. Failure to do this will make the display very confusing.
    
  See also `%S=guardband`.
  
  Examples:
> %w;              %%Clear away all preexisting windows.
> %w 35; %w 0;     %%Add one window of 34 lines and a delimiter line.

}}}
{{{ %%
3.30.10 %%
----------
  A JOT comment.
  
  The command scanner ignores all text to the right of the %%.

}}}
{{{ %~
3.30.11 %~
----------
%~ - Insert/Evaluate Control Character
   
  All control characters (i.e. characters having an ASCII code  of  less  than
  0x20) are represented on the screen as a '~'. To evaluate such a  character,
  the %~ command returns the ASCII code, in hex,  for  the  character  at  the
  cursor position. This command has an optional hex-value parameter, if  given
  then the command will instead insert a control character  of  the  specified
  value, at the cursor position.

}}}
}}}
}}}
{{{ JOT techniques
4 JOT techniques
-----------------
  This section attempts to reveal some insights into JOT usage.

{{{ Do that again
4.1 Do that again
-----------------
  Simply typing a number at the console will repeat the last command that many
  times. This is how the <<Again>> function works. Typically you will want  to
  do  this  when  you've  typed  in  a  short  command  string  and  want   to
  interactively control how many times it gets repeated.
  
  e.g. The following command removes any indentation from the current line and
  replaces it with two blanks:
> (v/ /e)0i/ /m
  To repeat the treatment  on  subsequent  lines  just  keep  on  pumping  the
  <<Again>> key.

}}}
{{{ Case blocks
4.2 Case blocks
---------------
  A block can have any number of failure handlers, thus each case becomes  the
  failure handler for the previous one e.g. (v/fred/..., v/jim/..., ...)

}}}
{{{ Match to any number of equal-priority conditions.
4.3 Match to any number of equal-priority conditions.
-----------------------------------------------------
  A block without a failure handler will pass it's status  up  to  the  parent
  block, so if there are a list of conditions, any of  which  may  be  met  we
  could write something like this:
    ( ... (v/fred/\v/jim/\v/bill/\) abc, def )
  If the cursor is at the start of any of those names, then the command string
  abc is executed, otherwise it's command def.

}}}
{{{ Tabulated text
4.4 Tabulated text
------------------
  Several scripts are available for handling tabulated text.  These  apply  to
  the entire buffer. To limit the scope of these scripts, abstract the section
  containing the tabular data into a temporary buffer and apply the scripts in
  there.
  
  By default, the tab character is the ASCII HT (Horizontal  Tab  0x0B),  this
  can be redefined with the `%s=tab` command.
  
  The scripts are all based on the  tab  character  indicating  the  alignment
  points.
    - `retab.jot` <string> - inserts tabs based on text content.
      
    - `retabhere.jot` - inserts tabs based on position.
      
    - `autotab.jot` - replaces the first instance of a tab with blanks  so  as
      to align the following text.
      
    - `autotabdp.jot` - similar to autotab but aligns decimal points in column
      following the first tab.
      
    - `autotabjust.jot` - similar to autotab but aligns the following  tabs  -
      the effect is to right-justify the column.

}}}
}}}
{{{ Command-Line qualifiers
5 Command-Line qualifiers
-------------------------
  The following command-line qualifiers are allowed,  the  keywords  are  case
  insensitive, the  upper-case  alphas  indicate  the  minimum  requirement  -
  briefly:
    - `-` - stream-in mode - edit the stdin stream (only required  by  windows
      version).
    - `-HOld` - holds screen on exit.
    - `-Help` - displays a brief help page.
    - `-History`=<n> - specifies size of internal history buffer.
    - `-Init`=<jotCommands> - some initialization commands, run after startup.
    - `-Journal` - create a journal file for recovery from crashes.
    - `-New` - The specified primary file does not exist.
    - `-Obey` - stdin stream is commands.
    - `-Quiet` - suppresses most messages.
    - `-STartup` <pathName> - specifies a nonstandard startup script.
    - `-SCreensize`=<width>x<height> - specifies screen size.
    - `-STACksize`=<n> - specifies operand-stack size.
    - `-To`=<pathName> - specifies the new default filename
    - `-Tty` - run in a simple teletype mode.
    - `-Locale`=<locale> - Set the locale appropriately (unix version only).
    - `-Codepage`=<codepage> - sets codepage (windows version only)

{{{ -
5.1 -
-----
$ <cmd> | jot - ...
  
  The shell command <cmd> generates a text stream which is picked  up  by  jot
  and loaded into the primary buffer ( . ) - this is  only  necessary  in  the
  windows version.

}}}
{{{ -New
5.2 -New
--------
$ jot -new <pathName> ...
  
  Either the file does not exist or, if it does it will be ignored. The editor
  starts with an empty buffer but with with the  specified  pathname  and  the
  file will be created by a `%o` or `%c` command.

}}}
{{{ -To
5.3 -To
-------
$ jot <origPathName -to=<toPathName> ...
  
  Sets the `%o` and `%c` destination file name.

}}}
{{{ -STartup
5.4 -STartup
------------
$ jot <pathName> -startup=[<startupPathName>] ...
  
  A  pathName  to  a  special  startup  sequence.  If  specified,  this  takes
  precedence  over  the  other   possible   startup-file   locations   -   see
  `startup.jot`. 
  
  If -startup is specified with no pathName argument then no startup is run.

}}}
{{{ -Init
5.5 -Init
---------
$ jot <pathName> -init=<jotCommandString> ...
  
  The jotCommandString commands are processed after running the normal startup
  sequence - this can be used to initialize the editor in some special way  or
  for stream editing. This qualifier is also useful when jot is  being  driven
  by a shell script.

}}}
{{{ -Tty
5.6 -Tty
--------
$ jot <pathName> -tty ...
  
  Teletype mode, for use  in  environments  where  the  normal  screen-control
  operations won't work or, when jot is driven by a script.
  
  With -tty any window setup in the startup file has no effect, on  completion
  of each command line, the current line is displayed,  the  position  of  the
  current character is indicated by a carat ( ^ ) in the  following  line  and
  the current substring by a string of tildes ( ~ ).

}}}
{{{ -Codepage
5.7 -Codepage
-------------
$ jot <pathName> -codepage <value> ...
  
  This qualifier is available only  in  the  windows  version,  in  linux  the
  -locale qualifier performs a similar function. This qualifier sets  codepage
  to specified value, by default codepage  is  set  to  65001  -  UTF8  -  see
  `Practicalities of unicode etc. and jot`

}}}
{{{ -Locale
5.8 -Locale
-----------
$ jot <pathName> -locale=<locale> ...
  
  This qualifier is available only  in  the  linux  version,  in  windows  the
  `-Codepage` qualifier performs a similar function.
  
  This sets the default locale for all buffers. Locale currently only  affects
  the rendering of unicode characters. e.g:
$jot ${JOT_RESOURCES}/t.t -locale=en_US.utf-8
  
  For linux the default locale is inherited from the shell env XTERM_LOCALE.

}}}
{{{ -Obey
5.9 -Obey
---------
$ jot pathName -obey << EndOfCommands ...
cmd1
cmd2
cmd3
EndOfCommands
  
  By default, when jot detects that stdin is not a keyboard, it is assumed  to
  be a text stream to be picked up and processed in  the  primary  buffer.  In
  this  case,  however,  it's  a  series  of  commands.  The  -obey  qualifier
  identifies these as such
  
  To push short sequences of in from the command line, the -init=<...>  method
  is generally preferable.
  
  Note that the last command in the -obey sequence  *must*  be  %c  or  %a  to
  terminate the editor session.
  
  This option is really only useful in shell scripts in order to make the  jot
  commands visible and accessible in the same context as the shell commands it
  interacts with. For an example look at Test 8 in ${JOT_HOME}/test.sh.

}}}
{{{ -Journal
5.10 -Journal
-------------
$ jot ... -journal ...
  
  This specifies a directory to hold the journal files. The journal files  are
  used to recover your work following a crash. See `About Journal  Files`  and
  `recover.jot` for details.

}}}
{{{ -Quiet
5.11 -Quiet
-----------
$ jot ... -quiet ...
  
  Suppresses all prompts and messages except for `P` commands. In -tty mode it
  also suppresses any indication of substrings and the current character.

}}}
{{{ -SCreensize
5.12 -SCreensize
----------------
$ jot ... -screensize=<width>x<height> ...
  
  Sets the screen size - only useful for  non-curses  environments  where  the
  editor can't determine the screen size for itself. The width is  denominated
  in characters, height in lines.

}}}
{{{ -STACksize
5.13 -STACksize
---------------
$ jot ... -stacksize=<n> ...
  
  Sets the size of the operand stack to n. By default it is 100, if  you  need
  more then there's probably something gone badly wrong with your scripts.

}}}
{{{ -HOld
5.14 -HOld
----------
$ jot ... -hold ...
  
  On exit, this holds the  curses  screen  until  any  keyboard  character  is
  detected. This allows you see any messages generated by a script before  the
  session finally terminates as you hit any key.
  
  In windows, the windows console is not restored on exit so -hold just  slows
  down your exit.

}}}
{{{ -History
5.15 -History
-------------
$ jot ... -History=<n> ...
  
  Sets the size of the internal command-history buffer, by default it's set to
  to 20 lines. The first element of the history array is the current  command,
  which must always exist. Hence you must specify a value in of 1 or more  for
  this.
  
  This buffer holds the last few typed-in commands. You  cannot,  at  present,
  edit history directly but you can only view  the  contents  of  the  history
  buffer with the %q<buf>=history command - see `query history`.
    
  N.B. The size of this history buffer has no effect on the operation  of  the
  journal history - see `about journal files`.

}}}
{{{ -Help
5.16 -Help
----------
$ jot -help
 
  Displays a brief description of the jot CLI qualifiers and exits.

}}}
}}}
{{{ Installation
6 Installation
--------------
  Start  by  downloading  either  jot_v<version>.tz   or   jot_v<version>.zip,
  whichever you fancy - both archives contain exactly the same files.
    
  Before you can run the editor a certain amount of system-dependent setup may
  be necessary - see either `unix and linux setup` or `ms-windows setup`.
  
  These envs are referenced  by  either  the  main  editor  programme  or  the
  scripts:
    - JOT_HOME - points to the installation tree root
    - JOT_JOURNAL - if set then all sessions create a journal.
    - JOT_RESOURCES  -  used  by  some  scripts  (e.g.  `dic.jot`)  to  locate
      resources such as dictionaries, the startup script uses  it  to  find  a
      help-file tree. If this file exists ${JOT_RESOURCES}/help/help.hlp, then
      this is taken to be the root help entry.
      
  Of these, the only essential one, for a working installation,  is  JOT_HOME,
  it uses this to locate the coms subdirectory (where  it  picks  up  scripts,
  including the all-important startup  scripts).  When  JOT_RESOURCES  is  not
  defined, the startup script  defaults  it  to  ${JOT_HOME}/resources  -  the
  resources directory  from  the  archive  contains  test,  demonstration  and
  training samples.
     
  Typically jot will be started from the command line  from  an  xterm  (or  a
  windows console) with a pathName argument, the editor takes over the  screen
  and displays an image of the specified file. It also reads a  setup  script,
  by default ${JOT_HOME}/coms/startup.jot,  this  defines  functions  and  the
  mapping of keyboard events to functions. To do this the  JOT_HOME  env  must
  point to the correct point in the installation tree.
  
  Also, if you have a shared jot installation then you may prefer to  maintain
  your own ${JOT_RESOURCES} files. This is a collection  of  bits  and  pieces
  used by some jot scripts.
  
	JOT_HOME should point here -->   v<version>                                  
	                                     |                                    
	                  ---------------------------------------------                  
	                 |      |      |                  |            |                  
	                bin    coms   releasenote.txt    resources    source                     
	                 |      |                         |            |
	                ...    ...                       ...          ...   
  
  In addition to files in the jot archives you may feel the need  for  one  or
  more of the following:
  
    - Websters dictionary, useful for authors, available as a plain-text Ebook
      from the Gutenberg project - gutenberg.org
      
    - Roget's thesaurus, another must-have for authors, again  it's  available
      as an Ebook from Gutenberg.
      
    - aspell - a GNU spelling checker. This one was chosen because  it  has  a
      command-driven interface, most of the others will only  work  via  their
      GUI.
      
    - gnumeric - this can be downloaded from the GNU project. It  is  used  to
      convert Microsoft XL spreadsheets to plain text, for `get.jot`
      
    - Apache Tika - this is  a  very  useful  format  conversion  utility.  In
      particular it is used by `get.jot` to convert the following  formats  to
      plain text: MS-word and PDF and MS-XL.
      
    - iconv - a gnu unicode converter (see the GNU libiconv project), used  by
      get.jot to convert the  various  other  unicode  formats  to  UTF-8  for
      display in jot.
      
    - Windows users will probably find life much  easier  with  the  UnixUtils
      toolset. Even if thy do not personally  have  any  use  for  basic  unix
      utilities like ls etc, many jot scripts are written assuming them to  be
      available.
      
    - xsel  -  this  little  utility  provides  an  interface   to   X-windows
      selections. This is used by `copy.jot` and  `paste.jot`  to  access  the
      X-windows selection buffer.
      
      Although not always  available  by  default,  xsel  is  available  as  a
      download from your linux disto provider.
      
      Windows users need  not  fret  about  xsel,  windows  does  not  support
      selections so you will have to use cut and paste instead.
      
    - cabextract, used by get.jot to unpack  these  microsoft  archives,  it's
      available by default with most linux distributions.

{{{ Unix and linux setup
6.1 Unix and linux setup
------------------------
  Wherever you decide to unpack the archive, JOT_HOME should be set  to  point
  at the v<version> directory. You will also  need  to  set  search  path.  In
  linux/bourne-shell:
$ export JOT_HOME=/<path>/v<version>
$ export PATH=${JOT_HOME}/bin/<arch>/;${PATH}
  
  In order to minimize the number of statically-linked libraries in the  linux
  version, the `%s=copy` and `%s=paste`commands are  not  available  with  the
  linux executables supplied in the download. This deficiency can be corrected
  by recompiling with X11 enabled and, if necessary, installation of  the  X11
  libs and header files.
  
  If you have to recompile the jot executable,  these  commands  should  work,
  there may be a few _devl and sharable libraries to be installed:
$ versionString="jot <version>, built `\date +%d/%m/%y\ %H:%M:%S` `\uname -nspr`  "
$ cc -D LINUX -g -Wall ${JOT_HOME}/source/jot.c -D_FILE_OFFSET_BITS=64 -D VERSION_STRING="\"${versionString}\"" \
     -lncursesw -lX11 -lXt -o ${JOT_HOME}/bin/<arch>/jot
$ gcc -g source/jot.c -D VERSION_STRING="${versionString}" -lncursesw -o bin/<arch>/jot
  
   The linux executables supplied in the tarball were statically linked to the
   curses library, with cut and paste disabled by  the  noX11  flag,  using  a
   command similar to this:
$ gcc -DLINUX -DnoX11 $debug -g -Wall source/jot.c \
     -D_FILE_OFFSET_BITS=64   -D    VERSION_STRING="\"${versionString}\""    \
     -Xlinker -dn -lncursesw -lncurses -Xlinker -dy -lgcc_s -o ed/bin/jot
  
  See also `X-windows setup`.
  
  To use the spelling checker functions (see `text document preparation`), you
  will need aspell on your search path.

{{{ Things that might go wrong
6.1.1 Things that might go wrong
--------------------------------
  - bash: jot: command not found
      Check your search path like this:
$ echo $PATH
      You should see the path to the bin subdir in the colon-separated list it
      returns - if not check the following:
        - did you remember to start a new bash after setting up your .bashrc?
        - is the spelling and case pattern correct.
        
      If the path is correct then check  the  binary  is  giving  you  execute
      permission:
$ ls -l <binPath>/jot
      you should see something like this "-rwxr-xr-x" if you don't see  the  x
      characters then make it executable - like this:
$ chmod ugo+x <binPath>/jot
  
  - /lib64/libc.so.6: version 'GLIBC_2.17' not found 
      This is probably because you are using an old  linux  distribution.  Try
      installing a newer glibc - either glibc.x86_64 or glibc.i686  for  older
      32-bit machines. Another  approach  would  be  to  try  recompiling  the
      source, you will need various libraries including some _dev libs  and  a
      gcc - see the previous section for details of the gcc command.
    
  - Error opening terminal: <termName>.
      Check your TERM env:
$ echo $TERM
      Most distributions default it to "xterm" if  it's  something  different,
      then try setting it to xterm like this:
$ export TERM=xterm
      If that works out, and you have no reason to want it  to  be  different,
      put that export line into ~/.bashrc so you don't have to keep on setting
      it in every new shell.
      
      If, however, your TERM is set to xterm, then you've got a problem. Check
      your terminfos:
$ ls -l /usr/share/terminfo/x/xterm*
      There will probably be several flavours of xterm to chose from - pick  a
      likely looking one and export that one.
      
      The Ubuntu crouton system (and perhaps other Ubuntu systems  -  possibly
      also Debian) it may be necessary to install xterm:
$ sudo apt-get install xterm
      and/or set your TERM env to xterm1:
$ export TERM=xterm1
    
  - Failure to render unicode correctly
    - first check your TERM setting (see above),
    - check that you have a good xterm version installed (see above).
    - check your locale setting - this might help:
export XTERM_LOCALE=C.UTF-8 

}}}
{{{ X-windows setup
6.1.2 X-windows setup
---------------------
  The mapping of keyboard function keys is dependent on  various  elements  of
  operating system and it's setup. This is done in several stages, ultimately,
  JOT picks up text characters, control codes and VT100-like escape sequences.
  
  Jot is implemented using functions from the curses library - these provide a
  consistent mapping of most function keys to control codes which jot can  map
  to your selected actions at setup time.
  
  In addition to function keys and other keys supported by  curses,  jot  will
  recognize   vt220-like   escape   sequences   generated   in   response   to
  numeric-keypad actions. The mapping of these is not consistent and different
  installations may give different results. Use  xev  and  xmodmap  to  define
  these mappings. See also `Keyboard functions defined at startup`
  
  The  jot  setup  assumes  unique  keycodes  from   the   numeric   keyboard,
  unfortunately,  in  the  linux-curses  environment,   the   numeric   keypad
  keystrokes are indistinguishable from their twins in other sections  of  the
  keyboard. The windows version does not use curses and does not  suffer  from
  this  problem.  The  solution  for  linux  users,  wanting  to   use   their
  bean-counters keypad, is to redefine the numeric keyboard keys with xmodmap.
  e.g:
$ xmodmap ${JOT_RESOURCES}/my_xmodmap
 
  This version of my_xmodmap works for PC keyboards:
!! Make the numeric keypad keys unique.
keycode  63 = KP_Multiply
keycode  82 = KP_Subtract
keycode  86 = KP_Add
keycode  91 = KP_Decimal
keycode 108 = KP_Enter
keycode  79 = KP_7
keycode  80 = KP_8
keycode  81 = KP_9
keycode  83 = KP_4
keycode  84 = KP_5
keycode  85 = KP_6
keycode  87 = KP_1
keycode  88 = KP_2
keycode  89 = KP_3
keycode  90 = KP_0

}}}
}}}
{{{ MS-Windows setup
6.2 MS-Windows setup
--------------------
  Wherever you unpack the archive, JOT_HOME should be  set  to  point  at  the
  v<version> directory. You will also need to set search path. System registry
  entries are the recommended method but, hey, life is short maybe  this  will
  be good enough for now:
$ setx JOT_HOME=C:\<unpackPath>\v<version>\
$ set PATH=C:\<unpackPath>\v<version>n.m\bin\win32;%PATH%
  
  In windowsland it is most unlikely you will need to recompile, which is just
  as well since compiling just about anything in windowsland is  going  to  be
  painful. If you have a working cl installation and libgcc and  libgw32c  gnu
  libraries (try sourceforge) then something like this might work:
$ cl /c /DVC /D__value=_value /Zi /D_DEBUG /DVERSION_STRING="jot for WindowsNT v<version>" %JOT_HOME%\jot.c /Fojot.obj
$ link /debug /out:%JOT_HOME%/bin/jot.exe jot.obj ^
    <MSDKsPath>\v7.1\Lib\*.Lib  ^  <gnuLibPath>\libgw32c-0.4\lib\libgw32c.a  ^
    <gnuLibPath>\libgcc\lib\libgcc.lib



}}}
}}}
