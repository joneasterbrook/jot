

                               JOT User Guide
                               --------------

 
1 Description of the Editor
---------------------------
  - The basic language has  less  than  30  basic  commands  and  some  simple
    structural constructs - their combined power is awesome.
  - Absolute minimum of magic modes and similar trickery.
  - Supports locks on buffers  e.g.  readOnly  or  writeIfChanged  -  prevents
    normal close down until modified buffer has been written.
  - Screen can be allocated between any number of viewing  areas  limited,  of
    course, by the total screen size.
  - Numerical values can be picked up,  arithmetic  operations  performed  and
    numeric values can be written to text using C-style format statements.
  - Strong interaction with system environment.
  - Customized startup - start up with any number of files ready  loaded  into
    familiar buffers and redefinition of overload function-key assignments.
  - Tidy handling of tabular text especially spreadsheets.
  - Recovery of entire edit session, following a crash.
  - Hash-table support - allows indexing and super-fast lookup.
  - Good support for abnormally wide text.
  - Supports UTF-8 (exotic alphabets) documents.
  - Stream-edit mode - to/from stdin and/or stdout.
  - Supports prefiltering of very large files or streams.
  - Easy construction of macro-commands  for  text  scanning  and  processing.
    Language-specific script library for many programming and CAD languages.
  - Interfaces for popular binary formats, e.g. PDF, MS-word and MS-excel.
  - A useful library of command scripts.
  - A useful error reporting and debugging environment.
  - Reasonably well behaved (i.e. crashes or lock-ups are rare events).
  - Reasonably high capacity (typically better than 1Gb).
  - Has a handy document-processing facility - formats  paragraphs,  maintains
    headings, interfaces to external spell-check agent.
  - Can read and send mail, using external MTA and MDA processes.  Not  useful
    as a general-purpose mailer but handy for processing mail text.
  - Display can be colour tagged.

1.1 Backstory
-------------
  Jot is based on the Edinburgh Compatible Context  Editor  (ECCE).  ECCE  was
  designed back in the days of teletypwriters and consequently has a  somewhat
  old-fashioned look and feel compared to modern editors  designed  for  video
  terminals.
   
  What it did have was a powerful  but  minimalist  command  language  -  this
  language forms the basis of jot - see the `Jot Programming` for details.

1.2 What is a text editor and why do I need one?
------------------------------------------------
  Modern computers have a filing system containing a great many files. Many of
  these files are binaries - meaningful to the computer  but  incomprehensible
  gobbledygook to you and me but some files are plain text. Plain  text  files
  are designed to be read by us humans and, in many cases, to  be  altered  by
  us.
  
  A text editor is an essential tool for altering (i.e. editing)  these  plain
  text files and a good one can be very  helpful  for  viewing  and  analysing
  their inner meaning. Note that the text on the screen (and  in  the  editors
  memory) is just an image of the text file. During  an  editing  session  the
  original file usually remains unchanged until you decide to save your edited
  version.
  
  A common feature of all modern editors is that they display text in a window
  on the computer screen with a cursor showing the current  focus.  They  also
  obey simple instructions to alter the text and to change the  focus  in  the
  text - typically with the cursor-control keys (Up, Down Left, Right, Page Up
  and Page Down). They can search  the  text  for  specified  combinations  of
  characters (strings), insert new text strings, erase and substitute strings.

1.3 About the current character and substrings
----------------------------------------------
  The editor places a special marker, the cursor, in the text to indicate it's
  current focus. This is the point where text might be inserted or  the  start
  point for searches.
  
  The current-character cursor is displayed  in  reverse  video.  This  cursor
  reflects the state of internal current-record and current-character pointer.
  This is allowed to go to the end of the string. At this point  there  is  no
  character to highlight. When this happens, a tilde ( ~ ) is displayed at the
  end of lines to indicate this situation.
  
  When a substring has been selected (e.g. by a find  command)  the  substring
  and the substring is displayed with underscores with the  current  character
  in reverse video. Of the commands which define a substring, some  leave  the
  cursor at the start of the substring (e.g. find - see `F`) others  leave  it
  at the end. For these  commands  the  current  character  is  the  character
  immediately following the substring (e.g. traverse `T` and insert `I`).
  
  In tty mode (see `-tty`) The current line is printed and below it the  carat
  character ( ^ ) indicates the current character, and tildes ( ~  )  indicate
  the currently-selected substring.

1.4 Command-mode vs. type-to-screen mode
----------------------------------------
  Jot is essentially a command-driven editor. In other words, you  give  it  a
  command and a parameter and it does something to your text. You  might,  for
  example give it the command to  insert  text,  by  typing  something  in  or
  pressing some  button,  and  the  parameter  would  be  the  text  you  want
  inserting.
   
  While typing-to-screen is fine for capturing a brain  dump;  when  the  task
  involves searching and doing several fiddly  tweaks  to  the  content  of  a
  text-file image then you will need to exiting  and  re-entering  the  screen
  mode to enter whatever search or command parameters are required. This is  a
  real drag most of of the time and can  be  a  right-royal  pain  at  others.
  Nevertheless, jot does offer a fully-functional type-to-screen environment.
  
  In it's command mode, all  native  jot  commands  as  well  as  jot  editing
  functions are available for use - jot functions are little bits of jot  code
  attached to function keys etc. Typically, to invoke a function:
    - First type in the parameter to the console area (if any) then
    - hit the function hotkey.
  
  Jot also has a direct type-to-screen mode which also  allows  jot  functions
  but not native jot commands. Also arrangements  or  passing  parameters  are
  different - see `about command parameters`. In the type-to-screen mode,  any
  typed-in text goes directly to the screen but to invoke editor functions the
  process is as follows:
    - hit the function key,
    - type in the parameter then
    - hit return.
  
  This is not the way most modern editors and word-processors work.  You  will
  probably  be  accustomed  to  always  typing  directly  to  the   text   and
  occasionally invoking editor functions via function keys and menus below the
  banner bar. Typically there will be a strictly-defined set of functions that
  *only* work in command mode and another set that *only* work in screen-entry
  mode.

1.5 About help
--------------
  The jot help system is based on fold marks - a sequence of three open braces
  ( { ) at the start of a line is a fold start,  a  sequence  of  three  close
  braces ( } ) is a fold-end mark. Folds can be nested to any level.
  
  Another type of fold mark is the file-fold mark - these take  the  following
  form:
[<pathstub>]<filename>
  The pathstub is a subpath in the filing system starting at the path  of  the
  current file  fold  (typically  ${JOT_RESOURCES}/help/...  )  and  the  file
  <filename>.hlp must exist in this directory. When opened the file is  merged
  into the help repository.
  
  The <<Help>> function (normally attached to {F1}) looks at the current  line
  in the display.
    - If the current line begins with an open-fold  mark  '{{{'  it  uses  the
      current line as a key and searches the help repository buffer ( : )  for
      a matching entry. It copies the entry to the help view buffer ( ; )  for
      viewing.
    - If the current record does not have a fold mark but the  current  buffer
      is the help viewing buffer ( ;  )  then  the  Help  function  exits  the
      current fold, returning to the parent fold.
    - If the current record contains a file-fold mark  (  [<subpath>]  at  the
      beginning of the line) and the current buffer is the help viewing buffer
      ( ; ) then the file is opened  and  it's  contents  added  to  the  help
      repository buffer ( : ).
    - In all other cases the Help function will open the top-level help entry.
    
    For details about the format and construction of  help  files  see  `About
    help files`.

1.6 About command editing
-------------------------
  The editor maintains  an  internal  history  log  containing  the  last  few
  commands. By default this holds the last 20 commands but this limit  can  be
  changed with the `-history` CLI qualifier.
  
  The standard startup script defines eight functions for  command  editing  -
  `CmdEditStart`, `CmdEditUp`, `CmdEditDown`,  `CmdEditLeft`,  `CmdEditRight`,
  `CmdEditInsert`, `CmdEditDelete`, and `CmdEditEnd`.
  
  CmdEditStart acquires a list of recent commands and displays the most recent
  command in the console area. CmdEditUp selects the previous command  in  the
  command history, CmdEditDown selects  the  next  command  (in  chronological
  ordering).
  
  CmdEditLeft and CmdEditRight adjust  the  position  of  the  command-editing
  cursor in pretty-much the way you'd expect.  CmdEditInsert  takes  a  string
  parameter and inserts it in the current cursor position of the command text.
  CmdEditDelete deletes one character left of the command-edit cursor.
  
  The  action  of  CmdEditEnd  is  to  push  the  selected  command  into  the
  command-input buffer and display it in the console. You need to hit {Return}
  to activate it.
  
  Note that the history is held in the $ buffer, this  is  used  for  lots  of
  other things and is frequently overwritten. CmdEditStart sets up  $  with  a
  new history report. All the other command-editing functions first check that
  this buffer contains a  valid  command-history  report,  if  not  they  exit
  abruptly.

1.7 About not losing your work
------------------------------
  There are many and varied ways of mistakenly losing or corrupting work in an
  editing session - jot offers a few methods of making this a bit less  easily
  done:
    - Setting the buffer attribute writeifchanged  (see  `%b=writeifchanged`),
      if the buffer has been changed in any way the %c and  %A  commands  will
      fail with a message telling you which  buffers  want  writing.  When  an
      editing session has many active  buffers  it's  not  all  that  easy  to
      remember which have been  updated  -  this  tells  you.  To  unset  this
      attribute use `%b=unrestricted`.
    
    - Setting the buffer attribute readonly (see `%b=readonly`), if  the  file
      is only to be used as a reference - any attempt to change it will fail.
      
    - Request an optional journal file - this is part of the  journal-recovery
      system and is designed to protect against power  failures  crashes  etc.
      (see `about journal files`)

1.8 About Journal Files
------------------------
  By default no journal is maintained - the editor is not particularly  crashy
  and modern computers and power  grids  are  generally  reasonably  reliable.
  Modern operating systems are also pretty good - although some,  maybe,  less
  so  than  others.  From  time  to  time,  however,  a   can't-happen   event
  demonstrates how they need to be reclassified and it's pretty distressing to
  see hours of work wiped out by such an event.
  
  With the CLI qualifier `-journal` is set, jot maintains a history  file  and
  snapshots of all the files it reads - these files are  normally  deleted  on
  exit from the editor.
  
  In the event of a crash the journal files remain and the original session is
  re-created by reading in snapshots of the original files and re-running  the
  interactive commands.
  
  The process for a session editing myfile.txt is described below.
   
    - 1 Start the editor with journal files enabled:
$ jot myfile.txt -journal [ -<any other valid args>]
 
    - 2 After crashing,  restart  the  editor  but  run  the  recovery  script
      journal_recover.jot:
$ jot myfile.txt -in=%r=journal_recover [ -<same valid args>]
  
    - 3 If there are problems, then edit the command script recover_now.jot in
      your current directory and re-run the recovery using that:
$ jot myfile.txt  -init="%r=./recover_now.jot -asConsole" [ -<same valid args>]
  
  See `journal_recover.jot` for full details.

1.9 About jot debugging
-----------------------
  Jot supports a simple debugging environment. It is possible to  display  the
  current state of the stack, the current record and breakpoint on a number of
  predefined conditions - see `the jot debugger`, `%S=trace` and `%S=debug`.
  
  Typically, one might request a breakpoint, a stack dump and display  of  the
  current record at each trace point. With a trace point at every  command  or
  every new command line. It is also possible  to  put  an  explicit  debugger
  request (the `T` command) in the command string.
  
  The debugger is controlled by the following commands:
    - %s=trace (`%s=trace`)  -  redefines  the  trace  vector  with  immediate
      effect.
    - %s=debug (`%s=debug`) - defines the  trace  vector  to  be  set  by  `T`
      commands.
    - `T` - An explicit debugger request a T command can be  inserted  at  any
      point in a macro or directly in the command line, this changes the trace
      vector to the value defined by `%s=debug`.  To  exit  the  debug  prompt
      loop, reset the trace vector with %s=trace 0, or q{Esc}.
    - Often, the explicit trace command is buried in a  complicated  loop  and
      control structure which makes it necessary to  continue  many,  possibly
      hundreds of times before reaching the iteration causing the problem. The
      %s=tracecounter command (see `%s=tracecounter`) causes the  given  value
      to be decremented at each pass and only triggers a trace point  when  it
      reaches zero.
    - Changing the verbosity level (see `%s=verbose`) may help - setting  this
      to 2 causes more information about failures to be displayed.

1.10 About block graphics
------------------------
  Jot offers some limited support for  the  creation  of  simple  line-drawing
  diagrams, flow-charts electrical schematics etc.
  
  The support consists of  functions  for  drawing  horizontal,  vertical  and
  diagonal lines, some some cursor  positioning  functions  specific  to  line
  drawings and a block move function.
   
  If, while drawing, an attempt is made to go  above  the  top  or  below  the
  bottom boundary of the buffer or there is an attempt to draw past the end of
  a line then additional lines and/or whitespace is automatically added.
  
  If the diagrams are to be  part  of  a  document  to  be  processed  by  the
  `doc.jot` family of scripts (`doc.jot`, `doc2html.jot`,  `doc2fold.jot`  and
  `html2doc.jot`) then it is important that the first character of  each  line
  in the graphical section begins with  any  character  other  than  an  ascii
  space -  an ASCII VT (tab) will do.
  
  It attempts to tidy corners when shifting between  horizontal  and  vertical
  lines and similarly with diagonals. Hence a series of <<LineE>> followed  by
  a <<LineS>> will  remove  the  last  hyphen  (  -  )  and  replace  it  with
  whitespace. Diagonals join  up  tidily  without  extra  whitespace  but  the
  drawing functions adjust the cursor position as appropriate e.g:
                          
     ----      /\     \     ----                                  \
    |    |    /  \     \   |    |     \        /        /\          \
    |    |   /    \    /   |    |       \    /        /    \        /
     ---              /     ----          \/        /        \    /
                                                                 
  For details take a look at:
    - `LineN`, `LineS`, `LineE`, `LineW` - functions for drawing north,  south
      east and west, `LineNE`,  `LineNW`,  `LineSW`,  `LineSE`  functions  for
      drawing simple diagonals.
      
    - `DSLineNE`, `DSLineNW`, `DSLineSW`, `DSLineSE` (Double Spaced) - similar
      to the other diagonal-drawing  functions  except  that  they  add  extra
      whitespace in order to get the diagonal at something more like 45deg. to
      the horizontal.
       
    - `CutRectangle` and `PasteRectangle` - these deal with copying and moving
      rectangular blocks of text.
      
    - `RightRegardless`,  `UpRegardless`  and   `DownRegardless`   these   are
      cursor-moving functions unconstrained by the  text  envelope.  They  add
      more lines and/or whitespace as they go.
      
    - The `Overwrite` function is also useful when handling block graphics  as
      it preserves the position of succeeding characters on the line.

2 Keyboard functions defined at startup
---------------------------------------
  The function-key layout of a typical  102-key  keyboard  is  shown  in  `IBM
  102-key map`. The mapping of these keys to editor  functions  is  determined
  various layers of OS/curses-determined  mappings  (see  the  man  pages  for
  xterm, xmodmap, termcap ... etc.) and, finally, by the editor startup  file.
  See also `X-windows setup`
  
  The  OS-mappings  determine  the  escape  sequences  delivered  to  keyboard
  applications, the editor startup file determines the mapping of these escape
  sequences to editor functions. This  latter  mapping  is  described  in  the
  following sections.
  
  For functions dealing with paragraphs, a paragraph is deemed to be  a  block
  of lines bounded by completely blank lines - i.e. a line which does not even
  contain whitespace.
  
  For functions dealing with code sections, a code section is deemed to  be  a
  block of indented text, headed by an unindented line. The code  section  may
  contain any number of blank lines.
  
  For functions dealing with words, JOT defines a word as a string  containing
  upper   and   lower-case   alpha   characters,   digits   and   underscores.
  Unfortunately, at present, all unicode characters are treated  as  non-alpha
  characters.
  
  The functions described here are defined by  the  `startup.jot`  file  which
  also links then to the keyboard, the keycodes are are defined in a  separate
  file `std_keys.jot` and `WindowsNT_keys.jot`.

2.1 F1 to F4 - Match, Help and Do functions.
--------------------------------------------
  F1 and F2 are help and do (i.e. run a jot script) respectively bur F3 and F4
  are various flavours of paragraph and parenthesis-matching functions.
  
2.1.1 Help
----------
> [<helpQuery>]{F1}
  Searches the help database for an entry with a name matching the  helpKey  -
  if no helpKey specified but the cursor is on a help fold the fold is  opened
  if not on a help fold then the current help fold  is  closed  -  see  `about
  help`.
    
2.1.2 FindAllHelp
-----------------
>  [<string>]{Shift+Help} or {Shift+F1}
  Searches the currently-opened help documents in the help repository  (the  :
  buffer) for matches with string, help menu is set up with matching entries.
  
2.1.3 RemoveHelpFold
--------------------
> {Ctrl+Help} or {Ctrl+F1}
  The contents of the current fold is removed, if it's a file  fold  then  the
  file-fold marker is restored.
  
2.1.4 Do
--------
> [<pathName>]{F2}
  Run a command file. The default path is  ${JOT_HOME}/coms  and  the  default
  file extension is .jot
     
2.1.5 ScriptByName
------------------
> [<string>]{Shift+F2}
  Searches all scripts in ${JOT_HOME}/coms and your pwd for those  with  names
  matching the string. If no string given then lists  all  scripts  with  .jot
  name extension.
  
2.1.6 ScriptByFunc
------------------
> [<string>]{Shift+F2}
  Searches the first-line comments of all scripts in ${JOT_HOME}/coms and your
  pwd for those with functions matching the string. If no  string  given  then
  lists all scripts with .jot name extension and their first lines.
  
2.1.7 ParagraphUp
-----------------
> {F3}
  Searches for the previous paragraph start  i.e.  a  block  of  text  with  a
  totally blank line above it - it passes by lines containing only whitespace.
    
2.1.8 ParagraphDown
-------------------
> {F4}
  Searches down the text for the next paragraph start - i.e. a block  of  text
  preceeded by a completely blank line - it passes by  lines  containing  only
  whitespace.
     
2.1.9 CodeSectionDown
---------------------
> {Shift+F4}
  Searches down the text for the next code section - code sections begin  with
  a non-whitespace character in column 1.
     
2.1.10 CodeSectionUp
-------------------
> {Shift+F3}
  Searches back up the text for the start  of  the  next  code  section.  Code
  sections begin with a non-whitespace character in column 1.
     
2.1.11 IndentMatchUp
-------------------
> {Ctrl+F3}
  Searches back up the text for the previous line at the same indent level  as
  the current line.
   
2.1.12 IndentMatchDown
----------------------
> {Ctrl+F4}
  Searches down the text for the next line at the same  indentation  level  as
  the current line.
  
2.1.13 ParenMatchLeft
---------------------
> {Alt F3}
  If the cursor is above a parenthesis close character ')', then the cursor is
  moved to the corresponding parenthesis open. This  works  by  plodding  back
  through the text, counting  open  and  close  braces  (  and  ),  until  the
  corresponding parenthesis-open character is found.
  
  If the cursor is not above a parenthesis-close character, then the buffer is
  searched back to find the previous parenthesis close and the cursor moved to
  the corresponding parenthesis open.
  
2.1.14 ParenMatchRight
----------------------
> {Alt F4}
  If cursor is above a parenthesis open '(' character, then cursor is moved to
  the corresponding parenthesis close ')'. This  works  by  plodding  forwards
  through the text, counting  open  and  close  braces  (  and  ),  until  the
  corresponding parenthesis-close character is found.
  
  If the current character is not above a parenthesis-open character, then  it
  searches forwards for one and then finds the corresponding parenthesis close
  character.
   
2.1.15 CurlyMatchLeft
---------------------
> {Ctrl+Shift F3}
  Similar to <<ParenMatchLeft>>, above, except matches { and }.
   
2.1.16 CurlyMatchRight
----------------------
> {Ctrl+Shift F4}
  Similar to <<ParenMatchRight>>, above, except matches { and }.
   
2.1.17 AngleMatchLeft
---------------------
> {Shift+Alt F3}
  Similar to <<ParenMatchLeft>>, above, except matches < and >.
     
2.1.18 AngleMatchRight
----------------------
> {Shift+Alt F4}
  Similar to <<ParenMatchRight>>, above, except matches < and >.
   
2.1.19 MarkupMatchLeft
----------------------
> {Ctrl+Shift+Alt F3}
  This is for use with HTML and XML. MarkupMatchLeft, working  back  from  the
  current cursor position, first locates the previous "</" string - indicating
  a block end in HTML and XML. It then picks up the block-type tag  and  finds
  the corresponding block-start.
   
2.1.20 MarkupMatchRight
-----------------------
> {Ctrl+Shift+Alt F4}
  This is for use with HTML and XML. MarkupMatchRight, working  forwards  from
  the current cursor position, it first  locates  the  next  "<"  character  -
  indicating a block start in HTML and XML. It then picks  up  the  block-type
  tag and finds the corresponding block-end.

2.2 F5 to F8 - Find and substitute.
-----------------------------------
  Arguably the most basic of all editor functions are  finding  and  replacing
  text F5 to F8 are dedicated to these operations with a few special  flavours
  obtained using the Shift, Ctrl and Alt keys.
 
2.2.1 Substitute
----------------
> [<string>]{F5}
  Replaces currently-selected substring  with  the  specified  string,  if  no
  string is specified then the last-substituted or inserted string is used.
  
2.2.2 Remove
------------
> {Shift+F5}
  The previously-selected string  (following  a  find,  substitute  etc.),  is
  removed altogether.
  
2.2.3 OverwriteBack
-------------------
> [<string>]{Ctrl+F5}
  The characters to the left  of  the  current  cursor  are  replaced  by  the
  specified string. If no string is specified, then the last string used in an
  insert or substitute operation is used. If the string is too long, then  the
  overflow characters are inserted at the start of the line.
  
2.2.4 SubstituteBack
--------------------
> [<string>]{Shift+Ctrl+F5}
  Replaces currently-selected substring  with  the  specified  string,  if  no
  string is specified then the last-substituted or inserted string is used.
  
2.2.5 SubstituteAgain
---------------------
> {Alt+F5}
  In type-to-screen mode, the Substitute function will always prompt  for  the
  search   string.   SubstituteAgain   will   just   apply    the    last-used
  substitute-string parameter once again.
  
2.2.6 Insert
------------
> [<string>]{F6}
  Inserts specified text at the current-character position, if  no  string  is
  specified then the last-substituted or inserted string is used.
  
2.2.7 InsertBack
----------------
> [<string>]{Shift+F6}
  Identical to Insert function except that the cursor is left at the start  of
  the inserted string.
 
2.2.8 Overwrite
---------------
> [<string>]{Ctrl+F6}
  The characters under and to the right of the current cursor are replaced  by
  the specified string. If no string is specified, then the last  string  used
  in an insert or substitute operation is used.
  
2.2.9 SubstituteInd
-------------------
> {Shift+Ctrl+F6}
  (Substitute Indirect) the currently-selected substring is  replaced  by  the
  current line in the paste buffer ( '_' ).
  
2.2.10 InsertAgain
------------------
> {Alt+F6}
  In type-to-screen mode, the Insert  function  will  always  prompt  for  the
  search string. InsertAgain  will  just  apply  the  last-used  insert-string
  parameter once again.
  
2.2.11 FindPrev
--------------
> [<string>]{F7}
  Find the previous occurrence of  the  specified  string,  if  no  string  is
  specified then the string used in the last find is used.
  
2.2.12 SubsThenFindPv
---------------------
> {Shift+F7}
  Parameterless  substitute  then   find   previous.   i.e   repeat   previous
  substitution then find previous occurrence of last-found string.
  
2.2.13 FindPrevInd
------------------
> {Ctrl+F7}
  Find indirect - find the previous occurrence of the string  defined  by  the
  current line of the _ buffer (paste buffer).
  
2.2.14 FindPrevAgain
--------------------
> {Alt+F7}
  In type-to-screen mode, the FindPrev function will  always  prompt  for  the
  search string. FindPrevAgain will just  apply  the  last-used  search-string
  parameter once again.
  
2.2.15 FindNext
---------------
> [<string>]{F8}
  Find the next occurrence of the specified string, if no string is  specified
  then the string used in the last find is used.
  
2.2.16 SubsThenFindNx
---------------------
> {Shift+F8}
  Parameterless,  repeats  last  substitution  then  find  next.  i.e.  repeat
  previous substitution, then repeat last find.
  
2.2.17 FindNextInd
------------------
> {Ctrl+F8}
  Find next indirect - the string in the current line of the _  buffer  (paste
  buffer).
  
2.2.18 FindNextAgain
--------------------
> {At+F8}
  In type-to-screen mode, the FindNext function will  always  prompt  for  the
  search string. FindNextAgain will just  apply  the  last-used  search-string
  parameter once again.

2.3 F9 to F12 - Delete/Restore Chr/Word/Line
--------------------------------------------
  Deletion and restoration of text is another pretty basic requirement  of  an
  editor. The JOT delete keys work by performing a cumulative abstraction into
  the dead-text buffer (the % buffer), this allows  dead-text  restoration  by
  reversing the process.
 
  In the context of word deletion,  a  word  is  a  sequence  of  alphanumeric
  characters and underscores of any length, bounded by any other characters or
  line breaks.
 
2.3.1 RestoreChrLeft
--------------------
> [<n>]{F9}
  Restores n characters (defaults to 1) from the start of the dead-text buffer
  to the left of the cursor.
  
2.3.2 RestoreWordLeft
---------------------
> {Shift+F9}
  Restores the first word in the dead-text buffer  to  the  current  character
  position.
  
2.3.3 RestoreLineLeft
---------------------
> {Shift+Ctrl+F9}
  Restore text from beginning of first line of the dead-text buffer.
  
2.3.4 RestoreChrRight
---------------------
> [<n>]{F10}
  Restores n characters (defaults to 1) from the end of the  dead-text  buffer
  to the right of the cursor.
  
2.3.5 RestoreWordRight
----------------------
> {Shift+F10}
  Restores last  word  in  the  dead-text  buffer  to  the  current  character
  position.
  
2.3.6 RestoreLineRight
----------------------
> {Shift+Ctrl+F10}
  Restores  last  line  in  the  dead-text  buffer  to  the  current-character
  position.
    
2.3.7 DeleteChrLeft
-------------------
> [<n>]{F11}
  Removes n characters (defaults to 1) to the left of  the  cursor,  appending
  them to the start of the dead-text buffer.
    
2.3.8 DeleteWordLeft
--------------------
> {Shift+F11}
  Deletes text from the current character to the start of the current word, if
  the cursor is not above a valid word then deletes from the current character
  back to the start of the previous word, which could be on the previous line.
  
2.3.9 DeleteLineLeft
--------------------
> {Shift+Ctrl+F11}
  From cursor to start of current line, if the cursor is already at the  start
  of a line then delete back to the start of the previous line.
  
2.3.10 DeleteChrRight
---------------------
> [<n>]{F12}
  Removes n characters (defaults to 1) to the right of the  cursor,  appending
  them to the end of the dead-text buffer.
    
2.3.11 DeleteWordRight
----------------------
> {Shift+F12}
  Deletes text from the current character position to the end of  the  current
  word, if the cursor is not over a valid word, then deletes from the  current
  character to the end of the next word, which could be on the next line.
  
2.3.12 DeleteLineRight
----------------------
> {Shift+Ctrl+F12}
  Deletes text from the current character position to the end of  the  current
  line, if the cursor is already at the end of a line then deletes to the  end
  of the next line.
   
2.3.13 AppendLeftPrev
---------------------
> {Alt+F9}
  Appends text to the left of the current character to the end of the previous
  line, preserving indentation of both lines.
  
2.3.14 AppendRightNext
----------------------
> {Alt+F10}
  Appends text under and to the right of the current character, to  the  start
  of the next line, preserving the indentation of both lines.
    
2.3.15 IndentFromPrev
---------------------
> {Alt+F11}
  Removes all indentation blanks from the current line and replaces them  with
  those from the previous line.
   
2.3.16 IndentFromNext
---------------------
> {Alt+F12}
  Removes all indentation blanks from the current line and replaces them  with
  those from the next line.

2.4 The Mid Keypad
------------------
  The mapping of functions to the mid  keypad  approximates  to  most  of  the
  key-cap functions but not, perhaps, the meaning IBM originally intended.
    - Delete and Insert become Cut and Paste respectively,
    - End is the Note key,
    - Home is an exact find function and
    - Page Up/Down work as advertised.
  
2.4.1 Paste
-----------
> {Insert}
  The contents of the paste buffer is inserted into the text  at  the  current
  character position.
   
2.4.2 PasteRectangle
--------------------
> {Ctrl+Alt+Insert}
> {Esc p r}
  The paste buffer is assumed to contain some graphical text (i.e. some  lines
  of text where both the horizontal and vertical  sequence  of  characters  is
  significant). The picture is inserted at the current character position  and
  in the same column of succeeding lines, text to the right  of  the  inserted
  block retains it's original position. The <<CutRectangle>> function  can  be
  used to extract the block of text.
     
2.4.3 CutRectangle
------------------
> {Ctrl+Alt+Delete}
> {Esc c r}
  First go to the top left corner of the rectangle and note the position  with
  <<Note>>, then move the cursor to the bottom-right corner of  the  rectangle
  and apply <<CutRectangle>>. The text  is  removed  and  replaced  by  blanks
  leaving the current character at  the  original  note  point  (the  top-left
  corner of the cut text).
  
  To restore the text  at  it's  original  position  apply  <<PasteRectangle>>
  immediately after <<CutRectangle>>.
  
2.4.4 FindExactNext
-------------------
> [<string>]{Home}
  The buffer is searched until the next exact-match occurrence of the word  is
  found - in this context an exact match is where the  matching  substring  is
  bounded by non-alphanumeric characters.
    
2.4.5 FindExactPrev
-------------------
> [<string>]{Shift+Home}
  Similar to above, except that it searches backwards.
  
2.4.6 SetFindString
-------------------
> {Ctrl+Home}
  The word below the cursor is picked up and defines the find string  for  the
  next find (or find exact) operation.
   
2.4.7 Cut
---------
> {Delete}
  Text from the last-defined note point up to the current  character  position
  is abstracted into the paste buffer.
  
2.4.8 Copy
----------
> {Shift+Delete}
  Text from the last-defined note point up to the current  character  position
  is copied to the paste buffer, and immediately restored. This  operation  is
  permitted for Readonly buffers - see `%b=readonly`.
    
2.4.9 CumulativeCopy
--------------------
> {Ctrl+Delete}
  Text from the last-defined note point up to the current  character  position
  is appended to the end of the paste buffer. This operation is permitted  for
  Readonly buffers (see `%b=readonly`). If no note point  was  set,  then  the
  complete line is copied to the paste buffer.
  
2.4.10 Note
----------
> {End}
> {Ctrl+Alt+End}
  The current character position is noted for a later cut or  copy  operation.
  The  same  function  is  duplicated  for  the  convenience  of  users  doing
  block-graphical editing (see `CutRectangle`).
  
2.4.11 PageUp
-------------
> [<n>]{PageUp}
  The view changed to show the page above  the  previously-displayed  page  of
  text, the current-line is changed according to the current window  size  and
  the character pointer is set to the first character of the new line.
  
2.4.12 GotoFoldStart
--------------------
> {Alt+PageUp}
  Find matching fold-start. In a file with fold marks, when  at  a  fold  end,
  this will search back for the corresponding fold start.
  
2.4.13 ShrinkWindow
-------------------
> {Ctrl+Alt+PageUp}
  Reduces the height of the current window by 1 line. If the  window  ends  up
  with a width of 0 or less, then the window is deleted.
   
  Normally there will be only one window, where there is more than one  window
  the first window displaying the current buffer is shrunk.
   
2.4.14 PageDown
---------------
> [<n>]{PageDown}
  The view is changed to the page below the current page.
    
2.4.15 GotoFoldEnd
------------------
> {Alt+PageDown}
  Find matching fold end. In a file with { { { and } } } fold marks, when at a
  fold start, this will search for the corresponding fold end.
  
2.4.16 StretchWindow
--------------------
> {Ctrl+Alt+PageDown}
  Increases the height of the current window by 1 line.
   
  Normally there will be only one window, where there is more than one  window
  the first window displaying the current buffer is stretched.

2.5 The Cursor-control keys
---------------------------
  
2.5.1 Up
---------
> [<n>]{UpArrow}
  Move up by n lines (defaults to 1) - the current line  becomes  the  line  n
  lines above original current  line,  the  current  character  is  the  first
  character.
    
2.5.2 WordUp
-------------
> {Shift+UpArrow}
  Moves up one column, for tab-separated tabular text, this moves to the  cell
  immediately above the currently-selected cell, for  normal  text  it  simply
  moves to the character immediately above the current character.
   
2.5.3 Home
-----------
> {Ctrl+PageUp}
  The current line is set to the first line in the file, the current character
  is the first character of the line.
  
2.5.4 ViewUp
-------------
> [<n>]{Ctrl+Shift+UpArrow}
  Shifts the view up by n lines (defaults to 1) without changing  the  current
  line, character or selected substring.
  
2.5.5 CmdEditStart
-------------------
> {Alt+Home}
  Enters the command-edit screen (see `about command editing`), this  is  used
  to edit and re-run commands held in the command history log.
   
2.5.6 CmdEditEnd
-----------------
> {Alt+End}
  Exits the command-edit screen (see `about command editing`), this is used to
  edit and re-run commands held in the command history log.
   
2.5.7 CmdEditInsert
--------------------
> <text>{Alt+Insert}
  Inserts the given text string into  the  current  position  of  the  command
  selected from history (see `about command editing`).
   
2.5.8 CmdEditDelete
--------------------
> {Alt+Delete}
  Deletes the character left of the current position of the  command  selected
  from history (see `about command editing`).
  
2.5.9 CmdEditUp
----------------
> {Alt+UpArrow}
  Goes back one command further into the command history, the  command-editing
  cursor is left at the begining of the command (see `about command editing`).
  
2.5.10 CmdEditDown
------------------
> {Alt+DownArrow}
  Goes forwards one command further in the command history cursor is  left  at
  the begining of the command (see `about command editing`).
  
2.5.11 CmdEditRight
-------------------
> {Alt+RightArrow}
  Moves  the  command-editing  cursor  one  character  to  the  right  in  the
  currently-selected  command  from  command  history  (see   `about   command
  editing`).
  
2.5.12 CmdEditLeft
------------------
> {Alt+LeftArrow}
  Moves  the  command-editing  cursor  one  character  to  the  left  in   the
  currently-selected  command  from  command  history  (see   `about   command
  editing`).
  
2.5.13 Down
-----------
> [<n>]{DownArrow}
  Move down by n (defaults to 1) lines - the current line pointer  is  shifted
  down, the current character becomes the first character of the new line.
    
2.5.14 WordDown
---------------
> {Shift+DownArrow}
  Moves down one column, for tab-separated tabular text,  this  moves  to  the
  cell immediately below the  currently-selected  cell,  for  normal  text  it
  simply moves to the character immediately below the current character.
  
2.5.15 End
----------
> {Ctrl+PageDown}
  The view is change to the last page in the file, the  current  line  is  the
  last line of the buffer, the current character becomes the  first  character
  of this line.
    
2.5.16 ViewDown
---------------
> [<n>]{Ctrl+Shift+DownArrow}
  Shifts the view down by n lines (defaults to 1) without changing the current
  line, character or selected substring.
    
2.5.17 Left
-----------
> [<n>]{LeftArrow}
  Move the cursor n (defaults to 1) characters left of it's original position.
  
2.5.18 WordLeft
---------------
> [<n>]{Shift+LeftArrow}
  For tabular text, i.e. the current line contains Tab characters, this  moves
  the cursor to the cell left of the current cell and, if  necessary,  adjusts
  leftoffset to bring all of the cell into view.
   
  For non-tabular text, this moves the cursor to the start of  previous  word.
  If the cursor is not currently above a word the cursor moves to the start of
  the current word.
   
  If n is given the process is repeated that many times.
   
2.5.19 ViewLeft
---------------
> [<n>]{Ctrl+Shift+LeftArrow}
  If the current character is not in view because  leftoffset  is  incorrectly
  set - see `about long lines`,  it  sets  leftoffset  to  bring  the  current
  character to the right edge of the screen.
   
2.5.20 ViewRight
----------------
> [<n>]{Ctrl+Shift+RightArrow}
  If the current character is not in view because  leftoffset  is  incorrectly
  set - see `about long lines`,  it  sets  leftoffset  to  bring  the  current
  character to the left edge of the screen.
   
2.5.21 LineLeft
---------------
> [<n>]{Ctrl+Alt+LeftArrow}
  Moves to the start of the current line, if the  cursor  is  already  at  the
  start of a line then go to start of previous line. If n is given the process
  is repeated that many times.
  
2.5.22 Right
------------
> [<n>]{RightArrow}
  Move the cursor  n  (defaults  to  1)  characters  right  of  it's  original
  position.
   
2.5.23 WordRight
----------------
> [<n>]{Shift+RightArrow}
  For tabular text, i.e. the current line contains Tab characters, this  moves
  the cursor to the cell right of the current cell and, if necessary,  adjusts
  leftoffset to bring all of the cell into view.
   
  For non-tabular text, this moves the cursor to the start of  next  word.  If
  the cursor is not currently above a word the cursor moves to  the  start  of
  the current word.
   
  If n is given the process is repeated that many times.
   
2.5.24 LineRight
----------------
> [<n>]{Ctrl+Alt+RightArrow}
  Moves to the end of the current line, if the cursor is already at the end of
  a line then go to end of next line. If n is given the  process  is  repeated
  that many times.
  
2.5.25 UpRegardless
-------------------
  This is intended for line-drawings. When editing these it is essential that,
  as the cursor moves up or down, it remains  in  the  same  column.  This  is
  achieve by adding extra whitespace to the end of lines too short to maintain
  the cursor position.
  
  Also, if the original line was the first line in the  buffer,  a  new  blank
  line is inserted and populated with whitespace.
  
2.5.26 DownRegardless
---------------------
  This is intended for line-drawings. When editing these it is essential that,
  as the cursor moves up or down, it remains  in  the  same  column.  This  is
  achieve by adding extra whitespace to the end of lines too short to maintain
  the cursor position.
  
  Also, if the original line was the last line in the buffer, a new blank line
  is inserted and populated with whitespace.
  
2.5.27 LeftRegardless
---------------------
  This is intended for line-drawings. However, it is  not  strictly  necessary
  since, shifting the cursor left is always guaranteed to work (except in  the
  first column). However, uses will probably find  it  easier  to  keep  their
  fingers on the Ctrl+Alt combination while navigating around the drawing.
  
2.5.28 RightRegardless
----------------------
  This is intended for line-drawings. It moves the cursor  one  space  to  the
  right, if at the end of a line, more whitespace is added.

2.6 The numeric keypad
----------------------                    
  For users with no numeric keypad, typically those with  small  laptops,  the
  basic functions 0-9 are  obtained  using  Escape  then  a  numeric  key  the
  appropriate numeric key - e.g. for Macro 8 - hit the escape key followed  by
  the 8 key - denoted by {Esc 8}.
   
  In windows, each key on the numeric keypad is uniquely identifiable by  it's
  keycode. In linux/curses the keys map  to  identical  codes  to  the  normal
  numeric keys or to those on the mid keypad according to the state of NumLock
  see `X-windows setup`).
  
2.6.1 Macro1
-------------
> {KP_1}
> {Esc 1}
  Picks up any arguments into the $  buffer  and  invokes  the  macro.  If  no
  arguments given, $ is left blank.
  
2.6.2 Macro2
-------------
> {KP_2}
> {Esc 2}
  Picks up any arguments into the $  buffer  and  invokes  the  macro.  If  no
  arguments given, $ is left blank.
  
2.6.3 Macro3
-------------
> {KP_3}
> {Esc 3}
  Picks up any arguments into the $  buffer  and  invokes  the  macro.  If  no
  arguments given, $ is left blank.
  
2.6.4 Macro4
-------------
> {KP_4}
> {Esc 4}
  Picks up any arguments into the $  buffer  and  invokes  the  macro.  If  no
  arguments given, $ is left blank.
  
2.6.5 Macro5
-------------
> {KP_5}
> {Esc 5}
  Picks up any arguments into the $  buffer  and  invokes  the  macro.  If  no
  arguments given, $ is left blank.
  
2.6.6 Macro6
-------------
> {KP_6}
> {Esc 6}
  Picks up any arguments into the $  buffer  and  invokes  the  macro.  If  no
  arguments given, $ is left blank.
  
2.6.7 Macro7
-------------
> {KP_7}
> {Esc 7}
  Picks up any arguments into the $  buffer  and  invokes  the  macro.  If  no
  arguments given, $ is left blank.
  
2.6.8 Macro8
-------------
> {KP_8}
> {Esc 8}
  Picks up any arguments into the $  buffer  and  invokes  the  macro.  If  no
  arguments given, $ is left blank.
  
2.6.9 Macro9
-------------
> {KP_9}
> {Esc 9}
  Picks up any arguments into the $  buffer  and  invokes  the  macro.  If  no
  arguments given, $ is left blank.
  
2.6.10 Macro0
-------------
> {KP_0}
> {Esc 0}
  Picks up any arguments into the $ buffer and invokes the macro. The  startup
  script defines macro 0  as  being  switch  to  type-to-screen  mode.  If  no
  arguments given, $ is left blank.
  
2.6.11 Again
------------
> [<n>]{KP_Decimal}
  Repeats last command or hotkey once, by default or n times if n is specified
  if n is zero then the command is repeated to exhaustion.
  
2.6.12 Enter
------------
> [<string>]{KP_Enter}
> [<string>]{Alt+e}
  The string is inserted as a  new  line  with  indent  level  inherited  from
  previous line. If no string is given then creates a blank line at  the  same
  indent level as the line above.
  
2.6.13 LineNW
------------
> [<string>]{Ctrl+Alt+KP_7}
> [<string>]{Esc \ u}
  A line-drawing function. Draws string, from the  current-character  position
  in a north-westerly direction. If <string> is unspecified,  draws  a  single
  backslash ( \ ).
  
  As with other drawing functions, <<LineNW>> always  creates  new  lines  and
  inserts padding whitespace where necessary but will fail when the cursor  is
  in column 1 (the first character of a line).
  
2.6.14 LineN
-----------
> [<string>]{Ctrl+Alt+KP_8}
> [<string>]{Esc l n}
  A line-drawing function. Draws string, from the  current-character  position
  in a northerly  direction.  If  <string>  is  unspecified,  draws  a  single
  vertical bar ( | ).
  
2.6.15 LineNE
------------
> [<string>]{Ctrl+Alt+KP_9}
> [<string>]{Esc / u}
  A line-drawing function. Draws string, from the  current-character  position
  in a north-easterly direction. If <string> is unspecified,  draws  a  single
  slash ( / ).
  
2.6.16 LineE
------------
> [<string>]{Ctrl+Alt+KP_4}
> [<string>]{Esc l e}
  A line-drawing function. Draws string, from the  current-character  position
  in a easterly direction. If <string> is unspecified, draws a single hyphen (
  - ).
  
2.6.17 LineW
------------
> [<string>]{Ctrl+Alt+KP_6}
> [<string>]{Esc l w}
  A line-drawing function. Draws string, from the  current-character  position
  in a westerly direction. If <string> is unspecified, draws a single hyphen (
  - ).
  
2.6.18 LineSW
------------
> [<string>]{Ctrl+Alt+KP_1}
> [<string>]{Esc / d}
  A line-drawing function. Draws string, from the  current-character  position
  in a south-easterly direction. If <string> is unspecified,  draws  a  single
  slash ( / ).
  
  As with other drawing functions, <<LineSW>> always  creates  new  lines  and
  inserts padding whitespace where necessary but will fail when the cursor  is
  in column 1 (the first character of a line).
  
2.6.19 LineS
------------
> [<string>]{Ctrl+Alt+KP_2}
> [<string>]{Esc l s}
  A line-drawing function. Draws string, from the  current-character  position
  in a southerly  direction.  If  <string>  is  unspecified,  draws  a  single
  backslash ( \ ).
  
2.6.20 LineSE
-------------
> [<string>]{Ctrl+Alt+KP_3}
> [<string>]{Esc \ d}
  A line-drawing function. Draws string, from the  current-character  position
  in a south-easterly direction. If <string> is unspecified,  draws  a  single
  backslash ( \ ).

2.7 Line-drawing escape sequences
---------------------------------
  The following line-drawing functions are mapped to escape sequences.
  
2.7.1 DSLineNW
--------------
> [<string>]{Esc \ n}
  A line-drawing function similar to  LineNE  except  that  it  inserts  extra
  whitespace to draw at something like 45deg - the  actual  angle  depends  on
  your font size.
  
2.7.2 DSLineSE
---------------
> [<string>]{Esc \ s}
  A line-drawing function similar to  LineSE  except  that  it  inserts  extra
  whitespace to draw at something like 45deg - the  actual  angle  depends  on
  your font size.
  
2.7.3 DSLineSW
--------------
> [<string>]{Esc / s}
  A line-drawing function similar to  LineSE  except  that  it  inserts  extra
  whitespace to draw at something like 45deg - the  actual  angle  depends  on
  your font size.
  
2.7.4 DSLineNE
--------------
> [<string>]{Esc / n}
  A line-drawing function similar to  LineNE  except  that  it  inserts  extra
  whitespace to draw at something like 45deg - the  actual  angle  depends  on
  your font size.
  
2.7.5 Box
----------
> [<width> <height>]{Esc b o x}
  This draws a box, using hyphens ( - ) and vertical bars  (  |  ),  with  the
  top-left corner of the box at the current cursor position. If the dimensions
  are not specified, the box size defaults to 10 characters wide  by  5  lines
  high.
  
2.7.6 Lozenge
--------------
> [<size>]{Esc z1}
  This draws a lozenge shape using slashes ( / ) and backslashes (  \  ).  The
  size is the number of slashes down any side, and defaults to 5.
  
2.7.7 DSLozenge
----------------
> [<size>]{Esc z2}
  Similar to the `Lozenge` function except that it uses double-spacing.
  
2.7.8 BoxText
--------------
> <string>{Ctrl+Alt+KP_5}
> <string>{Esc bt}
  This inserts text into an area bounded my line drawn with  Hyphens  (  -  ),
  Vertical bars ( | ), or slashes ( / and \ ). It is intended to simplify  the
  process of labelling boxes where the label requires more than  one  line  in
  the box.

2.8 Other key bindings
----------------------
  In addition to the various keypads, the  startup  script  also  defines  the
  following escape sequences - many are for  the  benefit  of  users  with  no
  numeric keypad. In all cases the  arguments  are  entered  first,  then  the
  escape key and finally the mapped keys.
    - `Enter`
    - `Macro1`
    - `Macro2`
    - `Macro3`
    - `Macro4`
    - `Macro5`
    - `Macro6`
    - `Macro7`
    - `Macro8`
    - `Macro9`
    - `Macro0`
    - `QuitDebugger`
    - `LineN`
    - `LineNE`
    - `LineE`
    - `LineSE`
    - `LineS`
    - `LineSW`
    - `LineW`
    - `LineNW`
    - `BoxText`
    - `CutRectangle`
    - `PasteRectangle`
    - `Box`
    - `Lozenge`
    - `DSLozenge`
  
2.8.1 InsertMode
----------------
> {Alt+I}
  Enters type-to-screen mode, mode persists until {Ctrl+c} or next {Alt+I}.
  
2.8.2 TempInsertMode
--------------------
> {Alt+i}
  Temporarily enters type-to-screen mode, mode persists  until  next  function
  key operation.
  
2.8.3 QuitDebugger
------------------
> q{Esc}
  Exits the debugger prompt loop and continues to the next `T` command  -  see
  also `About jot debugging`.
  
2.8.4 FindWild
--------------
> [<string>]{Esc f w}
  This searches for the next occurrence of a string  containing  one  or  more
  wildcards ( * ). The argument list is parsed and held in buffer @.
  
  If no argument is given then it matches to whatever happens to be in  the  @
  buffer.
   
2.8.5 FindWildPrev
------------------
> [<string>]{Esc - f w}
  This searches for the previous occurrence of a string containing one or more
  wildcards ( * ). The argument list is parsed and held in buffer @.
  
  If no argument is given then it matches to whatever happens to be in  the  @
  buffer.
   
2.8.6 FindInParaNext
--------------------
> [<substring1>[ <substring2>[ <substring3>[ ...]]]{Esc f p}
  
  Locates the next paragraph containing all of the substrings in the  argument
  list.
  
  The argument list is parsed and held in buffer @. If no  argument  is  given
  then it matches to whatever happens to be in the @ buffer  -  typically  the
  parsed argument list from the last such search.
  
  In this context, a paragraph is any number of lines separated by blank lines
  or lines containing only whitespace.

2.8.7 FindInParaPrev
--------------------
> [<substring1>[ <substring2>[ <substring3>[ ...]]]{Esc - f p}
  
  Locates the previous paragraph containing  all  of  the  substrings  in  the
  argument list.
  
  The argument list is parsed and held in buffer @. If no  argument  is  given
  then it matches to whatever happens to be in the @ buffer  -  typically  the
  parsed argument list from the last such search.
  
  In this context, a paragraph is any number of lines separated by blank lines
  or lines containing only whitespace.

2.8.8 FindSequence
------------------
> [<string>]{Esc f s}
  The  editor  will  search  for  the   sequence   of   words   ignoring   any
  non-alphanumeric delimiters including line breaks. One or more words can  be
  represented by the wildcard character ( * ). The argument list is parsed and
  held in buffer @.
  
  If no argument is given then it matches to whatever happens to be in  the  @
  buffer.
  
  This is function is useful for locating sequences of words after  they  have
  been reformatted in some way, with wildcards it is also useful for  locating
  expressions in programming code.
  
2.8.9 FindSequencePrev
----------------------
> [<string>] {Esc - f s} 
  Similar to FindPhrase except that it searches back towards the start of  the
  file.
