<! Made with jot using doc2html -style main.css>
<link rel="stylesheet" href="main.css" type="text/css">

</UL><H1><A NAME="COMMAND FILE LIBRARY">Command file library</H1>

</UL><H2><A NAME="RUNNING THE SCRIPTS">Running the scripts</H2>
<P>There are a number of predefined JOT command file in the $&#123;JOT_HOME&#125;/coms area - see <A HREF="#INSTALLATION">installation</A>. In general these have a one-line description at the start of the command file. The most useful ones are described below</P>

<P>These are run by first typing the name of the script, followed by any arguments and then pressing the 'F2' button i.e:</P>

<PRE>
&#062; &#060;scriptName&#062;&#091; &#060;arg1&#062;&#091; &#060;arg2&#062;&#091; ...&#093;&#093;&#093;&#123;F2&#125;
</PRE>
<P>If the &#060;&#060;Do&#062;&#062; function has not been mapped to the F2 button then, as a temporary workaround you can type in the command %r=&#060;scriptName&#062;. If the script happens to be one that takes arguments then you must manually define the arguments in the $ buffer - this is always used to define script and macro arguments. Then run the script with %r=&#060;scriptName&#062; like this:</P>

<PRE>
&#062; %d$=%% &#060;arg1&#062; &#060;arg2&#062; ...
&#062; %r=&#060;scriptName&#062;
</PRE>
<P>In addition to Do there are two script-search functions ScriptByName and <A HREF="#SCRIPTBYFUNC">ScriptByFunc</A>. ScriptByName searches for scripts in $&#123;JOT_HOME&#125;/coms and your PWD for those with the '.jot' name extension whose names match the given string (if no string given then it just lists all scripts in the searched areas e.g:</P>

&#062; mc&#123;Shift+F2&#125;
<P>To apply the script on your buffer, move the cursor to the line with your script name and run macro 0 (normally &#123;KP_0&#125;.</P>

<P>By convention, all jot scripts should have a one-line comment in the first line. This should briefly describe what the script is intended to do. If it's a complicated script then detailed instructions should be left in the ? buffer.</P>

<P><A HREF="#SCRIPTBYFUNC">ScriptByFunc</A> searches these first-line comments in the search areas and returns a list of those matching the string e.g:</P>

&#062; multicolumn&#123;Ctrl+F2&#125;
<P>To apply a script on your buffer, first select one by moving the cursor to the line with your script name and run macro 0 (normally &#123;KP_0&#125;.</P>


</UL><H3><A NAME="STARTUP.JOT">startup.jot</H3>
<P>The script $&#123;JOT_HOME&#125;/coms/startup.jot is normally run by the editor as it starts up. </P>

<P>It's principal functions are:</P>

<UL><P><LI>To define a basic viewing window, it normally fills the screen except for the last four lines, which are used for user interaction and to display messages.</P></LI>

<P><LI>To define editor functions in native jot code.</P></LI>

<P><LI>To define the mapping of keystrokes to editor actions. Most of the rest of this section is dedicated to explaining how this works.</P></LI>

</UL><P>This script creates a mapping of xterm escape sequences to code calls. It's first requirement is to have a map detailing the translation of key codes the to key names that appear in all the documentation.</P>

<P>The mapping of key names to function calls is entirely for the the convenience of the user and can be changed to suit user requirements.</P>

<P>In linux, the mapping of keys to actual key codes is determined by the terminfo/termcap database identified by your TERM variable. For most linux distributions this seems to default to "xterm". If you are interested in that sort of thing, there's a compiled terminfo database file below /usr/share/terminfo/... - if your $TERM is set to xterm, for example, you will pick up the file /usr/share/terminfo/x/xterm.</P>

<P>Although there seems to be pretty broad agreement on what the default setting for $TERM should be, there is no standardization on what it's capabilities should be and, in particular, what keycodes should be returned for some of the Shift - Ctrl - Alt combinations. Jot uses many of these.</P>

<P>If the current directory contains a startup.jot file then jot picks up this in preference to the $&#123;JOT_HOME&#125;/coms version.</P>

<P>If the optional CLI arg -startup is specified (see <A HREF="#COMMAND-LINE QUALIFIERS">command-line qualifiers</A>), then this overrides any startup path from $&#123;JOT_HOME&#125;/coms or the current directory. if the qualifier is given without the '=&#060;pathName&#062;' value, this is equivalent to -startup=/dev/null i.e. no startup script.</P>

<P>In summary, the startup-file selection is, in order of precedence:</P>

<UL><P><LI>1 The -startup=&#060;pathName&#062; arg,</P></LI>

<P><LI>2 a startup.jot in the current directory and, finally,</P></LI>

<P><LI>3 $&#123;JOT_HOME&#125;/coms/startup.jot</P></LI>

</UL><P>There are two mapping tables used to fully define the finished key translations table in the ( ^ ) buffer:</P>

<UL><P><LI>The key-names to key-codes table - set up in buffer ( @ ) by the <A HREF="#CURSES_KEYS_&#060;TERM&#062;.JOT">curses_keys_&#060;TERM&#062;.jot</A> or <A HREF="#WINDOWSNT_KEYS.JOT">WindowsNT_keys.jot</A> script.</P></LI>

<P><LI>The assignment of functions to key-names map in buffer ( ! ) set to by the startup.jot script.</P></LI>

</UL><P>The startup.jot script takes one optional qualifier -keyfuncs=&#060;pathname&#062; for example:</P>

<PRE>
$ jot &#060;myFile&#062; -st="startup -keyfuncs=my_keyfuncs";  
</PRE>
<P>This will run a user specified script that can modify or entirely redefine either all of the following before generating the key translation table in buffer ( ^ ):</P>

<UL><P><LI>The key-codes to key-names table in buffer ( ! ),</P></LI>

<P><LI>the key-names to functions table in buffet (@ ) and</P></LI>

<P><LI>the code repository in buffer ( ' ).</P></LI>


</UL><H4><A NAME="CURSES_KEYS_&#060;TERM&#062;.JOT">curses_keys_&#060;TERM&#062;.jot</H4>
<P>Theses scripts are run by the standard <A HREF="#STARTUP.JOT">startup.jot</A> script, they define mapping of keys to whatever key codes are generated by your terminfo , these are then assigned functions by the <A HREF="#STARTUP.JOT">startup.jot</A> script. Currently there is a keymap file only for the xterm:</P>

<UL><P><LI>curses_keys_xterm.jot</P></LI>

</UL><P>If run directly, it's only effect is to load buffer @ with the key-names to key-codes map - after doing that none of the function keys will work properly until startup has been re-run to attach functions to them.</P>

<P>In addition to providing the all-important mapping of editing functions to keystrokes this file also maps out the unassigned and unassignable key mappings. Some key mappings are unassignable because they collide with other keys or because they've been hijacked by the operating system for other purposes. Feel free to add your own functions or rearrange the or redefine the assignments as in whatever way seems appropriate.</P>

<P>The key mappings tend to vary significantly, so a utility is provided to assist with redefining the key-mapping script - see <A HREF="#DEFINE_KEYMAP.JOT">define_keymap.jot</A> and checked with <A HREF="#VERIFY_KEYS.JOT">verify_keys.jot</A>.</P>


</UL><H4><A NAME="WINDOWSNT_KEYS.JOT">WindowsNT_keys.jot</H4>
<P>The function of this is identical to the various flavours of curses_keys (see <A HREF="#CURSES_KEYS_&#060;TERM&#062;.JOT">curses_keys_&#060;TERM&#062;.jot</A>) in that it associates functions with keycodes - i.e it defines key bindings.</P>


</UL><H4><A NAME="UC_BASIC.JOT">uc_basic.jot</H4>
&#062; uc_basic&#123;F2&#125;
<P>This script defines a small number of basic unicode characters that may then be entered using a four-key sequence beginning &#123;Esc&#125;, &#123;u&#125;, &#123;c1&#062;&#125; and &#123;&#060;c2&#062;&#125; where the characters c1 and c2 uniquely define a character in the supported unicode subset. The uc_basic script performs this substitution on the command line using <A HREF="#%S=COMMANDSTRING">%s=commandstring</A>. See also <A HREF="#ABOUT UNICODE">about unicode</A>.</P>

<P>These are the escape sequences and characters supported by uc_basic.jot:</P>

&#123;Esc u ' a&#125;   á           &#123;Esc u ' A&#125;   Á           &#123;Esc u " a&#125;   ä           &#123;Esc u " A&#125;   Ä           
&#123;Esc u <CODE>&lt;</CODE>A HREF="# A&#125; à &#123;ESC U "<CODE>></CODE> a&#125; à &#123;Esc u <CODE>&lt;</CODE>/A<CODE>></CODE> A&#125; À &#123;Esc u ~ a&#125; ã &#123;Esc u ~ A&#125; Ã 
&#123;Esc u ^ a&#125;   â           &#123;Esc u ^ A&#125;   Â           &#123;Esc u c a&#125;   ǎ           &#123;Esc u c A&#125;   Ǎ           
&#123;Esc u o a&#125;   å           &#123;Esc u o A&#125;   Å           &#123;Esc u _ a&#125;   ā           &#123;Esc u _ A&#125;   Ā           
&#123;Esc u ; a&#125;   ą           &#123;Esc u ; A&#125;   Ą           &#123;Esc u b a&#125;   ă           &#123;Esc u b A&#125;   Ă           
&#123;Esc u , c&#125;   ç           &#123;Esc u , C&#125;   Ç           &#123;Esc u O R&#125;   ®           &#123;Esc u O C&#125;   ©           
&#123;Esc u t m&#125;   ™           &#123;Esc u &#060; &#060;&#125;   «           &#123;Esc u &#062; &#062;&#125;   »           &#123;Esc u " &#060;&#125;   “           
&#123;Esc u " &#062;&#125;   ”           &#123;Esc u ' &#060;&#125;   ‘           &#123;Esc u ' &#062;&#125;   ’           &#123;Esc u . .&#125;   …           
&#123;Esc u . ^&#125;   ·           &#123;Esc u x x&#125;   ×           &#123;Esc u - :&#125;   ÷           &#123;Esc u ^ 0&#125;   ⁰           
&#123;Esc u ^ 1&#125;   ¹           &#123;Esc u ^ 2&#125;   ²           &#123;Esc u ^ 3&#125;   ³           &#123;Esc u 1 2&#125;   ½           
&#123;Esc u 1 4&#125;   ¼           &#123;Esc u 3 4&#125;   ¾           &#123;Esc u s s&#125;   ß           &#123;Esc u s o&#125;   §           
&#123;Esc u / o&#125;   ø           &#123;Esc u / O&#125;   Ø           &#123;Esc u - d&#125;   đ           &#123;Esc u - D&#125;   Đ           
&#123;Esc u d h&#125;   ð           &#123;Esc u D H&#125;   Ð           &#123;Esc u ~ n&#125;   ñ           &#123;Esc u t h&#125;   þ           
&#123;Esc u T H&#125;   Þ           &#123;Esc u a e&#125;   æ           &#123;Esc u A E&#125;   Æ           &#123;Esc u ! !&#125;   ¡           
&#123;Esc u ? ?&#125;   ¿           &#123;Esc u = L&#125;   £           &#123;Esc u = E&#125;   €           &#123;Esc u = Y&#125;   ¥           
&#123;Esc u / C&#125;   ₡           &#123;Esc u | c&#125;   ¢           &#123;Esc u o x&#125;   ¤           &#123;Esc u / /&#125;   \           
&#123;Esc u o o&#125;   °           
<P>e.g:</P>

<PRE>
&#123;Esc q = Y&#125; - is replaced by the Yen character ( ¥ ).
&#123;Esc q o o&#125; - is replaced by the degrees character ( ° ).
</PRE>

</UL><H4><A NAME="UC_MATH.JOT">uc_math.jot</H4>
&#062;uc_math&#123;F2&#125;
<P>This script sets up some characters used in maths and engineering, essentially it is used in the same way as <A HREF="#UC_BASIC.JOT">uc_basic.jot</A>. It follows the vim digraph scheme.</P>

<UL><P><LI>&#123;Esc u + -&#125; ± -- plus minus </P></LI>

<P><LI>&#123;Esc u 2 S&#125; ² -- squared (superscript 2) </P></LI>

<P><LI>&#123;Esc u * P&#125; ∏ -- coproduct (big, tall Pi) </P></LI>

<P><LI>&#123;Esc u + Z&#125; ∑ -- summation (big, tall Sigma) </P></LI>

<P><LI>&#123;Esc u S b&#125; ∙ -- bullet operator (dot product) </P></LI>

<P><LI>&#123;Esc u R T&#125; √ -- (square) root </P></LI>

<P><LI>&#123;Esc u 0 0&#125; ∞ -- infinity </P></LI>

<P><LI>&#123;Esc u G *&#125; Γ -- Gamma </P></LI>

<P><LI>&#123;Esc u D *&#125; Δ -- Delta </P></LI>

<P><LI>&#123;Esc u H *&#125; Θ -- Theta </P></LI>

<P><LI>&#123;Esc u P *&#125; Π -- Pi </P></LI>

<P><LI>&#123;Esc u S *&#125; Σ -- Sigma </P></LI>

<P><LI>&#123;Esc u F *&#125; Φ -- Phi </P></LI>

<P><LI>&#123;Esc u Q *&#125; Ψ -- Psi </P></LI>

<P><LI>&#123;Esc u W *&#125; Ω -- Omega </P></LI>

<P><LI>&#123;Esc u a *&#125; α -- alpha </P></LI>

<P><LI>&#123;Esc u b *&#125; β -- beta </P></LI>

<P><LI>&#123;Esc u g *&#125; γ -- gamma </P></LI>

<P><LI>&#123;Esc u d *&#125; δ -- delta </P></LI>

<P><LI>&#123;Esc u e *&#125; ε -- epsilon </P></LI>

<P><LI>&#123;Esc u y *&#125; η -- eta </P></LI>

<P><LI>&#123;Esc u h *&#125; θ -- theta </P></LI>

<P><LI>&#123;Esc u k *&#125; κ -- kappa </P></LI>

<P><LI>&#123;Esc u l *&#125; λ -- lambda </P></LI>

<P><LI>&#123;Esc u m *&#125; μ -- mu </P></LI>

<P><LI>&#123;Esc u p *&#125; π -- pi </P></LI>

<P><LI>&#123;Esc u r *&#125; ρ -- rho </P></LI>

<P><LI>&#123;Esc u s *&#125; σ -- sigma </P></LI>

<P><LI>&#123;Esc u * s&#125; ς -- sigma (alternative) </P></LI>

<P><LI>&#123;Esc u t *&#125; τ -- tau </P></LI>

<P><LI>&#123;Esc u f *&#125; φ -- phi* </P></LI>

<P><LI>&#123;Esc u q *&#125; ψ -- psi* </P></LI>

<P><LI>&#123;Esc u w *&#125; ω -- omega* </P></LI>

<P><LI>&#123;Esc u / -&#125; † -- dagger (sword) </P></LI>

<P><LI>&#123;Esc u / =&#125; ‡ -- double dagger (double sword) </P></LI>

<P><LI>&#123;Esc u &#060; -&#125; ← -- left arrow* </P></LI>

<P><LI>&#123;Esc u - !&#125; ↑ -- up arrow </P></LI>

<P><LI>&#123;Esc u - &#062;&#125; → -- right arrow </P></LI>

<P><LI>&#123;Esc u - v&#125; ↓ -- down arrow </P></LI>

<P><LI>&#123;Esc u F A&#125; ∀ -- for all (for any) </P></LI>

<P><LI>&#123;Esc u d P&#125; ∂ -- partial differential (curled little d) </P></LI>

<P><LI>&#123;Esc u T E&#125; ∃ -- there exists (backwards capital E) </P></LI>

<P><LI>&#123;Esc u A N&#125; ∧ -- logical and </P></LI>

<P><LI>&#123;Esc u O R&#125; ∨ -- logical or </P></LI>

<P><LI>&#123;Esc u . :&#125; ∴ -- therefore (triangle of dots) </P></LI>

<P><LI>&#123;Esc u : .&#125; ∵ -- because (upside-down triangle of dots) </P></LI>

<P><LI>&#123;Esc u / 0&#125; ∅ -- Null set, empty set, var nothing, capital O slash </P></LI>

<P><LI>&#123;Esc u O /&#125; Ø -- Null set, empty set, var nothing, capital O slash </P></LI>

<P><LI>&#123;Esc u ( -&#125; ∈ -- element of </P></LI>

<P><LI>&#123;Esc u - )&#125; ∋ -- contains as member </P></LI>

<P><LI>&#123;Esc u ( U&#125; ∩ -- set intersect </P></LI>

<P><LI>&#123;Esc u U )&#125; ∪ -- set union </P></LI>

<P><LI>&#123;Esc u ( C&#125; ⊂ -- subset of (contained in) </P></LI>

<P><LI>&#123;Esc u ) C&#125; ⊃ -- superset of (contains) </P></LI>

<P><LI>&#123;Esc u ( _&#125; ⊆ -- subset of or equal to </P></LI>

<P><LI>&#123;Esc u ) _&#125; ⊇ -- superset of or equal to </P></LI>

<P><LI>&#123;Esc u O b&#125; ∘ -- concatenation, centred dot </P></LI>

<P><LI>&#123;Esc u I n&#125; ∫ -- integral S </P></LI>

<P><LI>&#123;Esc u D I&#125; ∬ -- double integral S </P></LI>

<P><LI>&#123;Esc u I o&#125; ∮ -- line integral S with circle </P></LI>

<P><LI>&#123;Esc u D E&#125; ∆ -- Delta </P></LI>

<P><LI>&#123;Esc u N B&#125; ∇ -- Nabla </P></LI>

<P><LI>&#123;Esc u ? 1&#125; ∼ -- tilde operator (centered tilde, proportional) </P></LI>

<P><LI>&#123;Esc u ? =&#125; ≅ -- approximately equal to </P></LI>

<P><LI>&#123;Esc u ? 2&#125; ≈ -- almost equal to </P></LI>

<P><LI>&#123;Esc u ! =&#125; ≠ -- not equal to </P></LI>

<P><LI>&#123;Esc u = &#060;&#125; ≤ -- less than or equal to </P></LI>

<P><LI>&#123;Esc u &#062; =&#125; ≥ -- greater than or equal to </P></LI>


</UL><H4><A NAME="DEFINE_KEYMAP.JOT">define_keymap.jot</H4>
<PRE>
$  jot $&#123;JOT_HOME&#125;/coms/curses_keys_Vn.jot -in="%r=define_keymap&#091; -init&#093;"
</PRE>
<P>This script is used to map actual keycodes received from a real keyboard. It works by prompting for each of the various keystrokes in the nominated keys file and replacing the key code with whatever it picks up from your typing.</P>

<P>Be aware though, that the operating system may pick up certain keys and cause evil or, at least, bizarre unhelpful, things to happen. Alt+F12 on some systems, for example, closes the current window. Now why we should need a shortcut to close a window when there must be at least half a dozen other ways of doing it is a question beyond the scope of this user guide. But that's what it does, it's very annoying, and there seems to be no way of turning it off - without re-coding and recompiling slabs of kernel.</P>

<P>Some of these can, however, be turned off in the system shortcuts setup the Alt+Fn actions, alas, seem to be cast in concrete - or, at least, in the kernel. So, if any jot key triggers a re-programmable shortcut that you don't need, it may be a good plan to turn them off before starting.</P>

<P>To completely redefine the define_keymap script, define_keymap.jot is first run with the -init qualifier:</P>

<PRE>
$  jot new_keys.jot -in="%r=define_keymap -init"
</PRE>
<P>The -init qualifier tells it to begin by scrubbing all keycodes in the file, replacing each with the string "????????". The main section of the script then searches these reset keycodes, prompts you to prod that combination of keys and picks up the keycode which then replaces the reset keycode. This process is repeated until all missing keycodes have been filled in.</P>

<P>If you only want to redefine a selection of keycodes, you can manually reset these to "????????" in an ordinary editor session.</P>

<P>If you've made a mistake or just want to take a break, you can interrupt (Ctrl+c) then save your work and exit. When restarting you should not, of course, give it the -init qualifier.</P>


</UL><H4><A NAME="VERIFY_KEYS.JOT">verify_keys.jot</H4>
<PRE>
$ jot /dev/null -in=%r=verify_keys
</PRE>
<P>This is a simple  script  that  allows  the  user  to  verify  the  keyboard
mappings. It simply prints the keycode and name of the function key  to  the
console area as they are struck. Function-key names are assumed to be  in  a
comment field of the keyboard map file e.g. $&#123;JOT_HOME&#125;/coms/curses_Vn.jot

</UL><H3><A NAME="MENU.JOT">menu.jot</H3>
For the default menu:
<PRE>
$ jot &#060;pathName&#062; -st=menu
</PRE>
For a custom menu and, optionally, custom functions:
<PRE>
$ jot &#060;pathName&#062; -st=&#060;customMenuScript&#062;
</PRE>
The custom script will normally conclude with a line like this:
<PRE>
%r=menu;
</PRE>

This is for the benefit of those who enjoy working with menu-driven systems,
menu.jot sets up a simple, but usable, menu-driven editing environment.

The  default  menu  includes  all  the  editor  functions  in  a   two-level
hierarchical menu.  An  alternative  menu  can  be  specified  -  see  `Menu
definition`.

Although the menu is crude and clonky looking - it's quite a lot  like  that
of windows version 1 - remember that? It's still usable as  it  stands  and,
for users with simple keyboards, it may actually be useful.

A menu item can be frozen  with  the  &#060;&#060;HoldSubMenu&#062;&#062;  function  defined  by
menu.jot ( &#123;Esc m h&#125; ), frozen menu entries can be removed  later  with  the
&#060;&#060;TopMenu&#062;&#062; function ( &#123;Esc m i&#125;  )  -  this  clears  the  menu  buffer  and
rebuilds the original top-level menu bar(s).

</UL><H4><A NAME="MENU DEFINITION">Menu definition</H4>
The menu structure is defined in a simple tabular format in buffer ( - ). To
define your own menu,  the  customMenuScript  should  set  up  a  plain-text
representation of the desired menu in buffer ( - ).

Brief syntax rules for the menu-definition buffer:
<UL><LI>Any line which does not begin with either a plus or minus sign ( +  -  )</LI>
or a label (defined below) is ignored. Note that comments  need  not  be
introduced by any special character but, in these examples, %% has  been
included for clarity.

<LI>Menu items *must* be enclosed in double quotes, each defines the name of</LI>
a function to be called when that menu item is clicked.

<LI>Each menu-bar definition line must have entries which either:</LI>
<UL><LI>are an exact match for a callable function or</LI>
<LI>must have a function name somewhere enclosed in double angle  brackets</LI>
eg: Any old text &#060;&#060;aFunction&#062;&#062; any old text.

</UL><LI>Any line begining with a plus sign ( + ) is a permanently  visible  menu</LI>
bar. If the plus sign is followed immediately with a string, this string
is prefixed to the menu items to define a function which will be  called
when a menu item is clicked. eg:
<PRE>
+fred_ "abc" "def" "ghi" "jkl"
</PRE>
This defines a permanently-visible menu bar showing:
<PRE>
abc def ghi jkl
</PRE>
Clicking on ghi will call the function fred_ghi

<LI>Lines begining with a minus sign ( -  )  are  similar  but  parts  of  a</LI>
submenu. Submenus are made  temporarialy  visible  by  some  function  -
typically called by some superior menu item.

<LI>Any line begining with a string followed by a colon ( : ) is a label, it</LI>
introduces  a  submenu  which  will  be  brought  into  view  when   the
appropriate function is called. The label  line  must  not  contain  any
other text and the label string  must  not  contain  blanks.  All  lines
following the label through to that before the next label,  defines  the
submenu. eg:
</UL>...
<PRE>
%%Submenu promoted by clicking on ghi, above.
</PRE>
</UL><H5><A NAME="FRED_GHI">fred_ghi</H5>
- "doThis" "doThat" "doSomethingElse"
-jim_ "mno" "pqr" "stu"

<PRE>
%%Submenu promoted by clicking on mno, above.
</PRE>
</UL><H5><A NAME="JIM_MNO">jim_mno</H5>
...

</UL><H3><A NAME="QR.JOT">qr.jot</H3>
<PRE>
$ jot /dev/null -st=qr
</PRE>
or this will also work:
<PRE>
$ jot /dev/null -in=%r=qr
</PRE>

qr.jot reads the main jot user documentation in their raw ( .txt )  form  to
provide a useful  quick-reference  entry  point  to  the  words,  using  the
`linkdocs.jot` script insert the link metadata. Valid links are  highlighted
in green.

A left-button click on a link will follow the link. A left-button  click  in
any other part of the window will return to the previous view.

If you are in a non-mouse environment, macro_1 is set up  to  emulate  mouse
clicks - move the cursor to a link and &#123;Esc 1&#125; emulates a mouse click.

</UL><H3><A NAME="FAKE_VIM AND FAKE_EMACS">fake_vim and fake_emacs</H3>
`fake_vim.jot` and `fake_emacs.jot` are attempts at emulating the  behaviour
of these editors in jot.

A good question, at this point, would be "why bother  with  a  vim  emulator
when there are perfectly good versions available for free anyway?" Well,  it
would be true to say it's a good demonstration of the power and  flexibility
of jot that it can  do  reasonable  emulations  of  two  entirely  different
editors without resorting to magic modes or special tricks. It's  also  true
that, if ever they get anywhere near complete,  they  provide  a  transition
path for vim users suffering from RSI problems in their  escape  fingers  or
Emacs users yearning for a bit of sanity. But, the real reason is, I did  it
because I could.

For occasional vim users or less  experienced  users  wanting  to  progress,
fake_vim.jot  offers  a  progression  route  for  those   daunted   by   the
labyrinthine  complexity  of  the  vim  and  the  immensity  of  it's   user
documentation (the quick-reference guide  quickref.txt  runs  to  over  1500
lines!)

The end point for this project is defined by a vim quick-reference  guide  I
found at `http://users.ece.utexas.edu/~adnan/vimqrc.html`. It's clearly  not
a complete guide to all  the  features  but  it  looks  like  a  good  solid
introduction.

</UL><H4><A NAME="FAKE_VIM.JOT">fake_vim.jot</H4>
<PRE>
$ jot /dev/null -st="fake_vim &#060;pathName1&#062;&#091; &#060;pathName2&#062;&#091; ...&#093;&#093;"
</PRE>
<UL><LI>Starts a fake-vim session on the specified list of file pathnames.</LI>
<PRE>
$ jot /dev/null -st="fake_vim &#060;pathName1&#062;&#091; &#060;pathName2&#062;&#091; ...&#093;&#093; -c=&#060;cmd1&#062;&#091; +&#060;cmd2&#062;&#091; +&#060;cmd3&#062;&#091; +...&#093;&#093;&#093;;"
</PRE>
<LI>ditto  but  executes  the  specified  vim  commands  before  starting  the</LI>
interactive session. Commands using control characters should  be  escaped
by prefixing with carat ( ^ ) - eg for an escape use  "^&#091;".  There  is  no
limit to the number of commands that may be passed in using -in and + they
are executed in left-to-right order.

The remainder  of  this  section  is  devoted  to  differences  between  the
behaviour of fake_vim and that of standard vim, as defined  by  this  guide.
Different versions  of  vim  have  slightly  different  behaviours.  for  my
analysis of vim behaviour I used two builds of the same version:
<UL><LI>Crouton Chromebook - 7.4 (2013 Aug 10, compiled Nov 24 2016 16:44:48)</LI>
<LI>Fedora PC -  7.4 (2013 Aug 10, compiled Apr  8 2016 11:52:51)</LI>
</UL>
<LI>Startup - As described above, start jot on /dev/null with the startup file</LI>
fake_vim followed by normal vim arguments.

<LI>jot functions - all of the key functions described in the user guide  (see</LI>
`Keyboard functions defined at startup`) are available in addition to  vim
editing keys.

<LI>Nomenclature alert: in vimspeak tags refer to index points (e.g. generated</LI>
by Exuberant Ctags), in jotspeak tags are little bits of metadata that can
be assigned to an, otherwise, plain-text file image.

<LI>fake_vim completely ignores whatever you may have in your ~/.viminfo</LI>

<LI>&#123;Ctrl+w&#125; - this is a prefix to several important window control  functions</LI>
but it closes the current page on my Chromebook and it's not  so  easy  to
nobble Chromebook shortcuts,  so  fake_vim  picks  these  up  on  &#123;Esc  w&#125;
instead.

<LI>Handling multiple files - When switching between  open  files  in  vim  it</LI>
insists on either writing or  abandoning  any  edits  you've  done  before
moving to the next file. This affects :n, jumps and  tag  operations.  The
fake_vim behaviour is to allow any  file-to-file  jumps  but  the  session
cannot be closed until all modified file images have been written.

<LI>Messages, warnings and errors - no effort was gone gone to in  the  making</LI>
of fake_vim messages to exactly match genuine-vim messages. Also  fake_vim
messages disappear on the next command and many error conditions, reported
by vim, do not result in fake_vim messages.

<LI>Currently, the &#123;d&#125; and &#123;y&#125; prefixes to movement commands behaves  slightly</LI>
differently to genuine vim. If the movement ends up at  the  beginning  of
the next line then genuine vim &#123;d&#125; will delete the character left  of  the
cursor, &#123;y&#125; yanks to the end of the line. Whether this be  either  bug  or
feature fake_vim does not attempt to replicate it - fake vim  deletes  and
yanks are consistent with the underlying movement command.

<LI>The vim cursor is red, fake_vim's is white.</LI>

<LI>There are all kinds of subtleties in the definition of a sentence for  &#123;(&#125;</LI>
and &#123;)&#125; - the implementation in fake_vim fails to respect a lot of these.

<LI>When genuine vim writes a report (eg :reg - reports  register  status)  ir</LI>
replaces the last few lines of the display with the report text - the view
is restored on next keystroke,  fake_vim  replaces  the  entire  view  and
prompts user to hit &#123;Return&#125; to continue. Unlike vim, the  keystroke  does
not contribute to the next command string.

<LI>Currently there is no undo/redo facility available  in  jot  or  fake_vim.</LI>
While this is not  too  difficult  to  implement  for  vim  commands,  its
impracticable for jot command strings. One of the main motivations  behind
fake_vim was to allow super-powerful jot command  sequences  to  be  mixed
with vim commands.

<LI>jot does not support any form of line-wrapping mode. Hence  :set  &#091;no&#093;wrap</LI>
is not supported in  fake_vim.  The  &#123;zh&#125;  and  &#123;zl&#125;  commands  are  fully
supported though.

<LI>In the event of &#123;zl&#125; or &#123;zh&#125; causing the current character to  go  out  of</LI>
view, genuine vim will adjust the cursor position to keep it in view. It's
hard to see how this feature could be even remotely helpful,  so  fake_vim
allows the cursor to go out of view and repeats the  relevant  section  of
the line in the console area.

<LI>The arrow keys are set up for normal  jot  operation  -  vim-style  cursor</LI>
control is available on the &#123;h&#125;, &#123;j&#125;, &#123;k&#125; and &#123;l&#125; keys.

<LI>When near the end of the file image, vim will often display  blank  lines.</LI>
Also the last line is deleted vim will generally move up the screen to the
previous line leaving another blank line behind.  In  contrast,  jot  will
only display blank lines when the file image is smaller than the window.

<LI>Genuine vim will not normally allow the cursor to go past  the  end  of  a</LI>
line of text, the only exception appears to be with entirely blank  lines.
In vim these are displayed as though the line  contains  whitespace.  This
aversion to allowing the cursor past the end of the line probably explains
the plethora of vim functions with before and after-the-cursor variants.

The native jot end-of-line behaviour is to allow the cursor to go just one
character past the end of line displaying a tilde ( ~ ) after  the  actual
end of the line. This native  jot  end-of-line  behaviour  is  adopted  in
fake_vim.

<LI>On exit from insert mode, vim will, for some reason, move the cursor  back</LI>
one character, jot just leaves it after the inserted text.

<LI>The &#123;U&#125; command, in genuine vim will restore the last  line  where  insert</LI>
mode was begun. For vim, this only works if the insertion created  no  new
lines (ie no &#123;return&#125; was entered in the  text)  then  no  restoration  is
done. In fake_vim the first line is restored and the additional lines  are
left as-is.


</UL><H4><A NAME="FAKE_EMACS.JOT">fake_emacs.jot</H4>
<PRE>
$ jot &#060;filePathName&#062; -st=fake_emacs
</PRE>

The fake_emacs script is designed to replace the normal startup script -  in
fact it calls the normal startup script (see `startup.jot`) so most  of  the
normal jot functionality is also available.

The end point for this project is a good  implementation  of  the  functions
described       in       the        emacs        quick-reference        card
(https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf)

There are some features of emacs features which will probably never be fully
implemented in jot because they're either too hard,  impossible  or  because
jot already has a better approach:
<UL><LI>"Undo changes" - undo commands are very difficult, maybe impossible,  to</LI>
implement in editors like jot as one operation can affect any number  of
buffers and internal bits of state. However it is quite likely that  the
journal system (see `recover.jot` and  `about  not  losing  your  work`)
could be adapted for this purpose.

<LI>"Incremental search" - although this looks flashy, it doesn't seem to be</LI>
a particularly helpful feature. Jot does an adequate emulation of it but
the  jot  `PopupSearch`  function  offers  a  better  way  viewing   the
population of partial matches to a string. The emacs incremental  search
restricts the horizon to  one  page,  PopupSearch  searches  toe  entire
document.

<LI>Key  sequences  involving  &#123;Ctrl+C&#125;  -  in   common   with   most   sane</LI>
applications, jot interprets  &#123;Ctrl+C&#125;  (C-c  -  in  emacsspeak)  as  an
interrupt  and  is  therefore  not  available  for  key  sequences.  All
instances of Ctrl+c have been changed to Alt+c.

</UL><H3><A NAME="GET.JOT">get.jot</H3>
&#062; get&#091; &#060;path&#062;&#091;/&#060;pathElem&#062;&#093;&#093;&#123;F2&#125;
<UL>
</UL>e.g.
<PRE>
&#062; get ~/ed/.t&#123;F2&#125;
</PRE>
<UL><LI>selects files matching *.t in ~/ed</LI>
<UL>
</UL></UL>The get script picks up a directory path and lists files in the directory in
a simple menu-style buffer. The intrepid user can then browse  through  this
buffer using the cursor-control or find keys to  select  either  a  file  or
directory. The target is selected by running  the  0  macro  (bound  to  the
numeric-keypad 0 button).

If the target file turns out to be a tar  or  zip  archive,  then  the  file
contents are listed and you are invited to select one of the  member  files.
The selected file is then unpacked and it's image turns up in the  nominated
buffer.

If the target file is an Excel spreadsheet then the spreadsheet  sheets  are
listed and you are invited to select one. If the xls2csv utility is on  your
search path, then it uses this to open the spreadsheet.

A directory listing shows one item to each line  of  the  buffer,  with  the
directory path at the head of the list, subdirectory names are suffixed with
a  slash  '/'.  Both  the  directory  path  and  the  trailing  slashes   on
subdirectory names are recognized by and are important to the 0 macro.

If the given path is  absolute  (i.e.begins  with  /  or  ~  (linuxland)  or
&#060;drive&#062;:/ (windowsland) the path is used as-is. If the given  relative  path
begins ./ then this is taken as an indication to construct a  path  relative
to your PWD. If the given relative path does not begin with "./" then it  is
taken to be relative to the current file's path.
<UL>
</UL>If no pathname is given, the current buffer  is  checked  -  if  the  cursor
points to a string that matches a valid pathName  relative  to  the  current
file then that is used. If not, then the env GetDefaultPath  is  used  as  a
path prefix.

When a file is selected, the get  script  runs  the  unix  file  utility  to
identify the file type, if it is an archive offer a  new  menu  showing  all
members of the archive and invites you to select again. If the selected file
is compressed then get will decompress a copy of the file before reading. In
windows, the file  utility  does  not  exist  and  the  file-name  extension
determines the file type:
<UL><LI>&#060;name&#062;.xls - a microsoft excel spreadsheet,</LI>
<LI>&#060;name&#062;.doc - a microsoft word document,</LI>
<LI>&#060;name&#062;.docx - a microsoft word document,</LI>
<LI>&#060;name&#062;.pdf - a PDF document,</LI>
<LI>&#060;name&#062;.tar - a tar archive,</LI>
<LI>&#060;name&#062;.tz - a compressed tar archive,</LI>
<LI>&#060;name&#062;.zip - a zip archive,</LI>
<LI>&#060;name&#062;.cab - a microsoft cabinet archive,</LI>
<LI>Files with any other extension are treated as plain text.</LI>
</UL>
If your selection is a directory (including the .. directory to descend  the
directory tree) then the new directory redefines the menu. If the target  is
a file and you did not specify a destination buffer on the command line, you
will be prompted for a destination buffer and the file will be  loaded  into
that buffer.
<UL>
</UL>To force get to pick up the current file-image  path,  even  when  the  text
under the cursor could  be  interpreted  as  a  pathName,  then  enter  some
wildcard as the path - e.g:
<PRE>
get *&#123;F2&#125;
</PRE>

If the file name is fully specified  and  exactly  matches  a  file  in  the
directory indicated by the path, then the file is selected, if the file name
contains wildcards (the * character)  then  the  resultant  menu  lists  the
matching files.

The get script will open some classes  of  non-text  documents  and  archive
files using a helper app where necessary, this requires the installation  of
the helper:
<UL>
<UL><LI>excel spreadsheets use xls2csv, this must be on your search path, if  an</LI>
xls2csv cannot be found, then it  attempts  to  use  the  tika-app  (see
below). Files required to make xls2csv can be downloaded from the libxls
sourceforge project. xls2csv is preferable on two counts:
<UL><LI>it's compiled c not java, so it goes like the wind,</LI>
<LI>it can extract a list of sheets for you to browse; tika, by contrast</LI>
just dumps all the sheets into one vast page.
</UL>
<LI>PDF, MS-word (.doc and .docx)  and  (where  xls2csv  is  missing)  excel</LI>
spreadsheets use apache tika - this requires a java on your search  path
and the tika-app jar in your $&#123;JOT_HOME&#125;/bin area. The tika-app jar  can
be downloaded from apache.org. A java  installation  can  be  downloaded
from java.com.

<LI>It opens tar archives with tar - this should be  on  your  linux  search</LI>
path. In MS-windows systems, a suitable version of tar can be downloaded
from the sourceforge gnu project.

<LI>It opens zip files with unzip.</LI>

</UL></UL>Here is a full list of the various helper co-processors you may need
<UL><LI>cabextract - microsoft, in most linux distributions</LI>
<LI>file - gnu.org, in most linux distributions</LI>
<LI>gunzip - gnu.org, in most linux distributions</LI>
<LI>iconv - gnu.org</LI>
<LI>gtar - gnu.org, in most linux distributions</LI>
<LI>tika - tika.apache.org/download.html, get.jot expects to  find  this  in</LI>
$&#123;JOT_HOME&#125;/bin - you will also need java.
<LI>unzip - gnu.org, in most linux distributions</LI>
<LI>which - gnu.org, in most linux distributions</LI>
<LI>xls2csv - http://libxls.sourceforge.net</LI>

</UL><H3><A NAME="COMP.JOT">comp.jot</H3>
&#062; comp&#091; &#060;key&#062;&#093;&#091; -backup&#091;=&#060;backupVersion&#062;&#093;&#093;&#091; -nosplit&#093;&#123;F2&#125;

This sets up macros 4 and 5 to compare the  contents  of  two  buffers.  The
current buffer and a nominated reference buffer. If no comparison buffer  is
nominated, then the buffer is assumed to be a file image and is compared  to
the version spinning on disc.

It also sets up macro 6, initially this repeats the last  given  command  in
the other buffer,subsequent invocations of macro-6 repeat the  same  command
in both buffers.

By default, comp.jot will redefine the windows to give  you  a  split-screen
view of the two buffers - the -nosplit option stops this happening.

If the &#060;key&#062; arg value is given, this  is  the  identity  of  the  Reference
buffer. If the reference buffer is not given, then the buffer is assumed  to
be a file image and the current filing-system version of the  file  is  read
into the ! buffer and that is compared to the current buffer.

If the -backup value is given, then the most recent backup version  is  read
to the ! buffer - see `backup.jot`. The path for  the  backup  directory  is
assumed to be &#060;originalFilePath&#062;/backup -  if  no  backupVersion  string  is
specified it takes the most recent backup version. If a backupVersion string
is specified then the extracted version name will match this string. In  the
even of more than one backup versions matching the given  string,  an  error
message is issued.

It also redefines macros 4, 5 and 6 (bound to numeric-keypad  buttons  4,  5
and 6).

<UL><LI>Macro 5 ( &#123;KP_5&#125; or &#123;Esc 5&#125; )  will  compare  successive  lines  in  the</LI>
current buffer with those  the  ref  buffer,  starting  at  the  current
character position in both progressing forwards through the buffers.

When the comparison reaches the end of a  buffer  all  colour  tags  are
removed from that buffer. This behaviour gives an easy way to remove the
colour tags from the buffers:
&#062; m0&#123;KP_5&#125;

<LI>Button 4 is similar, except that it  compares  backwards  and  does  not</LI>
clear the colour tags.

<LI>If a jot command string is entered before hitting buttons 4 or  5,  then</LI>
instead of running the comparison, the jot command string is applied  to
both buffers - this is designed to facilitate re-synchronization of  the
two buffers.

<LI>For those lacking a numeric keypad, or for linux users when  the  keypad</LI>
has not been set up for jot (see `X-windows setup`) then &#123;Esc  4&#125;,  &#123;Esc
5&#125; and &#123;Esc 6&#125; will work.

<LI>Button 6 initially repeats the previous interactive command but  in  the</LI>
other buffer. Subsequently, it repeats the same command in both buffers.

</UL><H3><A NAME="RECOVER.JOT">recover.jot</H3>
Journal files are collected when the editor is  started  with  the  -journal
qualifier see `About not losing your work`. These can  be  used  to  retrace
every step in an editor session in the event of a crash. The  journal  files
are held in a subdirectory alongside the primary file  named  &#060;filename&#062;.jnl
(where fileName is the primary file). It holds snapshots of  all  files  and
system queries read by the session and a history.txt file containing  a  log
of your keyboard and mouse activity. All these files are  deleted  when  the
editor closes normally.

The recover.jot script works by translating  the  history.txt  file  into  a
command script that will retrace  your  interactive  session  with  snapshot
copies of your input files and then winding it's way  through  all  of  your
interactive commands and keystrokes.

The identities of saved-copies of files is preserved but they are uniquified
by suffixing them with your session's pid and a unique number.  An  extended
session may read, modify and write a file and then read it in  again  later.
It therefor keeps a separate snapshot of every read of the same file.

Note that if there's a preexisting journal directory of the same  name,  the
session will bounce complaining it can't create the  &#060;fileName&#062;.jnl  journal
directory.

For the duration of the recovery run all file writes are disabled - when the
recover_now script script terminates the session should  continue  normally,
Appending any new commands to the original history.txt file and  adding  new
snapshot files.

The recovery process starts with a special initialisation script recover.jot
which reads the history.txt file and creates a runnable recovery  script  in
your pwd, named recover_now.jot it then runs this recovery script.  Here  is
the full process, from the start of the crashing session:
<UL>
<PRE>
$ jot &#060;fileName&#062; -journal
</PRE>
<UL><LI>It crashes (to see this in operation, suspend and  kill  the  session.</LI>
The journal files should visible in ./&#060;fileName&#062;.jnl/

<LI>Start of the recovery procedure (note  this  next  editor  session  is</LI>
started  with  no  -journal  qualifier  if  you  did  it  would   fail
immediately complaining that it  could  not  create  the  new  history
file). 
<PRE>
$ jot &#060;fileName&#062; -st=recover
</PRE>
This  creates  a  recovery  script  recover_now.jot  which   it   then
immediately runs - if all goes well you will end up exactly where  you
were. On completion of the recovery, any new  commands  or  keystrokes
are appended to the journal repository. In theory,  you  can  keep  on
crashing and recovering the sessions.

If your original session was started with an -init=... sequence  these
need not be inserted here - they are recovered from the history file.
</UL></UL>
<UL>Now, if the recovery session crashes in  the  same  way  at  the  same
point, congratulations, you have probably  discovered  a  genuine  jot
bug!! Please report your bug - a  tarball  of  the  journal  directory
would be most helpful to the investigation into what  went  wrong.  To
recover from such a situation, edit the  recovery  script  created  by
recover, removing the last command then  restart  using  the  modified
recover_now script:
<PRE>
$ jot &#060;fileName&#062; -init="%r=./recover_now.jot -asConsole"
</PRE>
</UL>
<UL><LI>This approach  is  also  useful  for  recovering  from  self-inflicted</LI>
disasters.  Suppose  that,  at  some  point  in  the  session,  you've
destroyed something and now you'd now like to see it back again.  Then
edit the recover_now script, deleting the  commands  that  caused  the
problem and all subsequent commands. Or, maybe, by inserting a command
to save what you want to keep.

<LI>The recover_now.jot script must be run with  -asConsole  because  they</LI>
contain escape sequences - see `%R`.

<LI>Optionally add the -hold  qualifier,  this  holds  the  screen  before</LI>
exiting so, in the  event  of  an  early  exit,  you  can  see  what's
happening - see `-hold`.

</UL>Note: the history file in the journal area is  entirely  separate  from  the
history maintained for the %Q `query history` and is not affected by the the
CLI -history setting.

</UL><H4><A NAME="ANNOTATE_RECOVERY_FILE.JOT">annotate_recovery_file.jot</H4>
This simple script is useful when puzzling over  what  activity  is  in  the
recovery file. It simply reads the relevant keymap file  and  back-annotates
the function and key names as comments in the recover_now.jot.

Although these comments should not affect the final outcome of the recovery,
they certainly slow it down as the recovery session reflects every one  back
to the console area. It is therefore  suggested  that  users  keep  a  clean
un-annotated copy to run and just use the annotated version for analysis.

</UL><H4><A NAME="RECOVER.JOT RESTRICTIONS">recover.jot Restrictions</H4>
A simple session will involve only  one  file  and  will  not  involve  any
interactions with other files or the system. 

More complex sessions can be problematic ... here are a  few  things  to  be
aware of. In all cases, the effect is the same - some slight  change  causes
the focus point in the recovery session to  be  different  to  that  in  the
original and the result is complete gibberish.

Essentially the problem is that we tend to browse around  text  buffers  and
menus using cursor-control keys rather than searching. If a menu (say a list
of files generated by get.jot) has a different  number  of  entries  because
files have been added or removed from that pat of the  filing  system,  then
the recovery session might end up picking the wrong item.

In  most  cases,  problems  can  be   wriggled   around   by   editing   the
recover_now.jot script and restarting as described above.
<PRE>
$ jot &#060;fileName&#062; -init="%r=./recover_now.jot -asConsole"
</PRE>
<UL>
</UL><LI>The recovery process will  only  work  if  the  recovery  session  has  an</LI>
<UL>identical environment to the original - unfortunately. This can  never  be
achievable since the clock will have ticked on since the original  session
and a few, but not  many,  scripts  and  procedures  are  time  dependant.
However response of all system queries via the %E command are held in  the
journal area  -  so  they're  fine,  system  queries  using  `%Q`  may  be
problematic.

The `query dir` is most likely to cause trouble - the  directory  contents
might change between the original session and the recovery  session.  Then
scrolling down a fixed number of filename may lead to the wrong  file.  If
the selected file is then read with the %i command, then  it  will  always
pick up the correct file from the journal area because  the  correct  file
name is picked up from the history.txt file.
</UL>
<UL><LI>If something, in the original session, fails and then it's fixed by making</LI>
some adjustment to the filing system (e.g. a chmod, mkdir or some-such)  -
then the command that originally failed will now succeed in  the  recovery
session. This might cause the overall  recovery  session  to  diverge  and
possibly fail.

<LI>The recovery should be done in the same sized xterm  as  in  the  original</LI>
session. If &#060;&#060;PageUp&#062;&#062; and &#060;&#060;PageDown&#062;&#062; operations were  used,  these  set
the focus point with reference to the window size. Also,  the  outcome  of
basic functions like &#060;&#060;WordRight&#062;&#062; and &#060;&#060;WordLeft&#062;&#062; are dependant  on  the
screen width. The standard startup script sets window size in relation  to
screen size. For this reason the recover.jot script will refuse to proceed
unless the window height in the recovery session is the same  as  that  in
the original session.

<LI>If, in the original session, you interrupted something  with  Ctrl+C,  the</LI>
command count at interrupt time is  noted  and  the  recovery  session  is
interrupted at the same point by setting a command counter.

</UL><H3><A NAME="CERR.JOT">cerr.jot</H3>
&#062; cerr&#123;F2&#125;
This picks up a compiler report and defines macros 3 and 4 which  allow  you
to step between error or warning reports in the C source.

For this to work you must have the C source file in the current  buffer  and
the compiler report must be in the same directory and with the same filename
as the source but with the .lis name extension.

The script uses line numbers picked up from the compiler report even if  the
actual line numbers have shifted because of  changes  already  made  to  the
source file. The report linenumber is adjusted linenumbers to compensate for
lines added or removed before the current line.  This  only  works  if  your
compiler reports problems in line-number order.

The current version of cerr.jot will work with the output from either gcc or
microsoft cl compilers.

</UL><H3><A NAME="DO.JOT">do.jot</H3>
&#062; do &#060;CliCommand&#062;&#123;F2&#125;
<UL>
</UL>This simply performs the shell commands and it's arguments,  the  result  is
read back into the @ buffer.

</UL><H3><A NAME="LS2LIST.JOT">ls2list.jot</H3>
&#062; ls2list&#123;F2&#125;
<UL>
</UL>Transforms the output of a unix ls -laRF listing to  a  list  of  paths  for
`multi_do.jot`, `multi_ed.jot` etc.

</UL><H3><A NAME="MULTI_DO.JOT">multi_do.jot</H3>
&#062; multi_do &#060;cmd1&#062;&#091; $1 | &#060;cmd2&#062; ... &#091; -quick&#093;&#093;

This script assumes that the current buffer is a list of pathnames. It takes
a CLI command as it's argument this is applied to all files in the list  and
the results are captured in the @ buffer. See also `ls2list.jot`.

<UL><LI>The -quick option runs the command with lists of pathnames  as  extended</LI>
argument lists this is faster for big heavyweight  commands  which  take
time to activate.
<LI>The optional $1 entries are replaced with pathnames from  the  list  ($1</LI>
only allowed once when -quick is given).

</UL>Examples:
<PRE>
$ ls $JOT_RESOURCES/*.txt | jot_dev -in="%r=multi_do cat \$1 | sed s/ and / AND / -quick"
$ ls $JOT_RESOURCES/*.txt | jot_dev -in="%r=multi_do cat \$1 | sed s/ and / AND /"
</PRE>

</UL><H3><A NAME="MULTI_PAIR">multi_pair</H3>
&#062; multi_pair &#060;shell command&#062;&#123;F2&#125;

The multi_pair.jot script applies pairs of arguments  (typically  pathnames)
to a unix command requiring two arguments - e.g cp, ln, mv, diff etc.

This requires the current buffer  to  contain  a  two-column  tab  separated
table, each entry being a pathname. The Unix command is applied to each pair
of pathnames in turn. This is only useful for unix commands which  apply  to
two pathnames.

Typically, you start off with a list of pathnames (derived,  perhaps,  using
'ls2list.jot') then  copy,  filter  and  modify  each  path  to  obtain  the
secondary pathname.

It works by creating  a  temporary  command  file  containing  the  expanded
command string for each pair of operands. The generated  script  is  written
for bourne shell and, consequently, multi_pair  will  not  work  in  windows
environments.

This example demonstrates multi_pair used with ls2list.jot  to  compare  the
contents of two directory subtrees.

<PRE>
$  mkdir test; cd test
</PRE>
Copy the resources tree to the test directory
<PRE>
$  cp -R $JOT_RESOURCES/* .
</PRE>
Compare all files with their originals - here, each pathname has been copied
and modified by prefixing it with '\t$JOT_RESOURCES/':
<PRE>
$  ls -aRF | jot -in="%r=ls2list; (rr-n.r0aa&i:\t$JOT_RESOURCES/:ham)0 %r=multi_pair diff"
</PRE>
Now change a local file and one deeper down the tree.
<PRE>
$  jot l99.t -in=f/__50/s/zzz/ %c
$  chmod u+w test_get/another_dir1/t.t; jot test_get/another_dir1/t.t -in=f/jon/s/zzz/ %c
</PRE>
This time diff should find two changes:
<PRE>
$  ls -aRF | jot -in="%r=ls2list; (rr-n.r0aa&i:\t$JOT_RESOURCES/:ham)0 %r=multi_pair diff"
</PRE>

</UL><H3><A NAME="MULTI_ED.JOT">multi_ed.jot</H3>
&#062; multi_ed&#091; -use &#060;key1&#062; &#060;key2&#062;&#093;&#091; -command &#060;jot commands&#062;&#093;&#123;F2&#125;
<UL>
</UL>This script requires that that  the  current  buffer  is  a  list  of  valid
pathNames. It prompts you for a series of jot commands, when you've finished
entering the jot commands, the complete set of jot commands  is  applied  to
every file in the list.

This script picks up your specified commands and constructs a command  macro
to execute these commands for all of the files in the list (in the @ buffer,
by default). This macro reads each of the files in turn to a working  buffer
(!, by default) where the commands are run.

If no -commands list is given, it  prompts  you  to  give  it  some,  theses
commands may extend over several lines, the list of commands  is  terminated
with a line containing only a colon ':'.
<UL>
</UL>Note - many command scripts us either or both of the default working buffers
used by this script, to wriggle around this problem, the  -use  &#060;key&#062;  &#060;key&#062;
qualifier allows you to nominate an alternative pair of  buffers.  Typically
you should chose a pair of buffers in the range A to Z,  since  jot  scripts
normally avoid these.

In particular, many document-processing scripts load doc.jot - this uses the
following buffers: & * &#060; &#062; @ $ - # and !
<UL>
</UL>Also use the -command qualifier to specify commands from the command line.

Note that multi_ed does not write out anything so, if you want to write  the
modified files, the last command must be %o.
<UL>
</UL>e.g If this these are the commands we want to run:
&#062; f/chapter/l0i/1 /&#123;Return&#125;
&#062; doc2fold&#123;F2&#125;
&#062; %o&#123;Return&#125;
<UL>
</UL>We want to apply the same process to a list of pathnames,  in  this  example
they are generated by ls, processed by ls2list and filtered to extract  just
.doc files:
&#062; %ep=ls -laRF&#123;Return&#125;
&#062; ls2list&#123;F2&#125;
&#062; m-0 (r0v-/.doc/m,k)0&#123;Return&#125;
&#062; multi_ed -use q w -command f/chapter/l0i/1 / %r=doc2fold; %o;&#123;F2&#125;
 
or something like this, starting from a unix prompt:
<PRE>
$ ls *.doc | jot
</PRE>
then, in jot:
&#062; multi_ed -use q w -command f/chapter/l0i/1 / %r=doc2fold; %o;&#123;F2&#125;

</UL><H3><A NAME="RETAB.JOT">retab.jot</H3>
&#062; retab&#091; &#060;string&#062;&#093;&#123;F2&#125;
<UL>
</UL>Searches the entire buffer for the  given  string,  when  found,  the  first
instance of the string in any line is prefixed with a  tab  character.  Also
removes any whitespace adjacent the inserted tab.  Note  that  jot  displays
tabs, along with other control characters are displayed as tildes ( ~ ).

This  script  is  intended  for  use  as  a  precursor   to   `autotab.jot`,
`autotabjust.jot`, `autotabdp.jot` - see `tabulated text`.

</UL><H3><A NAME="RETABHERE.JOT">retabhere.jot</H3>
&#062; retabhere&#123;F2&#125;
<UL>
</UL>This  inserts  tabs  in  the  current-character  column.  This  is  used  in
conjunction with `retab.jot`, `autotab.jot` and `autotabjust.jot`.

This script is useful for preservation of one column of  a  partly-formatted
table - see `tabulated text`. If you have several tab points to  insert,  it
is important to start with the rightmost tab point and work leftwards.

</UL><H3><A NAME="AUTOTAB.JOT">autotab.jot</H3>
&#062; autotab&#123;F2&#125;

Aligns tab points in a buffer.
<UL>
</UL>This operates by searching the buffer for lines containing tabs, it  locates
the leftmost tab character on each line and finds the rightmost  first  tab.
The position of the rightmost first tab defines the tab points for  all  the
other first tabs.

It then replaces the first tab on any line  with  sufficient  whitespace  to
align the text following the first tab on any line.

Lines which do not contain any tabs are ignored - see `tabulated text`.

</UL><H3><A NAME="AUTOTABJUST.JOT">autotabjust.jot</H3>
&#062; autotabjust&#123;F2&#125;
<UL>
</UL>Similar to autotab, but right-justifies so  that,  on  any  line  containing
tabs, the following tabs are aligned - see `tabulated text`.

</UL><H3><A NAME="AUTOTABDP.JOT">autotabdp.jot</H3>
&#062; autotabdp&#123;F2&#125;
<UL>
</UL>Similar to autotab but inserts blanks so as to align decimal points  in  the
column following the tab - see `tabulated text`.

</UL><H3><A NAME="TAB.JOT">tab.jot</H3>
&#062; tab&#091;&#060;n&#062;&#093;&#123;F2&#125;
<UL>
</UL>Resolves all tabs to the specified tab spacing - defaults to 8.

</UL><H3><A NAME="MAIL.JOT">mail.jot</H3>
&#062; mail&#091; -FOlder &#060;folderName&#062;&#093;&#091; -Last &#060;n&#062;&#093;&#091; -FINd &#060;string&#062;&#093;&#091; -New&#093;&#091;&#091; -File &#060;MailPathName&#062;&#093;&#123;F2&#125;
<UL>-FOlder foldername - loads the specified mail folder from ~/Mail/&#060;folderName&#062;
-Last &#060;n&#062;          - loads only the last n mail messages
-FINd &#060;string&#062;     - loads only the messages containing the string.
-New               - Read no mail just create a new mail message.
-File &#060;fileName&#062;   - Read the specified file as a mail message.

</UL><H4><A NAME="USAGE EXAMPLE">Usage example</H4>
jot /dev/null -in="%r=mail -file=$&#123;JOT_RESOURCES&#125;/mail"
<UL>
</UL><H4><A NAME="DEFINED ESCAPE SEQUENCES">Defined escape sequences</H4>
<UL>&#123;Esc+o&#125; - Open selected message.
&#123;Esc+x&#125; - eXtracts message to file
</UL>&#060;list&#062; &#123;Esc+m&#125; - send current buffer as mail using "To:" , "Cc:" and "Bcc:" lines
&#091;&#060;CClist&#062;&#093; &#123;Esc+r&#125; - reply to sender &#091;and users on CC list&#093;, if list contains a '*'
<UL>the list will  reply to all recipients of original message.    
</UL>&#091;&#060;n&#062;&#093; &#123;Esc+i&#125; - include indented current &#091;or nominated&#093; message, in current buffer
<UL>&#123;Esc+a&#125; - autograph - add the autograph message to the current folder. 
</UL>
This script is not really seriously intended to be used as a general-purpose
mailer. However with the mail handling agents correctly set up for  a  local
POP mail file it can read and send mails. It may be useful to users of  MUTT
or similar POP-based mailers as  a  means  of  integrating  with  an  editor
session.

This script sets up a simple Mail User Agent (MUA) - a programme that  reads
from a POP file and constructs a mail index. POP (Post Office Protocol) is a
simple text-based format. This POP file is generally created  by  your  Mail
Delivery Agent (MDA) working with  your  Mail  Transfer  Agent  (MTA)  which
interacts with your mail provider.

Linux  users  should  set  up  their  MDA  to  deliver  in  POP3   form   to
/var/spool/mail/&#060;yourUserName&#062;  a  reasonably  simple   and   robust   setup
involving     fetchmail     and      procmail      is      described      in
http://www.andrews-corner.org/mutt.html You can test your setup using mutt -
a useful text-based MUA.

The POP-file image and mail index are held in the * buffer, to return to the
mail index, type in the z* command.

Mail adds the following control functions:
<UL>&#123;Esc o&#125; - Open - opens the message indicated at the current  line 
<UL>of the mail index.
</UL>&#123;Esc x&#125; - eXtracts message to file
</UL>&#060;list&#062; &#123;Esc m&#125; - send (Mail) current buffer  using  "To:"  ,  "Cc:"  and
<UL>"Bcc:" lines.
</UL>&#091;&#060;CClist&#062;&#093; &#123;Esc r&#125; - Reply to  sender  &#091;and  users  on  CC  list&#093;,  if  list
<UL>contains a '*' the list will reply to all recipients of
original message.
</UL>&#091;&#060;n&#062;&#093; &#123;Esc i&#125; - Include indented current  &#091;or  nominated&#093;  message,  in
<UL>current buffer
</UL>&#123;Esc a&#125; - Autograph - add the autograph message  to  the  current
<UL>folder.

</UL><H3><A NAME="C.JOT">c.jot</H3>
&#062; c&#091; -tag&#093;&#123;F2&#125;
<UL>
</UL>Redefines macros 1 and 2 (bound to numeric-keypad  1  and  2)  to  functions
suitable for browsing C code. It is reasonably bulletproof but it will  fail
to set up the hashtables  when  it  finds  a  mismatch  in  the  curly-brace
structure of  your  coding.  Note  that  c.jot  has  no  knowledge  of  what
compile-time variables are set - it assumes #ifdefs are  TRUE.  Hence  c.jot
can fail to match braces even valid C when braces are inside  #ifdef  (etc.)
blocks.

Once set up, macros 1 and 2 (numeric keypad buttons  1  and  2)  will  first
create a block index for the current c function. With the index set up,  the
2 macro will locate the next block-start character '&#123;' in the c code or,  if
already at a block-start, will locate the corresponding block-end  character
'&#125;'. Similarly, macro 1 will locate the move back  in  the  c  code  to  the
nearest block-end character or, if already  at  a  block-end,  move  to  the
corresponding block start character.

The optional -tag qualifier adds colour tags to comments.

It also sets the env variable GetDefaultPath to /usr/include - the effect of
this is to tell the `get.jot` script to default to the specified path,  with
this set you can set the cursor to a library include file and it  will  find
it.

The speedup due to the hashtables,  although  welcome,  is  not  really  the
principal motivation for their use. Because C allows multi-line comments and
text strings, it is difficult, perhaps impossible, to reliably parse C  when
plodding back through the code. The c script  plods  forwards  once  to  get
forward and back links for the hashtable.
<UL>
<UL><LI>&#123;KP_1&#125; - Calls macro 1, this finds last '&#125;' character then goes back  to</LI>
it's matching '&#123;' using the hash table for  that  buffer  -  see  `about
hashtables`.
<UL>
</UL><LI>&#123;KP_2&#125; - Calls macro 2, this Find next '&#123;' character then goes  to  it's</LI>
matching '&#125;'.

</UL></UL><H3><A NAME="JOT.JOT">jot.jot</H3>
&#062; jot&#123;F2&#125;
<UL>
</UL>Sets up macros 1, 2  and  3  (bound  to  numeric-keypad  1-3)  to  functions
suitable for browsing jot command scripts. As with the  `c.jot`  script,  it
uses hash tables. Jot code is another one of those difficult ones where it's
difficult to plod back through the code.

In  interactive   usage,   unterminated   strings   are   allowed   -   e.g.
f/fred&#123;Return&#125;, jot also  allows  these  in  macros  although  this  is  not
recommended. When one of these is  left  unterminated  in  a  script  it  is
generally a coding mistake, but it might lead  to  the  jot  command  parser
being unable to match parenthesis. Such errors are difficult to  trace.  Use
&#123;* KP_3&#125; to locate unterminated strings in your scripts.

Note that jot.jot adds tags to the code, this will cause code called via the
`hashtable call` command to fail when it is next  recompiled.  See  `Calling
subroutines by name`.
<UL>
<UL><LI>&#123;KP_1&#125; (or &#123;Esc 1&#125;) Calls macro 1 - find previous ')'  then  refocus  to</LI>
its matching '(' using hashtables.

<LI>&#123;KP_2&#125; (or &#123;Esc 2&#125;) Calls macro 2 - find next '(' then  refocus  to  its</LI>
matching ')' using hashtables.

<LI>&#060;jotCommand&#062;&#123;KP_3&#125; Calls macro 3 find next occurrence of  the  specified</LI>
jot command string.

<LI>&#123;* KP_3&#125; (or &#123;* Esc 3&#125;) Calls macro 3 modified, finds next  unterminated</LI>
string in a macro.

</UL></UL><H3><A NAME="PERL.JOT">perl.jot</H3>
&#062; perl&#123;F2&#125;
<UL>
</UL>Defines macros 1 and 2 (bound to numeric-keypad 1 & 2)  assigning  functions
suitable for browsing perl code.
<UL><LI>&#123;KP_1&#125; Macro 1 Go back to start of current block i.e locates the '&#123;'  or</LI>
'&#091;' matching the current '&#125;' or '&#093;'.
<UL>
</UL><LI>&#123;KP_2&#125; Macro 2 Go forwards end of current block i.e locates the  '&#125;'  or</LI>
'&#093;' matching the current '&#123;' or '&#091;'.
</UL>
Normally, macro 1 should be started with the cursor over a  block-end  brace
(a '&#125;'&#125; or '&#093;' character) or over whitespace to the right of one. If started
with the cursor at some other point, the  macro  locates  a  suitable  start
point and stops - you need to check the chosen start point and press  the'1'
key once more.

Similarly, macro 2 matches  to  the  current  open-brace  character  or  the
whitespace immediately  before  one,  if  the  cursor  is  over  some  other
character, it locates a suitable start point and  stops  to  let  you  check
before restarting.

</UL><H3><A NAME="SKILL.JOT">skill.jot</H3>
&#062; skill&#123;F2&#125;
<UL>
</UL>This is one for  users  of  Cadence  design  frameworks  interface  language
(skill) - a lisp-like language.

Defines macros 1, 2, 3, 4 and 5  (bound  to  numeric-keypad  1-5)  assigning
functions useful for browsing skill code. The functions dedicated  to  skill
keywords recognize the following skill keywords: if, when, unless,  foreach,
for, while, case, cond and procedure
<UL><LI>Macro 1 scan back to keyword at start of current block.</LI>
<LI>Macro 2 scan forwards to keyword at end of current block.</LI>
<LI>Macro 3 scan forwards to next "( ... )" block-start.</LI>
<LI>Macro 4 scan back to start of current "( ... )" block.</LI>
<LI>Macro 5 scan forwards to end of current "( ... )" block.</LI>

</UL><H3><A NAME="CSH.JOT">csh.jot</H3>
&#062; csh&#123;F2&#125;
<UL>
</UL>Redefines macros 1, 2, 3, 4 and 5 to functions suitable for browsing C-shell
scripts (these macros are normally bound to Numeric-keypad buttons 1, 2,  3,
4 and 5 respectively).

In the context of a  C-shell  script,  a  block  is  a  series  of  commands
controlled by some recognized  C-shell  built-in  structure.  The  following
structures are supported:
<UL><LI>if ... else ... elsif ... endif</LI>
<LI>foreach ... end</LI>
<LI>while ... end</LI>
<LI>switch case ... case ... endsw</LI>

</UL>The following macros are defined:
<UL><LI>&#123;KP_1&#125; - Macro 1 - searches back for the  previous  end-block  statement</LI>
(endif, end or endsw)  and  then  finds  the  matching  startpoint  (if,
foreach, while or switch). Note, the  jot  script  does  not  check  the
consistency of the start and end points (e.g. it will not complain if  a
foreach is terminated by an endsw).
<UL>
</UL><LI>&#123;KP_2&#125; - Macro 2 - searches forwards for the next start-block  statement</LI>
(if, foreach, while or switch) and  then  finds  the  matching  endpoint
(endif, end  or  endsw).  As  with  Macro  1,  it  does  not  check  the
consistency of the start and end points.

</UL><H3><A NAME="SH.JOT">sh.jot</H3>
&#062; sh&#123;F2&#125;
<UL>
</UL>Redefines macros 1 and 2 (bound to numeric-keypad  1  and  2)  to  functions
suitable for browsing Bourne-shell scripts.
<UL><LI>&#123;KP_1&#125; - Macro 1, Locates previous block-end statement (fi, esac,  done,</LI>
else, or elif), if not already at one, then  finds  corresponding  block
start (if, case, for, if, elif).
</UL>
<UL><LI>&#123;KP_2&#125; - Macro 2, Locates previous block-start statement (if, case, for,</LI>
if, elif) with it's matching  block-start  (fi,  esac,  done,  else,  or
elif).

<PRE>
N.B.
</PRE>
</UL>Both functions work by  counting  block  depth,  there  is  no  checking  of
block-start to block-end keyword-consistency, e.g. an 'if' block  terminated
by 'end' is matched without complaint.

</UL><H3><A NAME="KSH.JOT">ksh.jot</H3>
&#062; ksh&#123;F2&#125;
<UL>
</UL>Similar to `sh.jot` but supports some additional ksh keywords.

</UL><H3><A NAME="MIF.JOT">mif.jot</H3>
&#062; mif&#123;F2&#125;
<UL>
</UL>Sets up macros 1, 2 and 3 (bound to numeric-keypad  1-3)  for  browsing  mif
files.
<UL><LI>&#123;KP_1&#125; Macro 1 - Go back to start of current block '&#060;'.</LI>

<LI>&#123;KP_2&#125; Macro 2 - 2 Go forwards end of current block '&#062;'.</LI>

<LI>&#123;KP_3&#125; Macro 3 - Go forwards to  next  'TextFlow'  keyword  disregarding</LI>
structure.

</UL><H3><A NAME="EDIF.JOT">edif.jot</H3>
 edif&#123;F2&#125;

Sets up macros 1, 2  and  3  (bound  to  numeric-keypad  1-3)  to  functions
suitable for browsing edif files.
<UL><LI>&#123;KP_1&#125; Macro 1 Go back to start of current block '('.</LI>
<LI>&#123;KP_2&#125; Macro 2 Go forwards end of current block ')'.</LI>
<LI>&#123;KP_3&#125; Macro 3 Go forwards to next Cell keyword disregarding structure.</LI>

</UL><H3><A NAME="VHDL.JOT">vhdl.jot</H3>
&#062; vhdl&#123;F2&#125;
<UL>
</UL>This sets up macros 1 to  5  (bound  to  numeric-keypad  1-5)  to  functions
suitable for browsing VHDL files.
<UL><LI>&#123;KP_1&#125; Macro 1 Finds previous clause in current block.</LI>
<LI>&#123;KP_2&#125; Macro 2 Finds next clause in current block.</LI>
<LI>&#123;KP_3&#125; Macro 3 Find next next signal/variable  assignment,  block  start</LI>
statement or labelled statement irrespective of level.
<LI>&#123;KP_4&#125; Macro 4 Finds previous block start statement.</LI>
<LI>&#123;KP_5&#125; Macro 5 Finds next block end (invariably the END statement).</LI>

</UL>Notes and restrictions:
<UL><LI>Block-start  keywords  recognized:  IF,  CASE,   FOR,   WHILE,   ENTITY,</LI>
ARCHITECTURE, CONFIGURATION, PROCESS, PACKAGE, PROCEDURE,  FUNCTION  and
COMPONENT

<LI>Subblock-start keywords recognized: ELSE, ELSIF, WHEN and BEGIN.</LI>
<UL>
</UL><LI>In general the  VHDL  keywords  mentioned  above  should  be  the  first</LI>
non-whitespace character on a line, but a crude  implementation  of  the
&#060;labelName&#062;:&#060;keyWord&#062; syntax works most of the time.

<LI>The editor should not be run in case sensitive mode  -  some  lower-case</LI>
identifiers may confuse it.

<LI>The cursor is left at the beginning of a significant VHDL  keyword,  all</LI>
buttons will work when the cursor is left anywhere in whitespace  before
a VHDL keyword.

<LI>There is no checking of the consistency of the keywords - thus  ELSE  is</LI>
accepted as a subblock delimiter in a COMPONENT definition.

</UL><H3><A NAME="TCL.JOT">tcl.jot</H3>
&#062; tcl&#123;F2&#125;
<UL>
</UL>Sets up macros 1, 2  and  3  (bound  to  numeric-keypad  1-3)  to  functions
suitable for browsing edif files.
<UL><LI>&#123;KP_1&#125; Macro 1 Go back to start of current block '&#123;/&#091;'.</LI>
<LI>&#123;KP_2&#125; Macro 2 Go forwards end of current block '&#125;/&#093;'.</LI>
<LI>&#123;KP_3&#125;  Macro  3  Go  forwards  to   next   structure-building   keyword</LI>
disregarding block structure.

</UL><H3><A NAME="BT.JOT">bt.jot</H3>
&#062; bt&#123;F2&#125;

This script is useful when debugging complicated modular scripts. It sets up
some backtrace functions using the `query backtrace` report.

&#062; &#123;Esc b t&#125;
<UL><LI>&#060;&#060;RawBacktrace&#062;&#062; - this simply extracts an ordinary  backtrace  report  to</LI>
buffer @.

&#062; &#123;Esc a b t&#125;
<LI>&#060;&#060;AdjustedBacktrace&#062;&#062; - This extracts a `query backtrace` report to buffer</LI>
@ and attempts to adjust the line numbers so that they match those in  the
source file.

The  backtrace  query  only  gives  the  linenumbers  as  they  are  in  the
code-repository buffer ( ' ). This report would be more useful if  the  line
numbers referred to the linenumbers in  the  source  file.  It  attempts  to
identify the source file using grep - searching for the last  function  name
in the code repository buffer. It then calculates  the  correct  line-number
offset to get the lines in the  source  file  and  adjusts  the  linenumbers
accordingly.

There are at least two ways in which this  can  fail  to  give  an  accurate
result:
<UL><LI>1 the last function in the code repository may not be from the same file</LI>
as the functions in the backtrace report and
<LI>2 the file may not be in the  place  where  bt.jot  does  the  search  (</LI>
$&#123;JOT_HOME&#125;/coms )

</UL></UL><H3><A NAME="SEARCHBUFFERS.JOT">searchbuffers.jot</H3>
&#062; searchbuffers &#060;delim&#062;&#060;string&#062;&#060;delim&#062;&#123;F2&#125;
<UL>
</UL>This searches all buffers for the string, results are presented in the  form
of a list of buffers where a string match was found. In  each  buffer  where
the string-match was found, the current line is set to  the  first  matching
line, for other buffers the current line ends up being the last line of  the
buffer.

</UL><H3><A NAME="SHOWBUFFERS.JOT">showbuffers.jot</H3>
&#062; showbuffers&#123;F2&#125;
<UL>
</UL>Generates a report in ! buffer with the filenames from each buffer.

</UL><H3><A NAME="AGE.JOT">age.jot</H3>
&#062; age&#123;F2&#125;
<UL>
</UL>Tells you the age of the file in the current buffer. Note that it  takes  no
account of leap years - each year is assumed to  be  365  days.  Hence,  for
files older than one year, the day-count is less than totally accurate.

</UL><H3><A NAME="DATE.JOT">date.jot</H3>
&#062; date&#091; -Rev&#093;&#091; -Time&#093;&#123;F2&#125;

Inserts the current date at the current-character position in the  text.  If
there is a substring, then the selected text  is  replaced  by  the  current
date.

If the -r  qualifier  is  given,  the  date  section  is  reversed  and  the
separating slashes removed.

if the -t qualifier is given, then also inserts current time.

</UL><H3><A NAME="BACKUP.JOT">backup.jot</H3>
&#062; backup &#091;&#060;comment&#062;|-again&#093;&#123;F2&#125;
This script makes a backup copy in  the  &#060;path&#062;/backup  subdirectory,  where
&#060;path&#062; is the path element of the file being backed up. It also maintains  a
README_backup file in the same area, this contains the comments.

Before doing anything the script checks for existence of &#060;path&#062;/backup if it
does not exist, the script fails immediately with a suitable message.

The buffer is written to the backup area with it's normal name suffixed with
'_&#060;dateStamp&#062;'

The script insists on being given either a comment or the -a modifier,  this
is included in  the  metadata  in  the  README_backup  file  in  the  backup
subdirectory. If -a (again) is given it inherits the datestamp  and  comment
from the last entry in the same README_backup file.

</UL><H3><A NAME="COPY.JOT">copy.jot</H3>
&#062; copy&#123;F2&#125;
 
Copies all of the current buffer into the X-windows  copy  buffer.  This  is
useful for exporting an entire buffer to some x application.

N.B: This script requires xsel to be on your search path  and,  it  kind  of
goes without saying really - copy.jot does not work in windowsland.

</UL><H3><A NAME="PASTE.JOT">paste.jot</H3>
&#062; paste&#091; &#060;key&#062;&#093;&#091; -here&#093;&#123;F2&#125;
<UL>
</UL>If neither the destination buffer or -here is specified it prompts  for  the
destination buffer.
<UL>
</UL>If the destination buffer is specified then the contents of that buffer  are
replaced with the contents of the x-windows paste buffer.

If -here is specified, then the paste buffer is inserted  into  the  current
character position of the current buffer.

N.B: This script requires xsel to be on your search path  and,  it  kind  of
goes without saying really - copy.jot does not work in windowsland.

</UL><H3><A NAME="COUNT.JOT">count.jot</H3>
&#062; count&#123;F2&#125;
<UL>
</UL>Counts the number of words in the current buffer.

This script predates the ability to pipe the  current  buffer  into  a  unix
command - the unix wc command should do the job just as well:
&#062; %e$=|wc;

</UL><H3><A NAME="UNLOCKALL.JOT">unlockall.jot</H3>
&#062; unlockall&#123;F2&#125;

Goes to every buffer activated in your session and sets the  write  lock  to
unrestricted.

</UL><H3><A NAME="FREEALL.JOT">freeall.jot</H3>
&#062; freeall&#123;F2&#125;

Unlocks and then deletes all buffers. 

</UL><H3><A NAME="EXIT.JOT">exit.jot</H3>
&#062; exit&#123;F2&#125;

Frees all buffers then exits the editor without saving any files.

</UL><H3><A NAME="DOC.JOT">doc.jot</H3>
&#062; doc&#123;F2&#125;
<UL>
</UL>The doc script sets up a  simple  document  formatting  system,  it  defines
several macros and escape sequences:
<UL>
<UL><LI>&#123;Esc p a&#125; - re-format the current paragraph, the paragraph is deemed  to</LI>
be the current line and all the adjacent  lines  with  the  same  indent
level. This adjusts whitespace between words to align line endings,  the
line-length to aim for is in the &#093; buffer.

If the paragraph with a bullet mark (typically a  dash  followed  by  at
least one blank) then the length of the bullet mark is included  in  the
indentation calculation.

<LI>&#123;Esc P a&#125; reformats all paragraphs in the current buffer.</LI>

<LI>&#091;ProformaHeadingKey&#093;&#123;Esc h e&#125; - makes the current line  into  a  section</LI>
heading. e.g:
&#062; 0&#123;Esc h e&#125;             - makes current line next top-level heading
In fact, the section number given here is ignored - so  this  will  have
exactly the same effect:
&#062; 999&#123;Esc h e&#125;           - makes current line next top-level heading
 
&#062; 12.34.56.78&#123;Esc h e&#125;   - makes current line next level-4 heading
Again, the section numbers given here are ignored - so  this  will  have
exactly the same effect:
&#062; ...&#123;Esc h e&#125;           - makes current line level-4 heading
<UL>
</UL>Section headings are in two sections separated by whitespace. The  first
part is a key of the form &#060;n1&#062;&#091;.&#060;n2&#062;&#091;.&#060;n3&#062;...&#093;&#093; e.g. 9.3.99, the  second
part is any text string e.g:
<UL>123.456.789 An example of a section heading.
</UL>
The heading level is determined by the previous heading  but  the  final
counter is incremented. If the current  line  has  any  kind  of  header
level, this is taken as a proforma and the new header  level  will  have
the same number of levels  but  will  inherit  the  numbering  from  the
previous heading.

If a proformaHeadingKey is given  this  defines  the  proforma  and  any
preexisting heading key is ignored.

By default, headings below level 4  (i.e.  1.2.3.4...)  are  underlined,
this behaviour is controlled by the number in line 4 of the & buffer.
<UL>
</UL><LI>&#123;Esc h a&#125; - resets all headings, the heading levels are  unchanged,  but</LI>
out-of-sequence section numbers are reordered.
<UL>
</UL><LI>&#123;Esc h +&#125; - makes the current line into a section heading,  the  heading</LI>
level is one higher than the previous heading.
<UL>
</UL><LI>&#123;Esc h -&#125; - makes the current line into a section heading,  the  heading</LI>
level is one lower than the previous heading.

<LI>&#123;Esc s p&#125; - checks the current paragraph for spelling errors (using  the</LI>
aspell spelling checker). Any errors appear in the console area -  note,
&#123;Esc s p&#125; does not overwrite the @ buffer.

<LI>&#123;Esc s d&#125; - checks the entire document for spelling errors, if the there</LI>
is a spell.lis file in the same directory as the document, then this  is
passed to the spelling checker (aspell command). The list of  misspelled
words is read into the @ buffer - see the &#123;Esc s w&#125; and &#123;Esc s i&#125;  keys,
below.

<LI>&#123;Esc s i&#125; - moves to the next Instance of the  current  misspelled  word</LI>
found by &#123;Esc s p&#125;, above. If there are no more instances, then moves to
the next word in the @ (misspelled words) buffer  and  finds  the  first
instance of that.

<LI>&#123;Esc s n&#125; - moves to the Next word in the @ (misspelled  words)  buffer,</LI>
this ignores any further instances of the current misspelled word.

<LI>&#123;Esc s f&#125; - Fix current instance of a misspelled word. Aspell  offers  a</LI>
list of correct spellings - select one then &#123;Esc s f&#125;

</UL></UL>Nb: To remove the spelling-suggestions popup re-draw the  windows  with  the
`WindowOne` function &#123;Esc w 1&#125;.
<UL>
<LI>&#060;re&#062;&#123;Esc l x&#125; - this greps for the regular expression  in  the  spelling</LI>
lexicon. The lexicon is quite small so there are plenty of  valid  words
that don't match but, on the  plus  side,  it  hardly  ever  matches  to
archaic or obscure words that hardly anyone knows.

</UL>The doc script takes a paragraph as any number of nonblank lines of text  at
the same indentation level.

A line of text can be protected from the paragraph processor (&#123;Esc p a&#125;  and
&#123;Esc P a&#125;) by placing a non-blank character in column 1 - in this context  a
tab is taken as a non-blank character.

Linux users may find an aspell with their distribution.  There  are  several
similar spelling checkers but aspell can be used in  command  mode  with  an
error report sent to stdout. Most others insist on you using their  gui.  If
your  distro  does  not  have  it  or  you  are  a  windows  user  then  try
http://aspell.net

</UL><H4><A NAME="DOC SECTION AND PARAGRAPH FORMAT">Doc section and paragraph format</H4>
Typically, most lines of of text in documents are in  paragraphs.  Paragraph
lines are always indented by at least one blank.  In  order  to  distinguish
paragraph lines from special text such as headings, tables and literal  text
such as code examples these must have a  non-blank  character  in  column  1
(tabs count as non-blanks for this purpose).

Text documents are deemed to consist of sections, introduced  by  a  section
heading and containing any number of paragraphs.
<UL>
</UL>Several scripts are designed to text documents in doc.jot format, these make
the following assumptions about the structuring of the text.
<UL>
<UL><LI>Numbered sections always start in column 0, may contain  any  number  of</LI>
subsection numbers, each delimited by a decimal point the section number
is terminated by whitespace, followed by the section name e.g:
<PRE>
&#062; 12.4.9 This section is a child of section 12.4 and grandchild of section 12
</PRE>
<UL>
</UL><LI>In addition to numbered sections, a section name may start at  column  0</LI>
and be terminated by a colon,  which  me,  optionally,  be  followed  by
section text e.g:
</UL></UL><H5><A NAME="FRED">Fred</H5>
This is name frequently used by unimaginative technical authors.

<UL><LI>Bullet points are  paragraphs  introduced  by  a  bullet  character,  by</LI>
default these are hyphens ( - ) the actual bullet string is  defined  in
line 4 of the ( & ) buffer.

<LI>A paragraph is a series of  lines,  all  indented  to  the  same  level,</LI>
delimited by either blank lines, special lines or  by  paragraphs  at  a
different level of indentation.

The rightmost extent of a paragraph  defaults  to  78  characters,  this
width is defined in line 3 of the ( & ) buffer.

</UL><H3><A NAME="DOC2FOLD.JOT">doc2fold.jot</H3>
&#062; doc2fold&#123;F2&#125;
<UL>
</UL>This translates a document to a folded help document suitable for use in the
jot help system. The document sections and  paragraphs  must  be  structured
according to the `doc.jot` script conventions. See also `about help files`.

</UL><H3><A NAME="FOLD2DOC.JOT">fold2doc.jot</H3>
&#062; fold2doc&#123;F2&#125;
<UL>
</UL>This performs the reverse of the `doc2fold.jot` process, it is only useful  when
a help file requires major changes and the original source document  is  not
available - see also `about help files`.

</UL><H3><A NAME="DOC2MIF.JOT">doc2mif.jot</H3>
&#062; doc2mif&#123;F2&#125;
<UL>
</UL>Translates the text in the current buffer  into  a  framemaker  mif  file  -
sections and paragraph format defined by `doc.jot`.

</UL><H3><A NAME="DOC2HTML.JOT">doc2html.jot</H3>
&#062; doc2html&#091; -split &#091; -head &#060;fooheadterImagePath&#062;&#093;&#091; -foot &#060;footerImagePath&#062;&#093;&#093;
<PRE>
    &#091; -index&#093;&#091; -noLinks&#093;&#091; -style &#060;styleSheetPath&#062;&#093;&#123;F2&#125;
</PRE>
<UL>
</UL>Translates the text in the current buffer into html.
<UL><LI>-split - splits up sections and moves contents into parent sections.</LI>
<LI>-index - Adds index at start of html (or each page  if  -split  is  also</LI>
set).
<LI>-noLinks - skips link-resolution stage, this saves time  for  debugging,</LI>
but the html is of little use.
<LI>-head &#060;headerImagePath&#062; - Image to be inserted between section  headings</LI>
and section text.
<LI>-foot &#060;footerImagePath&#062; - Image to be inserted below each section.</LI>
<LI>-style &#060;styleSheetPath&#062; - includes the nominated stylesheet</LI>
</UL>
Any text in backticks is assumed to be  a  hyperlink  -  several  forms  are
supported:
<UL><LI>A link to a heading either in the same file</LI>
<LI>A link to a heading in some other file in the same directory.</LI>
<LI>A file://&#060;path&#062;#&#060;tag&#062;</LI>
<LI>&#060;file&#062;.gif</LI>
</UL>For example, the following line (from the  walkthrough  course),  refers  to
`Keyboard functions defined at startup`.
<UL>
</UL>HREF references are checked - these must match a section heading  either  in
the current document or in some other html in the same directory. If,  after
searching these, it still cannot resolve the HREF then the  HREF  target  is
added to a list of  unresolved  HREFs  and  the  script  terminates  without
writing any html.

If the document contains more than one section with  the  same  section-name
string, then this is listed and the script terminates  without  writing  any
html.

</UL><H3><A NAME="DOC2HELP.JOT">doc2help.jot</H3>
&#062; doc2help&#123;F2&#125;
<UL>
</UL>Transforms an jot doc-format document into a folded-help file  suitable  for
including in the jot help system.

</UL><H3><A NAME="HTML2DOC.JOT">html2doc.jot</H3>
&#062; html2doc&#123;F2&#125;
<UL>
</UL>Transforms an html document in  the  current  buffer  to  the  jot  document
format.

</UL><H3><A NAME="DIC.JOT">dic.jot</H3>
&#062; dic&#123;F2&#125;

This looks up definitions of words using the gutenberg.org  version  of  the
websters dictionary. You must first download a copy of the  dictionary  from
the Gutenberg project www.gutenberg.org and save it  in  your  JOT_RESOURCES
area naming it websters.txt

When you run dic.jot for the first time an index file  is  written  to  your
JOT_RESOURCES area - you must have write access to this area. The index file
is named $&#123;JOT_RESOURCES&#125;/websters_index.txt it is plain  text  file,  about
one tenth the size of the actual dictionary (about 2.2Mb compared  to  about
28Mb for the complete dictionary). The index file structure is  a  bit  more
complicated than the index files used by `big_file.jot` - it has an explicit
entry for the length of each section.

<UL><LI>First download the dictionary,</LI>
<LI>now create the index:</LI>
<PRE>
$ jot /dev/null -in="%r=dic"
</PRE>
</UL><LI>It takes a few moments to digest the  dictionary,  once  that's  done  you</LI>
<UL>should never need to do it again. In any jot session you can now launch  a
query as follows:
&#062; dic&#123;F2&#125;
&#062; &#060;word&#062;&#123;&#123;Esc 7&#125;

</UL><H3><A NAME="BIG_FILE.JOT">big_file.jot</H3>
&#062; big_file -file=&#060;pathName&#062;&#091; -size=&#060;n&#062;&#093;&#091; -index=&#060;indexPathName&#062;&#093;
&#091; -grep=&#060;grepCommands&#062;&#091; -trim=&#060;jotCommands&#062;&#093;&#093;&#123;F2&#125;

or, a more typical usage, from the shell command line:
<PRE>
$ jot /dev/null -in="%r=big_file&#091;&#060;options as above&#062;&#093;;"
</PRE>

<UL>This script is designed to facilitate browsing and limited editing of  very
large files (see `about large files`). It reads an index file which must be
previously prepared, the index file identifies sections of interest  within
the file. The structure of the index file is quite simple  and  a  suitable
index can be prepared in no time with suitable text-scanning tool (grep and
it's various namesakes, even jot but jot will be much slower).

The -pathName qualifier is mandatory - it's  the  pathname  of  your  large
file.

The index file can be prepared earlier and read from  disc  or  it  can  be
generated by big file.jot - the latter has the advantage that it marks  the
index file with the original datestamp of the big file. When the index file
is contains this datestamp the big_file.jot script  can  detect  situations
when the index is out of date.

If the optional -index qualifier is given the big_file.jot script uses that
file to reference your big file - see below. If no -index is given then the
index pathname defaults to &#060;pathName&#062;_index - where pathName is that  given
in the -path qualifier.

The -grep qualifier is grep command string that can be used to create a new
index file  with  the  appropriate  datestamp  mark.  The  -trim  qualifier
specifies some jot commands that transform the raw grep output to a  usable
index file.

The script defines these functions:
<UL><LI>big_file_init - the initialization routine.</LI>

<LI>big_file_verifyMainFile - checks that the main-file  datestamp  matches</LI>
the index-file check data.

<LI>big_file_simpleQuery - reads the section specified in the &#123; $ &#125; buffer.</LI>

<LI>big_file_grepQuery - searches the main file for the string specified in</LI>
the ( $ ) buffer and calls big_file_simpleQuery to  read  each  one  of
them.

<LI>big_file_writeModifiedFile - writes any changes you have  made  to  the</LI>
sections loaded by big_file_simpleQuery.

<LI>Macro 7 calls big_file_simpleQuery to load  a  specified  section.  </LI>
&#062; fred&#123;KP_7&#125;
or, if there is no numeric keypad or it's not been set up:
&#062; fred&#123;Esc 7&#125;
</UL></UL>
<UL><LI>macro 8 reads  all  sections  containing  substrings  matching  a  grep</LI>
regular expression for example if we're interested in  all  subcircuits
connecting to a net named "master_clock":
&#062; master_clock&#123;KP_8&#125;
or
&#062; master_clock&#123;Esc 8&#125;
</UL>
<UL><LI>macro 9 writes a new version of the file. In the new  version  all  the</LI>
sections read into the editor replace those in the original file.
&#062; &#123;KP_9&#125;
or
&#062; &#123;Esc 9&#125;
</UL>
<UL>The index is used to create hashtable entries for the named sections  which
can then be accessed reasonably quickly using the -section=&#060;key&#062;  qualifier
of the `%I` command.

The index file contains one-line entries for each section in the file, each
entry consists of a byte-offset to the start of the section and  a  section
key, separated by a colon ':'. Sections are assumed  to  start  immediately
before the next one starts and entries must be  in  ascending  byte  order.
Section-keys  must,  of  course,  be  unique.  This  structure  is  exactly
compatible with the output of the  grep  command  when  used  with  the  -b
option.

For example to index a CDL file by subcircuit name:
<PRE>
$ grep -b "\.SUBCKT " example.cdl &#062; example.cdl_index
</PRE>
</UL>At this point the index still contain the  .SUBCKT  keyword  and  subcircuit
nets - these might be stripped out by a little awking - or, maybe, jot:
<PRE>
$ jot example.cdl_index -in="(f/:/-n.f1/.SUBCKT /-(v/ /r)0a%(f1/ /e0,)m)0 %c"
</PRE>

Now start the edit session - initially the editor starts with a blank screen
( /dev/null )
<PRE>
$ jot /dev/null -in="%r=big_file -file=example.cdl;"
</PRE>
Alternatively, to see a list of keys (subcircuit names) in buffer ( z ):
<PRE>
$ jot /dev/null -in="%r=big_file -file=example.cdl; %qz=keys;"
</PRE>
you may then add sections interactively:
&#062; SectionKey&#123;KP_7&#125;

To generate the index at the start of the session -  specify  the  grep  and
trim commands on the command line - these is an example of this in  `working
with large files`. For CDL  files  there  is  a  predefined  grep  and  trim
activated with the -cdlindex modifier:
<PRE>
$ jot /dev/null -in="%r=big_file -file=example.cdl -cdlindex;"
</PRE>

It is possible to write a complete, modified, version of the file  but  some
care is required. the  big_files.jot  script  defines  macro  (  9  )as  the
write-out macro. It writes all sections in  their  original  order  but  any
section you've loaded using macro ( 7 ) will be  written  from  the  editors
memory, replacing the original. This is  one  very  good  reason  for  using
internally-generated index files which allow date-stamp checks.

There's an example for you to try in the walkthrough course - `Working  with
large files`

</UL><H3><A NAME="TAGS_INDEX.JOT">tags_index.jot</H3>
<PRE>
$ jot &#060;tagsFile&#062; -in=%r=tags_index
</PRE>

This reads the ctags-generated index file and defines a macro which takes an
index-key and checks to see if it has already read it's source file. If not,
the source file is read and the editor focuses to the start of the  relevant
section.

</UL><H3><A NAME="MULTI_FILE.JOT">multi_file.jot</H3>
&#062; multi_file&#091; -index=&#060;pathName&#062;&#093;&#091; -indextype=&#060;type&#062;&#093;&#091; -htabsize=&#060;n&#062;&#093;&#123;F2&#125;
or, a more typical usage, from the shell  command  line,  to  create  a  new
index:
<PRE>
$ ls -aRF &#060;rootDir&#062; | jot -in="%r=multi_file -indextype=&#060;type&#062; &#091; ... &#093;"
</PRE>

or, to use an existing index:
<PRE>
$ jot /dev/null -in="%r=multi_file&#091; &#060;options as above&#062;"
</PRE>

The multi_file script is intended for browsing large collections  of  source
files belonging to some system  see  `about  large  collections  of  files`.
Selected sections are read  into  a  buffer  for  viewing  -  typically  the
sections  will  correspond  to  programming-language  modules.   These   are
typically referenced by module name.

The optional arguments are:
<UL><LI>-indextype=&#060;type&#062; - specifies that a new index file is to be built.  The</LI>
type argument specifies the indexing method to be used -  currently  the
valid index method are:

<UL><LI>c - for C-language files. The detection of c-function definitions is a</LI>
compromise between run time and accuracy. It checks each line  of  the
file and selects lines  which  match  the  following  criteria,  after
removing any potentially-confusing comments and strings:
<UL><LI>The first character  on  the  line  must  be  a  lower-case  alpha</LI>
character,
<LI>the line must contain an open bracket ' ( ' character and</LI>
<LI>the line must not end with a semicolon.</LI>
</UL>This catches almost all valid function definitions and rejects  almost
all non-function-definition lines.

<LI>perl - for perl scripts. It identifies lines  begining  withe  "sub  "</LI>
followed by the subroutine name and an opn-brace character ' &#123; '

</UL><LI>-index=&#060;pathName&#062;&#091;,&#060;pathname2&#062;&#091;,...&#093;&#093; - specifies the  pathnames  to  be</LI>
used for the index file, this defaults to multi_file_index in your  PWD.
You can use as many index files as necessary and they need not all refer
to the same file types - indexes referring to both C and perl files  can
be used together as appropriate.

<LI>-htabsize=&#060;n&#062; - specifies the hashtable size, this  corresponds  to  the</LI>
number of modules in the index file. It defaults to 100,000.

</UL>The script define these functions:
<UL><LI>multi_file_init - As it's name suggests  it's  the  main  initialization</LI>
routine, it checks and parses parameters,  creates  the  hashtable  and,
when requested by the -indextype  arg,  it  launches  an  index  rebuild
operation.

<LI>multi_file_create_index - This reads the ls report and creates the index</LI>
file.

<LI>multi_file_simpleQuery - This expects to find a  valid  section-name  in</LI>
buffer ( $ ). This function is attached to macro_7 - ( &#123;KP_7&#125; or &#123;Esc 7&#125;

<LI>multi_search_section_names -  This  searches  the  valid  keys  for  any</LI>
matching a string in the ( $ ) buffer.

</UL>Usage:
&#062; &#060;sectionName&#062;&#123;KP_7&#125;
or, if you're lacking a numeric keypad:
&#062; &#060;sectionName&#062;&#123;Esc 7&#125;
Passes the section name to multi_file_simpleQuery. If successful, the module
text is appended to the primary buffer.

&#062; &#060;string&#062;&#123;KP_8&#125;
or, if you're lacking a numeric keypad:
&#062; &#060;string&#062;&#123;Esc 8&#125;
Passes the string to multi_search_section_names, this searches all the valid
keys for any matching the string. The matching process is pretty crude -  it
obtains a list of keys and then filters  out  lines  that  don't  match  the
string. Note that queries using the strings Byte, Section, Seek or any other
strings that appear a lot in `query keys` reports are going to  return  lots
of results.

Note that there is no facility for writing back modified versions  of  these
files from a multi_file session - you must load the relevant files normally,
in a separate buffer, then make your changes and write the complete file.

As with `big_file.jot`, multi_file.jot is driven  by  user  queries  and  an
index file. In this case, however, the files will normally  be  of  moderate
size but there may be hundreds of them with  each  one  defining  dozens  of
sections.

In the event of a name collision, the  first  instance  of  a  name,  as  it
appears in  the  index  file,  is  taken  as-is.  Subsequent  instances  are
uniquified by suffixing the name with __nnn, where  nnn  is  the  index-file
line number for the duplicated name.

</UL><H3><A NAME="THES.JOT">thes.jot</H3>
&#062; thes&#123;F2&#125;
<UL>
</UL>This reads the Gutenberg Ebook version of Roget's thesaurus and  sets  up  a
simple   macro   to   process   queries.   It   reads   the    Ebook    from
$&#123;JOT_RESOURCES&#125;/thesaurus.txt, this can be downloaded  from  the  gutenberg
project - www.gutenberg.org.
<UL><LI>&#060;word1&#062;&#091; &#060;word2&#062;&#091; ...&#093;&#093;&#123;KP_8&#125;</LI>
</UL>
The query macro expects a  list  of  words,  it  then  returns  all  Roget's
sections which contain all of the given words, the  results  are  in  the  @
buffer.

</UL><H3><A NAME="DUPLICATES.JOT">duplicates.jot</H3>
&#062; duplicates&#123;F2&#125;
<UL>
</UL>The current buffer is searched  for  duplicated  lines,  starting  from  the
current line. The script halts at a  duplicated  line  or  the  end  of  the
buffer.

</UL><H3><A NAME="PURGE.JOT">purge.jot</H3>
&#062; purge&#091; -rev | -count&#093;&#123;F2&#125;
<UL>
</UL>The current buffer is searched  for  duplicated  lines,  starting  from  the
current line. Duplicated lines are removed leaving just the  first  instance
of each unique line of text.

If the optional qualifier -rev is given, then it is the  unduplicated  lines
that are removed.

If the optional  qualifier  -count  is  given  then  the  number  of  purged
duplicate lines is appended to  the  undeleted  lines  separated  by  a  tab
character.

</UL><H3><A NAME="MC.JOT">mc.jot</H3>
&#062; mc&#091; -size=&#060;width&#062;x&#060;height&#062;&#123;F2&#125;

mc is useful for scanning through long files with  very  short  lines.  Such
files are reasonably common when maintaining IT system files and  CAD  files
etc - but it's not usually much use for viewing natural language documents.

The mc script calculates your window size and then chops up a copy  of  your
buffer into columns to fill the display.  You  may  be  more  interested  in
printing the multicolumned text in which case the  size  of  the  window  is
irrelevant - you  can  specify  the  size  of  your  paper  with  the  -size
qualifier.

The script also defines macro  1  and  macro  2  as  page-up  and  page-down
functions, respectively. The standard page-up and  page-down  functions  are
not suitable for viewing the mc result buffer.

e.g:
<PRE>
$ jot $&#123;JOT_HOME&#125;/docs/spell.dic -ini="%r=mc"
$ ls /usr/lib64 | jot -ini=%r=mc
$ ls /usr/lib64 | jot_dev -ini="%r=mc -size=80x90"
</PRE>

</UL><H3><A NAME="EXPAND_VERILOG_BUSSES.JOT">expand_verilog_busses.jot</H3>
&#062; expand_verilog_busses&#123;F2&#125;
<UL>
</UL>Locates verilog busses of the form name&#091;start:end&#093; (where end &#060; start),  and
replaces them with fully-expanded form

</UL><H3><A NAME="FINDCOL.JOT">findcol.jot</H3>
&#062; findcol&#060;delim&#062;&#060;string&#062;&#060;delim&#062;&#123;F2&#125;
<UL>
</UL>The current  buffer  is  assumed  to  be  text  written  written  vertically
top-to-bottom. The current column is searched for the string.

</UL><H3><A NAME="FINDHELP.JOT">findhelp.jot</H3>
&#062; findhelp &#060;string&#062;&#123;F2&#125;
<UL>
</UL>The $&#123;JOT_RESOURCES&#125;/help tree is searched for the string, results appear in
the help menu buffer.

This uses the unix find and egrep  commands,  this  search  is  always  case
insensitive.

</UL><H3><A NAME="HEX2ASCII.JOT">hex2ascii.jot</H3>
&#062; %i ... -binary;
&#062; %r=hex2ascii

This simple script appends a text annotation to each line in  the  hex  dump
generated by the -binary option of `%I`.

Example output  -  this  is  a  fragment  of  hex  dump  of  the  test  file
$&#123;JOT_RESOURCES&#125;/l99.t, the text "80: abc ..." was  added  by  hex2ascii.jot
notice that any nonprinting characters are represented by carats ( ^ ).
</UL><H2><A NAME="1 1 A 20 61 62 63 20 64 65 66 20 67 68 69 20 80: ABC DEF GHI ">1 1 A 20 61 62 63 20 64 65 66 20 67 68 69 20 80: abc def ghi </H2>
</UL><H2><A NAME="A 6B 6C 20 6D 6E 6F 20 70 71 72 20 73 74 75 20 JKL MNO PQR STU ">A 6B 6C 20 6D 6E 6F 20 70 71 72 20 73 74 75 20 jkl mno pqr stu </H2>
</UL><H2><A NAME="1 1 1 1 A 3A 30 31 32 33 34 35 36 37 38 39 VWXYZ:0123456789 ">1 1 1 1 A 3A 30 31 32 33 34 35 36 37 38 39 vwxyz:0123456789 </H2>
</UL><H2><A NAME="1 F 5F 37 39 3A 20 61 62 63 20 64 65 66 20 67 ^__79: ABC DEF G ">1 F 5F 37 39 3A 20 61 62 63 20 64 65 66 20 67 ^__79: abc def g </H2>

</UL><H3><A NAME="UPDATEHELP.JOT">updatehelp.jot</H3>
&#062; updatehelp&#091; -NODATEstamp&#093;&#123;F2&#125;
<UL>
</UL>This command file is used after you've updated an entry in the  help  buffer
(;). The current buffer must be the help buffer and the fold marks  must  be
unchanged (these are used to locate the fold in the file).  It  locates  the
current file fold by searching for the previous file fold in the help buffer
(:) then reads the file into a temporary buffer and  updates  it  with  your
revised fold.

The changes must not affect the fold structure in any  way,  or  the  script
will fail.

The updatehelp script will insert a datestamp mark near  the  start  of  the
fold indicating when the change was made. The  -nodatestamp  qualifier  will
prevent it doing this

</UL><H3><A NAME="MANHELP.JOT">manhelp.jot</H3>
&#062; manhelp &#060;manArgs&#062;&#091; -fold&#093;

Generates requested man page and adds it to sessions help repository.

The manargs are passed directly to the man utility and the reply  becomes  a
new page in the jot-sessions help repository.

The -fold option folds sections inside the new help page.

</UL><H3><A NAME="NEAR.JOT">near.jot</H3>
&#062; near &#060;string1&#062; &#060;string2&#062;&#091; &#060;n&#062;&#093;&#123;F2&#125;

If n is specified, this sets the search-window size - defaults to 5.
<UL>
</UL>Searches the current buffer, starting at the current line,  for  occurrences
of the two strings in nearby  lines  -  the  definition  of  nearby  is  the
optional window-size parameter.

</UL><H3><A NAME="NONPRINTING.JOT">nonprinting.jot</H3>
&#062; nonprinting&#123;F2&#125;
<UL>
</UL>Detects any nonprinting characters in the current buffer.

</UL><H3><A NAME="CLI.JOT">cli.jot</H3>
&#062; cli &#060;cliCommand&#062;&#123;F2&#125;

The cli script assumes that the current buffer is a file image,  the  file's
pathName is picked up and the specified CLI (Command-Line Interpreter  -  or
shell, in unix parlance) command is applied to it.

</UL><H3><A NAME="PATH.JOT">path.jot</H3>
&#062; path &#060;cliCommand&#062;&#123;F2&#125;
<UL>
</UL>The path script assumes that the current buffer is a file image, the  file's
path is picked up and the specified command is applied to it.

</UL><H3><A NAME="SCCS.JOT">sccs.jot</H3>
&#062; sccs &#060;sccsCommand&#062;&#123;F2&#125;
<UL>
</UL>This assumes that the current buffer is a file image, it  applies  the  sccs
command to the current file.

</UL><H3><A NAME="PASCAL.JOT">pascal.jot</H3>
This replaces the contents of the current buffer with the first  n  rows  of
pascals triangle.

The number of rows defaults to 30 but can be  set  as  an  argument  to  the
script. Note that the size of the numerical values in the triangle increases
very rapidly, 30 rows is about as many as can be  accommodated  with  64-bit
integer arithmetic.
&#062; pascal&#123;F2&#125;
<UL><LI>displays the first 30 rows.</LI>
&#062; pascal 10&#123;F2&#125;
<LI>displays the first 10 rows.</LI>

</UL><H3><A NAME="PRINT.JOT">print.jot</H3>
&#062; print&#091; -break&#093;&#123;F2&#125;
<UL>
</UL>The current buffer is checked and,  if  there  are  no  unresolved  tabs  or
overlong lines, it is written out to a temporary file, this  temporary  file
is printed using a2ps.

The optional -break qualifier causes overlong lines ( &#062;80 characters) to  be
broken at a suitable point.

</UL><H3><A NAME="WIDEPRINT.JOT">wideprint.jot</H3>
&#062; wideprint&#091; -break&#093;&#091; -preview&#093;&#091; -l &#060;n&#062;&#093;&#091; -1, 2, 3, ... 9&#093;&#123;F2&#125;
<UL>
</UL>The current buffer is checked and,  if  there  are  no  unresolved  tabs  or
overlong lines, it is written out to a temporary file, this  temporary  file
is printed using a2ps.

<UL><LI>The -break qualifier allows overlong lines to be broken.</LI>
<LI>the preview qualifier displays the buffer with broken lines,</LI>
<LI>the -l &#060;n&#062; sets the maximum line width, this is used to set the font size.</LI>
<LI>the -1, -2, -3 ... -9 qualifiers set multicolumn mode.</LI>

</UL><H3><A NAME="RENUMBER.JOT">renumber.jot</H3>
&#062; renumber&#123;F2&#125;
<UL>
</UL>The line numbers in the current buffer are reset  so  that  the  first  line
becomes line no. 1 again.

</UL><H3><A NAME="TIMEX.JOT">timex.jot</H3>
&#062; timex&#123;F2&#125;
<UL>
</UL>Sets  up  macro  1  to  generate  an  activity  summary  report  from   your
timex/titracks files.

</UL><H3><A NAME="TRACE.JOT">trace.jot</H3>
&#062; trace&#091; &#060;args&#062;&#093;&#123;F2&#125;

This sets the trace-vector bits (see `%s=trace`) symbolically.  If  no  args
are given, it displays the options (shown below) and prompts.

Trace bits 0x0001 to 0x0040 define the trigger points  -  i.e.  they  select
which class of event will trigger a  trace  or  other  diagnostic  response.
Trace bits 0x1000 to 0x8000 define the desired action.

These can be set directly - e.g. to set a breakpoint on the  start  of  each
new command line we would say %s=trace 8002 to dump the stack  we  would  OR
with 0x1000 giving %s=trace 9002 - trace.jot sets these symbolically.
<UL>
</UL>Trace arguments - trigger points:
<UL><LI>a  - trace all commands</LI>
<LI>l  - trace at start of each new command line.</LI>
<LI>f  - trace only failed commands.</LI>
<LI>bl - trace at start of each new block.</LI>
<LI>m  - trace at start of each new macro.</LI>
<LI>f  - trace on entry to command files.</LI>
<LI>i  - trace Ctrl+C interrupts.</LI>

</UL>Trace arguments - trace actions:
<UL><LI>s  - dump stack at each trace point.</LI>
<LI>p  - print current line of current buffer at each trace point.</LI>
<LI>c  - show command line at each trace point.</LI>
<LI>b  - breakpoint - stop on trigger points.</LI>

</UL>So to dump the stack and breakpoint at each new line of a script or macro:
&#062; trace lsb&#123;F2&#125;

</UL><H3><A NAME="CAL.JOT">cal.jot</H3>
&#062; cal&#091; &#060;year&#062;&#093;&#091; -split&#093;&#123;F2&#125;
<UL>
</UL>This runs the unix cal command, by default, it takes the current year.

The result is similar to that of the  unix  cal  command  except  that  week
numbers are prefixed before each week.

The -split qualifier splits the output listing each day on a separate line.

</UL><H3><A NAME="MATCH_WORDS.JOT">match_words.jot</H3>
&#062; match_words &#060;bufferKey&#062;&#091;&#060;anotherBufferKey&#062;&#093;&#091;&#060;...&#062;&#093;&#093;&#091; -split&#093;&#091; -nosort&#093;&#091; -notab&#093;&#091; -map&#093;&#123;F2&#125;

This The object of this script  is  to  match  lists  of  words  in  various
buffers. Typically, the words will  be  the  names  of  objects  defined  in
different places (e.g. file names in various directories or backup discs  or
module names from a linker map).

<UL><LI>-split - splits text at whitespace.</LI>

<LI>-nosort - by default match_words begins by sorting the  lists  to  improve</LI>
the speed of the re-synchronization process.  For  unsorted  lists  it  is
necessary to search the entire buffer for a match - this becomes  an  n**2
process and can get tedious for long lists. The -nosort qualifier is  used
to leave the list ordering unchanged. N.B. match_words only sorts  a  copy
of the buffer - the original list is always left unchanged.

<LI>-notab - while processing match_words  inserts  tabs  to  indicate  column</LI>
boundaries. Normally these are resolved to create  a  nice  neat  table  -
-notab suppresses this last step.

<LI>-map - the map qualifier simplifies the final table to put  all  words  in</LI>
the left column and subsequent columns  contain  either  whitespace  or  a
buffer-key character  to  indicate  that  the  word  was  matched  in  the
specified buffer.

</UL><H3><A NAME="LINKDOCS.JOT">linkdocs.jot</H3>
&#062; linkdocs&#091; -allxrefs&#093;&#091; -bufs &#060;BufferKey1&#062;&#091;&#060;BufferKey2&#062;&#091; ...&#093;&#093;&#093;&#123;F2&#125;

This script identifies links in `doc.jot`-style  documents  and  add  colour
tags, hashtables and sets up a mouse-event handler to allow clicking through
the links.

The -bufs qualifier introduces a whitespace-separated list of  buffer  keys,
these are the buffers to be analysed. If -bufs list is not  given,  then  it
analyses the primary buffer ( . ) and all buffer with an alphabetical buffer
key (a, b, c ...). 

The -allxrefs matches references to headings in all text  -  by  default  it
only matches to cross-references enclosed in backticks.

Macro_1 is defined for users without mice - first navigate the cursor  to  a
link (or a non-link if returning) then &#123;Esc 0&#125;

The list of buffer keys specifies the buffers containing suitable documents,
if this list is not given then linkdocs inspects each buffer  in  the  range
A-Z and processes those which appear to have doc.jot-style section headings.

A good example to try would be the jot user documents:
<PRE>
$ jot $&#123;JOT_HOME&#125;/docs/jot_qr.txt -in="%it=jot_tech; %ic=jot_coms; \
</PRE>
<UL>%iu=jot_ug; %iw=jot_walkthrough; %r=linkdocs -bufs=. c t u w;"
</UL>
The file images are displayed normally except that links are highlighted  in
green (unresolved links are highlighted in red). Clicking  the  left  button
with the mouse over over a green link will switch context to that section.

See also `qr.jot`

</UL><H3><A NAME="BOOKINGS.JOT">bookings.jot</H3>
<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/resources.txt -in="%r=bookings -mail=$&#123;JOT_RESOURCES&#125;/mail -resource=The House"
</PRE>

This is an application designed to simplify the  process  of  maintaining  a
bookings register for a holiday let or some similar  resource  that's  hired
out on a weekly basis. One of the worst things that can happen,  apart  from
getting the place totally trashed, is a double booking. This app is designed
to provide strict control  of  the  bookings  calendar  and  the  associated
database to prevent double  bookings  keep  track  of  payments  and  client
details etc.

Although few jot users will actually require such an application,  it  is  a
useful example of how to  implement  similar  interactive  applications.  It
maintains various different views (e.g. the calendar,  the  accounts  table,
emails and various lists relating to each booking. These views are linked by
hash-tables and tags containing metadata (typically hashtable keys).

Looking at the calendar (in buffer C) we notice  that  it's  organized  from
Saturday to the following Saturday - this is because the letting week starts
Saturday afternoon and ends the following Saturday morning - that's  because
Saturday is the default changeover day.

The changeover day is an important day in the world of holiday letting. It's
intended to give the previous weeks guests time to pack up their things  and
get off home  while  also  allowing  the  incoming  guests  time  for  their
travelling  and  getting  themselves  organized  as  well  as   giving   the
housekeeper a chance to prepare the house for the incoming guests.

Many operators chose either Friday or Saturday for their  changeover  day  -
bookings.jot defaults to Saturday but can be set for changeover on any other
day of the week.

The most important document is the resources.txt file - this contains a list
of resources (e.g. properties to let) and, for each  resource,  an  accounts
table and bookings, each consisting of lists of emails and notes relating to
the booking.

The bookings system also has a simple Email reader. Although this lacks even
the ability to send emails, it can still be useful because incoming messages
are integrated into the bookings system. It is assumed that most users  will
be using a modern webmail mailer based on a remote imap server, bookings.jot
uses a local POP mail file. POP is a simple plain-text file containing  mail
messages. In most cases this will be copied  from  the  remote  imap  server
using a mail-retrieval agent (MRA) such  as  fetchmail.  Messages  are  then
assembled in a POP mail file using a  mail  delivery  agent  (MDA)  such  as
procmail.  See  `http://dev.mutt.org/trac/wiki/MailConcept`  for   a   basic
description of how this works and  `http://www.andrews-corner.org/mutt.html`
for a description of how to set up your MRA and MDA.

</UL><H4><A NAME="BUTTONS AND MENUS">Buttons and Menus</H4>
At the top of the screen are two lines with mauve-tagged text - clicking  on
these has the following effects:
<UL><LI>"Save and Exit" - saves the resources file and terminates the session.</LI>
<LI>"Abandon" - terminates the session without saving anything.</LI>
<LI>"Save resources" - saves resources without terminating the session.</LI>
<LI>"Calendar" - switches focus to the calendar for the current booking.</LI>
<LI>"Account" - switches to the accounts line for the current booking.</LI>
<LI>"Booking" - switches to the booking entries for the current booking.</LI>
<LI>"Errors" - switches view to the list of error messages.</LI>
<LI>"Previous" opens the previous mail message.</LI>
<LI>"Current" re-opens the current mail message.</LI>
<LI>"Next" - opens the next mail message.</LI>
<LI>"List" - returns to the main mail index.</LI>
<LI>"Search" - prompts for a search  string  then  returns  a  list  of  all</LI>
messages containing the string.
<LI>"Results" - returns to the list of messages from last message search.</LI>

</UL>The "Options:" menu, below, changes according to view:
<UL><LI>In the Bookings view, it displays one option "Note", this prompts for  a</LI>
note-text message with the prompt "Note text&#062; " The note is added to the
list of notes in the booking, and the notes appear after the booking  on
the calendar.

<LI>In  the  Account  view,  it  displays  "Set  cell",  this  prompts   for</LI>
"Column-name Values&#062; " you should respond  with  an  exact  column  name
followed a blank and by any number of values, each separated by either a
semicolon or a tab. This causes the specified cell to be  set  i.e.  the
cell where the booking-ID line intersects the specified column. If  more
than one value is given, succeeding cells are set using these values.

<LI>In the mail view there are two options offered: - "Add to mail thread" -</LI>
this adds a pointer, to the currently-viewed
<UL>mail, to the mailthread for the current booking.
</UL><LI>"Find more from sender" - this  searches  the  mail  archive  for  all</LI>
<UL>messages from the sender of the current message -  the  list  includes
the current message.

</UL></UL><H4><A NAME="MOUSE AND KEYBOARD ACTIONS:">Mouse and keyboard actions:</H4>
In any view, position the  cursor  onto  some  colour-tagged  text  and  the
following actions are defined:

<UL><LI>Left-button click - refocus to indicated point, if it is tagged  with  a</LI>
booking then this booking becomes the current booking. If the  point  is
tagged as a mail message, this message is opened.

<LI>Most colour-tagged text can be clicked through. The top two lines of the</LI>
display are dedicated to two rows of mauve-tagged buttons. Their  effect
is as follows:
<UL><LI>"Save and Exit" - Saves the resources.txt file  and,  if  necessary,</LI>
the POP mail file, then terminates the session.
<LI>"Abandon" - terminates the session without saving anything.</LI>
<LI>"Save resources" - Saves the resources file without terminating.</LI>

</UL>The "Goto:" group of buttons:
<UL><LI>"Calendar" - switches view to the calendar for the current booking.</LI>
<LI>"Account" - switches view  to  the  accounts  table  entry  for  the</LI>
current booking.
<LI>"Booking" - switches view to the booking  entries  for  the  current</LI>
booking.
<LI>"Errors" - switches view to the error reports.</LI>

</UL>The "Emails:" group of buttons:
<UL><LI>"Previous" - opens the mail before the currently-selected message.</LI>
<LI>"Current" - (re)opens the currently-selected message.</LI>
<LI>"Next" - opens the mail after the currently-selected message.</LI>
<LI>"Paste" - Creates a new message from the  system  paste  buffer  and</LI>
inserts it in the POP file - use this to import messages  from  your
favourite mailer.
<LI>"List" - switches view to the mail index (list of messages).</LI>
<LI>"Search" - Prompts for a string and searches messages for the  given</LI>
string.
<LI>"Results" - Returns view to the search results.</LI>

</UL>When viewing a mail message it displays the mail "Options:" buttons:
<UL><LI>"Add to mail thread" - Adds current message to  messages  listed  in</LI>
the BOOKINGS: section of the resources file.
<LI>"Find more from sender" - Searches the POP file  for  more  messages</LI>
from the sender of the current message.
<LI>"Owners Direct Booking" - Extracts the booking information from  the</LI>
standard owners-direct enquiry message.

</UL>When viewing the calendar it displays the calendar "Options:" buttons:
<UL><LI>"New booking" - After defining a pending  booking  by  dragging  the</LI>
mouse across the calendar, this button changes it to a full booking.
<LI>"Delete booking" - Removes the booking from the resources-file image</LI>
and all views.
<LI>"Re-make calendar" - Rebuilds calendar - this is sometimes necessary</LI>
after deleting a booking, in order to  remove  redundant  changeover
days from the calendar.

</UL><LI>Left-button drag - only valid in calendar view. Sets a  pending  booking</LI>
in the calendar for the dragged-over days - this can later be changed to
a booking by &#123;Ctrl B&#125;.

Alternatively, if you prefer, you  can  drive  the  bookings  script  with
escape sequences:
<UL><LI>&#091;&#060;pathName&#062;&#093;&#123;Esc R&#125; - (re)Read mail - Either re-read the mail spool or</LI>
append specified mail archive then re-index the messages.
<LI>&#123;Esc A&#125; - Abandon - exits session without writing resources.txt</LI>
<LI>&#091;&#060;Booking ID&#062;&#093;&#123;Esc B&#125; - Booking - creates a new booking entry.</LI>
<LI>&#123;Esc D&#125; - Delete booking - removes currently-selected booking.</LI>
<LI>&#123;Esc S&#125; - Save - saves the revised resources.txt</LI>
<LI>&#060;column&#062; &#060;value&#062;&#123;Esc s&#125; - Set - sets specified cell in booking table.</LI>
<LI>&#123;Esc a&#125; - Accounts - refocus to relevant row of the accounts</LI>
<LI>&#123;Esc c&#125; - Calendar - refocus to relevant week in the calendar.</LI>
<LI>&#123;Esc b&#125; - Booking - refocus to current booking section in resources.</LI>
<LI>&#123;Esc n&#125; - Notes - Adds a text note to the booking - these  sow  up  at</LI>
the end of the booking line of the calendar.
<LI>&#060;name&#062;&#123;Esc r&#125; - Resource - selects a named resource in resources.txt</LI>
<LI>&#123;Esc t&#125; - add to mail Thread - add current mail message to mail thread</LI>
for the current booking.
<LI>&#123;Esc m&#125; - return to current &#091;or first&#093; mail message.</LI>
<LI>&#123;Esc u&#125; and &#123;Esc d&#125; - Up/Down - moves up, to previous mail or down, to</LI>
next mail message in the mail spool.
<LI>&#123;Esc o&#125; Owners-direct - read bookings directly from  an  Owners-direct</LI>
mail archive file.

</UL></UL><H3><A NAME="XWORD.JOT">xword.jot</H3>
<PRE>
&#062; xword&#123;F2&#125;
</PRE>
This is a little fun script primarily intended to  demonstrate  features  of
jot. It's a crossword puzzle assistant, it looks up words and phrases  of  a
predetermined length matching various criteria.

The words and phrases are read from the on-line  Roget's  (see  `thes.jot`),
these are munged into a database that's designed for  speedy  searching.  It
takes a few moments to do this, when complete it prompts you before  writing
out the file to your JOT_RESOURCES area, thereafter it only  needs  to  read
that file.

The query syntax is
<UL>&#060;n&#062; &#060;c1&#062;=&#060;l1&#062;&#091;&#060;l2&#062;&#091;&#060;l3&#062;...&#093;&#093;&#093; &#091;&#060;c2&#062;=&#060;l1&#062;&#091;&#060;l2&#062;&#091;&#060;l3&#062;...&#093;&#093;&#093;...
</UL>where
<UL><LI>n is the number of characters in the word or phrase you're looking for.</LI>
<LI>c1 denotes the character number of the  first  character  in  the  first</LI>
query element.
<LI>l1 is the first letter of a substring beginning at c1.</LI>
<LI>l2, l3 are the letters immediately after l1.</LI>
<LI>Any number of query elements are allowed in any order.</LI>
<LI>Any single character may be replaced by the wildcard character '?'.</LI>
</UL>
Queries are entered using macro 4, defined by xword and attached to  &#123;KP_4&#125;.
Suppose we're looking for a 6 letter word with the 3rd. letter t and the 5th
letter e - then any of these queries would identify the same set of matching
words:
<PRE>
&#062; 6 3=t 5=e&#123;KP_4&#125;
&#062; 6 5=e 3=t&#123;KP_4&#125;
&#062; 6 3=t?e&#123;KP_4&#125;
&#062; 6 1=??t?e&#123;KP_4&#125;
&#062; 6 1=??t?e 5=e&#123;KP_4&#125;
</PRE>

