<! Made with jot using doc2html -style main.css>
<link rel="stylesheet" href="main.css" type="text/css">


</UL><H2><A NAME="JOT TECHNICAL GUIDE">JOT Technical Guide</H2>
<P>This guide is rather more technical than the user guide and goes into some details of the design of the editor, it's command structure, it's primitive commands and installation.</P>


</UL><H3><A NAME="ABOUT JOT COMMANDS">About jot commands</H3>
<P>There are two clearly identifiable groups of jot commands - those text manipulation and those for interfacing with the operating system and for internal housekeeping.</P>

<P>The basic text manipulation commands are all single characters, e.g. <A HREF="#F">F</A>- find, <A HREF="#S">S</A> - substitute, <A HREF="#I">I</A> - insert, <A HREF="#M">M</A> - move (up/down), <A HREF="#R">R</A> - move right. There is also an important group of commands to do with creating programme structures e.g. <A HREF="#(">(</A> - block start, <A HREF="#)">)</A> - block end and <A HREF="#,">,</A> - introduces a logical else clause.</P>

<P>The housekeeping commands can be for probing and setting system state or calling system services. These are generally prefixed with a percent ( % ) character e.g:</P>

<UL><P><LI><A HREF="#%I">%I</A> - input - reads a file from the filing system,</P></LI>

<P><LI><A HREF="#%O">%O</A> - output - writes a file to the filing system,</P></LI>

<P><LI><A HREF="#%Q">%Q</A> - query - returns reports or values reflecting the internal state of the editor,</P></LI>

<P><LI><A HREF="#%S">%S</A> - System settings and services - these affect all buffers.</P></LI>

<P><LI><A HREF="#%B">%B</A> - Buffer settings and services - these affect only the current buffer.</P></LI>


</UL><H3><A NAME="ABOUT COMMAND PARAMETERS">About command parameters</H3>
<P>Numeric parameters are generally specified in decimal e.g:</P>

&#062; m123
<P>String parameters may use any non-alphanumeric ASCII character as a delimiter provided the delimiter does not occur in the string. Note that most (see <A HREF="#Q">Q</A>) of these commands will accept ISO-8859-x or UTF-8 characters in the parameter string but UTF-8 characters cannot be used as delimiters.</P>

<P>If there is no further text on the command line then the string may be left unterminated. These examples all find the next instance of the string £1234:</P>

&#062; f/£1234/
&#062; f/£1234
&#062; f@£1234@
&#062; f"£1234"
<P>Most commands that accept a string parameter will also accept a reference to a buffer by replacing the string and delimiters with '&#060;key&#062; in the command line (e.g. F'@ ) in this case the string used is the entire current line of the secondary buffer. The input parameters to many of the percent commands (mainly those which take pathNames) may also be defined indirectly in this way (e.g. %ia='$; %qb=file '$ ) but the destination buffer cannot be the same as the pathName buffer. Where this type of indirection is used, there is an upper limit of 1024 on the allowable length of parameter strings.</P>

<P>The indirect reference can be to a buffer on the operand stack (see <A HREF="#ABOUT THE OPERAND STACK">about the operand stack</A>). </P>

<P>In this example, the value of env FRED is used to define a search string:</P>

&#062; %q~=env FRED; mz. f'~
<P>All references to numerical items on the stack cause the to item to be removed, references to buffers on the stack do not delete the buffer. In this example, the top item on the stack contains a numerical value used to set the size of a hashtable:</P>

&#062; %h=create '~;
<P>In jot's direct insert mode (see <A HREF="#COMMAND-MODE VS. INSERT MODE">command-mode vs. insert mode</A>), you cannot enter commands. You can only type text straight onto the screen or fire off the editor functions attached to hot-keys and control keys. If an editor function requires an parameter it will prompt you for it. Type it into the console area and hit &#123;Return&#125;. See <A HREF="#%S=COMMANDMODE">%s=commandmode</A> for details about jot's type-into screen mode.</P>


</UL><H3><A NAME="ABOUT PARAMETERS TO MACROS AND JOT SCRIPTS">About parameters to macros and jot scripts</H3>
<P>The <A HREF="#%R">%R</A> command picks up any parameters from the command line and copies them to the $ buffer where they can be examined by the script.</P>

<P>The <A HREF="#CLI.JOT">cli.jot</A> script, for example, take an ordinary CLI command executes it and returns the result in the @ buffer. For example:</P>

&#062; %r=cli ls -l;
<P>On completion the @ buffer contains a directory listing of your PWD. The &#060;&#060;<A HREF="#DO">Do</A>&#062;&#062; function is just a wrapper for the %R command.</P>

<P>The native jot language does not define how parameters find their way from the keyboard via the console area to macros or functions (see <A HREF="#HASHTABLE CALL">hashtable call</A>). For the most important of these Macro1 to Macro9 the startup script (See <A HREF="#ABOUT STARTUP SCRIPTS">about startup scripts</A>) arranges for parameters to be copied into the ( $ ) buffer.</P>

<P>It's a similar story for the more complex functions held in the code repository (see <A HREF="#CALLING SUBROUTINES BY NAME">calling subroutines by name</A>) The <A HREF="#FINDSEQUENCE">FindSequence</A> function, for example, takes a list of words from the command line - these are picked up from console area and copied to the $ buffer and the FindSequence function picks them up from there.</P>

<P>When in insert mode (see <A HREF="#COMMAND-MODE VS. INSERT MODE">Command-mode vs. insert mode</A>) the startup script arranges for the correct prompt to appear - see <A HREF="#TRANSLATION OF KEYBOARD EVENTS TO ACTIONS">translation of keyboard events to actions</A></P>


</UL><H3><A NAME="ABOUT TEXT BUFFERS">About text buffers</H3>
<P>In jot, a text buffer is an internal data structure containing an image of some text. Each buffer is identified by a single-character buffer key. The following buffers are accessible but some are used by command file scripts. Buffers may contain a file image, fragments of text or jot command strings - otherwise known as macro commands.</P>

<UL><P><LI>( . ) is the primary buffer, this contains an image of the file you gave on the shell command line.</P></LI>

<P><LI>( A ) to ( Z ) available without restriction, note that these are case insensitive i.e. a and A are the same buffer.</P></LI>

<P><LI>( 0 ) to ( 9 ) user-defined functions attached to Numeric keypad keys 0 to 9 (&#123;Esc 0&#125; to&#123;Esc 9&#125; for those lacking a numeric keypad) but, if you don't want to use these as macros, they are available for any other purpose.</P></LI>

<P><LI>( $ ) used to pass parameters to function keys, scripts and macros.</P></LI>

<P><LI>( ^ ) set up by startup script - defines function-key mapping.</P></LI>

<P><LI>( ' ) Set up by startup script - hosts the code repository and it's hashtable. It's hashtable is also used to hold bits of global data - like the jump addresses for <A HREF="#VIEWSAVE">ViewSave</A> and <A HREF="#VIEWRESTORE">ViewRestore</A>.</P></LI>

<P><LI>( : ) Set up by the startup script, is the help repository - see <A HREF="#ABOUT HELP FILES">about help files</A>.</P></LI>

<P><LI>( $ ! " # % & ( ) * + - . / ; &#060; = &#062; ? @ &#091; \ &#093; _ ) are all available but may be used by scripts or functions hence they can only be relied on for temporary storage.</P></LI>

<P><LI>The ( ! $ % ; @ ) buffers are used by the standard setup script, so they may contain something after the startup has run - but may be redefined without causing problems.</P></LI>

<P><LI>The buffers ( ^ ' : ) are defined by the standard setup script (see above), changing these may cause things to not work properly.</P></LI>

<P><LI>The ( & ) buffer is dedicated to the <A HREF="#DOC.JOT">doc.jot</A> script a simple document-processing utility.</P></LI>

<P><LI>The ( = ) buffer is available but cannot be used as a destination buffer for the <A HREF="#%Q">%Q</A>, <A HREF="#%F">%F</A> and, possibly, other percent commands with an optional buffer-key, since it would confuse the command parser.</P></LI>

<P><LI>The ( ; ) buffer is used to display help pages but it can be used for temporary storage, the syntax gets a bit messy when used in percent commands since the semicolon is used to terminate percent commands.</P></LI>

<P><LI>The ( ? ) buffer is defined by many scripts to give brief help information on the script.</P></LI>

</UL><P>See <A HREF="#A">A</A>, <A HREF="#H">H</A> and <A HREF="#ABOUT COMMAND PARAMETERS">about command parameters</A>.</P>


</UL><H3><A NAME="TRANSLATION OF KEYBOARD EVENTS TO ACTIONS">Translation of keyboard events to actions</H3>
<P>Like most modern editors jot attaches editor functions to various function keys, escape sequences and and various combinations of the Shift, Ctrl and Alt keys with function and other keys. The key-to-function translation table is held in the text buffer ( ^ ) defined at startup time - see <A HREF="#ABOUT STARTUP SCRIPTS">about startup scripts</A>.</P>

<P>After a key event is received, jot will attempt to match the received keycode with codes in the ^ buffer. Some keys return a simple numerical value, others return an escape sequence - an &#123;Esc&#125; character followed by a few ordinary printable characters. Alternatively, the user may type in &#123;Esc&#125; followed by two or more characters - essentially another form of escape sequence.</P>

<P>Where a parameter is required, e.g. for the &#060;&#060;Do&#062;&#062; function the script name parameter is represented in the function definition by a pair of adjacent hash characters. For in a typical linux installation this key will be defined by this entry in the ^ buffer:</P>

<PRE>
X010A   %r=##"Command file pathName&#062; ";
</PRE>
<P>In command mode, the name of the script is typed in *before* hitting &#123;F2&#125;, thus the function key doubles up as a delimiter for the parameter string, saving you the bother of hitting &#123;Return&#125;.</P>

<P>In insert mode, however, it is necessary to prompt for the pathname and the prompt is, of course, the string following the double hash. If the prompt string is omitted then no prompt is issued.</P>

<P>The startup script builds the key translation table in buffer ( ^ ) - see <A HREF="#STARTUP.JOT">startup.jot</A>.</P>

<P>In the normal startup script, for example, we find this  definition  of  the
&#060;&#060;Remove&#062;&#062; function (this removes the currently-selected substring):
&#060;&#060;Remove&#062;&#062;(s/ /e-)

Then, further along in the startup.jot script we see this:
&#060;&#060;Remove&#062;&#062;            &#123;Shift+F5&#125;
This says that the &#060;&#060;Remove&#062;&#062; function should be activated by  pressing  the
F5 function key while the Shift key is held down.

In the curses_keys_xterm script we find this line:
<PRE>
X0119                        -- &#123;Shift+F5&#125;
</PRE>
In the WindowsNT_keys script we find this line - functionally similar but  a
different keycode.
<PRE>
X374                         -- &#123;Shift+F5&#125;
</PRE>
these give the specific key code for &#123;Shift+F5&#125;.  Finally,  looking  in  the
key-translation buffer ( ^ ) of a linux session we should see this:
<PRE>
X0119   (s/ /e-)
</PRE>
The sequence of events is thus:
<UL><LI>You select a substring,</LI>
<LI>you press &#123;Shift+F5&#125;,</LI>
<LI>the  system  detects  this  event  and  generates  a  binary  the   code</LI>
determined by terminfo to be 0x119,
<LI>jot translates the code 0x119 to the escape sequence &#123;Esc 0 1  1  9&#125;,</LI>
<LI>jot matches the internally-generated escape sequence and finds  the  jot</LI>
command sequence (s/ /e-) by searching the ( ^ ) buffer,
<LI>jot then executes that little bit of code and, finally,</LI>
<LI>you see the substring disappear from the screen</LI>

</UL><H3><A NAME="ABOUT STARTUP SCRIPTS">About startup scripts</H3>
As we hit keys, various layers of hardware and the operating system  perform
a translation from electrical impulses in the keyboard to keycodes  that  can
be understood by whatever software is reading them - in this case jot.

For windows the situation appears to be  that  all  flavours  of  NT-windows
running on any machine connected to  any  compatible  keyboard  will  always
yield the same keycodes.

For linux, the recent history of unix intrudes, as  video  terminals  became
popular a great many firms entered the  market  with  competing  and,  well,
incompatible devices which all had to be connected to unix servers. This was
the necessity that gave birth to the invention of termcaps. Later there  was
terminfo - an improved version of termcaps.

With termcaps/info it became possible for many users,  all  connected  to  a
unix server using a variety of terminals and for the system  to  communicate
reliably with all of them. But only if  each  has  properly announced  which
terminal type they have by setting their $TERM env.

However ... most linux installations run on PCs with only one  keyboard  and
only one monitor but the unix distros have provided a plethora  of  terminal
types and many distros set up the default TERM to xterm. But no! ... not all
distros  provide  a  complete  description  of  the   capabilities   of   an
IBM-compatible keyboard and worse yet, not all agree on what keycodes result
from various combinations of function and control keys.

This is resolved in the startup script (See <CODE>&lt;</CODE>A HREF="#STARTUP.JOT"<CODE>></CODE>startup.jot<CODE>&lt;</CODE>/A<CODE>></CODE>), which runs
different keycode-setup  scripts  according  to  your  curses  version  (see
<A HREF="#WINDOWSNT_KEYS.JOT">WindowsNT_keys.jot</A> and <A HREF="#CURSES_KEYS_&#060;TERM&#062;.JOT">curses_keys_&#060;TERM&#062;.jot</A>).

The mapping of  function  key  events  to  editor  functions  is  determined
various layers of OS and, in particular your terminfo file and, finally,  by
the editor startup file. See also <CODE>&lt;</CODE>A HREF="#X-WINDOWS SETUP"<CODE>></CODE>X-windows setup<CODE>&lt;</CODE>/A<CODE>></CODE>

The approximate sequence of events, in the <CODE>&lt;</CODE>A HREF="#STARTUP.JOT">startup.jot<CODE>&lt;</CODE>/A> file is:
<UL><LI>The appropriate curses_keys_&#060;TermName&#062;.jot script is run - this  defines</LI>
the mapping of keycodes (either numerical keycodes or escape  sequences)
to the names printed on the keycaps. This table is set up in the (  @  )
buffer.
<LI>The startup script then defines functions in the code repository  buffer</LI>
( ' ).
<LI>The startup script then defines the mapping of functions  to  key  names</LI>
in buffer ( ! ).
<LI>If you have specified a function and keymap  modification  script  using</LI>
the -keyfuncs=&#060;pathName&#062; qualifier then  that  script  is  run  at  this
point.
<LI>The startup script merges the keycodes map, the functions  map  and  the</LI>
functions to create the key translation table in buffer ( ^ ) - this  is
used to map hotkeys function keys and escape sequences  to  actual  code
and function calls.

</UL><H3><A NAME="ABOUT HELP FILES">About help files</H3>
The help files are structured in a similar fashion to occam folded files.

The top help file normally contains only file folds. If,  for  example,  the
JOT_RESOURCES env is set  to  /home/my_home/resources,  there  should  be  a
top-level helpfile help.hlp in the help subdirectory:
<UL>/home/my_home/resources/help/help.hlp
</UL>Inside that file we might find this line:
<UL>&#091;unix&#093;unix - Notes on a few unix commands.
</UL>When When a user queries this help entry (by moving the cursor to  somewhere
in the line and hitting F1) the &#091;unix&#093;unix element is transformed  into  the
path:
<UL>/home/my_home/resources/help/unix/unix.hlp

</UL>Within the child help files are folded sections like this:
&#062; &#123;&#123;&#123; Section name
&#062;   Section text.
&#062;   ...
&#062; &#125;&#125;&#125;

These help sections are nestable.

The help files can be typed in manually, but it is easy to make mistakes  in
the fold  nesting.  It  is  recommended  that  help  files  be  prepared  as
plain-text documents using <CODE>&lt;</CODE>A HREF="#DOC.JOT">doc.jot<CODE>&lt;</CODE>/A> with the section hierarchy defined by
section header levels (i.e. the section  levels  indicated  by  the  section
numbers).

There are some text-processing scripts to help with this:
<UL><LI><A HREF="#DOC.JOT">doc.jot</A> - the main document processing script.</LI>
<LI><A HREF="#DOC2FOLD.JOT">doc2fold.jot</A> - Creates a help file from a text document.</LI>
<LI><A HREF="#FOLD2DOC.JOT">fold2doc.jot</A> - reverse of doc2fold - only use this when the source</LI>
text is not available.
<LI><A HREF="#UPDATEHELP.JOT">updatehelp.jot</A> - pushes simple modifications to a help fold back to</LI>
the helpfile.
<LI><A HREF="#FINDHELP.JOT">findhelp.jot</A> &#060;word&#062; - searches all help entries for the given word.</LI>

</UL><H3><A NAME="ABOUT LONG LINES">About long lines</H3>
The maximum length line that can be displayed properly  is  limited  by  the
display window. When the editor has to display a longer line  the  behaviour
is as follows:
<UL>
<UL><LI>If current character and all of any selected substring are in within the</LI>
terminal width then the line, the current character  and  the  substring
are displayed normally. Any text to the right of the window right margin
is silently ignored.
<UL>
</UL><LI>If the current character or some part of the selected substring is at or</LI>
beyond the terminal width then the line is displayed in the console area
of the screen.
<UL>
</UL><LI>If a LeftOffset is set for the buffer (see <A HREF="#%B=LEFTOFFSET">%b=leftoffset</A>) then the</LI>
left margin of the display is aligned to somewhere right  of  the  first
character. If the current  character  or  some  part  of  the  currently
selected substring falls outside the defined screen  area  then,  again,
the relevant section of the record is displayed in the console area.

<LI>When a script or macro has to ensure that the current  character  is  in</LI>
view use %q=inview - see <CODE>&lt;</CODE>A HREF="#QUERY INVIEW">Query inView<CODE>&lt;</CODE>/A>.

<LI>The &#060;&#060;CellLeft&#062;&#062; and &#060;&#060;CellRight&#062;&#062; actions  (normally  &#123;Shift+LeftArrow&#125;</LI>
and &#123;Shift+RightArrow&#125; respectively), will check  for  visibility  using
%q=inview and will adjust leftoffset accordingly.

<LI>The     &#060;&#060;ViewLeft&#062;&#062;     and     &#060;&#060;ViewRight&#062;&#062;     actions     (normally</LI>
&#123;Ctrl+Shift+LeftArrow&#125; and &#123;Ctrl+Shift+RightArrow&#125; respectively), can be
used to manually adjust leftoffset.

</UL></UL><H3><A NAME="ABOUT JOT-DISPLAY WINDOWS">About Jot-display Windows</H3>
In jot documentation, a window  is  a  viewing  area  of  the  terminal.  By
default, the startup script creates a single window which displays  whatever
happens to be the current buffer. The area at the bottom of  the  screen  is
the console area, used to display system messages  etc.  and  your  typed-in
commands are echoed here.

For debugging scripts, especially when using <CODE>&lt;</CODE>A HREF="#THE JOT DEBUGGER">the jot debugger<CODE>&lt;</CODE>/A>, it is
useful to set up windows for a fairly large  console  window.  However,  for
normal usage a smallish console area is  useful  since  this  maximizes  the
view. The the console area can be set to temporarily expand upwards into the
lower part of the windows (see <CODE>&lt;</CODE>A HREF="#%S=CONSOLE">%s=console<CODE>&lt;</CODE>/A>) this ensures that most messages
are visible.

The size of a window can be adjusted with the <CODE>&lt;</CODE>A HREF="#WINDOWSTRETCH">WindowStretch<CODE>&lt;</CODE>/A> and
<A HREF="#WINDOWSHRINK">WindowShrink</A> functions.

It is possible to split the viewing area between more than one  window  with
one or more windows dedicated to displaying specified  buffers.  The  screen
may be split either vertically or horizontally  -  see  `about  multi-window
working`   and   `WindowOne`,   `WindowHorizSplit`   and   `WindowVertSplit`
functions.

</UL><H3><A NAME="ABOUT TABULAR TEXT">About Tabular text</H3>
Jot supports text two types of text containing tabs - normally the ascii  VT
character, here referred to as tab. The first form uses tabs simply to align
text into predefined columns, the  second  form  aligns  tab-delimited  text
cells. Cells often contain numerical data, so the  text  is  right-justified
and over-long strings are truncated to maintain the tabular structure.

See  `%b=tabstops`,  `%b=tabcells`  and  `%b=tabsort`.  It  also   generates
tab-separated tables (see `Query dir`).

When viewing tabular data it is often useful to have a header  line  showing
the meaning of each column - the window headers provided by `%b=header` will
follow tabstops set in the text body.

In addition to `%b=tabstops` and `%b=tabcells`, there are two  more  options
for representing tabular text. 
<UL><LI>By default, jot will treat tabs as it does any other control  characters</LI>
and will represent them with tildes ( ~ ) -  not  a  especially  helpful
option for most uses - but it is sometimes useful to see where they are.
<LI>The following scripts will reformat documents, guided by temporary tabs:</LI>
`autotab.jot`     `autotabdp.jot`     `autotabjust.jot`      `retab.jot`
`retabhere.jot`
</UL>
If the width of the table execeeds that of your  window,  you  can  set  the
leftoffset - see `about long lines` and `%b=leftoffset` this  is  all  taken
care of by the &#060;&#060;`WordRight`&#062;&#062; and &#060;&#060;`WordLeft`&#062;&#062; functions.

As with linear text, if the current character ends up  outside  the  visible
area of the screen (i.e. left of the buffers leftoffset setting, or right of
the right margin), the relevant section is repeated  in  the  console  area.
Also, if any part of the cell is out of the viewing area or the tabstops are
set to narrow to properly display a cell, the cell  text  is  truncated  and
displayed prefixed with a pling ( ! ) character. The section of text is also
repeated in the console area - see `about long lines`.

While the %b=tabstops command affects only the way tables are represented on
the screen in the current edit  session,  There  are  scripts  available  to
permanently change the text file  -  see  `autotab.jot`,  `autotabjust.jot`,
`autotabdp.jot` and `retab.jot`.

</UL><H3><A NAME="ABOUT MOUSE EVENTS">About Mouse Events</H3>
By default, any mouse activity (movements, clicks, drags etc.)  are  ignored
since in X the default mouse functions (selections) are  reasonably  useful.
If however, some application needs to handle  mouse  events,  these  can  be
enabled.    An    example    of    a    script    that    does    this    is
$&#123;JOT_HOME&#125;/coms/linkdocs.jot - see `linkdocs.jot` and `qr.jot`.

Jot is normally driven by keyboard events with mouse-button events disabled.
When mouse events are enabled, these are treated  as  keyboard  events  with
special mouse event codes prefixed with 'M@. In linux,  it  is  possible  to
select mouse events in the `%s=mousemask` command, in  windows  this  either
enables or disables all mouse events.

The normal startup sequence defines four functions
<PRE>
M0040   &#060;&#060;CopyFromMouse&#062;&#062;    -- &#123;Button2Up&#125;
M0080   &#060;&#060;NoteFromMouse&#062;&#062;    -- &#123;Button2Down&#125;
M0200   &#060;&#060;FocusToMouse&#062;&#062;     -- &#123;Button2DoubleClick&#125;
M4000   &#060;&#060;InsertHereMouse&#062;&#062;  -- &#123;Button3Click&#125;
</PRE>
these are intended to be demonstrators rather than useful functions - enable
them for use with the mousemask command:
&#062; %s=mousemask 42A0

To integrate these in a useful way - e.g. for mouse clicks to perform useful
processing some metadata is often required - e.g. to perform a jump to  some
place in another buffer on a mouse click we might  need  a  hash-table  key.
This key can be associated with a launch point by adding a text tag  in  the
launch point with the`%b=addtag` command using the -text=&#060;string&#062; modifier.

See also `OP`, `%s=mousemask` and `%b=addtag`

</UL><H3><A NAME="ABOUT MENUS">About menus</H3>
Jot can support simple mouse-click menu-driven  applications.  Although  the
plain-text menus are very crude by modern standards they can  be  useful  in
certain situations. Take a look at the coding of $&#123;JOT_HOME&#125;/coms/menu.jot

Popup menus can be set up using popup windows - see the -popup option of the
`%W` command.

Firstly, to enable mouse  events,  the  mousemask  must  be  set  up  -  see
`%s=mousemask`.

A menu item is normally tagged with a colour that makes it stand out  -  see
`About tagged text`, `%b=tagtype` and `%b=addtag`. Menu items will  normally
be tagged with some text that can be used to identify  an  event  handler  -
typically the name of  a  handler  function  see  `About  tagged  text`  and
`%b=addtag`.

When a mouse click  is  detected,  it  passes  through  the  key-translation
mechanism as if it were a function key or an  escape  sequence-  see  `about
mouse events`. There will usually be a mouse-event handler  which  picks  up
the click coordinates, identifies the button and extracts the button-handler
name from the button's text tag.

Finally, a function  call  is  launched  and  the  appropriate  action  gets
underway.

</UL><H3><A NAME="ABOUT UNICODE">About unicode</H3>
Back in the days of teletypewriters and paper tape it was all so  easy.  The
American Standard Code for Information Interchange (ASCII)  would  represent
every character you could ever want with just  7  bits  -  so  long  as  you
weren't  a   mathematician,   an   engineer   or   anyone   working   in   a
non-english-speaking part of the world.

Mapping the 7-bit ASCII code to 8-track paper tape code left one  extra  bit
which was sometimes used for checking  -  early  modems,  electro-mechanical
tape punches and readers were not especially reliable. Since that time,  the
8-bit unit (one byte) has become the industry-standard unit for organization
of computer memory. 

Modern computer hardware is much less error prone and, where  error-checking
schemes are employed, nowadays they are  usually  cyclic-redundancy  systems
that can detect and correct multiple errors. Also modern modern transmission
protocols include error detection and correction. So the 8-th.  bit  is  not
required as a check for storage or transcription errors.

Unicode (or Universal Character Set - UCS) - an  industry-standard  encoding
scheme for most characters in  the  alphabets  of  most  written  languages,
including many symbols used in mathematics and  engineering.  The  range  of
characters is  so  vast  that,  in  practice,  it  is  necessary  to  encode
characters as  sequences  of  one-byte  tokens.  Some  tokens  indicate  the
existence of yet more tokens to come, in UTF-8, UTF-16 and UTF-7. In  common
with many mail  and  unix  systems  jot  uses  UTF-8  to  represent  unicode
characters. 

It's important to note that whereas UCS is basically a vast  character  set,
UTF-8, UTF-16, UTF-7 ... are  coding  schemes  designed  for  efficient(ish)
transmission, storage and handling of characters belonging to  that  set  by
encoding them as sequences of bytes in the range 128-255.
<UL>
</UL>UTF-8 is a back-compatible expansion of the usual  8-bit,  non-parity  ASCII
character set utilizing the, now redundant, 8th. bit and two or  more  bytes
to yield an encoding space for many thousands  of  unique  character  codes.
These can be used to represent all  of  the  unicode  characters.  Both  the
windows and linux versions of jot support UTF-8 encoding.

UCS-2 is an early attempt at  a  unicode  encoding  scheme  -  unfortunately
whereas UCS-2 can address a character space of 64K characters (at most,  and
in practice far less) the full chinese character set has in  excess  of  70K
characters. This resulted in UTF-16 and UTF-32, UTF-32 abandons all pretence
of packing efficiency and just gives each character 32 bits (a full word  in
most modern computers). UTF-16, like UTF-8 is a variable-length scheme which
can address most of the current unicode characters.

While ICS-2 and UTF-16, may not be actually obsolete they were never  really
much good. Consequently jot offers only very limited support for UCS-2, it's
slightly more intelligent younger  sibling  UTF-16  or  it's  obese  brother
UTF-32. UTF-16 is essentially UCS-2 with  some  complicated  variable-length
coding.

Jot makes  no  attempt  to  make  sense  of  any  of  these  encodings.  The
recommended solution for UCS-2, UTF-16 and UCF-32 is to convert  them  using
iconv (linux) or a similar windows file-format converter. The  filing-system
explorer `get.jot` automatically uses iconv to read these formats  as  UTF-8
but to be consistent with the jot policy of not making  unrequested  changes
to files, the pathname is changed in the editor session.

Various earlier schemes, designed for users working in their own  languages,
allows an additional character space (theoretically  up  to  a  further  128
characters) by setting the parity bit. This scheme, enshrined  in  microsoft
code pages, became popular because it  allowed  several  sets  of  non-roman
alphabets with the minimum of fuss and still preserves the ancient principle
of one byte  equals  one  character  -  very  important  for  developers  of
text-handling tools. This is fine for those, like most of us, who never have
to write in more than one non-roman alphabet in any one document. There  are
now various ISO-8859-x standards covering these character sets.

</UL><H4><A NAME="PRACTICALITIES OF UNICODE ETC. AND JOT.">Practicalities of unicode etc. and jot.</H4>
The linux version of jot of jot can read  and  manipulate  files  containing
mixed UTF-8 and ISO-8859-x character encodings.  For  correct  rendering  of
ISO-8859-x you must have your locale set correctly - see `-locale`. Any text
entered will be encoded in UTF-8.

The windows version can properly display files containing  either  UTF-8  or
those containing ISO-8859-x - but  not  both  in  the  same  document.  This
version  requires  the  correct  code-page  setting  for  the  file  -   see
`%b=codepage` and `-Codepage`, by default  it's  set  to  codepage  65001  -
that's UTF-8 to you and me. Again, any  text  entered  will  be  encoded  in
UTF-8.

To enter  UTF-8  characters  into  the  command  line  use  the  jot  script
uc_basic.jot - this recognizes sequences of keystrokes and converts them  to
the relevant UTF-8 byte sequence. To generate the euro symbol  (  €  ),  for
example:
&#062; &#123;Esc u = E&#125;
In command mode, `uc_basic.jot` translates  this  sequence  on  the  command
line, so start off by loading the basic unicode:
&#062; uc_basic&#123;F2&#125;
Then, for example, to search for the the string "cost €123.456", type:
&#062; cost &#123;Esc u = E&#125;123.456F8
The uc_basic.jot script added the u=E escape string to your key translations
list and it substituted the UTF-8 encoding for € in the command line.

Many IBM-compatible keyboards supplied in non-english-speaking parts of  the
world, have non-roman characters. Assuming your system is set up  correctly,
in linux, these keystrokes are converted to the correct  UTF-8  sequence  by
the OS. If, for whatever reason, your linux  locale  (or  Windows  codepage)
does not match your keyboard, you can specify a different  locale  with  the
`-locale` (or `-Codepage`) qualifier. If you have some ISO-8859-x encoded in
a different locale, you can change the locale of a buffer with the `-locale`
CLI modifier.

To suppress conversion of unicode, turn off unicode support for that  buffer
with the `%b=unicode` command. This renders each non-ASCII byte as a tilde (
~ ).

</UL><H4><A NAME="UNICODE - THE GRUESOME DETAILS">Unicode - the gruesome details</H4>
Internally, jot stores characters in whatever way as they  were  transported
and then stored in the filing system. This is  important  because  it  means
that files written by  jot  will  preserve  the  original  encoding  of  the
original. To be quite clear on this, jot does *not* plant  BOMs  (byte-order
marks) or change any character encoding except when explicitly requested  or
for characters you have  changed  or  inserted  in  your  edit  session.  By
default, the latter end up as UTF-8.

When jot reads a UCS-2, UTF-16 or UTF-32 file, jot saves the BOM (which is a
two or four-byte prefix added by microsoft and most other windows tools), it
saves the BOM internally and re-prefixes the text as it is written back out.

For example, the UTF-8 encoding for the euro sign ( € ) is E2, 82, AC -  jot
will recognize these characters as UTF-8 and convert  them  to  the  correct
coding for the euro symbol for display on the  screen.  It's  left  to  your
terminal emulator to correctly interpret the UTF-8  string  to  present  the
correct image on the screen.

Note that the `R` and `OR` commands will  normally  traverse  the  specified
number of characters irrespective of  how  many  bytes  have  been  used  to
represent each character. Similarly the  `E`  command  normally  erases  the
specified number of  characters  irrespective  of  their  byte  count.  This
behaviour is modified by the `%b=unicode` command, which can be used to turn
off all unicode support - with unicode disabled, R, OR and E commands  count
bytes not characters. Erasing bytes belonging to  UTF-8  characters  is  not
recommended - there is no guarantee that the  line  will  display  properly
when unicode-support is turned back on.

</UL><H3><A NAME="ABOUT JOURNAL FILES">About Journal Files</H3>
Jot's journal files are designed to recreate a session  following  a  crash.
The journal file, along with a cache  of  files  and  queries  read  by  the
original session, can be used to retrace all your  activity  in  a  recovery
session so that you end up with an editing environment identical to that  in
the crashed session.

By default no journal is maintained - the editor is not particularly  crashy
and modern computers and power grids are generally reasonably reliable.  The
endurance of battery-powered devices is also quite  good  these  days.  From
time to time however, a can't-happen event demonstrates how these need to be
reclassified as infrequent events and it's pretty distressing to  see  hours
of work wiped out like that.

With the CLI qualifier `-journal` is set, jot maintains a history  file  and
snapshots of all the files it reads - these files are  normally  deleted  on
exit from the editor.

In the event of a crash the journal files remain and the original session is
re-created by reading in snapshots of the original files and re-running  the
interactive commands.

The process for a session editing myfile.txt is described below.
<UL>
<UL><LI>1 Start the editor with journal files enabled:</LI>
<PRE>
$ jot myfile.txt -journal &#091; -&#060;any other valid args&#062;&#093;
</PRE>
 
<LI>2 After crashing,  restart  the  editor  but  run  the  recovery  script</LI>
recover.jot - any other args will be ignored, the recovery process  will
restart with your original arg list:
<PRE>
$ jot myfile.txt -st=recover
</PRE>
</UL></UL>
<UL><LI>3 If there are problems, then edit the command script recover_now.jot in</LI>
your current directory and re-run the recovery using that:
<PRE>
$ jot myfile.txt  -init="%r=./recover_now.jot -asConsole"
</PRE>
</UL>
See `about not losing your work` and `recover.jot` for full details  of  the
journal/recovery process.

</UL><H3><A NAME="ABOUT TAGGED TEXT">About Tagged Text</H3>
Tags are used  to  mark  sections  of  text  with  some  special  attribute.
Typically, this will be display colour but tags are also used internally  to
identify and to protect hash-table target  points  or  to  add  metadata  to
points in the text. The metadata is in the form of a text string, this is an
essential ingredient in jot mouse and menu-driven interfaces where  the  tag
metadata is used to identify a mouse-event callback.

Those familiar with vim and Emacs tags and tags should note  that  jot  tags
are nothing to do with that. The jot equivalent of vim  and  Emacs  tags  is
described in `about index files`.

Each colour tag indicates a colour pair (i.e. a foreground and a  background
colour) to be associated with the tag see `%b=tagtype`. The tags  are  added
to test with the `%b=addtag` command.

The colours associated with the tags are defined in the `%b=tagtype` command
<UL><LI>this associates a colour pair with  a  user-supplied  name  which  can  be</LI>
referenced by  the  `%b=addtag`  command.  The  names  must  not  exceed  12
characters.

The `%b=addtag` command adds a pair of tags into the internal record data  -
one identifies a start point and another the end of the tagged substring.

The tag definitions are associated with the buffer and are displayed by  the
`query buffer` query. The tags can be listed using the `query tags` query.

For windows there is no limit on the number of named tags you can  define  -
although there seems little point in going beyond the 256 unique colour pair
combinations that are possible with windows.

For linux, there are only  64  possible  colour-pair  combinations  and  the
curses system allows only 63 user-defined colour pairs.  The  63-colour-pair
limit is a system limit - the total number of colour pairs  in  all  buffers
cannot exceed this.

This is what happens if the text is changed  on  a  line  containing  tagged
text:
<UL><LI>If a change is made after (i.e. right-of) the tagged text  there  is  no</LI>
effect on the tagging.
<LI>If the change happens before (i.e. left-of) the  tagged  text  any  tags</LI>
then the tags are shifted left or right as appropriate.
<LI>If text is inserted deleted or substituted in a  tagged  substring,  the</LI>
extent (n. of characters) of the tag remains unaffected but text covered
is changed.
<LI>If the record is broken mid tag (e.g. by a B  or  A  command)  then  the</LI>
extent of the tag is reduced to match the new record length.
<LI>If a new colour tag starts inside the scope of some outer colour tag the</LI>
display effect is not guaranteed but, with the current  version  of  the
editor, the inner tag is invisible even if it's end point is  after  the
end of the first tag.

</UL></UL><H3><A NAME="ABOUT HASHTABLES">About Hashtables</H3>
Each buffer can have an associated hashtable. Hashtables are  referenced  by
keyword - the keyword can be any unique string and each hashtable entry  may
point to one of the following classes of data object:
<UL><LI>A pointer to some point in the text - a FindObj,</LI>
<LI>a stack-frame image - a DataObj,</LI>
<LI>a file section (a seek offset and a byte count) - a SetsectObj, </LI>
<LI>a file  section  (a  pathName,  seek  offset  and  a  byte  count)  -  a</LI>
SetfsectObj,
<LI>a deleted object - a ZombieObj.</LI>
</UL>
The FindObj is essentially an index which allows fast references to  indexed
text. Hashtables are a useful alternative to searching with the `F`  command
when the buffer is extremely large or when a macro makes many references  to
moderately large buffer making the searching a significant proportion  of  a
macros execution time (see `hashtable jump`)

The DataObj is a stack-frame that has been detached  from  the  top  of  the
stack and can be copied back to the stack as required, this  works  for  any
stack-frame type - integer, float or buffer (see `hashtable data`, `OV`  and
`OQ` commands). Data objects can  be  swapped  between  the  stack  and  the
hashtables, note that the data-object  buffers  can  also  have  hashtables,
leading to the possibility of unlimited hierarchies of hashtables.

For data objects assigned to one of the main buffers, the syntax  is  pretty
simple - to extract the value of an object  named  "fred"  hanging  off  the
current buffer it would be:
&#062; ov/fred/

But to access an object named 'fred' hanging  off  data-object-buffer  named
'jim', which is itself hanging off another data-object-buffer named  'brian'
hanging off the primary buffer ( . ) - then we might just plod  through  the
hierarchy:
&#062; z.oq/brian/z~ oq/jim/z~ oq/fred/

That's pretty painful - so there is a path-specification syntax designed for
buffer hierarchies:
<UL>&#091;&#060;bufferKey&#062;=&#093;&#091;&#060;PathElement1&#062;&#091;|&#060;pathElement2&#062;&#091;| ... &#093;&#093;&#093;
</UL>eg:
&#062; oq/.=brian|jim|fred/

While this syntax simplifies  usage,  it  still  requires  three  relatively
expensive hashtable operations to locate the data. Note that that,  although
some path depth may be desirable - possibly  essential  for  some  recursive
functions, it can get expensive and programmers should strive too keep their
data structures as flat as possible.

The SetsectObj is intended for the handling of very large files, it  defines
the byte-offset and  byte-count  of  sections  of  files  -  see  `hashtable
setsect`, `hashtable setfsect` and the -section=&#060;hastableKey&#062; section of the
`%I` command.

The SetfsectObj is similar to SetsectObj except  that  it  also  includes  a
pathname and is intended for support of collections of files  -  see  `about
large collections of files`

Typically what happens is the text is first scanned to identify  the  target
points, and create hashtable entries. When queried, the editor  picks  up  a
reference to the original target point an restores the editor focus to  that
at the time when the entry was created.

The ZombiObj exists because the gnu hashtables do  not  support  removal  of
entries. When a `hashtable delete` request is made, the hashtable  entry  is
left in place but the object it points to becomes a zombie.

When a buffer object is duplicated on the stack it is said to be cloned. The
original and the clone are identical and point have  pointers  to  the  same
underlying data structure.

Note that stack-based buffer that has already been used to define  one  data
object cannot be used to define another. This restriction is, hopefully, not
very onerous since the same data can be accessed via the first data  object.
The restriction comes about because, put simply, an object can only have one
parent tree. In practice, as the hash-table trees are deleted, a data object
shared between two different trees would acquire an undefined status.

When a hashtable is destroyed by `hashtable destroy` or it's  parent  buffer
is cleared (eg by the `A`, `%D`, `%Q`, `%I`, ... commands), then all of it's
it's objects and any descendants are also destroyed. There may be clones  of
destroyed buffers on the stack or the current buffer may be  a  clone  of  a
buffer previously dangling off a destroyed hashtable. These remain effective
and usable - but their hashtable path is removed as their parent buffers  no
longer exist.

For more details on hashtables, take a look at `Using Hashtables`.

</UL><H3><A NAME="ABOUT INDEX FILES">About index files</H3>
Index files contain pointers to specific points in one or  more  text  files
and are used to facilitate rapid and convenient context changes.

Jot supports two types of index files - the native jot format which is  used
to drive the `%I` command with a seek and section-size specification and the
vim-style tags file generated by the ctags unix command.

The native-jot index files are optimised for navigating *very* large  files,
where it would be impossible, or very inconvenient, to load and  search  the
whole file - see `about large files`. The native-jot  index  form  has  also
been adapted for use with large collections of files eg the source-file tree
for a complicated programming project -  see  `about  large  collections  of
files`.

Jot also supports the  vim-style  tags  files,  these  can  be  conveniently
generated by generated by ctags.

The native-jot indexes supported  by  the  jot  scripts  `big_file.jot`  and
`multi_file.jot` are significantly faster for very large  files  since  they
use a filing-system seek to access the files and only read the  sections  of
interest. The downside is  that  writing  modified  versions  of  the  files
requires special care. Writing is supported by  big_file.jot,  the  modified
file will usually require re-indexing as the seek points will have changed.

In contrast, vim-style tags files read the entire file to a buffer making it
easy to write an updated version but, because it needs to search the  entire
file for each new section heading, it can be slow if there are any very  big
files in the tree - this is most unlikely for normal source-code trees.

</UL><H3><A NAME="ABOUT LARGE FILES">About Large Files</H3>
A working definition of a very large file is one big enough  to  exceed  the
capacity of a text editor as supported by our system. That definition  takes
into account various system configuration  and  tuning  considerations  like
memory size swap size disc bandwidth cache size and all that sort of stuff.

The main problem with *very* large text files is not changing them but  just
viewing them. Although These files are generally both generated and read  by
machine they are presented in a text form because people  need  to  work  on
them when something goes wrong.

These files are frequently used as intermediaries in CAD design flows  using
design systems from rival vendors. Many are based on spice  netlists  and  a
spice netlist of just a section of a modern chip is  never  going  to  be  a
small file.

So the way jot approaches  this  problem  is  to  acknowledge  that  nobody,
pondering the problem of "what went wrong" or "why am I  seeing  that  error
report" or "why that timing violation" is ever going to want to look at  all
xxxGb of a file - only the bits that an investigation leads to. So we need a
method that lets us pull in the relevant  bits  of  information.  There  are
several qualifiers to the %I command that allow us to pull in selected parts
of a big file and make it viewable - even  if  not  editable.  In  any  case
modifying these files wouldn't do us much good  -  we'd  be  corrupting  the
design flow.

The `%I` command has a number of qualifiers that are designed to  facilitate
the reading big files by the spoonful but this is of little  use  unless  we
already know which bits to read and precisely where they  are.  In  %I,  the
-hold, -bytes and -block qualifiers can be used to read large files  by  the
spoonful (or, indeed, by the  bucketful)  for  filtering  or  generating  an
index, as in the `big_file.jot` script. This  script  gives  a  more-or-less
normal editing environment for specified sections of large files.

</UL><H3><A NAME="ABOUT LARGE COLLECTIONS OF FILES">About Large Collections of Files</H3>
Many modern editors offer methods of  maintaining  source-code  trees  using
some sort of index file. In vim and Emacs thes index files are  called  tags
files but in jotland we like to keep things simple, and jot index files  are
just called index files.

When working on some big complicated project, involving lots of source files
or maybe, after downloading some source-code, one of the first  things  many
of us like to do is to browse the source code to get some  idea  of  how  it
works. 

Unfortunately, the more complicated systems consist of  a  large  number  of
source files and, without some  prior  knowledge  of  how  the  sources  are
structured, it can  be  difficult  to  see  what's  going  on.  The  scripts
`multi_file.jot`  and  `tags_index.jot`  are  designed  to  help  with  this
problem.

These scripts each support  a  separate  index-file  format,  multi_file.jot
supports one based on an extension of the form used  for  large  files  (see
`about large files`) and tags_index.jot supports vim-style tags files  which
can be conveniently generated by Exuberant Ctags.

</UL><H2><A NAME="JOT PROGRAMMING">Jot Programming</H2>
 
</UL><H3><A NAME="SUCCESS, FAILURE AND ERRORS">Success, Failure and Errors</H3>
Most commands set a success/failure flag. Failures are quite normal in JOT -
many commands are used simply to locate structures in  the  text  and  these
failures are normally handled in the command sequence. One may, for  example
want to test if the cursor is at the end of a record, then we might use  the
move right (`R`) command and check it's status - a failure can  only  happen
when the cursor is at the end of a line.

Errors are more serious (typically a syntax error in your coding or  an  I/O
operation that failed), these result in an immediate exit from  the  command
sequence with a message in the console area. By default,  errors  will  stop
execution of the current command sequence with a message  indicating  what's
gone wrong - these can be suppressed using `%s=verbose` or `-quiet`.

There is a message associated with failures too but these are suppressed  by
default. If a command sequence  ends  with  the  error  flag  set  then  the
termination message "&#123;Command-sequence failed.&#125;" is  issued  with  a  simple
diagnostic indicating which command failed.

If a command fails and no command is found to handle the failure,  then  the
block or macro fails, if the failing command was not in  a  block  or  macro
then a message like this appears at the console:
&#062; &#123;Command-sequence failed.&#125;...&#060;failingcommand&#062;...

See `%s=verbose` for details on controlling the level of error reporting.

Failing commands are handled as follows:
<UL>
<UL><LI>If the next command is the ignore-failures command `?`, the failure  is</LI>
ignored and processing continues.
<UL>
</UL><LI>If  a  failure  handler  exists  (see  the  `,`  command),   then   the</LI>
failure-handler code is executed

<LI>If there is no failure handler, then the current block exits (see  `Jot</LI>
command structure` and `(` `)` ).
<UL>
</UL>If the block was an infinite loop i.e. '( ... )0' then the  loop  exits
without passing on the failure, all other types of blocks fail.

<LI>The reverse status command `\` reverses the  status  of  the  preceding</LI>
command you can also reverse the status of a command that's already had
it's status reset by the  `?`  command  -  in  this  case  the  command
*always* fails - which can sometimes be useful.

</UL></UL><H3><A NAME="JOT COMMAND STRUCTURE">Jot command structure</H3>
Jot allows users to construct macro-commands  which  can  apply  tests  make
decisions and return results - they can also, of course, alter your text.

Most commands are capable of failure, by looking at the status returned by a
command we can often deduce something useful about the  text  we're  working
on. If, for example, the `r` command fails it can only mean that the  cursor
is already at the end of a line, if `f`/&#060;string&#062;/ fails then it  means  that
string does not exist. When writing a macro-command these failures  are  not
so much disasters as potentially useful results.

Jot  commands  are  organized  into  blocks  bounded  by   round   brackets.
Optionally, the sequence of commands within a block may be broken by commas,
the sequence following the comma take control if a  failure  occurs  in  the
sequence before the comma -  giving  us  an  if-else  structure.  Since  the
else-sequence might fail successive commas can be deployed giving us  an  if
... elseif ... elseif ... structure. Ultimately, if the last sequence in the
block fails then the *entire* block returns a failure. Blocks may be  nested
to any number of levels.

Jot blocks, like most jot commands, can be given a repeat count. As with jot
commands this may be infinite the repeat count for a block must be a decimal
literal immediately after the end brace. As with other jot commands  for  an
infinitely repeating block, set the repeat count to zero. In the event of an
unhandled failure occurring in a repeated block, the block exits immediately
even if it has not gone through all it's iterations. In these  circumstances
a   block   with   a   finite   repeat   count   returns   a   failure,   an
infinitely-repeating block always returns success.

A sequence of commands can be enclosed within parenthesis (see `(`  and  `)`
), this has the following effects:
<UL>
<UL><LI>The block can be used to define the  extent  of  `success,  failure  and</LI>
errors` - in the phrase (r, m) ... , for example, if the r command fails
(because we're at the end of a line), then it moves to the next line.

<LI>The block can repeat commands for a predefined number  of  iterations  -</LI>
for example, the phrase (mi/#/)10 will insert a # at the  start  of  the
next 10 lines. If a command in this type of block should fail, then  the
loop exits early and the block sets the failure flag.

<LI>The block can be repeated to exhaustion - i.e. until something  fails  -</LI>
for example l0(q/A-Z/c, r)0 will  change  the  case  of  all  upper-case
characters on the line. In this case, a failing command will also  cause
the block to exit, but the failure flag is reset.

<LI>The block's status can be handled like the status of any other command:</LI>

<UL><LI>( ... )? and ( ...  )123?  -  resets  the  failure  flag  following  a</LI>
failure.

<LI>( ... )\ and ( ... 123)\ reverse the status on exit.</LI>

<LI>( ... )?\ and ( ... )123?\ - these blocks will always fail.</LI>

<LI>( abc ) def , ghi - if the '( abc )' block fails then commands ghi are</LI>
executed, otherwise it takes commands def.

</UL>Here's a few examples:
<UL><LI>( ... , )0 - this block will loop indefinitely.</LI>
<LI>( ... ,) and ( ... )? - these two have an identical effect,</LI>

</UL></UL></UL><H4><A NAME="FINITE REPEAT BLOCK EXAMPLE">Finite Repeat Block Example</H4>
(f/fred/s/bill/)23 - is  a  finite  repeat  block,  it  seeks  the  next  23
occurrences of fred and substitutes bill. If there are less then 23 freds in
the text then the F command fails and so to  does  the  complete  block.  If
there are more than 23 then, on completion, there will still be some  fred's
left.

</UL><H4><A NAME="CONDITIONAL REPEAT BLOCK EXAMPLE">Conditional Repeat Block Example</H4>
(f/fred/s/william/)0 - is a conditional repetitive block, the thing keeps on
finding freds and substituting williams until all  freds  have  been  found,
then the `F` command fails, the block exits but in this case the block exits
successfully.

</UL><H4><A NAME="STATUS CHECKING EXAMPLE">Status Checking Example</H4>
(f1/fred/s/bill/, f1/jim/s/dave/) - If the current line has a fred at or  to
the right of the current character, it will get changed to bill. If there is
no fred then the failed f1 command leaves the  current  character  unchanged
and searches the line for jim, if found then it gets changed to dave.

</UL><H3><A NAME="ABOUT MACROS">About macros</H3>
Any buffer can hold sequence of commands, the commands in the buffer can  be
executed as a macro command. Macro commands can  call  other  macros  -  but
recursive macro calls (where a macro, or one of it's children, calls itself)
are not allowed. The command to run a macro is a single quote ( ' ) followed
by the buffer key.

To run a macro place the macro-buffer key it in a command string prefixed by
a single quotemark ( ' ) e.g:
&#062; %d3=f/my_string/
this macro is run as follows:
&#062; '3 

</UL><H3><A NAME="CALLING SUBROUTINES BY NAME">Calling subroutines by name</H3>
Jot offers a primitive form of subroutine support, Sequences of commands may
be entered in a buffer  and  then  referenced  using  the  `hashtable  call`
command.

Code  can  be  designed  to  operate  only  on  the   stack   resulting   in
procedure-like behaviour. There  is  no  formally-defined  parameter-passing
mechanism - programmers may use the stack or global buffers. But, it  should
be noted, that there is no protection of stack objects - programmers must be
very careful to maintain strict discipline in their stack operations.  Also,
the only way back to the calling macro is to reach the  end  of  the  called
sequence - there is no return command.

The code repository set up by `startup.jot` is in the '  buffer.  The  first
line of the code is, by convention, assumed to be the routine  name  and  is
ignored by the %h=call command. 

Where there are many routines defined by  the  normal  startup  script  (see
`startup.jot`) saved in a buffer, there is no explicit mark denoting the end
of each. Instead, the first line of the next  routine  is  used  as  an  end
marker. The %h=call behaviour detects the end of a routine by  checking  for
the existence of tags  on  each  record.  Any  tag  is  assumed  to  be  the
hash-table target for the next routine in the repository. This  very  simple
approach breaks if, for any reason, other tags have been added - so  do  not
apply the `jot.jot` to the code repository.

</UL><H3><A NAME="ABOUT THE OPERAND STACK">About the Operand Stack</H3>
The operand stack allows  simple  arithmetic  operations  and  tests  to  be
performed on objects (typically integer  quantities)  held  in  a  push-down
stack. It can also hold  temporary  buffers  created  by  the  system  query
commands. The full range of operations is described in `Stack Operations`.

The underlying C-language type for integer values is  long  long,  for  real
values it's double.

For the benefit  of  those  not  familiar  with  the  notion  of  stacks  in
computing. Stacks are analogous  to  those  spring-loaded  plate  stacks  so
beloved of institutional caterers. As clean plates are delivered, the  stack
gets pushed down, as plates are taken off the next one pops up.  Note  that,
as plates are added individually, the last one on is the  first  one  off  -
this is a key property of computer stacks. 

And so it is, with our operand stack, new values are 'pushed' onto the stack
and later 'popped' off for processing. Each item on the jot stack is wrapped
up in a little data structure called a stack frame, which play the  part  of
plates in the above description.

Essentially the stack can be loaded with values from (see `Stack operations`
for the full list):
<UL><LI>Integer or real numbers picked up from the text (e.g. with `oi`),</LI>
<LI>Integers or real numbers literals from the command line (see `OL`),</LI>
<LI>Integers generated by the random-number generator (see `OA`),</LI>
<LI>Integers describing the current focus  point  (i.e.  buffer  i.e.,  line</LI>
number `ON` and character number`OC`),
<LI>Integers, Reals or Buffers held by hashtable data  objects  (see  `Using</LI>
hashtable data`)
<LI>A temporary buffer created for as a destination buffer for  any  command</LI>
that directs it's output  to  a  buffer  eg: %q~=date;.
<LI>Arithmetic and logical operations can be performed on  numerical  values</LI>
(see `O+`, for example.
<LI>Values and strings can be written to the buffer text (see `OO`).</LI>
<LI>Numerical values can be extracted by indirect references - eg: %w '~;  -</LI>
sets the window size to an integer picked up from the stack. If the  top
stack frame is a buffer, then the current character of that buffer  must
be pointing to one or more digits for conversion to  an  integer  -  see
also `About command parameters`.

</UL>If performing a straightforward abstraction or maybe a query to  stack  with
%q~=... (see `%Q`), a new buffer stack frame will be created at the  top  of
the stack. If, however, you are doing a cumulative abstraction (i.e. a~+,a~-
or a~. - see `A`) then the item at the top of the stack  must  be  a  buffer
stack frame.
<UL>
</UL>Jot supports the usual arithmetic and logical operations and can use  values
in the stack to control programme flow or values can be written to the text.
Addition, for example, pops the top two values and  pushes  their  sum  back
onto the stack (see `O+`).

All arithmetic and comparison operations will  work  with  integer  or  real
values, for mixed operations integers are first converted to reals  and  the
results of such arithmetic is always real. Any attempt to perform arithmetic
on a buffer-type will fail.

</UL><H3><A NAME="ABOUT METASYNTAX">About metasyntax</H3>
The following metasyntax has been used in this user guide:
<UL><LI>a '$' in the first column represents a CLI prompt, the following text is</LI>
something for you to type in response to whatever prompt your CLI uses.

<LI>a '&#062;' in the first column represents a jot prompt, the following  string</LI>
is something you type to the editor.

<LI>A key name in curly  brackets  indicates  that  this  is  a  button,  or</LI>
sequence of buttons to press e.g:
&#062; fred&#123;F8&#125;        - type the word 'fred' then hit the F8 function key
&#062; fred&#123;Shift+F8&#125;  - type 'fred' then hold the Shift key and hit F8
&#062; fred&#123;Ctrl+F8&#125;   - type 'fred' then hold the Control key and hit F8
&#062; fred&#123;Alt+F8&#125;    - type 'fred' then hold the Alt key and hit F8
&#062; 7 12&#123;Esc b x&#125; - type 7 a blank then 12 then hit the Escape key followed by
the letter b followed by the letter x.

<LI>Anything else in angle brackets is intended to represent some  class  of</LI>
command or command argument. e.g. &#060;failingCommand&#062; denotes some  command
that failed, &#060;n&#062; any number, &#060;alphaString&#062; - any number of  alphabetical
characters.

<LI>Something in double angle brackets  (e.g.  &#060;&#060;this&#062;&#062;)  represents  a  jot</LI>
function defined in the startup file - normally you will  be  given  the
key bindings to type in. You will see these mentioned in the user  guide
$&#123;JOT_HOME&#125;/docs/jot_ug.html    and    in    the     startup     scripts
$&#123;JOT_HOME&#125;/coms/startup.jot and $&#123;JOT_HOME&#125;/coms/curses_keys_&#060;TERM&#062;.jot

<LI>Something  in  square  brackets  is  optional  &#091;   -bells&#093;&#091;   -whistles&#093;</LI>
indicating that it's valid to give -bells and/or -whistles  or  neither.
In some cases they are nested - e.g.: &#091; -bells&#091; -whistles&#093;&#093;  -  in  this
case valid usage would be give -bells, -bells and -whistles or neither.

<LI>A list of things, separated by vertical bars ( | ) are valid options, in</LI>
some cases you must give at least on of them  -  the  accompanying  text
should clarify this.

</UL><H3><A NAME="PERCENT-COMMAND SYNTAX">Percent-command syntax</H3>
Typical syntax of a percent command (for details see `percent commands`):
<PRE>
%da=f/example/;
</PRE>
The first character after '%' is the command character,  'd'  in  this  case
defines a buffer. As with many percent commands, the  next  character  is  a
buffer key. The text following the '=' is normally a string argument for the
command.

For most of these commands, all or part of the  text  following  the  equals
sign ( = ) may contain an indirect reference to the  current  line  of  some
other buffer e.g:
<PRE>
%d$=dir /home
%q~=dir '$
</PRE>
or, more usefully:
<PRE>
%q$=env JOT_HOME; m
%q~=dir '$
</PRE>
The main exception is `%E` - the single-quote character (  '  )  being  very
important in unix shell commands so any ' characters are passed  through  to
the CLI unchanged.
 
Historically, these commands occupied a complete command line on  their  own
with no terminating character. This made it difficult to incorporate percent
commands in command sequences, so now they may be terminated by a  semicolon
( ; ) and other commands may follow, in the same line. The  only  exceptions
are comments - where all text to the right of the %% is ignored.

Unfortunately, the string argument may contain semicolons or  apostrophes  -
these are quite commonly occurring characters in various  percent  commands.
Semicolons and apostrophes in the command text can be escaped  by  prefixing
with a backslash ( \ ) thus:
&#062; %da=123\;456\\;789;
this should result in buffer ( A ) being set to  "123;456\;789".  Sometimes,
of course we might want to use an apostrophe as an apostrophe  -  then  this
too can be escaped with a backslash:
&#062; %x=The system\\'s broken - sorry!

Now that's OK for programming jot code, unfortunately users  will  sometimes
want to define parameters  containing  semicolons.  All  parameters  to  jot
function-key functions pass through a a %d - users would find  it  to  be  a
real drag having to remember to escape these every time they are entered. To
avoid this, there is an explicit command terminator syntax that's  only  for
picking up parameters: " -hereEndsThePercentCommand;".

A function requiring a parameter that might include a semicolon  might  pick
it up in buffer ( $ ) like this:
<UL>%d$=##" Insert string&#062;  " -hereEndsThePercentCommand; ...

<LI>A semicolon escaped by a backslash works in %E:</LI>
&#062; %ea=( cd JOT_RESOURCES&#125; \; ls -l ); f/ t.t/

</UL><H3><A NAME="USING HASHTABLES">Using Hashtables</H3>
Hashtables offer a good way of  rapidly  accessing  data  objects  scattered
around in an unstructured mass. Although initially introduced to the  editor
as a way of finding predetermined points in a large file image  (see  `Using
Hashtables to Locate Text`), their range has been expanded  to  calling  jot
functions (see `calling subroutines by name`), fast access  of  large  files
(see `about large files`), accessing large collections  of  moderately-sized
files (see `about large collections of files`) and storage and retrieval  of
generic data (see `using hashtable data`).

All %h commands can refer to hashtables belonging to other buffers e.g.  the
command "%hz=jump fred;'" will search for an entry "fred" in  the  hashtable
associated with buffer z, whereas "%h=jump fred;" will search the  hashtable
in the current buffer. 

</UL><H4><A NAME="USING HASHTABLES TO LOCATE TEXT">Using Hashtables to Locate Text</H4>
The `hashtable add` and  `hashtable  jump`  commands  provide  a  method  of
indexing and rapidly returning to sections on the text image.

Internally, this works by storing internal memory addresses of text  targets
in the hashtable. The hashtable entry points to a  record  descriptor  which
remains constant even if text has been added or removed in the buffer and  a
target-point tag is inserted in the record metadata.

The target is the selected substring at the time when the  hash-table  entry
was first created. Now future changes to the  text  may  change  the  record
containing the target but the target  substring  must  match  the  hashtable
entry. In this context there are two important classes of change to consider
<UL><LI>changes which only move the target to a  new  location  and  changes  that</LI>
delete the target string.

The `hashtable jump` command returns to same focus point as when  the  entry
was created with the `hashtable new` or `hashtable add`  commands.  It  also
maintains the original line number - this might now be wrong  since  changes
to the target buffer may have altered the  actual  line  number  -  but  the
linenumber entry in the hashtable is out of date. If this is a problem  then
use the `hashtable fix` command to update line numbers held in hashtables.

When the context switch happens, the line number in the target buffer is set
to the line number at the time when the entry was created. This may  now  be
incorrect if records have been  added  or  deleted  between  the  hash-table
target points.

The editor automatically adjusts hashtable entries when changes  have  moved
the target. It offers several options for situations when the target  string
has been deleted.

The simplest method is to  make  the  target  buffer  readonly  (the  buffer
containing the  target  string  -  see  `%b=readonly`).  Making  the  buffer
ReadOnly is a simple and totally effective but it is quite restrictive.

Another option is to automatically destroy the hashtable when target records
are deleted - this is appropriate when the usage  implies  that  any  change
requires a hashtable rebuild - see `hashtable create`.

Another option is to protect records  containing  the  target  strings  from
deletion - see `hashtable create`.

Another option is for the hashtable target points to be adjusted to point to
the next available point in the text - see adjust in  `hashtable create`.

Finally, the default option,  is  to  just  remove  the  hash-table  entries
pointing to deleted targets, this is the default behaviour - see  delete  in
`hashtable create`.

For examples of %h=jump - look at $&#123;JOT_HOME&#125;/coms/qr.jot (see `qr.jot`).

</UL><H4><A NAME="USING HASHTABLE DATA">Using Hashtable data</H4>
The primary focus for arithmetic and logical operations is  the  stack  (see
`about the operand stack`) - values and strings can be placed on the  stack,
manipulated and either written to some buffer or used to  control  programme
flow. The `hashtable data` command is essentially the declaration of a  data
object. The value of this object can be copied to and from the  top  of  the
stack.

Once defined by the hashtable data command, a value can  be  assigned  using
the `OV` command which pops the stack and  copies  the  value  to  the  data
object.

Note that the hashtable data command does not require the specification of a
data type - the type of data (an integer value, a real value or a string) is
defined at the time when a value is assigned. In  fact  it  is  possible  to
change the type of a data object any number of times.

The value can be retrieved using the `OQ` command, essentially  the  reverse
of OV, the value is copied to a new stack frame and pushed onto the stack.

</UL><H3><A NAME="THE JOT DEBUGGER">The jot debugger</H3>
The editor has various features designed for  the  monitoring  of  execution
flow and the location and analysis of bugs. There  are  various  methods  of
probing the internal state of the editor and various methods  for  selecting
break points. It supports a simple single-step debugger with various options
for controlling the step range and the amount of  information  displayed  at
each step - see `About jot debugging`. The break point can be defined in the
following ways:
<UL><LI>explicitly by inserting the `T` command in the code what this does is to</LI>
set the trace vector (see `%s=trace` and `%s=tracedefault`),
<LI>by setting the command counter - see `%s=commandcounter` or</LI>
<LI>by selecting one of a set of predefined event classes - see `%s=trace`.</LI>

</UL>The T command is easily inserted into the source code of any  script,  macro
or command line. Where this is not selective enough, the T  command  can  be
made conditional e.g.: ... (v/fred/t, ) ... will only trigger the trap  when
the text at the current character matches the string "fred".

The command counter method is useful when a  data-sensitive  failure  occurs
deep into many re-iterations of programme loops. In order to use this method
successfully it is first necessary to identify the command count just before
the point of failure. The `%s=verbose` command  can  be  used  to  call  for
failure reports from all failing commands,  along  with  associated  command
counts. Under these  circumstances  many  thousands  of  messages  might  be
generated but, normally,  it  is  only  the  last  two  or  three  that  are
significant. It's a good plan to reduce the size of the display window  (see
`WindowShrink`) in order to maximize the size of the  console  area  of  the
screen. It may even be necessary to run in -tty mode  so  that  all  of  the
messages can be scanned.

Finally, one can set a breakpoint to go off every time  a  particular  event
occurs:
<UL><LI>a new line is read from the command stream,</LI>
<LI>a new script has started (see `%R`),</LI>
<LI>a new macro-command has been called,</LI>
<LI>A Ctrl+C interrupt has been received,</LI>
<LI>a command failure has occurred or</LI>
<LI>every new command.</LI>

</UL><H3><A NAME="JOT FOR EXPERIENCED ECCE USERS">Jot for experienced ecce users</H3>
The first, most obvious difference between jot and ecce is  that  jot  is  a
screen editor - it maintains a window as an accurate reflection of the  what
the file image is currently looking like.

The next significant  difference  is  that,  whereas  ecce  would  only  use
printing characters for controlling the editor, jot also  utilizes  function
keys and, where available, the numeric and mid keypads.

Internally,  the  structure  is  quite  different,  jot  does  not  use  the
buffer-gap structure  but  utilizes  a  less  efficient  but  more  flexible
record-descriptor structure.

Comparing the command set of ecce with jot, we see a few old favourites have
been culled (D, T, U  have  been  abolished  or  reassigned  new  meanings).
However, for the percent commands, the cull is more like a total bloodbath -
only %A, %C, %I and %O remain in anything like their original forms.
<UL><LI>`A` - can now abstract to the nearest character (see `N`), and  has  new</LI>
'+', '-', '.', '*' and '&' qualifiers.
<LI>`B`, `C` - identical.</LI>
<LI>D Abolished.</LI>
<LI>`E`, `F`, `G` - pretty much unchanged.</LI>
<LI>`H` - has new '*' qualifier.</LI>
<LI>`I`, `J`, `K` and `M` - unchanged.</LI>
<LI>L - abolished - use `R`- instead.</LI>
<LI>`N` has new '.' qualifier for abstraction to nearest character.</LI>
<LI>`M` - has new '*' qualifier (move window).</LI>
<LI>O - Reassigned - now prefix for `stack Operations`.</LI>
<LI>`P`, `Q`, `R` and `S` - unchanged.</LI>
<LI>`T` Reassigned as Trace point, traverse replaced by f/&#060;string&#062;/- .</LI>
<LI>U - abolished.</LI>
<LI>`V` - unchanged.</LI>
<LI>`W` - new command - refresh Window.</LI>
<LI>X - was macro-X call, now abolished.</LI>
<LI>`Y` - was macro Y call, now Y command (move in column).</LI>
<LI>`Z` - was macro Z call, now zoom (i.e. change current buffer).</LI>
<LI>`%A` - Now accepts exit status and exit message.</LI>
<LI>`%C` - essentially unchanged.</LI>
<LI>`%D` - Reassigned, now defines a one-line macro/text buffer.</LI>
<LI>`%F` - Reassigned - now regular-expression search.</LI>
<LI>`%G` - Reassigned - now defines (Gets) multi-line macro/buffer.</LI>
<LI>`%H` - New Command - for hashtable maintenance.</LI>
<LI>`%I` - unchanged, new options.</LI>
<LI>`%L` - Reassigned - (case sensitivity set by %S)  now  defines  terminal</LI>
line length.
<LI>`%M` - Reassigned prints message to console area.</LI>
<LI>%N - Abolished.</LI>
<LI>`%O` - Unchanged, new options.</LI>
<LI>`%Q` - Reassigned - now system Query.</LI>
<LI>`%R` - Reassigned - now Run a command script (file).</LI>
<LI>`%S` - Replaced by `Z` command, %S now System interaction.</LI>
<LI>%T - Abolished.</LI>
<LI>`%U` - Reassigned - (now use %S to set case  sensitivity)  now  reverses</LI>
last substitution.
<LI>`%W` - Reassigned - now assigns buffers to windows.</LI>
<LI>`%X` - Reassigned - now prints specified message in the console area and</LI>
eXits.
<LI>%Z - Abolished.</LI>

</UL><H2><A NAME="EDITOR COMMANDS">Editor commands</H2>
JOT has the  following  commands,  meta-commands  and  modifiers,  most  are
capable of failing in some way, failures normally result in the  raising  of
the failure flag (see  `success,  failure  and  errors`),  this  can  affect
execution flow:
<UL><LI>`A` - Abstract (remove or copy) all Text From Note Point (see `N`).</LI>
<LI>`B` - Break Line At Current Character e.g. b2</LI>
<LI>`C` - Change Case e.g. c5</LI>
<LI>`E` - Erase bytes &#091;defaults to 1&#093; e.g. e5</LI>
<LI>`F` - Find Substring e.g. f/fred/</LI>
<LI>`G` - Get (read) Some Lines From Terminal e.g. g3</LI>
<LI>`H` - Here (copy Text Buffer Here) e.g. hq</LI>
<LI>`I` - Insert Substring e.g. i/fred/</LI>
<LI>`J` - Join This Line With Next/previous Line(s) e.g. j-3</LI>
<LI>`K` - Kill (delete) record(s) e.g. k</LI>
<LI>`M` - Move To A New Line e.g. m</LI>
<LI>`N` - Note This Point In Text For A Later Abstract Operation e.g. n</LI>
<LI>O - `Stack Operations`</LI>
<LI>`P` - Print Line(s) e.g. p9</LI>
<LI>`Q` - Qualify (tests next chr. for membership of string) e.g. q/a-zA-z/</LI>
<LI>`R` - Move Cursor Right e.g. r</LI>
<LI>`S` - Substitute current substring for given string e.g. s/fred/</LI>
<LI>`T` - enter (Trace) debug (single-step) mode e.g. t</LI>
<LI>`V` - Verify (tests immediate for match with substring) e.g. v/fred/</LI>
<LI>`Y` - Move Cursor In Y Axis e.g. y3</LI>
<LI>`Z` - Zoom to Another Buffer e.g. zq</LI>
<LI>`(` - Block start e.g. (f/fred/s/jim/)0</LI>
<LI>`)` - Block end e.g. (f/fred/s/jim/)0</LI>
<LI>`,` - Else clause e.g. f/fred/, f/jim/.</LI>
<LI>`\` - Reverse status of previous command e.g. v/fred/\</LI>
<LI>`?` - Ignore status of previous command e.g. f/fred/?.</LI>
<LI>% - Mainly housekeeping - see `percent commands`</LI>

</UL><H3><A NAME="R">R</H3>
<PRE>
R&#091;n&#093; - shift Right by n characters (bytes if unicode support is turned 
</PRE>
off - see `Unicode - the gruesome details`).
<UL>
</UL>Move character pointer n&#091;1&#093; places to the right, it  fails  and  raises  the
failure flag if there is an attempt to go past the  end  of  the  line.  For
non-unicode characters one byte is equivalent to one character. For  unicode
characters, if unicode support has been turned  off  (see  the  `%b=unicode`
command) the current-character pointer may be left pointing to a mid-unicode
byte. See also `OR` command and `about unicode`.

</UL><H3><A NAME="M">M</H3>
<PRE>
M&#091;&#091;=|-&#093;n&#093;|&#091;*&#091;-&#093;&#093; - Move to start of specified line.
</PRE>
<UL><LI>M moves forwards by one line.</LI>
<LI>M&#060;n&#062; Moves forwards by n lines.</LI>
<LI>M* Moves forwards sufficient lines to view next page on screen.</LI>
<LI>M- moves back by 1 line.</LI>
<LI>M-&#060;n&#062; moves back by n lines.</LI>
<LI>M*- (or M-*) Moves back sufficient lines to view previous page on screen.</LI>
<LI>M0 moves to last line of file.</LI>
<LI>M-0 move to first line of file.</LI>
<LI>M+&#060;n&#062; moves to absolute line no. n</LI>

</UL>The command raises the failure flag if there is an attempt to move past  the
last line or before the first line of the file.

</UL><H3><A NAME="Y">Y</H3>
<PRE>
Y&#091;&#091;+|-&#093;n&#093;|&#091;*&#091;-&#093;&#093; - move in column (Y axis) by &#091;n&#093; lines.
</PRE>
Note - there is a special case:
<PRE>
Y0 - Does not shift focus but sets Y-command column to the current chr.
</PRE>

Similar to the `M` command except that it up and down in a column of text.

If it passes through a line that is  too  short  to  maintain  the  columnar
movement, the cursor is left at the end of the line but the original  column
number remains stored internally. If some subsequent invocation of Y  passes
through lines of  sufficient  length,  the  original  columnar  movement  is
restored.

The special case y0 will reset the internally-stored column number. It  does
not affect the cursor position but causes the *next* y command  to  redefine
the column number.

</UL><H3><A NAME="E">E</H3>
<PRE>
E&#091;-&#093;&#091;&#060;n&#062;&#093; - Erase n bytes to the right &#091; or left&#093; of the cursor.
</PRE>
<UL>
</UL>Erase next&#091;previous&#093; n&#091;1&#093; bytes. If n is finite and would cause  the  cursor
to go out of bounds the failure flag is  raised.  With  a  positive  arg,  E
deletes the bytes from the currently-selected character  and  characters  to
it's right. With a negative arg, it deletes bytes  from  characters  to  the
left of the current chr.

The programmer must be aware that one byte is  not  necessarily  a  complete
character - see `about unicode`.

</UL><H3><A NAME="P">P</H3>
<PRE>
P&#091;-&#093;&#091;&#060;n&#062;&#093; - print line(s).
</PRE>
<UL>
</UL>Prints (displays in the console area) the next&#091;/previous&#093; n&#091;1&#093; lines.  If  n
is specified, and is greater than 1, or less than -1, then the current  line
is set to the last line printed. If the value of n  would  cause  it  to  go
outside the range of the current buffer then the failure flag is raised.

</UL><H3><A NAME="W">W</H3>
<PRE>
W - redraw Window.
</PRE>
<UL>
</UL>Forces a redrawing of the Window - by default the  window  is  only  redrawn
when it re-prompts for a new command  string  (at  a  breakpoint  or  normal
command-entry prompt) - this command can be included in a complicated  macro
or command script to allow the user to review progress or for debugging.

</UL><H3><A NAME="F">F</H3>
<PRE>
F&#091;-&#093;&#091;range&#093;&#091;&#060;delim&#062;&#060;string&#062;&#060;delim&#062;|'&#060;key&#062;&#093;&#091;-&#093;&#091;rpts&#093; - Find
</PRE>
<UL>
</UL>Search text for specified string. If found the substring is highlighted  and
becomes the selected substring. -  see  `About  the  current  character  and
substrings`

The F command takes parameters which specify the search string, a range  and
repeat count.

By default JOT starts off  in  it's  case  insensitive  mode,  this  can  be
modified by the '%S=case' command.

If there is no currently-selected no substring, the  search  starts  at  the
current character. If there is a substring, the search starts one characters
after (or one character before, in the case of F-) the start of the  current
substring.

For unsuccessful forwards-looking multi-line searches the current  character
is  left  at  the  start  of  the  last  searched  line.  For   unsuccessful
backwards-looking searches current character is  left  at  the  end  of  the
last-searched line.

For unsuccessful single line searches (i.e. when the range parameter is  set
to 1) the current character pointer is left unchanged for both forwards  and
backwards-looking searches.
<UL>
</UL>Parameters:

<UL><LI>1 Direction, a '-' will cause it to search back towards the start e.g.</LI>
<UL>f-/abc/
</UL></UL>
<UL><LI>2 Range  specifies  the  max.  no.  of  lines  to  search  (defaults  to</LI>
unlimited). e.g. f3/abc/ -  this  will  search  the  next  three  lines,
including any of the current line to the right of the cursor.
</UL>
<UL><LI>3 The string can be a literal string delimited by  any  non-alphanumeric</LI>
ASCII character that does not appear in the string  e.g.  f"abc",  also,
the ' character cannot be used - see `about  command  parameters`.  N.B.
unicode characters cannot be used as delimiters.

The second delimiter may be omitted is there are no further commands  or
modifiers on the command line - e.g. f/monday

Alternatively, the '&#060;key&#062; form will search for a match  to  the  current
line of the nominated buffer e.g. f'@ - see `about command parameters`.

Finally, if no find string is specified,  then  it  uses  the  last-used
literal search string.

</UL>e.g: in the following, the first command finds the next occurrence  of  the
<UL>string 'fred', the next find locates the string indicated  by  the  current
record of the $ buffer and, finally, it locates the next  instance  of  the
string 'fred'.
&#062; f/fred
&#062; f/'$
&#062; f
<UL>
</UL><LI>The optional hyphen after the search string causes the current-character</LI>
<UL>pointer to be left after the end of the substring. By default it is left
at the first character of the substring.
&#062; f/fred/-
</UL></UL>
<UL><LI>4 The final parameter is used to repeat the search. e.g.  f/abc/23  will</LI>
stop at the 23rd. occurrence of "abc".

</UL>See  also  `%F`  -  regular-expression  search  and  `%S`  to  change   case
sensitivity.

</UL><H3><A NAME="T">T</H3>
<PRE>
T - Trace
</PRE>

This sets the trace vector to the  value  specified  by  the  default  trace
vector. By default the trace vector is  0  (no  tracing  activity)  and  the
default trace vector is set to  Trace_Stack,  Trace_Print,  Trace_Break  and
Trace_AllCommands this means:
<UL><LI>It will report the stack contents at each trace point,</LI>
<LI>it will print the current line of the  current  buffer  at  every  trace</LI>
point,
<LI>it will enter an execution breakpoint at every trace point and</LI>
<LI>the trace point will be every command.</LI>
</UL>
Alternatively, the trace vector can be set  explicitly  with  the  `%s=trace`
command. The default trace vector can be redefined with `%s=tracedefault`.

See also `about jot debugging` and `the jot debugger`.

</UL><H3><A NAME="Q">Q</H3>
<PRE>
Q&#091;-&#093;&#091;&#060;delim&#062;&#060;string&#062;&#060;delim&#062;|'&#060;key&#062;&#093; -  Qualify
</PRE>
Tests for existence of any  of  a  specified  set  of  ASCII  characters  in
substring - n.b. This does not currently work for unicode characters.

The argument string can contain any ASCII characters but not unicode.
<UL>
</UL>The character at &#091;or before&#093; the current character position  is  matched  to
the character set specified by the string parameter, if one of the specified
set of characters matches then the command returns  successfully,  otherwise
if reports a failure. The Q command is invariably case sensitive and has  no
effect on the text file image.

If, instead of the &#060;delim&#062;&#060;string&#062;&#060;delim&#062; syntax, the '&#060;key&#062; syntax is used,
then the qualifying string is in the current line of the specified buffer.

The string may be a simple list of all allowable characters, or may  specify
a range of ASCII characters ordered by their ASCII codes, to  match  to  the
literal '-' character it should be the first  or  last  in  the  string  for
example:- Q/0123456789/ Will match to any digit. Q/0-9/ Will do the same but
saves typing. Q/0-9+-/ Will match to any digit or the '+' or '-' characters.
Q/0-9A-Fa-f/ Will match to any Hex digit.

</UL><H3><A NAME="V">V</H3>
<PRE>
V&#091;-&#093;&#091;string&#093; - Verify string.
</PRE>
<UL>
</UL>Verify - tests text at current character position for match with string.

If the given string matches the substring to the right of  the  cursor  then
the substring is highlighted and becomes the `About  the  current  character
and substrings`. If not then the failure flag is raised. Correspondingly, V-
verifies the text to the left of the cursor.

</UL><H3><A NAME="C">C</H3>
<PRE>
C&#091;-&#093;&#091;n&#093; - Change case.
</PRE>
<UL>
</UL>Change case of next &#091;/previous&#093; n characters. If n is  specified  and  would
cause the cursor to go out of bounds the failure flag is raised.

Note that the C command has no affect on unicode characters.

</UL><H3><A NAME="I">I</H3>
<PRE>
I&#091;-&#093;&#091;string&#093;&#091;n&#093; - Insert substring
</PRE>
Inserts specified substring before current character.
<UL>
</UL>The optional '-' parameter only affects the position of  the  substring  end
pointer on completion - normally the cursor is immediately after the end  of
the inserted substring I- causes it to be at the start.

</UL><H3><A NAME="S">S</H3>
<PRE>
S&#091;-&#093;&#091;&#060;delim&#062;&#060;string&#062;&#060;delim&#062;|'&#060;key&#062;&#093; - Substitute
</PRE>
Replace the currently-selected string with the given string.
<UL>
</UL>If a substitute  string  is  defined  then  this  is  replaces  the  current
substring,  if  no  substitute  string  is  specified  then  the  last  used
substitute string is used.

When the '&#060;key&#062; syntax is used, the substituted string  is  taken  from  the
current line of the specified buffer.

This command normally only fails when the current buffer does not  currently
have a valid substring `About the current character  and  substrings`  (e.g.
following a F, T V or a previous S command) - when it fails the failure flag
is raised.

</UL><H3><A NAME="B">B</H3>
<PRE>
B&#091;-&#093;&#091;n&#093; - Break line.
</PRE>
<UL>
</UL>Where n is an optional (defaults to  1)  repeat  count,  on  completion  the
character pointer is left at the beginning of the second line (i.e. it still
points to the same character), except if a negative repeat count is  entered
<UL><LI>zeros are not allowed for break counts.</LI>

A negative repeat count will break the line the same  number  of  times  but
will leave the character pointer at the end of the first half line.

</UL><H3><A NAME="G">G</H3>
<PRE>
G&#091;&#060;n&#062;&#093; - Get 
</PRE>
Read a new line(s) of text or single character from the keyboard.
<UL>
</UL>Use this to key in new text above the current line, the parameter  sets  the
number of lines to be input or you may terminate with a control+C or a colon
':' at the beginning of an otherwise empty line.

By default it prompts with "&#062; " but you may define the prompt  string  using
`%s=prompt`.

If a linecount is specified and an early exit is forced,  then  the  failure
flag is raised.

See also the `%G` command, which reads lines  from  the  current  script  or
macro and the `OG` command, which reads single characters to the stack.

</UL><H3><A NAME="J">J</H3>
<PRE>
J&#091;-&#093;&#091;n&#093; - Join
</PRE>
Joins current line with next (or previous) line.
<UL>
<LI>J Joins the current line with the next line</LI>
<LI>J- Joins the current line with the previous line</LI>
<LI>J&#060;n&#062; joins the next n+1 lines</LI>
<LI>J-&#060;n&#062; joins the previous n+1 lines</LI>

</UL>If join runs out of lines (because it's at the start/end of the buffer) then
the failure flag is raised.

</UL><H3><A NAME="K">K</H3>
<PRE>
K&#091;-&#093;&#091;n&#093; - Kill i.e. delete line(s).
</PRE>
<UL>
</UL>This completely removes lines and there is no way of getting them back. If n
is specified and finite and it runs out of lines to kill, then  the  command
fails. K0 deletes the current line and all subsequent lines, K-0 deletes the
current line and all previous lines.

K- deletes the current line and leaves the cursor at  the  begining  of  the
line above, similarly K-n deletes the current line and  up  to  (n-1)  lines
above leaving the cursor at the begining of the line above the last  deleted
line. If the first line was deleted, then the cursor is left at the begining
of the line following the original current line.

Note that there must always be at least one line in a  buffer.  To  maintain
this situation, an instruction to kill the last record in  the  buffer  will
only erase all the text leaving an empty record - it will also fail.

</UL><H3><A NAME="N">N</H3>
<PRE>
N&#091;.&#093; Note
</PRE>
Note = Note line &#091;and character&#093; number for later abstract.

This sets the start point of one or more lines of text  to  be  moved  by  a
later abstract `A` command. 

Without the ( . ) modifier, complete lines are  removed  by  the  subsequent
abstraction. 

With the ( . ) modifier, all lines and characters are abstracted between the
current character position when the N command was given to that at the  time
of the A command.

See also `A` and `H` commands.

</UL><H3><A NAME="A">A</H3>
<PRE>
A&#060;key&#062;&#091;+|-|.&#093;&#091;*|&&#093; - Abstract
</PRE>
Abstracts (moves) text from note point to current character (see  `N`)  into
the nominated buffer.
<UL>
</UL>If the whole-line abstraction flag is  set  (see  `N`  command),  then  only
complete lines are moved.

The optional '+' qualifier places the abstracted text after the end  of  any
preexisting text in the destination buffer, '-' similarly places  it  before
the start '.' places at the current character in the destination buffer.  If
none of these qualifiers are specified then the buffer is cleared before the
new text is abstracted. The current  character  pointer  of  the  buffer  is
always left at the beginning of the of the last line of abstracted text.

The optional * qualifier replaces the abstracted  text  with  an  equivalent
number of spaces, this feature is useful when editing tables  and  pictorial
text.

The optional & qualifier copies the text without changing the original. This
is essential if abstracting from a readonly buffer - see `%b=readonly`.

The two valid optional qualifiers must follow the buffer key but not in  any
particular order.

If the abstraction fails (typically because no note-point is set)  then  the
failure flag is raised.

See also `H` and `N` commands.

</UL><H4><A NAME="ABSTRACTION OPTIONS">Abstraction options</H4>
Abstraction in jot is similar to ecce - by default, the n (note) and  the  a
(abstract) commands abstract only complete lines.

By default jot abstracts complete lines - like ecce. By adding the .  option
to the note command it abstracts to the nearest character.

Cumulative abstraction - by default the destination buffer is first  cleared
of any preexisting text only  the  abstract  appears  in  the  buffer  after
abstraction.
<UL><LI>The + qualifier adds the now text to the end of any preexisting text  in</LI>
the destination buffer.
<LI>The - qualifier prepends  the  abstracted  text  to  the  start  of  any</LI>
preexisting text.
<LI>The .  qualifier  inserts  the  new  text  at  the  destination  buffers</LI>
current-character point.
</UL>
Non-destructive abstraction. By default text  is  removed  from  the  source
buffer. For non-cumulative abstraction  it's  easy  enough  to  restore  the
abstract it immediately after but this process sets an internal  marker  tag
indicating that the buffer has been modified - this is not  always  helpful.
The '&' qualifier will abstract without changing the source text or  setting
the marker tag.

</UL><H3><A NAME="H">H</H3>
<PRE>
H&#060;key&#062;&#091;&#060;count&#062;&#093;&#091;*&#093; - copy Here
</PRE>
Contents of specified buffer (the source buffer) is copied to current buffer
(the destination buffer) either to the current character position  or  above
the current line.  There  is  a  status  flag  in  the  source  buffer  that
determines which.

If the source buffer was itself defined by  abstraction  part  lines  (using
`N`.) then the buffer is inserted at the current character.  If  the  source
buffer was defined in any other way (abstraction with  N,  `%I`  or  a  `%Q`
query) then the source text is inserted immediately above the current line.

The status flag is invisible except in the "wholeRecords" line of  a  `query
buffer` report.

The effect of the optional count is to insert the text that many times.

The effect of the optional * qualifier is to overlay the original text  with
the new. This feature is intended  for  maintenance  of  column  spacing  in
whitespace-delimited tables and line-drawings.

See also `N` and `A` commands.

</UL><H3><A NAME="Z">Z</H3>
<PRE>
Z&#060;key&#062; - Zoom (change focus to nominated buffer)
</PRE>

Changes the current buffer to the one identified by the buffer key.

The the key for the  current  buffer  is  displayed  in  the  editor  prompt
following the line number, it is also be displayed in the  window  separator
lines (see `%w` command).

See also `OB` and `OZ`

</UL><H3><A NAME="(">(</H3>
<PRE>
( - Block start
</PRE>
<UL>
</UL>The block of commands must be terminated by a ')', it may contain any number
of valid jot commands, including sub blocks. See also `)` and  `jot  command
structure`.

</UL><H3><A NAME=")">)</H3>
<PRE>
)&#091;&#060;n&#062;&#093; - Block end.
</PRE>
<UL>
</UL>This terminates the current block, if a repeat count ( &#060;n&#062;  )  is  specified
then the block is repeated that many times or until the block fails, if  the
repeat count is zero then the block only exits when something in the command
sequence fails but, overall, a zero-repeat block never fails.

If repeat count finite or  not  given,  then  any  failure  in  the  command
sequence is passed on upwards. See also `(` and `jot command structure`.

</UL><H3><A NAME=",">,</H3>
<PRE>
(&#060;anyNumberOfCommands&#062;, &#060;failureHandler&#062;) - Failure handler.
</PRE>
<UL>
</UL>The commands following the comma are only executed when some earlier command
has failed. When a  command  fails,  control  is  transferred  to  the  code
following the comma - the failure handler. A single block can containing any
number of failure handlers, each picking up the failure condition  from  the
previous - this is effectively an if, else-if, else-if ... structure.

</UL><H3><A NAME="\">\</H3>
&#060;cmd&#062;\ - Reverse status of command or block.
<UL>
</UL>If the previous command failed and raised the failure flag, then this resets
it, correspondingly, if the previous command did not fail then  the  failure
flag is raised.

Note, \ only applies to the command or block *immediately* before it.

If, for example, we want to insert abc in any case except  when  it  already
exists:
<PRE>
(v/abc/\i/abc/,)
</PRE>

This is also useful for inverting the status of blocks, e.g.:
<PRE>
(f1/fred/\ f1/jim/ f1/bill/\)\
</PRE>
The block will succeed if the current line contains either if the substrings
"fred", "jim" or "bill".

</UL><H3><A NAME="?">?</H3>
 &#060;validCommand or block&#062;? - ignore status of command or block.
<UL>
</UL>This has the effect of lowering the failure flag irrespective of the outcome
of the previous command.

Note, ? only applies to the command or block *immediately* before  it.  Thus
in the sequence m99p? the ignore-failure  command  applies  only  to  the  p
command - not m99.

You can also follow ? with \ to ensure that a command *always* fails -  this
is useful when a failure handler needs to exit a repeated block.

See also `\`, `Jot command structure` and `success, failure and errors`.

</UL><H3><A NAME="STACK OPERATIONS">Stack Operations</H3>
The editor maintains an evaluation stack  used  for  numerical  and  logical
operations.

A stack frame may contain one  of  three  datatypes,  an  integer  value,  a
floating-point quantity or a buffer. All buffers on  the  stack  are  tagged
with the buffer key '~'), as values are retrieved, there is a  simple  check
to ensure compatibility with the  expected  datatype,  in  the  event  of  a
mismatch, execution halts with an error message.

If a stack-based buffer is the current buffer, numeric values may  be  added
to the stack without  affecting  the  status  of  the  buffer.  You  cannot,
however, return to the buffer with  a  Z~  or  OZ  command  (and,  also  the
`hashtable jump` command) unless the buffer is at the top of the stack. This
command sequence, for example, will fail:
<PRE>
%q~=date; m(oidr)3 z.z~
</PRE>
But this one's OK:
<PRE>
%q~=date; m(oidr)3 z.(oo/%d:/r0)3z~
</PRE>

The stack size is by default limited to 100  slots  (see  `-stacksize`)  any
push operation will fail abruptly if there are already  100  on  the  stack.
Similarly, any pop operation will fail if there are no values on the stack.

The arithmetic operations (O+, O-, O*, O/, O=. O&#060;  and  O&#062;)  work  for  both
integer or real (floating-point) quantities. If one item is integer and  the
other is real then the integer operand is first converted to  real  and  the
result, where applicable, is also real.
<UL>
<UL><LI>`O+` - Add.</LI>
<LI>`O-` - Subtract.</LI>
<LI>`O*` - Multiply.</LI>
<LI>`O/` - Divide.</LI>
<LI>`O%` - remainder</LI>
<LI>`O~` - increment - add 1 to item at top, fail if result=0.</LI>

<LI>`O|` - OR - performs bitwise OR of top two items in stack.</LI>
<LI>`O&` - AND - performs bitwise AND of top two items in stack.</LI>
<LI>`O!` - NOT - bitwise NOT.</LI>

<LI>`O?` - dump contents of stack - stack contents are not changed.</LI>
<LI>`O#` - duplicate top of stack.</LI>
<LI>`O=` - fail if top two items on stack not equal, top item is destroyed.</LI>
<LI>`O&#060;` - test that item at top greater than next one down</LI>
<LI>`O&#062;` - test that item at top less than next one down</LI>

<LI>`OB` - push pointer to current buffer onto stack.</LI>
<LI>`OE` - push Extent of current record/substring onto stack.</LI>
<LI>`OF` - push line no. of First line in window.</LI>
<LI>`OC` - push current chr. no. onto stack.</LI>
<LI>`ON` - push current line no. onto stack.</LI>
<LI>`OP` - push mouse cursor Position no. onto stack.</LI>
<LI>`OU` - set sUbstring length from stack.</LI>
<LI>`OA` - push rAndom number onto stack.</LI>
<LI>`O.` - set current line number to &#060;top of stack&#062;.</LI>
<LI>`OL`&#060;n&#062;&#091;.&#060;n&#062;&#093; - Literal integer (optionally fp) value is pushed onto stack.</LI>
<LI>`OI`&#091;C|D|O|X|F&#093; - formatted conversion from text - result to stack.</LI>
<LI>`OG` - formatted character input - prompts and reads one character to stack.</LI>
<LI>`OO` - formatted Output - pop value, using given string.</LI>
<LI>`OV` - Value - defines hashtable data item from stack.</LI>
<LI>`OQ` - Query, query a hashtable value and push value onto stack.</LI>

<LI>`OR` - index Right (left if -ve) by no. of characters popped off stack.</LI>
<LI>`OM` - Move (backwards if -ve) no. of lines popped off stack.</LI>
<LI>`OZ` - Zoom (change to buffer) key popped off stack.</LI>

<LI>`OK` - Kill - delete top of stack.</LI>
<LI>`O@` - reset stack and random number generator.</LI>
<LI>`OS` - Swap 1st and 2nd items of stack.</LI>

<LI>`OW` - scrolls Window view by no. lines set in top of stack.</LI>

<LI>See also `query stack`</LI>

</UL></UL><H4><A NAME="OL">OL</H4>
<PRE>
OL&#060;intVal&#062; - push an integer Literal onto stack.
</PRE>
or
<PRE>
OL&#060;floatingPointValue&#062; - push a floating-point Literal onto stack.
</PRE>
 
The specified value is placed on the top of the stack. e.g:
&#062; ol123
This pushes the number 123 onto the top of the stack.

The literal can be modified by prefixing with x or o to specify the  integer
in Hex or Octal respectively. eg:
&#062; ol1024
&#062; olx100
&#062; olo400

Note that the usual C-language format 0xnnn or 0onnn are not supported  here
as these are syntactically indistinguishable from an OL0 followed by an X or
another O command.

For floating-point (real) values the only permissible syntax is  &#060;nnn&#062;.&#060;mmm&#062;
eg:
&#062; ol1234.56789

</UL><H4><A NAME="O&">O&</H4>
<PRE>
o& - bitwise AND
</PRE>

The top two items in the stack must be integers. These are removed  and  the
bitwise AND of the two values is added.
<UL>
</UL><H4><A NAME="O|">O|</H4>
<PRE>
o| - bitwise OR
</PRE>

The top two items in the stack must be integers. These are removed  and  the
bitwise OR of the two values is added.
<UL>
</UL><H4><A NAME="O!">O!</H4>
<PRE>
o! - bitwise NOT
</PRE>

The item at the top of the stack must be an integer. It is replaced  by  the
bitwise NOT of the original bit pattern - i.e. 0's are changed  to  1's  and
1's are changed to 0's.
<UL>
</UL><H4><A NAME="O?">O?</H4>
<PRE>
O? - List contents of stack.
</PRE>

This is useful for debugging - dumps the entire contents of the stack to the
console - see also `query stack`.

</UL><H4><A NAME="OG">OG</H4>
<PRE>
OG - reads one character from console and pushes character onto stack.
</PRE>

<UL>This prompts using the prompt string defined by `%s=prompt` and  reads  one
character that is pushed onto the stack as a wide-format unicode  character
(see `about unicode`).

If unicode-support is disabled (see `%b=unicode`) then  unicode  characters
arrive as a series of values in the range  128-255  requiring  multiple  OG
calls. Jot does not offer any  method  of  determining  where  one  unicode
character ends and the next begins when a series of unicode characters  are
entered in this way.

</UL><H4><A NAME="OO">OO</H4>
<PRE>
OO&#060;delim&#062;&#060;formatString&#062;&#060;delim&#062; - Output using sprintf format string.
</PRE>

Output the value at top of stack using the format  string.  

If the current buffer has a substring following a  command  that  defines  a
substring (eg: F, S, I, OI or a previous OO command), then the substring  is
replaced by the sprintf output. This sequence will first insert 999 and then
immediately change it to 123:
&#062; ol123 ol999 oo/%d/ oo/%d/
this will give both numbers - the r-r removes the substring  marker  without
affecting the cursor position:
&#062; ol123 ol999 oo/%d/ r-r oo/%d/

When writing unicode characters, the %c format  string  *must*  have  the  l
(long-format) modifier to convert the wide-format  unicode eg:
&#062; ol65r0boo/%c simple ASCII character/r0
&#062; ol163r0boo/but the unicode %lc requires the l modifier with %%c/
Note that the `OG` command can add a unicode character too the stack.

For numeric values the use of this modifier is recommended but a  simple  %d
seems to work on most systems for integers of not more then  32  bits  eg  -
this generally seems to work;
&#062; ol123456789r0boo/%d/
but use %ld to avoid truncation:
&#062; ol123456789123456789r0boo/%ld/

On completion, the current character points  to  the  end  of  the  inserted
substring.

Examples:
&#062; ol12345 oo"The number you first thought of is %-10d"
&#062; %q~=buffer; f/pathName = /-bza oo/The pathname is %s/ok
&#062; off za oo/%8f/

</UL><H4><A NAME="OQ">OQ</H4>
<PRE>
OQ&#060;delim&#062;&#060;key&#062;&#060;delim&#062; - Value, push value from hashtable onto stack.
</PRE>

The delimitedKey must match the key used to create a  hashtable  entry  with
the `hashtable data` command. The OV operation pops the stack and copies the
top frame value to the hash-table entry, deleting any previously-held  value
associated with that hashtable entry. A copy  of  the  frame  can  later  be
returned to the top of stack with the `OQ` command.

In the event of an unmatched hashtable key or an empty stack, the OV command
fails. Note that there is no typing in the `hashtable data`  command  so  OV
just takes whatever datatype happens to be at  the  top  of  the  stack  and
copies it to the data object.

If the top item on the stack is a buffer, then a complete copy  of  all  the
buffer records is made and associated with the data object, ignoring most of
the other buffer attributes like PathName, header or Footer.

For example:
&#062; %h=data fred;  %%Creates the entry associated with the keyword 'fred'
&#062; ol123
&#062; ov/fred/       %%Moves the top stack frame (integer 123) to the hashtable.
<PRE>
...
</PRE>
&#062; oq"fred"       %%Queries (restores) the stack frame 'fred'.
&#062; ol456
&#062; ov,fred,       %%Redefines  the value of the data object 'fred'.

</UL><H4><A NAME="OV">OV</H4>
<PRE>
OV&#060;delim&#062;&#060;key&#062;&#060;delim&#062; - Query - pops stack and sets value in hash-table.
</PRE>

The key must match one used to create a data entry with the `hashtable data`
command with a value previously  defined  with  the  `OV`  command.  The  OQ
command copies the contents of the hashtable data entry associated with  the
hashtable key to the top of stack.

In the event of an unmatched hashtable key or no value associated  with  the
entry or, less likely, a full stack, the OQ command fails.

If the data object holds a buffer, then a complete copy of  all  the  buffer
records is made and placed on the top  of  the  stack,  ignoring  the  other
attributes like PathName, header or Footer.

</UL><H4><A NAME="O+">O+</H4>
<PRE>
O+ - Add
</PRE>

Replace top two values with their sum.

If either of the two values is a real number then the result is real, if one
is integer then it is first converted to real.

There is no checking for arithmetic overflows.

</UL><H4><A NAME="O-">O-</H4>
<PRE>
O- - Subtract
</PRE>

The value at the top of the stack is subtracted from the next value, the top
two items are replaced by the result.

If either of the two values is a real number then the result is real, if one
is integer then it is first converted to real.

There is no checking for arithmetic overflows.

</UL><H4><A NAME="O*">O*</H4>
<PRE>
O* - Multiply
</PRE>
<UL>
</UL>Replace top two values with their product.

If either of the two values is a real number then the result is real, if one
is integer then it is first converted to real.

There is no checking for arithmetic overflows.

</UL><H4><A NAME="O/">O/</H4>
<PRE>
O/ - Divide
</PRE>

The top item on  the  stack  is  the  denominator,  the  next  item  is  the
numerator, both  items  are  removed  from  the  stack  and  the  result  of
numerator/denominator is then added to the stack.

If either of the two values is a real number then the result is real, if one
is integer then it is first converted to real.

There is no checking for arithmetic overflows but this command will fail  if
the denominator (the 1st. item in the stack) is 0.

</UL><H4><A NAME="O%">O%</H4>
<PRE>
O% - remainder.
</PRE>

The top item on  the  stack  is  the  denominator,  the  next  item  is  the
numerator, both items are removed  from  the  stack  and  the  remainder  of
numerator/denominator is then added to the stack.

If either or both items are real, the reals are first converted  to  integer
the result is always integer.
<UL>
</UL>There is no checking for arithmetic overflows but this command will fail  if
the denominator (the 1st. item in the stack) is 0.

</UL><H4><A NAME="O=">O=</H4>
<PRE>
O= Test for numerical equality
</PRE>

The top two items must be either integer or real, they are compared and  the
top item is removed, if they  are  equal  the  command  status  is  Success,
otherwise it's Fail.

If either item is a real number  it  is  converted  to  integer  before  the
comparison. This conversion does not apply to the value left behind  on  the
stack.

</UL><H4><A NAME="O~">O~</H4>
<PRE>
O~ Increment value in top of stack.
</PRE>
<UL>
</UL>The item at the top of the stack must be an integer, for any other type  the
the operation fails. The modified value is checked  and  fails  the  failure
flag is raised if the result is zero.

</UL><H4><A NAME="O&#062;">O&#062;</H4>
<PRE>
O&#062; - Greater than.
</PRE>

The top two items compared and the top item is removed, if the top  item  is
greater than the next, then the command  status  is  Success,  otherwise  it
Fails.

If both of the operands are floating-point values,  then  a  floating  point
comparison is used.  Similarly,  if  both  items  are  integer,  an  integer
comparison is performed. If only one of the operands is floating point, then
a  floating-point  comparison  is  performed,   using   the   floating-point
conversion of the integer value. This conversion does not affect  the  value
left behind on the stack.

</UL><H4><A NAME="O&#060;">O&#060;</H4>
<PRE>
O&#060; - Less than.
</PRE>

The top two items compared and the top item is removed, if the top  item  is
less than the next, then the command status is Success, otherwise it's Fail.

If both of the operands are floating-point values,  then  a  floating  point
comparison is used.  Similarly,  if  both  items  are  integer,  an  integer
comparison is performed. If only one of the operands is floating point, then
a  floating-point  comparison  is  performed,   using   the   floating-point
conversion of the integer value. This conversion does not affect  the  value
left behind on the stack.

</UL><H4><A NAME="OB">OB</H4>
<PRE>
OB - save Buffer key
</PRE>

The ASCII value of the current buffer identification key is  placed  on  the
stack (see also `OZ`).

</UL><H4><A NAME="OE">OE</H4>
<PRE>
OE - push Extent of current substring or record.
</PRE>

This command pushes the length, in  characters,  of  the  currently-selected
substring onto the stack. Jot has two forms of substring  yielding  +ve  and
-ve results:
<UL><LI>Positive, where the current character is  the  first  character  of  the</LI>
substring typically the result of a `F` command.
<LI>Negative, where the current character is immediately after the substring</LI>
typically the result of the `S` command.
</UL>
If unicode support is turned off off (see `%b=unicode`) then it  pushes  the
number of bytes in the currently-selected  substring.  If  no  substring  is
currently selected, it pushes the total length of the  current  record  onto
the top of the stack.  The  result  is  negative  if  the  current-character
pointer follows the selected substring (as would be the case after  the  `S`
command, for example).

See also `OU`, `about unicode`, `%b=tabstops`, `about tabular text`,  `query
inview` and `uc_basic.jot`.

The substring-length calculation disregards  any  leftoffset  setting  -  it
always assumes all characters  are  fully  visible.  See  also  `about  long
lines`.

</UL><H4><A NAME="OF">OF</H4>
<PRE>
OF - push line no. of First line of current buffer in window.
</PRE>

This command will  search  all  currently  displaying  windows,  from  first
(topmost) to last window (bottommost) until  it  finds  one  displaying  the
current buffer. It then calculates the  line  number  of  the  topmost  line
displayed in the window. In most cases it's much simpler than that - usually
there's only one window set up to display the current buffer - see `%W`  for
details.

This information can be used to control the view e.g.  it  can  be  used  to
return to a previously displayed view - see also `OW`.

Note that the line number returned is the line number at the time  when  the
display was last updated. If your code contains anything that  might  change
the display you should first refresh the display with the `W` command.

</UL><H4><A NAME="OU">OU</H4>
<PRE>
OU - set sUbstring length from stack.
</PRE>

The length of the currently-selected substring is set to the value currently
at the top of the stack. A zero can be used to remove the substring  setting
in that buffer. 

With unicode support turned on (see `%b=unicode`) this value is  interpreted
as a character count, otherwise 's taken as a byte count.

A negative substring indicates that the  current  character  is  immediately
after the selected substring (e.g. after a f/.../- os s/.../  command,  doc.
Otherwise the value is positive indicating that the current character is the
first character of the substring (e.g. after a F/.../ or S-/../ command).

See also `OE`.

</UL><H4><A NAME="OZ">OZ</H4>
<PRE>
OZ - Zoom.
</PRE>

The value at the top of the stack is removed and used to  specify  a  buffer
key, this is used to specify the new current buffer (see also `OB`).

Unlike the `Z` command, oz does not transliterate to uppercase and an  error
will result if there happens to be a lower-case acsii alpha character at the
top of the stack.

</UL><H4><A NAME="OP">OP</H4>
<PRE>
OP - push mouse Position onto stack.
</PRE>

This places coordinates of the last-detected  mouse-click  onto  the  stack.
Readback  of  mouse-click  coordinates  is  enabled  by  the  `%s=MouseMask`
command.

On completion, the top of the stack holds the following:
<UL><LI>buffer key on display in the window receiving the last mouse click</LI>
<LI>the line number and</LI>
<LI>the character number for the mouse-click point.</LI>

</UL>If the last-clicked mouse event has not been  enabled  (see  `%s=MouseMask`)
then OP places three zeros on the stack.

See also `About mouse events`, `%s=mousemask`, `%s=setmouse` and `%b=addtag`

</UL><H4><A NAME="ON">ON</H4>
<PRE>
ON - save line Number
</PRE>

The current line number is placed on the stack (see also `OM`).

</UL><H4><A NAME="OM">OM</H4>
<PRE>
OM - Move
</PRE>

The value at the top of the stack is removed and used to specify a  relative
move forwards (+ve.) or backwards (-ve) by no. of lines.

If the move is out of bounds (i.e. before the start or after the end of  the
current buffer) then the cursor is left at the start of the  first  or  last
line as appropriate and the command fails.

n.b. With a zero at the top of the stack, OM just moves to the start of  the
current line (see also `ON`).

</UL><H4><A NAME="OA">OA</H4>
<PRE>
OA - rAndom
</PRE>

A randomly-generated number is pushed onto the top of the stack. In reality,
of course, this  is  a  pseudo-random  number.  That  means  it  runs  to  a
predictable repeatable sequence depending on  how  the  pseudorandom  number
generator is seeded (see `O@`).

</UL><H4><A NAME="O.">O.</H4>
<PRE>
O. - Set line number.
</PRE>

The value at the top of the stack is removed and used to  specify  the  line
no. of current line from top of stack.

N.B.  This  has  no  effect   on   the   cursor,   it   only   changes   the
internally-maintained line number. This is displayed in the JOT prompt,  and
the line number in `M`+ operations and `ON` etc.

</UL><H4><A NAME="OC">OC</H4>
<PRE>
OC - save Chr no.
</PRE>

Place current character no. (i.e. number of  characters  from  beginning  of
line to the current cursor position) onto the stack (see also `OR`).

If unicode support has been turned off (see  `%b=unicode`)  then  OC  counts
bytes not characters, including all bytes in any unicode characters.

</UL><H4><A NAME="OR">OR</H4>
<PRE>
OR - shift Right by character count (byte count if unicode support is turned 
</PRE>
off - see `Unicode - the gruesome details`) shifts left for negative values.


Item at top of stack is removed and used  to  shift  the  current  character
pointer. Cursor moves cursor right (+ve.) or left (-ve.) by no. bytes at top
of stack.
<UL>
</UL>If the move is out of bounds (before the start  or  after  the  end  of  the
current line) then the operation  fails  and  the  cursor  is  left  at  the
start/end of the line as appropriate (see also `OC`).

</UL><H4><A NAME="OI">OI</H4>
<PRE>
OI&#091;C|D|O|X|F&#093; - formatted Input conversion (of string at current character).
</PRE>

OI&#060;chr&#062; uses the character (C, D, O, X or F) as a format specifier and  uses
it to extract a value from the  string  at  the  current  character  in  the
current buffer.  The  result  is  pushed  onto  the  stack.  Note  that  the
interpretation of the format-selection character (C, D, O, X or F)  is  case
insensitive - so c, d, o, x or f will do just as well.

Each of these  variants  converts  characters  beginning  with  the  current
character and proceeding  to  the  right.  The  current  character  is  left
pointing to the character to the right of the last converted  character  and
all the converted characters are highlighted as a substring. 

In the event of there being no valid characters  the  current  character  is
left unchanged, nothing is added to the stack and the command fails.
<UL><LI>OIC converts one character immediately  to  the  right  of  the  current</LI>
character to it's ASCII  code  -  this  one  does  not  skip  whitespace
characters.
<LI>OID converts a string of numeric characters to decimal.</LI>
<LI>OIO converts value in an octal string and</LI>
<LI>OIX converts value in a hexadecimal string.</LI>
<LI>OIF converts real-number value in a string.</LI>
</UL>OID, OIO, OIX and OIF all skip past any leading whitespace before converting
digits.

</UL><H4><A NAME="OK">OK</H4>
<PRE>
OK - Kill top item on stack
</PRE>

The item at the top of the stack is removed and it's  value  is  lost.  Note
that the OK command will fail if the stack is empty or the item at  the  top
of the stack is a buffer and this happens to be the current buffer or if  it
is marked as write-if-changed (see `%b=writeifchanged`).

</UL><H4><A NAME="O@">O@</H4>
<PRE>
O@ - Reset stack
</PRE>

Reseeds the random number generator (see `OA`) and then destroys  all  items
currently in the stack. If the item at the top of the stack  is  an  integer
type then this is is used to reseed the generator, otherwise  it's  reseeded
with 1.

The O@ command will work it's way down the stack, deleting entries, starting
with the top item in the stack. If it encounters a buffer, it might fail  at
this point if this buffer is the current buffer.

</UL><H4><A NAME="OS">OS</H4>
<PRE>
OS - Swap
</PRE>

The items in the top and next-but-one slots in the stack swap places.

OS will fail if there are less than two items on the stack.

</UL><H4><A NAME="O#">O#</H4>
<PRE>
O# - Duplicate
</PRE>

The item at the top of the stack is copied and  placed  above  the  original
item. 

If the top item on the stack is a buffer, the O# operation does not copy the
buffer records etc.  it  simply  constructs  another  pointer  to  the  same
internal data. This is in contrast to `OV` and `OQ` which do make new copies
of buffer data.

O# will fail if the stack is already full.

</UL><H4><A NAME="OW">OW</H4>
The screen display is scrolled by the number of lines indicated by  the  top
of stack - a positive value scrolls up the screen, negative scrolls down.

</UL><H3><A NAME="PERCENT COMMANDS">Percent Commands</H3>
See also `percent-command syntax`
<UL><LI>`%%` - Comment line.</LI>
<LI>`%A` - Exit without writing file.</LI>
<LI>`%B` - set Buffer attributes.</LI>
<LI>`%C` - Exit writing new file.</LI>
<LI>`%D` - Define a buffer from console.</LI>
<LI>`%E` - Execute following CLI command line.</LI>
<LI>`%G` - Get - Define a complete buffer from current command file.</LI>
<LI>`%H` - Hashtable maintenance.</LI>
<LI>`%I` - Secondary input file.</LI>
<LI>`%L` - set line Length and redraws all windows and slices.</LI>
<LI>`%M` - Message.</LI>
<LI>`%O` - Output current buffer as specified file.</LI>
<LI>`%Q` - system Query.</LI>
<LI>`%R` - Run a command file.</LI>
<LI>`%S` - define System settings (case sensitivity, insert mode ...).</LI>
<LI>`%U` - Undo last substitution.</LI>
<LI>`%W` - Set up a screen window.</LI>
<LI>`%X` - eXit current macro with a user-defined error message.</LI>
<LI>`%~` - Insert or display control character.</LI>

</UL><H4><A NAME="%A">%A</H4>
<PRE>
%A&#091;&#091;&#060;status&#062;&#093;=&#060;message&#062;&#093; - Abandon = Exit without writing file.
</PRE>

This exits the editor, no files are written out.

The message defaults to "Edit abandoned", it  is  written  to  stdout  after
closing the screen management system.

By default, the exit status code is set to 1, any value in the  range  0  to
255 can be supplied in decimal.

If some buffer has been marked as `%b=writeifchanged`, and  the  buffer  has
been changed, then the editor will refuse to exit until that buffer has been
written. A suitable message appears if this happens - see `freeall.jot`.

</UL><H4><A NAME="%C">%C</H4>
<PRE>
%C&#091;=&#060;message&#062;&#093; - Close = Exit writing new file.
</PRE>

The file spec. is initially determined by the arguments given to the  editor
image (see `-to`) and may be further redefined by the `%b=pathname` command.
By default the file will have the same pathname as the original.

The command fails if there is an attempt to %C from any  buffer  other  than
the main buffer . - to write out some other buffer use `%O`.
<UL>
</UL>The message defaults to "Normal exit", it is written to stdout after closing
the screen management system. For %C, the exit status is always set to 0.

If  some  buffer  (other  than  the  main  buffer)  has   been   marked   as
`%b=writeifchanged`, and the buffer has been changed, then the  editor  will
refuse to exit until that buffer has been written or the writeifchanged lock
is removed - see `freeall.jot`.

</UL><H4><A NAME="%E">%E</H4>
<PRE>
%E&#091;&#060;key&#062;&#093;=&#091;|&#093;&#060;CliCommand&#062;
</PRE>

If a destination buffer is specified with the optional &#060;key&#062; qualifier, then
the stdout of the child process is picked up  and  saved  in  the  specified
buffer. If no destination buffer is specified the child's stdout goes to the
screen.

Since the single quote character ( ' ) is so important  to  shell  commands,
the usual '&#060;bufferKey&#062; syntax is not allowed for %e -  see  `percent-command
syntax`.

The command is passed to the CLI, the return status is checked and  used  to
set the failure flag.

If the CliCommand is prefixed with a vertical bar ( | ), then  the  contents
of the current buffer is output to the stdin of the  command.  This  feature
allows users to use external co-processors for  handling  specific  tasks  -
e.g. sorting, numerical processing.

</UL><H4><A NAME="%F">%F</H4>
<PRE>
%F&#091;&#060;key&#062;&#093;=&#091;&#060;REx&#062;&#093; - search forwards in buffer using regular expression.
%F-&#091;&#060;key&#062;&#093;=&#091;&#060;REx&#062;&#093; - search back in buffer using regular expression.
</PRE>

When a match is found, the first record of the destination buffer is set  to
the complete matched substring. Subsequent records of the destination buffer
are set to substrings matching parenthesized sub-expressions.

If the  optional  regular  expression  &#060;REx&#062;  is  not  specified,  then  the
last-specified REx is re-used.

The underlying system call  only  searches  forwards  hence,  for  backwards
searches, when a matching line of text is found, the system call is repeated
until there are no more valid matches. Hence reverse regex searches  can  be
quite inefficient for cases where there are many possible matches on a line.

Briefly, it supports most of the  usual  regular-expression  constructs  but
some of the more complex ones may  be  missing,  for  details  look  at  the
documentation of the regex library routine:
<UL>http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html   -
Circumflex '^' and dollar sign '$', respectively, at the start or end of
the RE, will anchor the body of the RE to the start or end of the  match
string.
<LI>Bracketed expressions - '&#091;' ... '&#093;', the expression  inside  a  pair  of</LI>
matching square brackets - see below.
<LI>Sub-expression grouping, enclosing expressions in matching round  braces</LI>
'(' and ')', creates a result for each such subexpression. Each of these
is assigned a separate record in  the  destination  buffer  and  may  be
referred to by  number  in  some  later  expression  (see  subexpression
references, below).
<LI>Alternation  within  sub-expressions  the  vertical  bar  character  '|'</LI>
indicates an alternative subexpression. (&#060;subexpr1&#062;|&#060;subExpr2&#062; ... )
<LI>Subexpression references - \n (where n is a decimal) refers to the value</LI>
extracted for that subexpression.
<LI>Numeric quantifiers -  specifying  that,  for  a  match,  the  preceding</LI>
subexpression should be reiterated a given number of times.
<LI>Range quantifiers, a comma-separated pair of  decimal  values  in  curly</LI>
braces '&#123;'m, n'&#125;' where m specifies the minimum number of repeats, n the
maximum.

</UL>Bracketed expressions - anything in matching square brackets &#091; ... &#093;
<UL><LI>A set of equally  acceptable  characters,  special  characters  must  be</LI>
escaped with a backslash.
<LI>A range of characters &#060;ch1&#062;-&#060;ch2&#062; in the ASCII/POSIX collating sequence.</LI>
<LI>A circumflex '^' - the negation character, matches to any character  not</LI>
in the expression e.g. &#091;^a-zA-Z&#093; matches to any non-alpha character.
<LI>Character-class expressions of the form &#091; ... &#091;:&#060;classexpr&#062;:&#093; ... &#093;  the</LI>
following character class expressions are allowed: alnum, cntrl,  lower,
space, alpha, digit, print, upper, blank, graph, punct, xdigit.

</UL><H4><A NAME="%M">%M</H4>
<PRE>
%M&#091;&#060;bufferKey&#062;&#093;=&#060;message&#062; - prints Message in console area.
</PRE>

Prints the message in the  console  area  and  continues.  If  the  optional
bufferKey is given then the message is also copied as a new line at the  end
of the specified buffer. 

The message may contain an indirect reference to any buffer or the  stack  -
see `about command parameters` e.g:
<PRE>
ob %q~=date; t2/, /b %m=This is the time '~; osozok
</PRE>

</UL><H4><A NAME="%X">%X</H4>
<PRE>
%X=&#060;message&#062; - eXit current command sequence, macro or script displaying the
</PRE>
message in the console area.

Prints the message to the  console  area  then  abruptly  exits  of  current
command sequence. e.g:
&#062; %x=File 'n is of the wrong type.

</UL><H4><A NAME="%S">%S</H4>
<PRE>
%S=&#060;attribute&#062; &#091;&#060;value&#062;&#093; - set the value of a System attribute.
</PRE>
<UL>
</UL>This group of commands control various system attributes affecting behaviour
in any buffer.

Briefly, these are the valid attribute keys:
<UL><LI>`%s=case` &#091;0|1|+1&#093; - Sets case sensitivity for F, and V commands.</LI>
<LI>`%s=system` &#091;0|1&#093; - system mode on/off - preserves search & insert strings.</LI>
<LI>`%s=commandmode` &#091;+&#093;&#091;&#060;bitMask&#062;&#093; - to select screen-edit mode.</LI>
<LI>`%s=commandcounter` - Sets the command-counter stop-point.</LI>
<LI>`%s=trace` - set Trace, prefix with '+' to XOR with current value</LI>
<LI>`%s=tracedefault` - set default trace bitmask see also `T` command.</LI>
<LI>`%s=setenv` &#060;envName&#062; &#060;envValue&#062; - sets an environmental variable.</LI>
<LI>`%s=verbose` - to change verbosity level.</LI>
<LI>`%s=console` &#060;n&#062; - sets an upper limit on console-area expansion.</LI>
<LI>`%s=commandstring` - redefines console-input string.</LI>
<LI>`%s=recoverymode` - disables I/O used in journal-recovery procedure.</LI>
<LI>`%s=copy` - copies currently-selected text to the system paste buffer.</LI>
<LI>`%s=paste` - imports text from the system paste buffer to the  text.</LI>
<LI>`%s=setmouse` - Sets the mouse-event coords to the current cursor position.</LI>
<LI>`%s=guardband` - Makes a few lines above or below cursor visible.</LI>
<LI>`%s=mousemask` - Enables mouse events.</LI>
<LI>`%s=tab` - defines the tab character in tabular text.</LI>
<LI>`%s=prompt` - defines the prompt string for `G` commands.</LI>

</UL><H5><A NAME="%S=CASE">%S=case</H5>
<PRE>
%S=case &#091;0|1|+1&#093; - set case sensitivity attribute.
</PRE>
<UL>
</UL>This sets case sensitivity for the `F` and `V` commands - 1 makes them  case
sensitive, 0 makes them case-insensitive (e.g. f/Fred/ will match  to  fred,
FRED or Fred equally well). If no valid value is given,  it  defaults  to  0
(i.e. insensitive to case). The value +1 reverses the current setting.

</UL><H5><A NAME="%S=SYSTEM">%S=system</H5>
<PRE>
%s=system &#091;0|1&#093;;
</PRE>

<UL>In system mode the usual behaviour of saving search  and  substitute/insert
strings is suspended. This is used in functions which use the `F`, `S`  and
`I` commands and maintains the original state of these  strings  after  the
function has completed.

</UL><H5><A NAME="%S=COMMANDMODE">%S=commandmode</H5>
<PRE>
%s=commandmode &#091;+&#093;&#091;&#060;hexBitMask&#062;&#093; - sets command-mode attribute.
</PRE>
<UL>
</UL>Bits are assigned as follows:
<UL><LI>01 - Temporary, Insert mode reverts to command mode when any function  or</LI>
<UL>cursor-control key is hit.
</UL><LI>02 - InsertMode (until next %S=commandmode or a Ctrl+C interrupt).</LI>
<LI>04 - Overtype - when in insert mode overwrites preexisting text.</LI>
<LI>08 - EscapeAll - all keyboard input is taken as escape strings.</LI>
<LI>10 - EscapeCtrl - any control character (ASCII characters in the range 0 to 31)</LI>
<UL>will be treated as initiating an escape sequence.

</UL></UL>Various useful combinations are available:
<UL><LI>%s=commandmode 0; - the default setting, sane command mode - your typing</LI>
appears in the console, it can supply a parameter to some jot  function.
To insert to the text use the `Insert` and `Enter` functions.
<LI>%s=commandmode 2; - normal insert mode -  your  typing  appears  on  the</LI>
screen at the current-character position indicated by the jot cursor.
<LI>%s=commandmode 6; -  insert-overtype  -  similar  to  %s=commandmode  2;</LI>
except that typed input overwrites any preexisting text.
<LI>%s=commandmode 8; - EscapeAll - all  your  typing  is  taken  as  escape</LI>
sequences - similar to vi/vim command mode.
<LI>%s=commandmode 10; - EscapeCtrl - any control character (ASCII codes  in</LI>
the range 0 to 31) is treated as the start of an escape sequence.
<LI>%s=commandmode 12; As above but with insert mode  -  control  characters</LI>
initiate escape-sequences  and  non-control  characters  appear  at  the
current-character position.
<LI>Other combinations may do something useful but there's no guarantees.</LI>

</UL><H5><A NAME="%S=COMMANDCOUNTER">%S=CommandCounter</H5>
<PRE>
%s=commandcounter 123456789; - sets the endpoint for the command counter.
</PRE>

This command is only really useful for debugging and in the journal-recovery
process. It specifies how many commands that should be  allowed  to  execute
normally before a trace event is triggered - see `the jot debugger`.

As each command is processed a  counter  is  incremented.  This  counter  is
normally set to 0 every time a new command line is read  from  the  console.
When the initial setting is defined with %s=SetCommandCounter it is  instead
set to run for the specified number of commands and then execution  proceeds
in whatever trace mode you  have  previously  selected.  Typically  it  will
proceed in single-step mode.

In a normal session,  execution  can  be  continued  under  control  of  the
debugger - see `about jot debugging`. In a  recovery  session,  the  command
counter is used to simulate a &#123;Ctrl+c&#125; interrupt at exactly the  same  point
as one was received in the original session - see `about journal files`.

For break point activation the command counter is designed to to be used  in
conjunction with the trace mask (see  `the  jot  debugger`,  `%S=trace`  and
`%S=tracedefault`).

The trace mask determines the trace trigger and action. When  this  internal
counter reaches zero, the trace action is enabled when nonzero, the  counter
is decremented.

Note that the counting only applies to the command sequence initiated by the
*next*  command  line.  For  subsequent  command  lines,  the   counter   is
initialized to zero, as usual.

</UL><H5><A NAME="%S=TRACE">%S=trace</H5>
<PRE>
%s=trace &#091;+-&#093;&#091;&#060;XXXX&#062;&#093; - Trace = Set &#091;modify&#093; trace mode, in hexadecimal.
</PRE>
<UL>
</UL>The optional + qualifier sets the specified bits, the optional  -  qualifier
unsets the specified bits.

The screen window is only redrawn when the Trace_Break bit is set.

%S=trace sets a mask which controls the user-script debugging  facility  for
the editor - see also `%S=tracedefault` and the `T` command.

The trace action may optionally be delayed by setting an internal counter  -
see `%S=commandcounter`.

The trace mode bitmask has the following control  bits  which  can  be  ORed
together:
<UL><LI>0001 Trace_AllCommands: Each new command is triggers a trace event.</LI>
<LI>0002 Trace_CommandLines: Each new command line triggers a trace event.</LI>
<LI>0004 Trace_Failures: Any failing command triggers a trace event.</LI>
<LI>0008 Trace_Interrupt: A &#123;Ctrl+C&#125; interrupt triggers a trace event.</LI>
<LI>0040 Trace_Recovery: Enables normal debugging in recovery mode.</LI>
<LI>0080 Trace_DumpSeq: Dumps compiled commands.</LI>
<LI>0800 Trace_Backtrace: Dumps a backtrace at each trace event.</LI>
<LI>1000 Trace_Stack: Dumps contents of the stack at each trace event.</LI>
<LI>2000 Trace_Print: Prints the current line of the current buffer.</LI>
<LI>4000 Trace_Source: Displays the command line at each trace event.</LI>
<LI>8000 Trace_Break: Break at selected trace point, halts and prompts for a</LI>
debug command.

</UL>One group of bits  (Trace_AllCommands,  Trace_CommandLines,  Trace_Failures,
and Trace_Interrupt) define the  trace  points.  The  other  group  of  bits
(Trace_Backtrace, Trace_Stack, Trace_Print,  Trace_Source  and  Trace_Break)
determine the action to  be  taken  at  a  trace  point.  The  other  one  -
Trace_Recovery is used in recovery scripts only - see `about journal files`.

Trace_AllCommands and Trace_CommandLines perform  the  selected  trace-point
actions at every command or at the start of a new command line respectively.
Trace_Failures performs the trace-point actions after a failing command.

Trace_Interrupt changes normal &#123;Ctrl+c&#125; behaviour - &#123;Ctrl+c&#125; normally  exits
everything and returns to the normal jot prompt. With Trace_Interrupt set it
enters the interactive jot debugger - note that, by  default,  Trace_Int  is
not set up the  `T`  command,  you  have  to  set  Trace_Interrupt  in  your
`%s=tracedefault`  setting  and  your  %s=trace  settings  -  see  `the  jot
debugger`.

The Trace_Stack bit directs a stack dump to the console, this will not be of
much help unless the console area of the screen is reasonably large or there
is not much on the stack.

The Trace_Print bit prints the current  line  of  the  current  buffer  just
before execution of the command.

The Trace_Break bit triggers a break at the trace point, it  prompts  for  a
command with 'Debug Command&#062;' any valid JOT command string may  be  entered.
If a hexadecimal value is entered with a leading zero, then this sets a  new
value for the trace mode - in  particular  0  will  exit  trace  mode.  Just
hitting the return key advances to the  next  break  point.  Note  that  the
debugger does not attempt to restore the original  context.  Note  also  the
debugger interface does not handle hotkeys.

The Trace_DumpSeq bit is only useful  when  Trace_Source  cannot  print  the
original source code - this happens when, for example, a macro has  modified
it's own source buffer and the debugger reports  "&#060;original  command  string
not available for display.&#062;"

The Trace_Recovery bit causes trace points to behave  normally  in  recovery
mode. By default, a trace break in recovery will read instructions from  the
recovery file, these are  identical  to  those  given  while  debugging  the
original session. With the Trace_Recovery bit  set,  debugger  commands  are
read from the console, as normal, so you can debug the recovery script.  Not
though, if the original session had debugger interaction then  what  happens
next is anyone's guess but the end result is  unlikely  to  be  an  accurate
reproduction of the original session state.

In order to enter the debugger while  processing  a  recovery  file,  it  is
necessary to edit  the  recovery  file  inserting  a  suitable  %s=trace  or
%s=tracedefault command in the script. A typical  useful  setting  might  be
0X8041:
&#062; %s=tracedefault 8041;

If no trace action is specified, it just prints the  command  line  at  each
trace point.

Setting the Trace_Backtrace bit causes a backtrace  to  be  issued  at  each
trace  point  -  not   particularly   useful   for   Trace_AllCommands   and
Trace_CommandLines but can be most useful when combined with Trace_Failures.
Even so, it is not a good idea to run the editor with Trace_Failures  turned
on - it's not unusual  for  simple  keyboard-driven  functions  to  generate
several failures - all appropriately handled.

The `T` command simply sets the trace value to the  current  default  value,
initially  set  to  B001  (Trace_Stack  |  Trace_Print   |   Trace_Break   |
Trace_AllCommands) but can be redefined using the '%s=tracedefault' command.
Another useful setting is B002 - this displays the same  at  each  stop  but
only stops at the start of each new command line.

See also `%s=tracedefault` and  `about jot debugging`.

</UL><H5><A NAME="%S=TRACEDEFAULT">%s=tracedefault</H5>
<PRE>
%S=tracedefault &#091;+-&#093;&#091;&#060;hexValue&#062;&#093;
</PRE>

This defines the value to be  assigned  to  the  trace  vector  by  the  `T`
command. By default this is:
<UL>Trace_Stack | Trace_Print | Trace_Break | Trace_AllCommands

</UL>The optional + qualifier sets the specified bits, the optional  -  qualifier
unsets the specified bits in the mask.

In contrast to %s=trace, which sets the trace mask  with  immediate  effect,
%s=tracedefault specifies a trace mask to be applied at the next break point
(breakpoints are set by the `T`, by the `%s=commandcounter` commands and  bu
Ctrl+C interrupts).
<UL>
</UL>See also `%s=trace` and  `about jot debugging`.

</UL><H5><A NAME="%S=SETENV">%s=setenv</H5>
<PRE>
%s=setenv &#060;envName&#062; &#060;envValue&#062;
</PRE>
<UL>
</UL>This sets an environmental variable in your session. It does not, of course,
change the environment in your shell but only for your  editor  session  and
any child processes it might spawn.

</UL><H5><A NAME="%S=VERBOSE">%s=verbose</H5>
<PRE>
%S=verbose &#060;x&#062; - sets the verbosity bit mask in hex.
</PRE>

The verbosity bit mask currently has four recognized bits:
<UL>
<UL><LI>1 (Bit 0) NonSilent - when set, normal error messages are delivered.</LI>

<LI>2 (Bit 1&#125; PromptUser - when set, prompts user for command input.</LI>

<LI>4 (Bit 2) QuiteChatty - when set it reports  a  few  more  failures  and</LI>
briefly explains what is wrong, it is recommended to allow  at  least  5
lines in the console area for this.

<LI>8 (bit 3) PrintLine - causes the current line of the current  buffer  to</LI>
be written to the console area, in addition to the other messages.

<LI>16 (bit 4) ReportCommandCount -  also  reports  command  counter  -  see</LI>
`%s=commandcounter` and `about jot debugging`.  When  ReportCommandCount
and QuiteChatty are both set, the failure reports are augmented with the
current state of the command counter.  Setting  ReportCommandCount  will
also cause user-defined messages (see `%M`) to  be  augmented  with  the
command counter state. The command counter can be used to  set  a  break
point in some later run - see `%s=commandcounter`).

<LI>32 (Bit 5) AnnoyingBleep - error messages are accompanied by a bleep.</LI>

<LI>64 (Bit 6) DebugMessages - enables whatever debugging messages may  have</LI>
been accidentally left in your version of jot.

</UL></UL>These bits are combined to achieve a desired effect e.g.
&#062; %s=verbose 3;   - (default state) for normal prompting and error reporting.
&#062; %s=verbose 23;  - for normal prompts and reporting with bleeping.
&#062; %s=verbose 1f;  - for normal prompts and comprehensive reporting.

</UL><H5><A NAME="%S=CONSOLE">%s=console</H5>
<PRE>
%s=console &#060;0&#062;|&#060;noOfLines&#062;;
</PRE>

This sets an upper limit on  the  expansion  of  the  console  messages.  By
default messages are restricted to any spare terminal lines at the bottom of
the display (see `about jot-display windows`),  setting  this  limit  allows
messages to encroach upwards into the window area of the terminal.

If set to 0 (the default state), then the  console  area  is  fixed  at  the
number of lines left below the windows. The startup script sets the  windows
to leave a 2-line console area.

If the console expansion area is set to more than the number of lines  below
the windows, then the console area will expand upwards to a total size limit
specified in the %s=console command. The Additional console lines are erased
on the next editor action (a new command string, an escape sequence or  just
by hitting &#123;return&#125;.

</UL><H5><A NAME="%S=GUARDBAND">%s=guardband</H5>
<PRE>
%S=guardband&#091; &#060;n&#062;&#093;
</PRE>
Sets an n-line guardband. A band  of  n  lines  is  maintained  between  the
current line of text and the top or bottom of the display. The value may  be
0 - this is also the default.

In the event of the total guardband exceeding the window size,  the  current
line is centred.
<UL>
</UL>With a 3-line guardband, for example, it always displays the 3  lines  above
and below the current record.

</UL><H5><A NAME="%S=TAB">%s=tab</H5>
<PRE>
%s=tab &#091;&#060;chr&#062;&#093;
</PRE>
This defines the character to be used as a cell separator for tabular  text.
It defaults to VT (vertical Tab). This  can  be  set  to,  pretty-much,  any
normal ASCII character but not unicode characters.

</UL><H5><A NAME="%S=COMMANDSTRING">%S=CommandString</H5>
<PRE>
%s=commandstring &#060;CommandString&#062;
</PRE>
This inserts the specified command string  back  into  the  console  command
buffer. This makes it possible to modify the console  input  using  ordinary
editor commands and then execute the modified command sequence.

This is used for command-line editing  (see  `about  command  editing`)  and
systematic modification of keyboard input - take a  look  at  `uc_basic.jot`
this uses %s=commandstring to substitute unicode escape sequences for  UTF-8
byte sequences.

</UL><H5><A NAME="%S=MOUSEMASK">%s=MouseMask</H5>
<PRE>
%s=mousemask&#091;=&#060;HexValue&#062;&#093;
</PRE>

This enables the detection and handling of  selected  mouse  events  -  e.g.
left-button clicks etc. When enabled by %s=MouseMask, mouse  events  can  be
picked up and handled  in  the  same  way  as  as  escape  sequences.  Also,
mouse-click coordinates can be picked up by the `OP` command.

By default, all mouse actions are disabled (the mouse mask is set to 0),  if
%s=mousemask is given with no value then all mouse events are picked  up  by
the editor (and normal X mouse actions are disabled).  If  a  hex  value  is
given then that value is passed to the curses mousemask() function. For full
details refer to curses.h and the mousemask (3NCURSES) man page.

The problem with enabling all mouse events is that it  replaces  the  really
useful X-windows selection actions - so only set the  mouse  mask  when  you
really need to define mouse functions. The  standard  setup  defines  a  few
mouse-action functions.

The problem is not so acute for windows users since windows offers virtually
no worthwhile mouse functions for console terminals.

In any case, normal service can be restored by resetting the mousemask to 0:
&#062; %s=mousemask 0;

See also `About mouse events`, `OP` and `%b=addtag`

</UL><H5><A NAME="%S=RECOVERYMODE">%S=RecoveryMode</H5>
<PRE>
%s=recoverymode &#060;value&#062;
</PRE>

Used when recovering a session from  journal  files.  In  order  to  prevent
corruption of existing files %o  operations  are  disabled  and  %I  and  %E
operations read from the journal area - see `about journal files`

</UL><H5><A NAME="%S=COPY">%S=copy</H5>
<PRE>
%s=copy
</PRE>
<UL>
</UL>Copies text into the system paste buffer. The start point is set by the  'N'
(Note) command, the end point is set by the current  character  position  at
the time when the %s=copy command is invoked. As  with  the  'A'  (Abstract)
command, the start and end point must be in the same buffer and, if the  end
point is before the start point the start and end points  are  automatically
reversed.

In windows, the system buffer used is the 'clipboard', in linux %s=copy  and
%s=paste both use the X paste buffer N.B. not the selections buffer.

In order to minimize the number of statically-linked libraries in the  linux
version, this command is not available in the linux executables supplied  in
the download - see `Unix and linux setup`.

</UL><H5><A NAME="%S=PASTE">%S=paste</H5>
<PRE>
%s=paste
</PRE>

Copies the contents of the system paste buffer into the  current  buffer  at
the current-character position.

In order to minimize the number of statically-linked libraries in the  linux
version, this command is not available in the linux executables supplied  in
the download - see `Unix and linux setup`.

</UL><H5><A NAME="%S=PROMPT">%s=prompt</H5>
<PRE>
%s=prompt&#091; &#060;promptString&#062;&#093;; - set prompt string.
</PRE>

Sets the prompt for the `G` command.

If the prompt string is not given, then the G-command prompt reverts to it's
default ( &#062; ).

</UL><H5><A NAME="%S=SETMOUSE">%s=setmouse</H5>
<PRE>
%s=setmouse
</PRE>

Initializes the mouse position to  the  current  character  in  the  current
buffer - see `OP`, `Query tags` and `query window`.

Useful  for  emulating   mouse   clicks   for   applications   designed   as
mouse/touch-pad interfaces in non-mouse environments (see `qr.jot`)  and  for
testing scripts using the OP command for the window query.

</UL><H4><A NAME="%B">%B</H4>
<PRE>
%b=&#060;attributeName&#062;&#091; &#060;value&#062;&#093; - set some attribute of the current buffer.
</PRE>
<UL><LI>`%b=unrestricted` - sets the buffer write-access attribute.</LI>
<LI>`%b=readonly` - sets the buffer write-access attribute.</LI>
<LI>`%b=leftoffset` &#060;n&#062; - sets the buffers left-offset attribute.</LI>
<LI>`%b=tabstops`&#091; &#060;n1&#062;&#091; &#060;n2&#062;&#091; &#060;n3&#062;&#091; ...&#093;&#093;&#093;&#093; - controls display of simple tabular text.</LI>
<LI>`%b=tabcells`&#091; &#060;n1&#062;&#091; &#060;n2&#062;&#091; &#060;n3&#062;&#091; ...&#093;&#093;&#093;&#093; - controls display of tabular text.</LI>
<LI>`%b=header` &#060;headerText&#062; - defines a static header line for display.</LI>
<LI>`%b=footer` &#060;footerText&#062; - defines text for window-separator line.</LI>
<LI>`%b=unicode` &#123;0|1&#125; - Disables|Enables unicode support in this buffer.</LI>
<LI>`%b=pathname` &#060;pathName&#062; - (re)defines pathname.</LI>
<LI>`%b=sameflag1` - sets the user change-control flag.</LI>
<LI>`%b=tagtype` - defines a named metadata tag.</LI>
<LI>`%b=addtag` - Adds a metadata tag to the text.</LI>
<LI>`%b=remove_tag` - Removes instances of a named tag</LI>
<LI>`%b=sort` - sorts text in buffer.</LI>
<LI>`%b=tabsort` - sorts tabular text in buffer.</LI>
<LI>`%b=codepage` - Sets code page for buffer (windows only).</LI>

</UL><H5><A NAME="%B=UNRESTRICTED">%B=unrestricted</H5>
<PRE>
%b=unrestricted - sets the buffer write-access attribute.
</PRE>
<UL>
</UL>This returns the readonly and  writeifchanged  status  of  the  buffer  (see
`%b=readonly` and `%b=writeifchanged`) to their default settings.

</UL><H5><A NAME="%B=READONLY">%B=readonly</H5>
<PRE>
%b=readonly&#091; 0|1&#093; - sets the buffer write-access attribute.
</PRE>

The default state for buffers is that they may be modified. If this  command
is applied with no value specified or is specified as  1  then  the  current
buffer is set to a readonly  state.  It  can  be  viewed  but  not  altered,
sections of text may be abstracted provided the & qualifier  is  given  (see
the `A` command).

See also the `%B=unrestricted` command.

</UL><H5><A NAME="%B=WRITEIFCHANGED">%b=writeifchanged</H5>
<PRE>
%b=writeifchanged&#091; 0|1&#093; - sets the buffer write-access attribute.
</PRE>
 
The default state for buffers is that any changes are lost if the session is
terminated without explicitly saving (see the `%O` command). If this command
is applied with no value or the value is specified as 1 then the buffer must
be saved if some changes have been made.

In this state the buffer may be modified but  if  there  is  an  attempt  to
overwrite or to exit the editor without first  saving.  Then  a  warning  is
issued and the editor session remains live. It is , of course,  possible  to
reset this lock and exit normally to discard changes.

The motivation for this one is that jot encourages users  to  edit  multiple
files in one session - it's just a bit too easy to forget and  exit  without
saving something important.

If, after you've checked the locked buffers, you  still  want  to  exit  the
session anyway, the `exit.jot` script might help.

See also the `%B=unrestricted` command.

</UL><H5><A NAME="%B=LEFTOFFSET">%b=leftoffset</H5>
<PRE>
%b=leftoffset &#060;n&#062; - sets the buffers left-offset attribute.
</PRE>
<UL>
</UL>Sets the text column to appear in the leftmost column  of  the  window  when
displaying this buffer.

By default, the left offset is 0. This may be increased to  display  records
longer than the width of the current window. See `about long lines`. If  the
given value is negative, this is silently ignored and the leftoffset is  set
to 0.

See also `about long lines` and `query inview`  -  this  verifies  that  the
current character is visible with the current leftoffset setting.

</UL><H5><A NAME="%B=TABSTOPS">%b=tabstops</H5>
<PRE>
%b=tabstops&#091; &#060;n1&#062;&#091; &#060;n2&#062;&#091; &#060;n3&#062;&#091; ...&#093;&#093;&#093;&#093; - controls display of simple tabular text.
</PRE>
<UL>
</UL>By default, tabs and other control characters are rendered as a tilde '~' on
the screen - see `about tabular text`. If tabStops have been defined  for  a
buffer containing tabular text then each tab is  replaced  by  one  or  more
blanks in the display. When correctly set up, the  tabular  text  is  neatly
aligned with that of other records in the buffer.

Each entry in the %b=tabStops command is a number  indicating  the  absolute
column number to be assigned to the following text - hence  tabStops  should
always be an ascending sequence of column numbers. If a tab  is  encountered
that is already beyond (i.e. to the right of) it's assigned column then  the
tab character is simply rendered as a single blank.

Use %b=tabcells for buffers containing simple tabular text - indented source
code,  simple  tables,  formatted  letter  headings  etc.  For  tables  with
wildly-varying cell lengths use `%b=tabcells` which will  truncate  overlong
cells to maintain the columns.

The %b=tabstops command will delete any  preexisting  tabstops  or  tabcells
settings, if no tabstops are given, then the buffer  reverts  to  displaying
tabs as tildes ( ~ ).

If the first tabstop is any negative number, then this is taken as a request
for automatically-assigned tabstops - any other values in the  command  line
are  ignored.  With  automatically  assigned  tabstops  the  window  manager
analyses the position of all tab characters currently in  view  and  assigns
the smallest tabstops  compatible  with  displaying  tabular  data  in  neat
columns. Currently, the maximum number of of automatically-assigned tabstops
is limited to 100.

The tabstops are displayed in the `query buffer` report.

</UL><H5><A NAME="%B=TABCELLS">%b=tabcells</H5>
Each  tab-delimited  item  of  text  is  said  to  be   a   cell.   If   the
manually-defined tabcell is insufficient to display all of a cell, then  the
cell text is truncated and an exclamation point  (  !  )  is  added  to  the
righthand end of the truncated text.

The %b=tabcells command will delete any  preexisting  tabstops  or  tabcells
settings, if no tabcells are given, then the buffer  reverts  to  displaying
tabs as tildes ( ~ ).

In the event of there being a record with more then the number of predefined
tabcells, then additional tabcells are assigned by adding the tab spacing to
the previous tabcell entry.

If the first tabcell is any negative number, then this is taken as a request
for automatically-assigned tabcells - any other values in the  command  line
are  ignored.  With  automatically  assigned  tabcells  the  window  manager
analyses the position of all tab characters currently in  view  and  assigns
the smallest tabcells  compatible  with  displaying  tabular  data  in  neat
columns. Currently, the maximum number of of automatically-assigned tabcells
is limited to 100.

The tabcells are displayed in the `query buffer` report.

</UL><H5><A NAME="%B=HEADER">%b=header</H5>
<PRE>
%b=header&#091; &#060;headerText&#062;&#093; - defines or removes a static header line.
</PRE>

If the headerText string is given, this is displayed in reverse video at the
top of any window displaying the current buffer. The header is static in the
sense that it is fixed to the top line of the window and text  scrolls  past
it. When you define a buffer string it occupies one of the  lines  requested
in the `%W` command, leaving you with  one  less  line  for  viewing  buffer
images. If no headerText string is given then any previously defined  header
line is removed. By default, buffers have no header line.

If the buffer has TabStops set (see `%b=tabstops`)  then  any  tabs  in  the
header text will be treated in the same way as those in the main body of the
buffer. The upshot of this is that the text can contain column headings  for
buffers containing tabular entries (e.g. images of spreadsheets etc.).

</UL><H5><A NAME="%B=FOOTER">%b=footer</H5>
<PRE>
%b=footer some text;
</PRE>

By default, the reverse-video separator at the end of a window contains  the
current buffer's pathname (if defined) and  the  buffer  key.  This  command
replaces the pathname with some text of your own choosing.

As with long pathnames, the text may be truncated to fit.

</UL><H5><A NAME="%B=UNICODE">%b=unicode</H5>
<PRE>
%b=unicode &#123;0|1&#125;
</PRE>
This controls unicode support for the current buffer.

Any value other than 0 restores the default  mode  of  operation  -  unicode
characters are rendered normally.

The value 0 turns off unicode support, in this state each byte of  UTF-8  is
represented on the screen by a tilde ( ~ ).

Disabling unicode support affects the rendering of characters on the  screen
any non-ASCII or ASCII control characters bytes are displayed as a tilde ( ~
) and also affects several commands:
<UL><LI>`R` - counts bytes not characters.</LI>
<LI>`OR` - counts bytes not characters.</LI>
<LI>`OE` - returns two  identical  values  (the  byte  count),  it  normally</LI>
returns byte count and character count.
<LI>`OC` - returns byte count not character count.</LI>
<LI>`OU` - expects to be given a byte count not a character count.</LI>

</UL><H5><A NAME="%B=PATHNAME">%b=pathname</H5>
<PRE>
%b=pathname &#060;pathName&#062; - (re)defines pathname.
</PRE>
<UL>
</UL>This sets the default pathname to be used when this buffer is later  written
to the filing system.

</UL><H5><A NAME="%B=SAMEFLAG1">%b=sameflag1</H5>
<PRE>
%b=sameflag1 - sets the user change-control flag.
</PRE>
<UL>
</UL>Sets the user flag SameFlag1 - this remains true until there is some  change
to the buffer text. This flag can be tested if ever a macro needs to  detect
changes that have occurred since the flag was set.

</UL><H5><A NAME="%B=TAGTYPE">%b=tagtype</H5>
<PRE>
%b=tagtype &#060;tagName&#062; colour &#060;foregroundColourNo&#062; &#060;backgroundColourNo&#062;
</PRE>

Currently the only tag types allowed are colour tags  but  it  is  envisaged
that this might be extended in the future.

This either defines a new colour pair or redefines  one.  Colour  pairs  are
defined in terms of the foreground and background colour and are  referenced
by the pair number.

The tag name can then be used to tag text with colour using the  `%b=addtag`
command - see also `about tagged text`.

Colours are identified by number in the range 0-to-7 - in linux these are:
<UL><LI>0 Black</LI>
<LI>1 Red</LI>
<LI>2 Green</LI>
<LI>3 Yellow</LI>
<LI>4 Blue</LI>
<LI>5 Magenta</LI>
<LI>6 Cyan</LI>
<LI>7 White</LI>

</UL>in windows:
<UL><LI>0 Black</LI>
<LI>1 Blue</LI>
<LI>2 Green</LI>
<LI>3 Cyan</LI>
<LI>4 Red</LI>
<LI>5 Magenta</LI>
<LI>6 Yellow</LI>
<LI>7 White</LI>
</UL>In windows, adding 8 gives a more intense colour.

e.g. To define a colour tag "fred" as yellow forground on a blue  background
in linux:
<PRE>
%s=colourpair fred 3 4;
</PRE>
in windows
<PRE>
%s=colourpair fred 6 1;
</PRE>
or, for a brighter yellow:
<PRE>
%s=colourpair fred 14 1;
</PRE>

</UL><H5><A NAME="%B=ADDTAG">%b=addtag</H5>
<PRE>
%b=addtag &#123;&#060;tagName&#062;|-text=&#060;textString&#062;&#125;;
</PRE>

<UL><LI>In the %b=addtag &#060;TagName&#062; form:</LI>
<UL>The TagName must match a previously defined tag type (see  `%b=tagtype`)
or the command fails.

Applies the named tag to the currently-selected substring in  text.  The
named tag type and it's colour pairs must  first  be  defined  with  the
`%b=tagtype` command - see also `about tagged text`.

If, at "addtag" time, there  is  a  selected  substring,  two  tags  are
applied - one at the start of the currently-selected substring  and  one
at it's end. If there is no selected substring then no end-tag is  added
the tagging continues through to the end of the line.
</UL>
<LI>In the %b=addtag -text=&#060;textString&#062; form:</LI>
<UL>The text string, which may be  of  any  length,  is  added  to  the  tag
descriptor. This string can be used for any  purpose  but  is  primarily
intended for use as a hashtable key. The string is only visible  in  the
`query tags` report.

</UL>Tags persist until removed  with  the  removed  with  the  `%b=remove_tag`
command or the text is deleted.

See also `About mouse events`, `%b=remove_tag`, `%s=mousemask` and `OP`

</UL><H5><A NAME="%B=REMOVE_TAG">%b=remove_tag</H5>
<PRE>
%b=remove_tag &#060;type&#062; &#060;name|key|text&#062;
</PRE>

The current character must be at the start-point of the tag to be deleted.

This command uses the details given and the  current-character  position  to
uniquely identify one tag and then removes it from the internal record  data
structure. In the event of there being two or more identical  tags  matching
the description, it randomly selects one of the matching  tags  and  deletes
it.

<UL><LI>The tag type field must be one of colour, text or target.</LI>
<LI>the name field for a colour tag must match the colour-tag  name,  for  a</LI>
text-tag it must match the first whitespace-separate  word  of  the  tag
text and, for a hash-table target, the name must  match  the  hash-table
key.
<LI>the current character and substring length  select  the  start  and  end</LI>
point of the tag.
</UL>
The tags were originally created by  the  `%b=addtag`,  `hashtable  new`  and
`hashtable add` commands - see `about tagged text`.

Where precise details of the tag is not  known,  use  the  `query  tags`  to
extract the necessary information from the internal data set.

In the event of there being no tag exactly matching the details  given  then
the command fails without affecting any tags.

</UL><H5><A NAME="%B=SORT">%B=sort</H5>
<PRE>
%b&#091;&#060;destBuf&#062;&#093;=sort &#091;&#060;sliceColumn1&#062;&#093;&#091; &#060;sliceColumn2&#062;&#091; &#060;sliceColumn3&#062; ...&#093;&#093;&#093;
</PRE>
Performs an alphabetical sort of all records in the buffer, by  default  the
records are sorted by the strings starting at the  first  character  (column
0). For tabular text, other columns  (slices)  may  be  specified,  to  sort
tab-separated tabular text use `%B=tabsort`
<UL>
</UL>Each parameter is taken as a slice definition (i.e. a  vertical  slice  down
the tabulated text), the following forms are supported:
<UL><LI>&#060;firstChrNo&#062;-&#060;lastChrNo&#062; - counting from the  first  character  in  each</LI>
record (chr no. 0), this defines a slice of the buffer to be used in the
sort comparison.
<LI>&#060;firstChrNo&#062;+&#060;width&#062; - defines the start  character  and  width  of  the</LI>
slice - minimum sensible width is 1.
</UL>
The sort function (a  version  of  quicksort)  compares  pairs  of  records,
initially from slice slice1. If they are found to be identical, it  tries  a
comparison from slice slice2, then slice3 etc... If no slices are  specified
it performs just one comparison on each complete record.

Note that left to the user to ensure that  each  record  has  at  least  the
number of columns specified - otherwise results are unpredictable.

The sort function modifies the current buffer and writes a sort summary into
the nominated destination buffer.

</UL><H5><A NAME="%B=TABSORT">%B=TabSort</H5>
<PRE>
%b=tabsort &#060;tab1&#062;&#091; &#060;tab2&#062; &#091;&#060;tab3&#062; ...&#093;&#093;&#093; - sort buffer holding tabular text.
</PRE>

Each tab entry is an integer in the range 0 to n-1 where n is the number  of
columns in the table.
<UL>
</UL>Similar to the  `%b=sort`  command,  tabsort  sorts  records  by  values  of
unaligned tab-separated fields, the delimiter character defaults to an ascii
VT ( 0xB ) character but can be redefined with the `%s=tab` command.

Shorter fields always rank higher in a  strcmp  string  comparison  so  some
additional whitespace padding may be required.

</UL><H5><A NAME="%B=CODEPAGE">%b=codepage</H5>
<PRE>
%b=codepage &#060;codepage&#062;
</PRE>
<UL>
</UL>This modifier is only available in the windows version. By default jot  uses
the 65001 (UTF-8).

This sets the codepage which is  only  relevant  to  unicode  -  see  `about
unicode`, `Practicalities of unicode etc. and jot.`

</UL><H4><A NAME="%Q">%Q</H4>
<PRE>
%Q&#091;&#060;bufferKey&#062;&#093;=&#060;query&#062;
</PRE>
<UL>
</UL>Query this command offers a few selected peepholes  into  selected  internal
editor states and the system environment.
<UL>
</UL>In most cases the target buffer, indicated by &#060;bufferKey&#062;, is the buffer  to
receive the  result.  The  exceptions  are  dir,  file,  SameFlag1  and  the
hashtable queries. In all cases the first line of output  to  the  nominated
buffer is the original %q command. Valid queries are:

%q~=... is a special case, the ~ buffer is created on the stack - see `about
the operand stack`.
<UL><LI>`query system` - Returns current system settings to specified buffer.</LI>
<LI>`query linux` fails if not running under linux.</LI>
<LI>`query windows` fails if not running under windows.</LI>
<LI>`query hashtables` - Summary report on all hashtables.</LI>
<LI>`query wd` -  Returns  users  current  working  directory  to  specified</LI>
buffer.
<LI>`query window` -  Reports  window  allocation  parameters  to  specified</LI>
buffer.
<LI>`query backtrace` reports command-script calls</LI>
<LI>`query date` - Reports current data and time to specified buffer.</LI>
<LI>`query env`  -  Reports  value  of  specified  environment  variable  to</LI>
specified buffer.
<LI>`Query stack` - Dumps stack contents to specified buffer.</LI>
<LI>`Query tabstops` - Fails if no tabstops set in current buffer.</LI>
<LI>`Query buffer` - Reports buffer status to specified buffer.</LI>
<LI>`Query samesinceio` - Fails if current buffer  has  been  changed  since</LI>
last read or written.
<LI>`Query samesinceindexed` - Fails if  current  buffer  has  been  changed</LI>
since last hash-table entry was added.
<LI>`Query sameflag1` - Fails if current buffer has been changed since  user</LI>
flag 1 was last reset.
<LI>`Query case` - Fails if case sensitivity is off.</LI>
<LI>`Query inview` - Fails if current character of current buffer is out  of</LI>
view.
<LI>`Query version` - Reports jot version to buffer, if specified or else as</LI>
a message to the console area.
<LI>`Query dir` - Reports contents of to buffer if specified or fails if not</LI>
a valid directory.
<LI>`Query file` - Reports system file data to buffer if specified, fails if</LI>
not a valid pathname.
<LI>`Query keys` - Writes a diagnostic dump of  buffer  hash-table  keys  to</LI>
specified buffer.
<LI>`Query tags` - lists the tags (hash-table target points and colour tags)</LI>
in current buffer.
<LI>`Query heap` - in linux sends heap-status to the nominated buffer.</LI>
<LI>`Query history` - Dumps command history to specified buffer.</LI>
<LI>`Query keys` - Lists details of all hashtable entries..</LI>
<LI>`Query key` &#060;string&#062; - Lists only hashtable entry specified by &#060;string&#062;.</LI>
<LI>`Query verify` - Checks consistency of current  buffer's  internal  data</LI>
structures.

</UL><H4><A NAME="QUERY SYSTEM">Query system</H4>
<PRE>
%q&#060;key&#062;=system
</PRE>

Reports current state of system settings to  nominated  buffer.  Each  value
appears as a separate record:
<PRE>
          Trace vector = &#060;hex value&#062; - of trace vector - (see `%S=trace`)
      Case sensitivity = &#060;hex value&#062; - case sensitivity vector - (see `%S=case`)
          Command mode = &#060;hex value&#062; - the command-mode vector (see `%S=commandMode`)
 Table-entry separator = &#060;hex value&#062; - the character used to separate  entries
</PRE>
<UL>in tabular text (see `%S=tab`).
<PRE>
   Hold screen on exit = &#123;On|Off&#125;    - Set by `-hold` CLI qualifier.
Buffers:
  buffer &#060;key1&#062;                   - First in list of defined buffers.
  buffer &#060;key2&#062;
  ...
Data-object buffers:
  data obj &#060;path&#062; 
  ...
</PRE>
</UL>
The list of buffers contains all buffers that have been created thus-far  in
the session, including some with lower-case alpha keys (i, t and p) -  these
are set up and used internally.

The final section of the list of active buffers are buffers created as  data
objects dangling off some other buffers hashtable - the parent buffer  might
itself be a similar data object. For these, the buffer key is always  '~'  -
indicating that they have, at some point, been  on  the  stack.  Instead  of
showing the buffer key, these entries show the pathname going back  down  to
the static parent buffer see `about hashtables`.

</UL><H4><A NAME="QUERY LINUX">Query linux</H4>
<PRE>
%q=linux
</PRE>

Used to test the underlying OS, this one fails for anything other than linux.

</UL><H4><A NAME="QUERY WINDOWS">Query windows</H4>
<PRE>
%q=windows
</PRE>

A simple test the underlying OS, this one fails for anything other than some
flavour of NT-windows.

Note - this has nothing  to  do  with  the  `query  window`  command,  which
generates a window-assignments report.

</UL><H4><A NAME="QUERY HASHTABLES">Query hashtables</H4>
<PRE>
%q&#060;key&#062;=hashtables
</PRE>

Searches all active  buffers,  for  each  of  those  with  a  hashtable.  It
generates a one-line list of all the buffers referenced by the  hashtable  -
see `about hashtables`.

</UL><H4><A NAME="QUERY WD">Query wd</H4>
<PRE>
%q&#060;key&#062;=wd
</PRE>
<UL><LI>Returns the users current working directory.</LI>
<UL>
</UL></UL><H4><A NAME="QUERY WINDOW">Query window</H4>
<PRE>
%q&#060;key&#062;=window - reports window assignments.
</PRE>
<UL>
</UL>Lists  screen  size,  details  of  all  allocated  windows  and  number   of
unallocated lines on the screen.

Then follows a screen dump - the current contents of the screen is copied to
the end of the  report.  Note  that  the  screen  dump  does  not  show  any
highlights, reverse video, colour tags or the cursor position.

Note - this has nothing to do with the `query windows` command, which  is  a
simple go-nogo test on your OS architecture.

</UL><H4><A NAME="QUERY TIME">Query Time</H4>
<PRE>
%q=time - pushes seconds since beginning of unix epoch onto the stack.
</PRE>

This uses the system clock to calculate how many seconds have elapsed  since
the begining of unix time (zero o'clock on the first of January  1970).  See
also `query cputime`.

</UL><H4><A NAME="QUERY CPUTIME">Query cputime</H4>
<PRE>
%q=cputime - pushes to stack, time elapsed since last query cputime.
</PRE>

This uses the system clock to measure the time interval  between  calls.  It
calculates gives a floating-point value calculated from the  system  seconds
and nanoseconds elapsed-time counters . Each time it's called  it  subtracts
the previous values of these counters from their current values and converts
the difference to a floating-point number, which is pushed onto  the  stack.
It is envisaged that this may be useful for some future profiling tool.  See
also `query time`.

</UL><H4><A NAME="QUERY DATE">Query date</H4>
<PRE>
%q&#060;key&#062;=date - reports date and time.
</PRE>
<UL>
</UL>Returns the current date and time in the form dd/mm/yy, hh:mm:ss
<UL>
</UL><H4><A NAME="QUERY ENV">Query env</H4>
<PRE>
%q&#060;key&#062;=env &#060;name&#062; - reports value of nominated env variable.
</PRE>
<UL>
</UL>Returns the current value of the specified variable in the users env.
<UL>
</UL><H4><A NAME="QUERY PID">Query pid</H4>
<PRE>
%q&#060;key&#062;=pid - Query the ID of the ediors process.
</PRE>

This reports just the process-ID number of the editor process.

</UL><H4><A NAME="QUERY STACK">Query stack</H4>
<PRE>
%q&#060;key&#062;=stack
</PRE>
<UL><LI>reports state of stack.</LI>

Returns the current state of the stack in decimal hex and character format -
see also `O?`.
<UL>
</UL></UL><H4><A NAME="QUERY TABSTOPS">Query tabstops</H4>
<PRE>
%q=tabstops
</PRE>

This is a  quick  test  to  identify  buffers
which have been set up for tabular text. The command  succeeds  if  tabstops
are set in the current buffer, otherwise it fails.

</UL><H4><A NAME="QUERY BACKTRACE">Query backtrace</H4>
<PRE>
%q&#060;key&#062;=backtrace
</PRE>

Lists macros, functions and scripts in the active call stack - for debugging
only. 

When called from a  normal  interactive  command  line  it,  unsurprisingly,
doesn't report very much. When called from a debugger break point prompt, it
shows all the call frames that led to  the  breakpoint.  It  also  dutifully
reports the debugger as a frame in the call stack.

In addition to the various scripts, macros and function calls you may notice
a few lower-case alpha macros you don't recognize:
<UL>i - the initialization commands passed in via the CLI qualifier `-init`
c - the normal interactive command buffer.
d - the debuggers own command buffer,
</UL>
See also `bt.jot`

</UL><H4><A NAME="QUERY BUFFER">Query buffer</H4>
<PRE>
%q&#060;key&#062;=buffer
</PRE>
<UL><LI>reports internal state of buffer.</LI>

Returns the state of  the  current  buffer  in  tabular  form  N.B.  if  the
nominated buffer is the current buffer  this  command  will  fail  and  will
return an empty report. e.g:
&#062; %qa=buffer
In buffer A it inserted the following text:
<PRE>
buffer
                  key = .                    The key for the buffer.
             pathName = t.t                  The pathname of the file read into the buffer.
     currentDatestamp = 2011/10/04, 16:27:16 The file's datestamp at the time of the query.
          SameSinceIO = TRUE                 This flag is set true when the file was originally read and reset by  a change to any text in the buffer.
     SameSinceIndexed = FALSE                This flag is set true by adding some hashtable entries and reset by  a change to any text in the buffer.
    SameSinceCompiled = FALSE                This flag is set TRUE when a new hash-table entry is added.
            SameFlag1 = FALSE                This flag is set by the `%b=sameflag1` command and reset by a change to any text in the buffer.
            NoUnicode = FALSE                Unicode support is enabled (controlled by `%b=unicode` command)
           lineNumber = 1                    The normal line number of the record.
           CurrentChr = 0                    The current character position, in this case it is the leftmost character of the record.
      SubstringLength = 0                    The length of the currently-selected substring - in this case none is selected.
         wholeRecords = TRUE                 Indicates that, if inserted into text it will not break lines.
          predecessor = =                    When called as a macro, this indicates the parent macro.
             editLock = Unrestricted         Other options are WriteIfChanged and ReadOnly.
           LeftOffset = 0                    See `%b=leftoffset`
    CurrentRec length = 209                  Indicates the current character in the current record, counting from the leftmost ( 0 )
 CurrentRec protected = 0                    Indicates that the current record of the buffer is a hash-table target and has been protected.
     ProtectedRecords = 0                    Indicates that the buffer contains at least one protected record.
               Header = "A"~"B"~"C" ...      See `%b=header`
             FileType = ascii                Currently the only valid entries are ascii or binary.
                        No tag types         If the buffer had tag types defined then these would be listed here (see `About Tagged text`).
        HashTableMode = 0                    Valid modes are 0 (No hashtable), 1 (ProtectEntries), 
                                               2 (AdjustEntries), 3 (DeleteEntries) and 4 (DestroyHashtables)
                                               see `hashtable create` for details.
             TabStops = 17 41 62 89 172 ...  Indicates columns in tabular text - see `about tabular text`.
                 htab = FALSE                Indicates that there is no hash table associated with this buffer.
</PRE>

</UL><H4><A NAME="QUERY SAMESINCEIO">Query samesinceio</H4>
<PRE>
%q=samesinceio
</PRE>
<UL><LI>tests state of buffers SameSinceIO flag.</LI>

Use this command to test for changes to the buffer since it was last read or
written back to the filing system.

Command exits with failure if  the  buffer  has  been  changed  in  any  way
compared to the  version  on  the  filing  system,  exits  with  success  if
unchanged. Note that text buffers which are not images of files  are  always
created with samesinceio set false.

</UL><H4><A NAME="QUERY SAMESINCEINDEXED">Query samesinceindexed</H4>
<PRE>
%q=samesinceindexed
</PRE>
<UL><LI>tests state of buffers SameSinceIndexed flag.</LI>

Use this command to test for changes to the the buffer since making the last
hash table entry.

Command exits with failure if the buffer has been changed in any  way  since
it was indexed with the `%H` commands, exits with success if unchanged. Note
that text buffers which have  not  been  indexed  are  always  created  with
samesinceindexed set false.

</UL><H4><A NAME="QUERY SAMEFLAG1">Query sameflag1</H4>
<PRE>
%q=sameflag1
</PRE>
<UL><LI>tests state of buffers SameFlag1 flag.</LI>

Use this command to test for changes to the buffer since the flag was set.

Command exits with failure if the buffer has been changed in any  way  since
the SameFlag1 was set (see `%b=sameflag1`), exits with success if unchanged.
Note that text buffers  are  initially  created  with  samesinceindexed  set
false.

</UL><H4><A NAME="QUERY CASE">Query case</H4>
<PRE>
%q=case
</PRE>
<UL><LI> Success if case sensitivity is on.</LI>

This simply sets the failure flag - it fails if case sensitivity is off.

</UL><H4><A NAME="QUERY INVIEW">Query inview</H4>
<PRE>
%q=inview
</PRE>
<UL><LI>Success if current character is visible on the screen, adds other  details</LI>
to stack.

Verifies that current character is  visible  with  the  current  setting  of
leftoffset - see `%b=leftoffset` and `about long lines`.  This  query  works
independently of the display management, the consequence of this is that  it
is not necessary  to  update  the  display  (see  the  `W`  command)  before
launching the query.
 
This query always pushes three values onto the stack:
<UL><LI>perceived current character offset - i.e. if tabstops are set,  it  take</LI>
these into account.
<LI>width of the screen and</LI>
<LI>the current buffer's leftoffset,</LI>
<LI>for a tabcells buffer (see `about tabular text`) the  query  fails  when</LI>
the current character is in a truncated part of the cell text - even  if
it's cell is somewhere between the screen margins.
</UL>
This command fails if the current character is outside the visible area. i.e
if the current character is off to the right of the screen  when  leftoffset
has been set too low or left of the left margin when the leftoffset has been
set to high.

The values placed on the stack are designed to be a  useful  starting  point
for calculation of a revised  leftoffset  -  for  an  example  look  at  the
definition of `WordLeft` and `WordRight` in the standard startup script.

</UL><H4><A NAME="QUERY COMMANDMODE">Query commandmode</H4>
<PRE>
%q=commandmode
</PRE>
<UL><LI>Success if editor is in command mode.</LI>

This does not affect any buffers or the stack - it  just  returns  a  status
result - Success indicates that the editor is indeed in command  mode,  fail
indicates that it is in insert mode.

</UL><H4><A NAME="QUERY VERSION">Query version</H4>
<PRE>
%q&#091;&#060;key&#062;&#093;=version
</PRE>
<UL><LI>reports editor version and, where appropriate, curses version.</LI>

This delivers a brief informational message about the editor  version  build
date and host system. If the buffer key is given this message goes  to  that
buffer otherwise it goes to the console area of the screen. A typical report
looks like this:
<PRE>
version
jot for chrome v2.0, built 27/12/16 16:59:42 using crouton  ncurses 6.0.20150808
</PRE>

The  majority  of  the  reply  is  defined  by   the   compile-time   string
VERSION_STRING. This is typically defined with using the output of the uname
command.

The  final  section   is   obtained   by   calling   the   curses   function
curses_version().

</UL><H4><A NAME="QUERY DIR">Query dir</H4>
<PRE>
%q&#091;&#060;key&#062;&#093;=dir &#091;&#060;fmt1&#062; &#091;&#060;fmt2&#062; &#091; &#060;fmt3&#062; ... &#093;&#093;&#093;&#060;path&#062;
</PRE>
<UL><LI>reports contents of directory.</LI>

If the specified pathname does not exits or does not point to  a  directory,
then the command fails. If no destination buffer is specified then  the  dir
query will only verify the path.

If the destination buffer is specified (i.e. if the optional buffer  key  is
given) then the dir query lists the contents of the nominated  directory  to
the nominated buffer. Note that the order is just as returned by the  filing
system - you will need to use `%b=sort` to get them in order.  This  command
will always check that the path exists and  destination  node  really  is  a
directory and will fail if this is not  so.  If  no  destination  buffer  is
specified this query will only check that the given path  exists  and  is  a
directory.

If any format specifiers are included then the relevant information is added
to  the  file  entries.  The  following  format  specifiers  are   currently
supported:
<UL><LI>-mtime - the file's modification time in the form yyyy/mm/dd-hh:mm:ss</LI>
<LI>-utime - the file's usage time in the form yyyy/mm/dd-hh:mm:ss</LI>
<LI>-ctime - the file's creation time in the form yyyy/mm/dd-hh:mm:ss</LI>
<LI>-uid - the uid of the file's owner (not available in Windows version),</LI>
<LI>-gid - the gid of the file's owner (not available in Windows version),</LI>
<LI>-size - the file size in bytes,</LI>
<LI>-mode - file permissions, in  windows  it  only  indicates  Readonly  or</LI>
Writable,
<LI>-inode - the file's inode number (not available in Windows version),</LI>

</UL>In the report sent to the specified destination buffer,  the  optional  data
fields are separated from the file names by a tab (VT)  character.  To  make
this a bit easier on the eye run the `autotab.jot` script.

</UL><H4><A NAME="QUERY FILE">Query file</H4>
<PRE>
%q&#091;&#060;key&#062;&#093;=file &#091;&#060;pathName&#062;&#093;
</PRE>
<UL><LI>reports on state of file.</LI>

The file query will always check that the pathName exists and will  fail  if
this is not the case. If no destination buffer is specified, this  check  is
all it does.

If no file name is specified then the pathName  of  the  current  buffer  is
used. If no pathname is specified and the destination buffer is the same  as
the current buffer then this command fails without completing the report.

When the destination buffer is specified, the file query lists various  bits
of system information about the  specified  file.  Note  that  there  is  no
stripping of additional whitespace following the delimiter blank  after  the
file keyword.

The following report is written to the destination buffer:
<PRE>
file &#060;pathName&#062;
                 Name = "&#060;pathName&#062;"
                inode = &#060;inodeNumber&#062;
                 Mode = &#060;modeInOctal&#062;
                  uid = &#060;userID&#062;
                  gid = &#060;groupID&#062;
                 size = &#060;fileSizeInBytes&#062;
 writable by this UID = &#060;yes|no&#062;
            directory = &#060;1_IfDirectory_0_IfNot&#062;
          Access time = &#060;fileAccessTime&#062;
          Modify time = &#060;fileModifyTime&#062;
        Creation time = &#060;fileCreationTime&#062;
</PRE>
All datestamps are in the following format: YYYY/MM/DD, HH:MM:SS

</UL><H4><A NAME="QUERY KEYS">Query keys</H4>
<PRE>
%q&#091;&#060;destinationBuffer&#062;&#093;=keys
</PRE>

This dumps all the keys associated with the current buffer to  a  report  in
the nominated destination  buffer  it  fails  if  there  is  no  hash  table
associated with the current buffer. If no destination  buffer  is  specified
then it simply returns the status result. In addition to listing each key in
full, it also the first 30 characters of the text associated with the key.

The keys are part of the internal  hash-table  data  structure.  While  this
query may be useful for diagnosis of problems with  macros  -  it's  primary
purpose is the detection of errors in the editors internal  hash-table-entry
handling operations.

</UL><H4><A NAME="QUERY KEY">Query key</H4>
<PRE>
%q&#091;&#060;destinationBuffer&#062;&#093;=key &#060;hTabKey&#062;;
</PRE>

This reports on the specified hash-table entry the report  is  sent  to  the
specified buffer. If the key has not been set up in that hash table then the
command fails.

</UL><H4><A NAME="QUERY TAGS">Query tags</H4>
<PRE>
%q&#060;destinationBuffer&#062;=tags&#091; -here&#093;
</PRE>

In the  internal  data  structure,  each  record  has  any  number  of  tags
associated with it. These tags are used  to  maintain  hashtables,  optional
text colours and user-specified metadata in the form of text  strings.  This
query lists the tags (hash-table target points, colour tags and  text  tags)
in current buffer the report goes to a nominated destination buffer.

The optional qualifier -here will return  only  those  tags  active  at  the
current character. Currently, this is the only mechanism for  extraction  of
user-specified metadata from the record. One useful application for this  is
storage of hash-table keys  associated  with  the  text  -  especially  when
combined with a mouse-event handler. The `linkdocs.jot`  and  `bookings.jot`
scripts are examples of this.

</UL><H4><A NAME="QUERY HEAP">Query heap</H4>
<PRE>
%q=heap
</PRE>
<UL><LI>reports heap statistics.</LI>

Reports raw data from the mallinfo routine (see the mallinfo man page).

</UL><H4><A NAME="QUERY HISTORY">Query history</H4>
<PRE>
%q&#060;buf&#062;=history
</PRE>
<UL><LI>reports command history.</LI>

Reports all entries in the history  buffer  in  chronological  order  -  the
report is directed to the nominated buffer. The size of the  history  buffer
is limited but can be changed with the `-history` cli qualifier. This report
is used in the command-edit screen - see `about command editing`.

N.B. The history maintained for the history query is entirety independent of
the history file in the journal area - see `about journal files`.

</UL><H4><A NAME="QUERY VERIFY">Query verify</H4>
<PRE>
%q=verify
</PRE>
<UL><LI>Verify integrity of current buffer's internal data structures.</LI>
</UL>
This command performs a few simple checks aimed at detection  of  errors  in
the internal record structures. The main test is to ensure that  the  string
length of each record is never longer than the allocated string  size.  This
situation should *never* occur, if it were to, the editor would crash before
long as other internal data gets corrupted.

If the verbosity level is more than 1 (See `%S=verbose`) then  the  contents
of the buffer are echoed to the console area.

</UL><H3><A NAME="%H">%H</H3>
The  %H  command  is  used  for  maintenance  of  hashtables  -  see  `about
hashtables`

<PRE>
%H&#091;&#060;key&#062;&#093;=create &#060;n&#062;&#091; &#060;path&#062;&#093; &#123;-delete|-destroy|-protect|-adjust&#125;
</PRE>
<UL><LI>Creates a new hashtable. See `hashtable create`</LI>

<PRE>
%H&#091;&#060;path&#062;&#093;=add &#060;hashTableKey&#062; - Create a hashtable entry.
</PRE>
See `hashtable add`

<PRE>
%H&#091;&#060;path&#062;&#093;=new &#060;hashTableKey&#062; - Create a new hashtable entry, fails if path 
</PRE>
does not define a unique name. See `hashtable new`

<PRE>
%H&#091;&#060;path&#062;&#093;=data &#060;hashTableKey&#062; - creates a hashtable object which can hold a 
</PRE>
stack frame - see `hashtable data`.

<PRE>
%H&#091;&#060;path&#062;&#093;=setsect &#060;hashTableKey&#062; - creates a hashtable object for use in a 
</PRE>
%i=&#060;pathName&#062; ... -section; command - see  `hashtable setsect`

<PRE>
%H&#091;&#060;path&#062;&#093;=setfsect &#060;hashTableKey&#062; - creates a hashtable object for use in a 
</PRE>
%i= ... -fsection; command - see  `hashtable setfsect`

<PRE>
%H&#091;&#060;path&#062;&#093;=delete &#060;hashTableKey&#062; - Removes specified hash-table entry.
</PRE>
See `hashtable delete`

<PRE>
%H&#091;&#060;bufferKey&#062;&#093;=jump &#060;hashTableKey&#062;
</PRE>
<LI>Search for a match to path - see `hashtable jump`.</LI>
<UL>
<PRE>
%H&#091;&#060;key&#062;&#093;=call &#060;hashTableKey&#062; -  Search for routine then run it.
</PRE>
</UL>See `hashtable call`

<PRE>
%H&#091;&#060;path&#062;&#093;=fix - resets line numbers for referencing hashtables.
</PRE>
See `hashtable fix`

<PRE>
%H&#091;&#060;path&#062;&#093;=destroy&#091; -all&#093; -  Destroys the hashtable.
</PRE>
See `hashtable destroy`

<PRE>
%H&#091;&#060;path&#062;&#093;=testkey &#091;&#060;string&#062;&#093; -  Verifies the hashtable entry exists.
</PRE>
See `hashtable testkey`

<PRE>
%q&#091;&#060;destBufKey&#062;&#093;=keys - lists all keys in the hash table associated with
</PRE>
<UL>this buffer - see `Query keys` for details  it  fails  if  there  is  no
hashtable associated with the buffer.

</UL><LI>%q&#091;&#060;destBufKey&#062;&#093;=key &#060;keyString&#062; - reports details of that key - if  the</LI>
<UL>key is not defied in the hashtable then the command fails.


</UL></UL><H5><A NAME="HASHTABLE CREATE">Hashtable create</H5>
<PRE>
%H&#091;&#060;bufferKey&#062;&#093;=create &#060;size&#062;&#091; &#060;path&#062;&#093; &#091;-delete|-destroy|-protect|-adjust&#093; - Create a new hashtable.
</PRE>
<UL>
</UL>Create an empty hashtable in specified buffer, or  the  current  buffer,  if
none specified. The size parameter specifies the size  of  the  table.  Take
care to not underestimate the required size. The value can be  specified  on
the command line or picked up from the top of the stack.

If the buffer already has a hashtable then this is destroyed first and  it's
mode and entries are copied to the new hashtable, at this point any  zombies
are removed (entries that have been  deleted  with  the  `hashtable  delete`
command). This behaviour is intended to allow purging  and  re-sizing  while
preserving existing entries.

If the size is set to 0 or any negative value then any preexisting  hastable
is destroyed and no new  hashtable  is  created  -  the  overall  effect  is
identical to `hashtable destroy`.

The hashtable contains pointers to various classes  of  object  (see  `about
hashtables`):

<UL><LI>'target strings' in your text - allowing fast access to sections of text, </LI>

<LI>data objects (see `hashtable data`), which can be copied to and from  the</LI>
stack and

<LI>file-section objects (see `%I`)</LI>

</UL>There are several options regarding behaviour when the targeted strings  are
to be deleted (see `about hashtables`). Essentially these are:

<UL><LI>-adjust - When  any  target  string  is  deleted  the  relevant  entries</LI>
targeting hashtables are silently redirected to some nearby point.  This
is the default mode of operation.

<LI>-delete - When any target string  is  changed  the  relevant  hash-table</LI>
entries are marked as deleted.

<LI>-destroy - When any target string is deleted the targeting hashtable  is</LI>
silently destroyed and all of it's target tags are  removed.  Any  other
changes in the vicinity of the hashtable target points cause the targets
to be adjusted.

<LI>-protect - Any record containing  a  target  string  is  protected  from</LI>
deletion Any other changes in  the  vicinity  of  the  hashtable  target
points cause the targets to be adjusted.

</UL><H5><A NAME="HASHTABLE ADD">Hashtable add</H5>
<PRE>
%H&#091;&#060;bufferKey&#062;&#093;=add &#060;hashtableKey&#062; - adds a hashtable key.
</PRE>
<UL>
</UL>Adds a new jump entry (see `hashtable jump`)  to  the  hash  table  for  the
specified or, current buffer, if none is specified.  The  hash  table  entry
will store the exact location  of  the  current  character  in  the  current
buffer. In the event of a collision (i.e. the  key  already  exists  in  the
hashtable) the original value is silently replaced by  the  new  value.  See
`about hashtables`.

</UL><H5><A NAME="HASHTABLE NEW">Hashtable new</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=new &#060;hashtableKey&#062; - adds a new hashtable key.
</PRE>
<UL>
</UL>Similar to add (above) except  that,  in  the  event  of  a  collision,  the
original entry is unchanged and the command fails. See `about hashtables`.

</UL><H5><A NAME="HASHTABLE JUMP">Hashtable jump</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=jump &#060;hashtableKey&#062; - performs a hashtable lookup and jump.
</PRE>
<UL>
</UL>The hash table in the specified buffer  (or  the  current  buffer,  if  none
specified) is searched. If the key exists then the focus is restored to  the
point at which the key was entered. If  the  key  is  not  found,  then  the
command fails - see `about hashtables`.

</UL><H5><A NAME="HASHTABLE DATA">Hashtable data</H5>
<PRE>
%h&#091;&#060;bufferKsy&#062;&#093;=data &#060;HashtableKey; - creates a hashtable entry for storage of generic data.
</PRE>

This creates a hashtable entry which can be used  for  storage  of  a  stack
frame. The command creates a blank entry and does not affect  the  state  of
the stack. The data value can be refined with the  `OV`  command  and  later
retrieved using the `OQ` commands. 

Note the absence of any typing with this command, any  of  the  three  valid
stack datatypes (integer value, floating-point value or buffer) may be  used
with any data object and the datatype is allowed to change. In this example,
the data object fred is first set to an integer, then a float and,  finally,
a buffer - it's all allowed.
&#062; %h=create 100;
&#062; %h=data fred;
&#062;ol123456789 ov/fred/
&#062; ol123.456 ov/fred/
&#062; %d~=Hello world; ov/fred/

</UL><H5><A NAME="HASHTABLE SETSECT">Hashtable setsect</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=setsect &#060;hashtableKey&#062;; - creates a hashtable entry for use in %i;
</PRE>

This takes the top two items on the stack and creates a hashtable entry  for
use by the -section=&#060;key&#062; qualifier of the `%I`  command.  This  is  a  rare
example of a magic command in jot -  it  is  designed  for  use  by  scripts
reading index tables for large files and is only useful  for  this  purpose.
(see `about large files`).

Another unusual feature of this command - although it uses two values at the
top of the stack, it does not remove them.  This  feature  is  designed  for
scripts which calculate section byte counts by subtracting seek neighbouring
seek points.

</UL><H5><A NAME="HASHTABLE SETFSECT">Hashtable setfsect</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=setfsect &#060;hashtableKey&#062;; - creates a hashtable entry for use in %i;
</PRE>

This takes the top three items on the stack and creates  a  hashtable  entry
for use by the -fsection=&#060;key&#062; qualifier of the `%I` command. It is designed
for use by scripts reading index tables for large numbers of  files  and  is
probably only useful for this purpose.  (see  `about  large  collections  of
files`).

Another unusual feature of this command,  similar  to  `hashtable  setsect`,
although it uses three values at the top of the stack, it  does  not  remove
them. This feature is designed for the computational convenience of  scripts
calculating section byte counts by  subtracting  the  previous-section  seek
point from the current-section seek point.

Note that consecutive setfsect calls referring to the same pathname will all
share the same internally-held copy  of  the  pathname.  This  behaviour  is
designed  to  minimize  memory  usage  by  the  internal  data   structures.
Fortunately most practical  indexation  methods  will  generate  index  file
structured in this way.

</UL><H5><A NAME="HASHTABLE DELETE">Hashtable delete</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=delete &#060;hashTableKey&#062;;
</PRE>

This changes the state of the selected key to a  sort  of  half-dead  zombie
state. Unfortunately it is not possible to delete keys from hashtables built
using the gnu-library hashtables. So we do the next-best thing.

The hash key can be re-assigned - this, for example, will work:
&#062; %h=add fred;
&#062; %h=delete fred;
&#062; %h=data fred;

The zombies are removed if the hashtable is rebuilt - see `hashtable create`.

</UL><H5><A NAME="HASHTABLE CALL">Hashtable call</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=call &#060;functionName&#062;
</PRE>
<UL>
</UL>The buffer indicated by the key must be a code  repository  (  see  `calling
subroutines by name` ). The `startup.jot` script, for example,  defines  and
creates hash-table entries for a number of routines in the ' buffer.

In the event of the named subroutine is not in the  specified  buffer,  then
the call fails silently.

Note that %h=call does not pass parameters into the routine.  The  way  this
is done with escape sequences is a little bit  of  code  immediately  before
the call that copies parameters into the ( $ ) buffer - see `translation  of
keyboard events to actions`

</UL><H5><A NAME="HASHTABLE FIX">Hashtable fix</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=fix
</PRE>
This corrects the linenumbers held in  any  hashtable  it  also  resets  the
linenumber of the first line to 1 and returns to the first line.

If records are added or removed after the  buffer  has  been  indexed  in  a
hashtable, the linenumbers held in the hashtable may be incorrect. This  can
result in errors when using these linenumbers to calculate  offsets  between
indexed records. The fix operation assigns the new, correct, linenumbers  in
the referencing hashtables and resets the buffer so that any errors  in  the
line numbering are resolved.

</UL><H5><A NAME="HASHTABLE DESTROY">Hashtable destroy</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=destroy&#091; -all&#093;
</PRE>

This removes the entire hashtable, destroying all entries. The optional -all
qualifier will destroy all hash tables in all buffers - N.B.  including  any
system hashtables like the code-repository functions set up in  the  (  '  )
buffer.

</UL><H5><A NAME="HASHTABLE TESTKEY">Hashtable testkey</H5>
<PRE>
%H&#091;&#060;bufferKey&#062;&#093;=testkey &#091;&#060;string&#062;&#093;
</PRE>

By default this tests the hashtable of  the  current  buffer.  The  optional
bufferKey specifies some other buffer's hashtable to be tested. 

The %h=testkey command verifies the hashtable  contains  at  least  one  key
matching the given string. This is used to find out if a hashtable has  been
set up and, if a search string is given, that at least one key  matches  the
string.

If the string parameter is not  given,  then  this  command  checks  that  a
hashtable exists.

This command does not write any report, it simply returns a Success or  Fail
status.

</UL><H4><A NAME="%D">%D</H4>
<PRE>
%D&#060;key&#062;=&#060;string&#062; - Defines the specified buffer directly from the console.
</PRE>

The first parameter is the buffer identifier key - a single  character  used
to reference the buffer. Note that, unlike most other percent commands,  any
indirect references in the  string  are  not  resolved  at  %D  time  -  see
`percent-command syntax` for details. This anomalous behaviour  is  designed
to facilitate the definition of macro commands.

Whereas %D will define a single-line buffer (usually a macro) `%G` is useful
for defining any-number of lines.

</UL><H4><A NAME="%G">%G</H4>
<PRE>
%G - Get = Reads in an buffer from current command stream or macro.
</PRE>

This is similar to the `G` command, except that whereas G always takes input
from the console, %G will take from whatever command input currently  active
<UL><LI>typically a script. Thus %G is a handy way for scripts to define</LI>
multi-line macros.

Whereas %G defines any number  of  records  `%D`  is  a  convenient  way  of
defining a single-line macro.

</UL><H4><A NAME="%I">%I</H4>
<PRE>
%I&#091;&#060;bufferKey&#062;&#093;&#091;=&#060;pathName&#062;&#093;&#091; -seek=&#060;ByteNo&#062;&#093;&#091; -bytes|-block=&#060;bytes&#062;|-records=&#060;n&#062;&#093;|
</PRE>
&#091; -section|-fsection&#093;&#091; -insert | -append&#093;&#091; -hold&#093;&#091; -binary&#091;=&#060;recordSize&#062;&#093;&#093;
<UL><LI>Input (read) a secondary file.</LI>
</UL>
This loads the file to buffer specified by the buffer identifier key. If  no
key is given, it reads to the current buffer.

The pathname defaults to the pathname of the currently-edited file.  If  the
new filename is incompletely specified then the missing fields are filled in
using the current-buffer's pathname. Note  that  this  behaviour  can  cause
difficulties. If the new file is in your pwd and the current file is in some
other directory, you must prefix the name with the path "./". If the  target
file has no name extension and the current file does, you must change  focus
to a buffer with no pathname set.

Briefly %I has the following optional qualifiers several dedicated  in  some
way to the loading of sections of large files - see `about large files`:
<UL><LI>-seek - specifies a byte-offset section start point,</LI>
<LI>-bytes - specifies a section length in bytes,</LI>
<LI>-section - loads a named section, previously defined in a hashtable,</LI>
<LI>-fsection - as -section but object also specifies pathname,</LI>
<LI>-append - adds the section to the end of an existing file image,</LI>
<LI>-insert - inserts the text at the current-character position,</LI>
<LI>-hold - holds the file-handle open for reading multiple sections,</LI>
<LI>-records - limits the number of records (lines) read from the file,</LI>
<LI>-binary - loads the (possibly binary) file in the form of a Hex dump</LI>
</UL>
The -bytes qualifier gives it an end count which restricts the read to  that
many bytes. It can be combined freely with the  -hold,  the  -seek  and  the
-binary options. The -block qualifier is similar  in  that  it  specifies  a
limit on the number of bytes but, with -block, blocks of data are read  into
one record of the specified size. This feature is designed to speed  up  the
movement of large blocks of data by bypassing all the normal record-building
activity associated with normal reads. The -records=&#060;n&#062;  qualifier  sets  an
upper limit on the number of records to be read.

The -seek can be used for reading sections of file, provided you know  where
the desired section is and how big it is. It can be useful for  reading  the
important bits from large files.

The -section qualifier sets the seek and limit from the top two items on the
stack. This is designed to  be  used  in  conjunction  with  the  `hashtable
setsect` command. Unlike the -fsection variant, -section  assumes  that  the
pathname is known and constant. It is therefore more suitable for situations
where only one file is required - typically a very large file  containing  a
great many sections.

The -hold qualifier causes the file handle associated with the buffer and to
be left open, this is to facilitate reading of files in blocks.  The  actual
file handle is associated with the buffer and therefore cannot  be  used  to
read into other buffers. This option is intended to be used  in  conjunction
with the -section option, on very large files.

The -fsection qualifier  is  very  similar  to  -section,  except  that  the
hashtable object it accepts is the form created by the `hashtable  setfsect`
command. These objects are created by the `hashtable setfsect` command. Like
the  setsect  object,  this  contains  a  seek-offset  byte  count   and   a
section-length bytecount but it also contains the pathname of the file to be
read. This  makes  the  -fsection  variant  suitable  for  situations  where
sections are distributed over a large number of files.

The -binary option reads the file and displays it in the form of a hex dump.
The optional recordSize value specifies ow many Hex pairs to place  in  each
line, defaults to 16 if not specified. To  view  ascii  characters  use  the
script `hex2ascii.jot`, this annotates each line of hex dump with the  ascii
translation.

The -insert qualifier  causes  the  file  image  to  be  inserted  into  the
current-character position of the buffer. By default the buffer  is  cleared
and the new file completely defines the buffer text. The  -append  qualifier
is similar except that the new records are  delivered  to  the  end  of  the
current buffer without changing the current view.

If the buffer has already been reading a file with -hold, the  new  pathname
is ignored and the old file handle is reused. To prevent this  happening  it
is necessary to perform a read without the -hold qualifier - something  like
this should do the trick:
&#062; %iz=/dev/null -append;

</UL><H4><A NAME="%L">%L</H4>
<PRE>
%L &#091;&#060;width&#062;x&#060;height&#062;&#093; - Sets the terminal line length and number of lines.
</PRE>

This is a throwback to the  days  of  VT200-series  terminals,  the  DECCOLM
function allowed 80/132 switches.

More typically, in an  xterm  environment  the  xterm  size  is  changed  by
dragging the window boundaries. After this, %l  can  be  used,  without  the
terminal-size parameter, after changing the xterm dimensions. It reads  back
the new screen height and width henceforth these  new  values  are  used  in
internal calculations involving screen dimensions.

If a terminal size is specified, each of the given dimensions should be less
that the than or  equal  to  the  corresponding  dimensions  of  the  actual
terminal you are using - if not then %L fails and both are set to the actual
screen size.

After a %L operation, all windows remain valid except any where the right or
bottom margin exceeds the relevant new terminal dimension.  If  this  should
happen the %L sets the failure flag and the offending windows are tagged  as
Void. Use the `WindowOne` function to re-assign the window.

This command also completely redraws all windows on the screen, hence it  is
useful if, for whatever reason, the screen happens to get messed up.

</UL><H4><A NAME="%O">%O</H4>
<PRE>
%O&#091;&#060;pathName&#062;&#093;&#091; -append&#093;  - Output current buffer as specified file.
</PRE>

The current buffer is written out using the given pathname.

The -append qualifier adds the contents of the buffer  to  the  end  of  the
file. Whether or not the -append qualifier is given, if the  file  does  not
exist, then a new one is created.

The pathName defaults to the pathname of the current buffer. If the new file
name is incompletely specified then the missing fields are filled  in  using
the current pathname.

</UL><H4><A NAME="%R">%R</H4>
<PRE>
%R=&#091;pathname&#093;&#091; -asConsole&#093;&#091; &#060;Arg1&#062;&#091; &#060;Arg2&#062;&#091; ...&#093;&#093;&#093; - Run a command file.
</PRE>

If no path is explicitly specified, then JOT first  searches  your  PWD,  if
it's not found there, it  searches  the  directory  $&#123;JOT_HOME&#125;/coms  -  see
`installation`.

Any parameters will be copied into the ( $ ) buffer to be picked up by  your
script.

The file contains editor commands, these are all executed in the same way as
with console input, the default file name is startup.jot.

In the event of an un-trapped error (i.e.  a  command  failed  and  no  else
clause applies), then execution of the script is  normally  terminated.  The
-asConsole qualifier changes this behaviour.

When the -asConsole qualifier is  given,  the  behaviour  is  more  like  an
interactive session:
<UL><LI>Errors are reported normally then, instead of abandoning the script, the</LI>
error is changed to an  ordinary  command  failure  so  that  processing
resumes at the else block or the next line of the script.
<LI>The script may contain escape sequences - in practice the only ones that</LI>
are likely to contain these are recovery scripts -  see  `about  journal
files`.
<LI>While the script is active  all  console  reads  (e.g.  commands  and  g</LI>
command input) are from this script.
<LI>The principal purpose for -asConsole  operation  is  to  allow  recovery</LI>
scripts to behave as the  original  interactive  session  -  see  `about
journal Files`.
</UL>
Command files may be nested to a depth of 20.

</UL><H4><A NAME="%U">%U</H4>
<PRE>
%U - Undo = Undo last substitution.
</PRE>

The current substring (irrespective of whether selected by `F`, `V`, `I`  or
`S`) is replaced by the last specified search string. Normally,  of  course,
this would have been set as a result of a S (substitute) command,  following
a F (Find) command, hence the substitution is undone.

If the original find substring had a different case pattern to the  replaced
substring (i.e. the find was done in case-insensitive mode)  then  the  undo
will not reflect the original case pattern.

</UL><H4><A NAME="%W">%W</H4>
<PRE>
%W&#091;&#060;key&#062;&#093;=&#091; -winno=&#060;n&#062;&#093;&#091; -key=&#060;NewKey&#062;&#093;&#091; -popup&#093;&#091; -delim&#093;
</PRE>
<UL>&#091; -height=&#060;height&#062;&#093;&#091; -width=&#060;width&#062;&#091;+&#060;guard&#062;&#093;&#093;&#093;&#093;
&#091; -delete|-insert|-freeze=&#091;0|1&#093;&#093;
</UL><H5><A NAME="HISTORICAL SYNTAX">Historical syntax</H5>
<PRE>
%w &#060;height&#062;&#091; &#060;key&#062;&#093;;
</PRE>
<UL>
</UL>The %W command controls the display which may be split into  any  number  of
windows, limited by the overall  size  of  your  terminal.  Windows  may  be
defined as a number of screen lines or may be vertical  slices  of  &#060;height&#062;
lines and &#060;width&#062; columns. Windows may be assigned to  specific  buffers  or
can be left unassigned - in which case they display the current buffer.

The window configuration can be modified by specifying a  particular  window
deleting it or specifying a  new  &#060;width&#062;,  &#060;height&#062;  or  &#060;windowKey&#062;  of  a
specific window.

<UL><LI>Set up next &#060;height&#062; lines as a screen window or</LI>
&#062; %W&#060;key&#062;= -width=&#060;width&#062;&#091;+&#060;guard&#062;&#093;
<LI>set up another vertical slice in the previously defined window or</LI>
&#062; %W&#060;key&#062;= -popup &#091; -width=&#060;width&#062;&#093;&#091; -height=&#060;height&#062;&#093;
<LI>defines a popup window (only appears when buffer contains text) or</LI>
&#062; %W;
<LI> with no arguments, all screen windows are cleared</LI>
&#062; %W &#060;height&#062;&#091; &#060;key&#062;&#093;;
</UL>This is a historical syntax, still supported but deprecated. If, when  using
the historical syntax, a -height=&#060;height&#062; qualifier is  included,  then  the
height specified here overrides the earlier specification. 

New windows, or vertical slices of windows,  are  added  in  sequence  by  a
series of %W commands, typically the first  will  be  %W;  -  to  clear  all
windows.

Note that the qualifiers must always follow whitespace  -  this  is  correct
syntax:
&#062; %wz= -height=11;
this will fail:
&#062; %wz=-height=11;

<UL><LI>&#060;height&#062; - Specifies the number of screen lines to allocate  to  the  next</LI>
window. These are allocated sequentially starting from the top  line.  New
windows are added below any preexisting ones. Note that  n  specifies  the
total size of the window, if you later request a delimiter line (%w 0;  ),
this replaces the bottom line of your window and if you specify  a  header
line to be associated with a buffer (see `%b=header`) then  this  replaces
the top line of your window. eg:
&#062; %w 20;
or, here we take the window size off the stack:
&#062; %w '~;

<LI>The -delim option requests that the last line of the window be filled with</LI>
a delimiter line. The  window  delimiter  is  in  reverse  video  and,  by
default, set to the pathname and the buffer key - see `%b=footer`.

An obsolete method of requesting a delimiter line was %w=0; after  the  %w
used to define the window - this is deprecated but still supported for the
benefit of old scripts.

<LI>The optional -width=&#060;width&#062; modifier specifies the  width  of  a  vertical</LI>
slice of the window. When mixed with  %W=&#060;height&#062;  ...  this  becomes  the
leftmost slice in a new window of that height. When the  window-height  is
set to 0, then a new slice of the specified  width  is  added  to  earlier
slices.

By default, the left margin of the second and subsequent slices will  abut
the right margin of the predecessor slice. The  +&#060;guard&#062;  modifier  (where
&#060;guard&#062; is a small integer) will insert that many  blank  columns  between
the slice and it's predecessor slice.

<LI>The optional &#060;key&#062; parameter specifies which buffer is  to  be  associated</LI>
with the screen window, if this is not given then the  current  buffer  is
displayed in the window - a floating window. 

In the event of there  being  more  than  one  floating  window,  or,  one
floating window and the current window is attached  to  a  static  window,
then the  floating  window  is  left  displaying  whatever  buffer  it  is
currently displaying or, at the start of day, it displays blank lines.

<LI>When  the  optional  -winno=&#060;windowNo&#062;  modifier  is  given,  rather  than</LI>
creating a new window, the  command  will  modify  the  attributes  of  an
existing window. The &#060;windowNo&#062; refers to the target window's position  in
the window list. This is the same as  the  order  that  the  windows  were
originally created and appears at the head of the report generated by  the
`Query window` command.

The  -winno=&#060;windowNo&#062;  qualifier  can  be  combined  with  the  following
modifiers to modify the relevant attributes of the target window:
<UL><LI>-height=&#060;height&#062; - to set the window height - for slices see below,</LI>
<LI>-width=&#060;width&#062; - to specify a new slice width,</LI>
<LI>-key=&#060;NewKey&#062; - to specify a new buffer association for the window.</LI>
<LI>-delete - deletes the selected window from the window list.</LI>
<LI>-insert - inserts the newly-specified window above the selected window.</LI>
<LI>-freeze=&#091;0|1&#093; - forces the window in/out of frozen mode - see below.</LI>

</UL>When it is required to change the height of an existing group  of  slices,
this can be  accomplished  by  changing  only  the  height  of  the  first
(leftmost) slice in the group. Any attempt to change the height  of  other
members of the group will fail.
<UL>
</UL><LI>The -freeze=1 modifier forces the selected window to be frozen -  even  if</LI>
there are no duplicate views in other windows. The -freeze option  can  be
applied to any window and it will remain displaying whatever was displayed
as the %w ... -freeze command was issued. Note that the  -freeze  modifier
is ignored for popup windows. The -freeze=0 modifier unfreezes the window.

Note that jot does not maintain a record of the state of  frozen  windows.
It simply avoids updating them as  the  state  of  the  underlying  buffer
changes. Any subsequent `%W` or `%L` command will clear  the  window  and,
should a `%E` corrupt the display by scrolling into the frozen section  of
the display, then the %E output will replace the original view.

<LI>When the -popup option is given, a buffer key must be given. Popup windows</LI>
can be used to display information or to provide some sort of  menu-driven
interface. These are  visible  only  when  the  associated  buffer  has  a
nonblank first line.

Popups overwrite rectangular sections of the display, in order  to  ensure
that the popup becomes visible the popup window should  be  defined  after
the definition of the underlying windows.

There is no limit to the number  of  popups  but  since  each  requires  a
dedicated buffer and it is quite easy to share them between  a  number  of
activities it is good practice to use as few as possible.

For -popup windows, the height and -width dimensions specify  the  maximum
size that the window can be allowed to grow to - if unspecified the  popup
may grow to fill the entire terminal screen. The top-left character of the
popup is normally aligned to  the  top  left  character  position  of  the
screen. If a negative width is specified  then  the  top  right  character
position of the popup is aligned to the top-right  character  position  of
the screen.

Note that, by default, the popup appears in the same colour pair and  font
as the surrounding text with no delimiter  markers.  It  is  left  to  the
programmer to make suitable arrangements for the popup stand out from  the
surrounding text. Failure to do this will make the display very confusing.

See also `%S=guardband`.

Examples:
&#062; %w;              %%Clear away all preexisting windows.
&#062; %w 35; %w 0;     %%Add one window of 34 lines and a delimiter line.

</UL><H4><A NAME="%%">%%</H4>
A JOT comment.

The command scanner ignores all text to the right of the %%.

</UL><H4><A NAME="%~">%~</H4>
<PRE>
%~ - Insert/Evaluate Control Character
</PRE>
<UL>
</UL>All control characters (i.e. characters having an ASCII code  of  less  than
0x20) are represented on the screen as a '~'. To evaluate such a  character,
the %~ command returns the ASCII code, in hex,  for  the  character  at  the
cursor position. This command has an optional hex-value parameter, if  given
then the command will instead insert a control character  of  the  specified
value, at the cursor position.

</UL><H2><A NAME="JOT TECHNIQUES">JOT techniques</H2>
This section attempts to reveal some insights into JOT usage.

</UL><H3><A NAME="DO THAT AGAIN">Do that again</H3>
Simply typing a number at the console will repeat the last command that many
times. This is how the &#060;&#060;Again&#062;&#062; function works. Typically you will want  to
do  this  when  you've  typed  in  a  short  command  string  and  want   to
interactively control how many times it gets repeated.

e.g. The following command removes any indentation from the current line and
replaces it with two blanks:
&#062; (v/ /e)0i/ /m
To repeat the treatment  on  subsequent  lines  just  keep  on  pumping  the
&#060;&#060;Again&#062;&#062; key.

</UL><H3><A NAME="CASE BLOCKS">Case blocks</H3>
A block can have any number of failure handlers, thus each case becomes  the
failure handler for the previous one e.g. (v/fred/..., v/jim/..., ...)

</UL><H3><A NAME="MATCH TO ANY NUMBER OF EQUAL-PRIORITY CONDITIONS.">Match to any number of equal-priority conditions.</H3>
A block without a failure handler will pass it's status  up  to  the  parent
block, so if there are a list of conditions, any of  which  may  be  met  we
could write something like this:
<UL>( ... (v/fred/\v/jim/\v/bill/\) abc, def )
</UL>If the cursor is at the start of any of those names, then the command string
abc is executed, otherwise it's command def.

</UL><H3><A NAME="TABULATED TEXT">Tabulated text</H3>
Several scripts are available for handling tabulated text.  These  apply  to
the entire buffer. To limit the scope of these scripts, abstract the section
containing the tabular data into a temporary buffer and apply the scripts in
there.

By default, the tab character is the ASCII HT (Horizontal  Tab  0x0B),  this
can be redefined with the `%s=tab` command.

The scripts are all based on the  tab  character  indicating  the  alignment
points.
<UL><LI>`retab.jot` &#060;string&#062; - inserts tabs based on text content.</LI>

<LI>`retabhere.jot` - inserts tabs based on position.</LI>

<LI>`autotab.jot` - replaces the first instance of a tab with blanks  so  as</LI>
to align the following text.

<LI>`autotabdp.jot` - similar to autotab but aligns decimal points in column</LI>
following the first tab.

<LI>`autotabjust.jot` - similar to autotab but aligns the following  tabs  -</LI>
the effect is to right-justify the column.

</UL><H2><A NAME="COMMAND-LINE QUALIFIERS">Command-Line qualifiers</H2>
The following command-line qualifiers are allowed,  the  keywords  are  case
insensitive, the  upper-case  alphas  indicate  the  minimum  requirement  -
briefly:
<UL><LI>`-HOld` - holds screen on exit.</LI>
<LI>`-Help` - displays a brief help page.</LI>
<LI>`-History`=&#060;n&#062; - specifies size of internal history buffer.</LI>
<LI>`-Init`=&#060;jotCommands&#062; - some initialization commands, run after startup.</LI>
<LI>`-Journal` - create a journal file for recovery from crashes.</LI>
<LI>`-New` - The specified primary file does not exist.</LI>
<LI>`-Obey` - stdin stream is commands.</LI>
<LI>`-Quiet` - suppresses most messages.</LI>
<LI>`-STartup` &#060;pathName&#062; - specifies a nonstandard startup script.</LI>
<LI>`-SCreensize`=&#060;width&#062;x&#060;height&#062; - specifies screen size.</LI>
<LI>`-STACksize`=&#060;n&#062; - specifies operand-stack size.</LI>
<LI>`-To`=&#060;pathName&#062; - specifies the new default filename</LI>
<LI>`-Tty` - run in a simple teletype mode.</LI>
<LI>`-Locale`=&#060;locale&#062; - Set the locale appropriately (unix version only).</LI>
<LI>`-Codepage`=&#060;codepage&#062; - sets codepage (windows version only)</LI>

</UL><H4><A NAME="-NEW">-New</H4>
<PRE>
$ jot -new &#060;pathName&#062; ...
</PRE>

Either the file does not exist or, if it does it will be ignored. The editor
starts with an empty buffer but with with the  specified  pathname  and  the
file will be created by a `%o` or `%c` command.

</UL><H4><A NAME="-TO">-To</H4>
<PRE>
$ jot &#060;origPathName -to=&#060;toPathName&#062; ...
</PRE>

Sets the `%o` and `%c` destination file name.

</UL><H4><A NAME="-STARTUP">-STartup</H4>
<PRE>
$ jot &#060;pathName&#062; -startup=&#091;&#060;startupPathName&#062;&#093; ...
</PRE>

A  pathName  to  a  special  startup  sequence.  If  specified,  this  takes
precedence  over  the  other   possible   startup-file   locations   -   see
`startup.jot`. 

If -startup is specified with no pathName argument then no startup is run.

</UL><H4><A NAME="-INIT">-Init</H4>
<PRE>
$ jot &#060;pathName&#062; -init=&#060;jotCommandString&#062; ...
</PRE>

The jotCommandString commands are processed after running the normal startup
sequence - this can be used to initialize the editor in some special way  or
for stream editing. This qualifier is also useful when jot is  being  driven
by a shell script.

</UL><H4><A NAME="-TTY">-Tty</H4>
<PRE>
$ jot &#060;pathName&#062; -tty ...
</PRE>

Teletype mode, for use  in  environments  where  the  normal  screen-control
operations won't work or, when jot is driven by a script.

With -tty any window setup in the startup file has no effect, on  completion
of each command line, the current line is displayed,  the  position  of  the
current character is indicated by a carat ( ^ ) in the  following  line  and
the current substring by a string of tildes ( ~ ).

</UL><H4><A NAME="-CODEPAGE">-Codepage</H4>
<PRE>
$ jot &#060;pathName&#062; -codepage &#060;value&#062; ...
</PRE>

This qualifier is available only  in  the  windows  version,  in  linux  the
-locale qualifier performs a similar function. This qualifier sets  codepage
to specified value, by default codepage  is  set  to  65001  -  UTF8  -  see
`Practicalities of unicode etc. and jot.`

</UL><H4><A NAME="-LOCALE">-Locale</H4>
<PRE>
$ jot &#060;pathName&#062; -locale=&#060;locale&#062; ...
</PRE>

This qualifier is available only  in  the  linux  version,  in  windows  the
`-Codepage` qualifier performs a similar function.

This sets the default locale for all buffers. Locale currently only  affects
the rendering of unicode characters. e.g:
<PRE>
$jot $&#123;JOT_RESOURCES&#125;/t.t -locale=en_US.utf-8
</PRE>

For linux the  default  locale  is  inherited  locale  from  the  shell  env
XTERM_LOCALE.

</UL><H4><A NAME="-OBEY">-Obey</H4>
<PRE>
$ jot pathName -obey &#060;&#060; EndOfCommands ...
cmd1
cmd2
cmd3
EndOfCommands
</PRE>

By default, when jot detects that stdin is not a keyboard, it is assumed  to
be a text stream to be picked up and processed in  the  primary  buffer.  In
this  case,  however,  it's  a  series  of  commands.  The  -obey  qualifier
identifies these as such

To push short sequences of in from the command line, the -init=&#060;...&#062;  method
is generally preferable.

Note that the last command in the -obey sequence  *must*  be  %c  or  %a  to
terminate the editor session.

This option is really only useful in shell scripts in order to make the  jot
commands visible and accessible in the same context as the shell commands it
interacts with. For an example look at Test 8 in $&#123;JOT_HOME&#125;/test.sh.

</UL><H4><A NAME="-JOURNAL">-Journal</H4>
<PRE>
$ jot ... -journal ...
</PRE>

This specifies a directory to hold the journal files. The journal files  are
used to recover your work following a crash. See `About Journal  Files`  and
`recover.jot` for details.

</UL><H4><A NAME="-QUIET">-Quiet</H4>
<PRE>
$ jot ... -quiet ...
</PRE>

Suppresses all prompts and messages except for `P` commands. In -tty mode it
also suppresses any indication of substrings and the current character.

</UL><H4><A NAME="-SCREENSIZE">-SCreensize</H4>
<PRE>
$ jot ... -screensize=&#060;width&#062;x&#060;height&#062; ...
</PRE>

Sets the screen size - only useful for  non-curses  environments  where  the
editor can't determine the screen size for itself. The width is  denominated
in characters, height in lines.

</UL><H4><A NAME="-STACKSIZE">-STACksize</H4>
<PRE>
$ jot ... -stacksize=&#060;n&#062; ...
</PRE>

Sets the size of the operand stack to n. By default it is 100, if  you  need
more then there's probably something gone badly wrong with your scripts.

</UL><H4><A NAME="-HOLD">-HOld</H4>
<PRE>
$ jot ... -hold ...
</PRE>

On exit, this holds the  curses  screen  until  any  keyboard  character  is
detected. This allows you see any messages generated by a script before  the
session finally terminates as you hit any key.

In windows, the windows console is not restored on exit so -hold just  slows
down your exit.

</UL><H4><A NAME="-HISTORY">-History</H4>
<PRE>
$ jot ... -History=&#060;n&#062; ...
</PRE>

Sets the size of the internal command-history buffer, by default it's set to
to 20 lines. The first element of the history array is the current  command,
which must always exist. Hence you must specify a value in of 1 or more  for
this.

This buffer holds the last few typed-in commands. You  cannot,  at  present,
edit history directly but you can only view  the  contents  of  the  history
buffer with the %q&#060;buf&#062;=history command - see `query history`.
<UL>
</UL>N.B. The size of this history buffer has no effect on the operation  of  the
journal history - see `about journal files`.

</UL><H4><A NAME="-HELP">-Help</H4>
<PRE>
$ jot -help
</PRE>
 
Displays a brief description of the jot CLI qualifiers and exits.

</UL><H3><A NAME="IMPLICIT MODES">Implicit modes</H3>
The editor automatically recognizes when it's stdin is some sort of stream.

</UL><H4><A NAME="READ STDIN">Read stdin</H4>
This is a useful alternative to more or less -  some  unix  utility  squirts
text that's piped into jot and, when an EOF is received,  the  text  becomes
visible as a text buffer.

Examples:
<PRE>
$ ls -laRF | jot
$ man xterm | jot
</PRE>

</UL><H4><A NAME="STREAM-OUT MODE">Stream-out mode</H4>
In normal usage, the `P` command prints line in the console area.  When  the
editor is stared in stream-out mode the printed lines are  sent  to  stdout,
where they can be directed to a  file  or  piped  to  another  process.  The
stream-out operation  is  detected  automatically  when  stdout  is  set  to
anything except your  xterm  (or  windows  console).  e.g  (this  matches  a
specific class of error message with the function name):
<PRE>
$ jot message.log -quiet -tty -init="t(f/warning: unused variable/onf-/in function/n.r2f1/:/aa&ono-omhapm)0 %a" | cat
</PRE>
This would also cause it to enter stream-out mode:
<PRE>
$ jot message.log -q -tty -in="t(f/warning: unused variable/onf-/in function/n.r2f1/:/aa&ono-omhapm)0 %a" &#062; errors.lis
</PRE>

Note the use of the -tty and -quiet qualifiers in these two examples -  -tty
this prevents xterm escape sequences appearing in stdout, -quiet  suppresses
many normal messages that would otherwise appear in the output stream.

In stream-out mode the records selected by the `P` command is sent off  down
stdout where it can be piped  off  to  some  other  process.  This  mode  of
operation  is  used  in  the  99  bottles  of   beer   demonstration.   (see
`http://99-bottles-of-beer.net`)

99 bottles of beer is a simple drinking song:

<PRE>
99 bottles of beer on the wall, 99 bottles of beer.
Take one down and pass it around, 98 bottles of beer on the wall.
   ...   
2 bottles of beer on the wall, 2 bottles of beer.
Take one down and pass it around, 1 bottle of beer on the wall.
  
1 bottle of beer on the wall, 1 bottle of beer.
Take one down and pass it around, no more bottles of beer on the wall.
  
No more bottles of beer on the wall, no more bottles of beer.
Go to the store and buy some more, 99 bottles of beer on the wall.
</PRE>

The object of the exercise is to write some code in your favourite language
to generate the lyrics correctly - this is one way of doing it in jot:

<PRE>
cat - | jot /dev/null -tty -obey &#060;&#060; EndOfJotCommands
i/$ bottles of beer on the wall, $ bottles of beer./b
i/Take one down and pass it around, $ bottles of beer on the wall./b2
m-0nm2aaha99
m-0ol99(f/$/o#oo/%d/)2 (ol1o-(f/$/o#oo/%d/)3)98
(f-0/1 bottles/-e-)3 (f/$/s/no/)3l0c
mki/Go to the store and buy some more, 99 bottles of beer on the wall./m-0b-p0
%a
EndOfJotCommands
</PRE>

</UL><H2><A NAME="INSTALLATION">Installation</H2>
Start  by  downloading  either  jot_v&#060;version&#062;.tz   or   jot_v&#060;version&#062;.zip,
whichever you fancy - both archives contain exactly the same files.
<UL>
</UL>Before you can run the editor a certain amount of system-dependent setup may
be necessary - see either `unix and linux setup` or `ms-windows setup`.

These envs are referenced  by  either  the  main  editor  programme  or  the
scripts:
<UL><LI>JOT_HOME - points to the installation tree root</LI>
<LI>JOT_JOURNAL - if set then all sessions create a journal.</LI>
<LI>JOT_RESOURCES  -  used  by  some  scripts  (e.g.  `dic.jot`)  to  locate</LI>
resources such as dictionaries, the startup script uses  it  to  find  a
help-file tree. If this file exists $&#123;JOT_RESOURCES&#125;/help/help.hlp, then
this is taken to be the root help entry.

</UL>Of these, the only essential one, for a working installation,  is  JOT_HOME,
it uses this to locate the coms subdirectory (where  it  picks  up  scripts,
including the all-important startup  scripts).  When  JOT_RESOURCES  is  not
defined, the startup script  defaults  it  to  $&#123;JOT_HOME&#125;/resources  -  the
resources directory  from  the  archive  contains  test,  demonstration  and
training samples.
<UL>
</UL>Typically jot will be started from the command line  from  an  xterm  (or  a
windows console) with a pathName argument, the editor takes over the  screen
and displays an image of the specified file. It also reads a  setup  script,
by default $&#123;JOT_HOME&#125;/coms/startup.jot,  this  defines  functions  and  the
mapping of keyboard events to functions. To do this the  JOT_HOME  env  must
point to the correct point in the installation tree.

Also, if you have a shared jot installation then you may prefer to  maintain
your own $&#123;JOT_RESOURCES&#125; files. This is a collection  of  bits  and  pieces
used by some jot scripts.

<PRE>
JOT_HOME should point here --&#062;   v&#060;version&#062;                                  
                                     |                                    
                  ---------------------------------------------                  
                 |      |      |                  |            |                  
                bin    coms   releasenote.txt    resources    source                     
                 |      |                         |            |
                ...    ...                       ...          ...   
</PRE>

In addition to files in the jot archives you may feel the need  for  one  or
more of the following:

<UL><LI>Websters dictionary, useful for authors, available as a plain-text Ebook</LI>
from the Gutenberg project  - gutenberg.org

<LI>Roget's thesaurus, another must-have for authors, again  it's  available</LI>
as an Ebook from Gutenberg.

<LI>aspell - a GNU spelling checker. This one was chosen because  it  has  a</LI>
command-driven interface, most of the others will only  work  via  their
GUI.

<LI>xls2csv - this can be downloaded from the sourceforge libxls project. It</LI>
is used  to  convert  Microsoft  XL  spreadsheets  to  plain  text.  For
`get.jot` xls2csv is used in preference to tika as it allows  individual
sheets to be selected.

<LI>Apache Tika - this is  a  very  useful  format  conversion  utility.  In</LI>
particular it is used by `get.jot` to convert the following  formats  to
plain text: MS-word, PDF and MS-XL - although xls2csv is  the  preferred
converter for XL as this allows sheet selection. Tika  requires  a  java
installation.

<LI>iconv - a gnu unicode converter (see the GNU libiconv project), used  by</LI>
get.jot to convert the  various  other  unicode  formats  to  UTF-8  for
display in jot.

<LI>Windows users will probably find life much  easier  with  the  UnixUtils</LI>
toolset. Even if thy do not personally  have  any  use  for  basic  unix
utilities like ls etc, many jot scripts are written assuming them to  be
available.

<LI>xsel  -  this  little  utility  provides  an  interface   to   X-windows</LI>
selections. This is used by `copy.jot` and  `paste.jot`  to  access  the
X-windows selection buffer.

Although not always  available  by  default,  xsel  is  available  as  a
download from your linux disto provider.

Windows users need  not  fret  about  xsel,  windows  does  not  support
selections so you will have to use cut and paste instead.

<LI>cabextract, used by get.jot to unpack  these  microsoft  archives,  it's</LI>
available by default with most linux distributions.

</UL><H3><A NAME="UNIX AND LINUX SETUP">Unix and linux setup</H3>
Wherever you decide to unpack the archive, JOT_HOME should be set  to  point
at the v&#060;version&#062; directory. You will also  need  to  set  search  path.  In
linux/bourne-shell:
<PRE>
$ export JOT_HOME=/&#060;path&#062;/v&#060;version&#062;
$ export PATH=$&#123;JOT_HOME&#125;/bin/&#060;arch&#062;/;$&#123;PATH&#125;
</PRE>

In order to minimize the number of statically-linked libraries in the  linux
version, the `%s=copy` and `%s=paste`commands are  not  available  with  the
linux executables supplied in the download. This deficiency can be corrected
by recompiling with X11 enabled and, if necessary, installation of  the  X11
libs and header files.

If you have to recompile the jot executable,  these  commands  should  work,
there may be a few _devl and sharable libraries to be  installed:
<PRE>
$ versionString="jot &#060;version&#062;, built `\date +%d/%m/%y\ %H:%M:%S` `\uname -nspr`  "
$ cc -D LINUX -g -Wall $&#123;JOT_HOME&#125;/source/jot.c -D_FILE_OFFSET_BITS=64 -D VERSION_STRING="\"$&#123;versionString&#125;\"" \
</PRE>
<UL>-lncursesw -lX11 -lXt -o $&#123;JOT_HOME&#125;/bin/&#060;arch&#062;/jot
<PRE>
$ gcc -g source/jot.c -D VERSION_STRING="$&#123;versionString&#125;" -lncursesw -o bin/&#060;arch&#062;/jot
</PRE>
</UL>
<UL>The linux executables supplied in the tarball were statically linked to the
curses library, with cut and paste disabled by  the  noX11  flag,  using  a
command similar to this:
<PRE>
$ gcc -DLINUX -DnoX11 $debug -g -Wall source/jot.c \
</PRE>
-D_FILE_OFFSET_BITS=64 -D VERSION_STRING="\"$&#123;versionString&#125;\"" \
-Xlinker -dn -lncursesw -lncurses -Xlinker -dy -lgcc_s -o ed/bin/jot
</UL>
See also `X-windows setup`.

To use the `doc.jot` spelling check, you will need  aspell  on  your  search
path.

</UL><H4><A NAME="THINGS THAT MIGHT GO WRONG">Things that might go wrong</H4>
<UL><LI>bash: jot: command not found</LI>
<UL>Check your search path like this:
<PRE>
$ echo $PATH
</PRE>
You should see the path to the bin subdir in  the  colon-separated  list
it returns - if not check the following:
<UL><LI>did you remember to start a new bash after setting up your .bashrc?</LI>
<LI>is the spelling and case pattern correct.</LI>

</UL>If the path is correct then check  the  binary  is  giving  you  execute
permission:
<PRE>
$ ls -l &#060;binPath&#062;/jot
</PRE>
you should see something like this "-rwxr-xr-x" if you don't see  the  x
characters then make it executable - like this:
<PRE>
$ chmod ugo+x &#060;binPath&#062;/jot
</PRE>
</UL>
<LI>/lib64/libc.so.6: version 'GLIBC_2.17' not found </LI>
<UL>This is probably because you are using an old  linux  distribution.  Try
installing a newer glibc - either glibc.x86_64 or glibc.i686  for  older
32-bit machines. Another  approach  would  be  to  try  recompiling  the
source, you will need various libraries including some _dev libs  and  a
gcc - see the previous section for details of the gcc command.
</UL>
<LI>Error opening terminal: &#060;termName&#062;.</LI>
<UL>Check your TERM env:
<PRE>
$ echo $TERM
</PRE>
Most distributions default it to "xterm" if  it's  something  different,
then try setting it to xterm like this:
<PRE>
$ export TERM=xterm
</PRE>
If that works out, and you have no reason to want it  to  be  different,
put that export line into  ~/.bashrc  so  you  don't  have  to  keep  on
setting it in every new shell.

If, however, your TERM is set to  xterm,  then  you've  got  a  problem.
Check your terminfos:
<PRE>
$ ls -l /usr/share/terminfo/x/xterm*
</PRE>
There will probably be several flavours of xterm to chose from - pick  a
likely looking one and export that one.

</UL></UL><H4><A NAME="X-WINDOWS SETUP">X-windows setup</H4>
The mapping of keyboard function keys is dependent on  various  elements  of
operating system and it's setup. This is done in several stages, ultimately,
JOT picks up text characters, control codes and VT100-like escape sequences.

Jot is implemented using functions from the curses library - these provide a
consistent mapping of most function keys to control codes which jot can  map
to your selected actions at setup time.

In addition to function keys and other keys supported by  curses,  jot  will
recognize   vt220-like   escape   sequences   generated   in   response   to
numeric-keypad actions. The mapping of these is not consistent and different
installations may give different results. Use  xev  and  xmodmap  to  define
these mappings. See also `Keyboard functions defined at startup`

The  jot  setup  assumes  unique  keycodes  from   the   numeric   keyboard,
unfortunately,  in  the  linux-curses  environment,   the   numeric   keypad
keystrokes are indistinguishable from their twins in other sections  of  the
keyboard. The windows version does not use curses and does not  suffer  from
this  problem.  The  solution  for  linux  users,  wanting  to   use   their
bean-counters keypad, is to redefine the numeric keyboard keys with xmodmap.
e.g:
<PRE>
$ xmodmap $&#123;JOT_RESOURCES&#125;/my_xmodmap
</PRE>
 
This version of my_xmodmap works for PC keyboards:
<PRE>
!! Make the numeric keypad keys unique.
keycode  63 = KP_Multiply
keycode  82 = KP_Subtract
keycode  86 = KP_Add
keycode  91 = KP_Decimal
keycode 108 = KP_Enter
keycode  79 = KP_7
keycode  80 = KP_8
keycode  81 = KP_9
keycode  83 = KP_4
keycode  84 = KP_5
keycode  85 = KP_6
keycode  87 = KP_1
keycode  88 = KP_2
keycode  89 = KP_3
keycode  90 = KP_0
</PRE>

</UL><H3><A NAME="MS-WINDOWS SETUP">MS-Windows setup</H3>
Wherever you unpack the archive, JOT_HOME should be  set  to  point  at  the
v&#060;version&#062; directory. You will also need to set search path. System registry
entries are the recommended method but, hey, life is short maybe  this  will
be good enough for now:
<PRE>
$ setx JOT_HOME=C:\&#060;unpackPath&#062;\v&#060;version&#062;\
$ set PATH=C:\&#060;unpackPath&#062;\v&#060;version&#062;n.m\bin\win32;%PATH%
</PRE>

In windowsland it is most unlikely you will need to recompile, which is just
as well since compiling just about anything in windowsland is  going  to  be
painful. If you have a working cl installation and libgcc and  libgw32c  gnu
libraries (try sourceforge) then something like this might work:
<PRE>
$ cl /c /DVC /D__value=_value /Zi /D_DEBUG /DVERSION_STRING="jot for WindowsNT v&#060;version&#062;" %JOT_HOME%\jot.c /Fojot.obj
$ link /debug /out:%JOT_HOME%/bin/jot.exe jot.obj ^
</PRE>
<UL>&#060;MSDKsPath&#062;\v7.1\Lib\*.Lib ^
&#060;gnuLibPath&#062;\libgw32c-0.4\lib\libgw32c.a ^
&#060;gnuLibPath&#062;\libgcc\lib\libgcc.lib


</UL>
