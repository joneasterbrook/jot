<P><! Made with jot using doc2html >
<link rel="stylesheet" href="flip.css" type="text/css">


</UL><H2><A NAME="JOT WALKTHROUGH">JOT Walkthrough</H2>
<BR><A HREF="#WALKTHROUGH SYNTAX"><SMALL>Forward to </SMALL>Walkthrough Syntax</A><BR><BR><BR>

<P>This is a simple walkthrough course for those who just want to get their hands dirty without going into the finer details of jot - such details may be found in the <A HREF="jot_ug.html#JOT USER GUIDE">jot user guide</A> and the <A HREF="jot_tech.html#JOT TECHNICAL GUIDE">jot technical guide</A>. </P>

<P>The exercises here do not require much thought, they are simply to get your fingers used to the jot way of doing things. Just follow the instructions, on completion, don't expect a framed and gilded certificate of accomplishment but feel free to treat yourself to a doughnut.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="WALKTHROUGH SYNTAX">Walkthrough Syntax</H3>
<A HREF="#JOT WALKTHROUGH"><SMALL>Back to </SMALL>JOT Walkthrough</A><BR><A HREF="#BASICS"><SMALL>Forward to </SMALL>Basics</A><BR><BR><BR>



<P>In the forgoing text the following shorthand applies (see <A HREF="jot_tech.html#ABOUT METASYNTAX">About metasyntax</A>):</P>

<UL><P><LI>This is a description of some text rather than the literal text: &#060;description&#062;</P></LI>

<P><LI>This is an instruction, to you, to type something in response to the computers Command-Line Interpreter prompt (CLI - e.g. the Windows console or unix shell):</P></LI>

<PRE>
$ &#060;a CLI Command&#062;
</PRE>
<P><LI>This is an instruction, to you, to type something in response to the editors command prompt:</P></LI>

&#062; &#060;a jot command or key&#062;
<P><LI>&#123;Key&#125; - This specifies a key on your keyboard.</P></LI>

<P><LI>&#123;Key1 Key2 ...&#125; - This specifies a sequence keys in order (as read from left to right)</P></LI>

<P><LI>&#123;Key1+Key2+...+FunctionKey&#125; This means press and hold key1 with key2 etc and then hit the function key. Key1, key2, etc are one or more of &#123;Shift&#125;, &#123;Ctrl&#125; and &#123;Alt&#125; keys, the function key is typically one of the top-row function keys, a mid-keypad or numeric-keypad key.</P></LI>

<P>N.B. literal env-variable references of the form $&#123;&#060;envVariableName&#062;&#125; (e.g: $&#123;JOT_HOME&#125; should not be confused with the &#123;&#060;key&#062;&#125; metasyntax.</P>

<P>The name of the key given in the curly brackets is generally the name printed on the key cap. The main exceptions are the beancounters keypad where the key names are prefixed KP_ and the cursor control keys referred to as &#123;UpArrow&#125;, &#123;DownArrow&#125;, etc..</P>

<P><LI>&#060;&#060; ... &#062;&#062; - is a reference to some jot function. This might be attached to a hotkey e.g. &#060;&#060;FindNext&#062;&#062; refers to the jot FindNext function, normally attached to &#123;F8&#125;.</P></LI>

<P><LI>&#091;&#060;optional&#062;&#093; - some optional element of a command syntax.</P></LI>

<P><LI>&#091;&#060;option1&#062;|&#060;option2&#062;|...&#060;lastOption&#062;&#093; - a series of optional alternatives, you may give one or more of these.</P></LI>

<P><LI>&#091;|&#060;option1&#062;|&#060;option2&#062;|...&#060;lastOption&#062;&#093; - a series of optional alternatives, you must chose none or only one of these.</P></LI>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="BASICS">Basics</H3>
<A HREF="#WALKTHROUGH SYNTAX"><SMALL>Back to </SMALL>Walkthrough Syntax</A><BR><A HREF="#STARTING JOT"><SMALL>Forward to </SMALL>Starting jot</A><BR><BR><BR>



<P>Jot is a command-driven screen-based editor - it obeys commands either typed-in directly or picked up from function keys etc and it maintains an screen image of the file being edited and displays changes as they happen.</P>

<P>Text is held in buffers, in the form of a complete file image or fragments. Jot maintains a number of buffers. Each buffer is identified by a single character key, typically A to Z, 0 to 9 and the various punctuation marks etc.</P>

<P>Jot has a small number of primitive commands and some structure-building syntax elements. On completion, most commands return a success/failure indication which can be picked up by the structural elements of the language.</P>

<P>Sequences of commands can also be held, as text, in buffers (a macro) and macros can be run and will deliver status results like the primitive commands.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="STARTING JOT">Starting jot</H3>
<A HREF="#BASICS"><SMALL>Back to </SMALL>Basics</A><BR><A HREF="#LOOK AT THE JOT DISPLAY"><SMALL>Forward to </SMALL>Look at the jot display</A><BR><BR><BR>



<P>The usual way to start jot is from a command line - i.e. an xterm (linux) or a console (windows). It is also possible to set it up to fire up from an icon of your choice - but then since you can't explicitly-specify a pathname you will have to hunt around in some idiotic menu to locate the file you already knew you wanted to work on.</P>

<P>Assuming your environment is set up correctly (see <A HREF="jot_tech.html#INSTALLATION">installation</A>) in linux you can start the editor from the command line from an xterm like this:</P>

<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/Richard_III_Entire_Play.txt
</PRE>
<P>In windows, start from a Terminal session like this:</P>

<PRE>
$ jot %JOT_RESOURCES%/Richard_III_Entire_Play.txt
</PRE>
<P>At the bottom of the terminal window you should see the prompt "1 .&#062; " This is an invitation to type commands to the editor the '1' is the line number, the '.' is the buffer key - see below.</P>

<P>Jot has a number of CLI qualifiers (see <A HREF="jot_tech.html#COMMAND-LINE QUALIFIERS">command-Line qualifiers</A>) but here we will only need to know about three of them: -journal, -init and -startup</P>

<PRE>
$ jot ... -journal
</PRE>
<P>This causes the editor to keep a journal which can be used to recover the session in the event of a crash or a power failure and</P>

<PRE>
$ jot ... -init="&#060;jotCommands&#062;"
</PRE>
<P>After running the normal startup script, but before starting the normal interactive session, the given command sequence is executed.</P>

<PRE>
$ jot ... -st=&#060;pathName&#062;
</PRE>
<P>Runs the specified startup script instead of default one.</P>

<PRE>
$ jot ... -st
</PRE>
<P>Runs the editor with no startup script.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="LOOK AT THE JOT DISPLAY">Look at the jot display</H3>
<A HREF="#STARTING JOT"><SMALL>Back to </SMALL>Starting jot</A><BR><A HREF="#SOME BASIC COMMANDS TO GET STARTED"><SMALL>Forward to </SMALL>Some basic commands to get started</A><BR><BR><BR>



<P>Look again at the Richard III session you started earlier.</P>

<UL><P><LI>Notice the screen is split into two areas. At the top there's an image of the file - a display window,</P></LI>

<P><LI>then there's a delimiter line in reverse video showing the pathname and the buffer key.</P></LI>

<P><LI>Finally, at the bottom, is the console area. Immediately after startup there should be three messages visible - these originate from the various scripts that comprise the startup procedure. Finally, in the bottommost line there's a command prompt "1 .&#062;" this in invitation for you to type in a command. The ( 1 ) indicates that we are currently focused on line 1 of the text. The full stop (or period, according to taste) ( . ) indicates that we are currently viewing the primary buffer.</P></LI>

<P>The startup script (more about that later) has adjusted the size of the main viewing area to leave you with three lines in the console area. This allows you to see any messages jot sends to the console area.</P>

<P>Look now at the top-left corner of the window - it should be displaying a tilde ( ~ ) in reverse video. The reverse video indicates that this is the current cursor position, the tilde indicates that the cursor has moved to the right of any displayable text - that's because this file starts off with an entirely blank line.</P>

<P><LI>We'll be seeing a lot of error and warning messages soon - so it's a good plan to know what they look like. We're going to type in a command that's guaranteed to generate a warning. Just type in the letter ( r ) and then return - r is the command to move the cursor one character rightwards, and it's already at the end of a blank line):</P></LI>

&#062; r
<P>The response should be:</P>

&#123;Command-sequence failed.&#125;r 
<P>The message comes wrapped up in curly braces followed by the full command line, with the failing command highlighted- a slightly more complicated command line illustrates this last detail:</P>

&#062; m1234m-1234r23m1234m-1234
<P>This first tells it to move the cursor 1234 lines down the file, 1234 lines back - it did that alright and, unsurprisingly, we ended up exactly where we started. It was then instructed to go right 23 characters then forwards and backwards 1234 lines again. It's the same message, but now the highlighting pinpoints the failing command ( r23 ).</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="SOME BASIC COMMANDS TO GET STARTED">Some basic commands to get started</H3>
<A HREF="#LOOK AT THE JOT DISPLAY"><SMALL>Back to </SMALL>Look at the jot display</A><BR><A HREF="#SOME BASIC FUNCTION KEYS"><SMALL>Forward to </SMALL>Some Basic Function Keys</A><BR><BR><BR>



<P>These are the most basic operations for anything claiming to be some sort of text editor:</P>

<UL><P><LI>Help &#123;F1&#125; - the view changes to a list of file folds (see <A HREF="jot_ug.html#ABOUT HELP">about help</A>) select a file fold (any line begining with '&#091;' and hit &#123;F1&#125; again. The file is opened and it shows some text containing text folds '&#123;&#123;&#123;' move to one of these and hit &#123;F1&#125; to open. Move to any non-fold line and hit &#123;F1&#125; again to close the current fold.</P></LI>

<P><LI>Find-string next &#123;F8&#125; and find-string previous &#123;F7&#125; note that the search string is entered before hitting th function key. eg to find the next occurrence of "fred":</P></LI>

&#062; fred&#123;F8&#125;
<P>to find the next one again:</P>

&#062; &#123;F8&#125;
<P>&#123;F7&#125; is similar except that it searches back up the text.</P>

<P><LI>Substitute string &#123;F5&#125; substitutes the currently-selected substring with the given new substring. eg:</P></LI>

&#062; aardvark&#123;F5&#125;
<P>the currently-selected substring is changed to "aardvark" and this word becomes the currently-selected string.</P>

<P><LI>Insert a substring &#123;F6&#125; - inserts the given substring at the current character position and the given substring becomes the currently-selected substring. eg:</P></LI>

&#062; wonderful&#123;F6&#125;
<P><LI>Exit and save the primary buffer <A HREF="jot_tech.html#%C">%c</A> - note, this fails and refuses to exit if you are not currently editing the primary buffer.</P></LI>

<P><LI>Exit without saving <A HREF="jot_tech.html#%A">%a</A> (abandon).</P></LI>

<P><LI>Save - write the buffer back to the filing system <A HREF="jot_tech.html#%O">%o</A> (output). Pathname defaults to the one remembered from when the file was read.</P></LI>

<P><LI>Save-as - write the buffer to some specified pathname - %o=&#060;pathname&#062; </P></LI>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="SOME BASIC FUNCTION KEYS">Some Basic Function Keys</H3>
<A HREF="#SOME BASIC COMMANDS TO GET STARTED"><SMALL>Back to </SMALL>Some basic commands to get started</A><BR><A HREF="#A FEW MORE FUNCTION KEYS"><SMALL>Forward to </SMALL>A few more function keys</A><BR><BR><BR>



<UL><P><LI>The up and down-arrow keys move to the begining of the previous or next line respectively.</P></LI>

<P><LI>Read specified file to a buffer - <A HREF="jot_tech.html#%I">%i</A>&#060;key&#062;&#091;=&#060;pathName&#062;&#093; -</P></LI>

<UL><P><LI>&#060;key&#062; is a single-character buffer identifier key,</P></LI>

<P><LI>&#060;pathName&#062; specifies the filing-system path file name add name extension, missing elements are filled in from the pathname of the current buffer and, failing that, from your PWD.</P></LI>

</UL><P><LI>Do it again &#123;F10&#125; - whatever command you last did, make it happen again.</P></LI>

<P><LI>Entering text. Like most other modern editors, jot has an insert mode but it's generally easier to stay in command mode - so there is a command for entering new lines of text - either &#123;KP_Enter&#125; (that's the enter key on the numeric keypad) or, if you don't have a numeric keypad, then &#123;Esc e&#125;:</P></LI>

&#062; &#060;lineOfText&#062;&#123;KP_Enter&#125;
<P>or</P>

&#062; &#060;lineOfText&#062;&#123;Esc e&#125;
<P><LI>Navigation through, deletion and restoration of text </P></LI>

<UL><P><LI>The left and right arrow keys move, unsurprisingly, left and right. If at the end of a line, the rightarrow key moves to the start of the next line, the behaviour of the leftarrow key is similar. When combined with the Alt key, these delete the previous/next character respectively.</P></LI>

<P><LI>With the Shift key, left/right arrow keys move to the start of the previous word or the end of the next word respectively. With shift and Alt they delete the previous or next word respectively.</P></LI>

<P><LI>With the Ctrl key, left/right arrow keys move to the start or end of the line respectively. If already at the start/end of a line they move to the relevant position of the previous/next line respectively. With Ctrl and Alt they delete to the start/end of the line respectively.</P></LI>

<P><LI>&#123;Ctrl+Shift+Alt+LeftArrow&#125; restores one character previously deleted by &#123;*Alt+LeftArrow&#125;, similarly for &#123;Ctrl+Shift+Alt+RightArrow&#125;.</P></LI>

</UL></UL><P>Have a play around with a text file:</P>

<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/Richard_III_Entire_Play.txt
</PRE>

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="A FEW MORE FUNCTION KEYS">A few more function keys</H3>
<A HREF="#SOME BASIC FUNCTION KEYS"><SMALL>Back to </SMALL>Some Basic Function Keys</A><BR><A HREF="#DO A FEW EASY EDITS WITH FUNCTION KEYS"><SMALL>Forward to </SMALL>Do a few easy edits with function keys</A><BR><BR><BR>



<P>To see all of the available function keys and to explore their functions in jot, start up a qr (quick-reference) session:</P>

<PRE>
$ jot /dev/null -st=qr
</PRE>
<P>or follow this link: <A HREF="jot_qr.html#JOT QUICK REFERENCE">jot quick reference</A></P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="DO A FEW EASY EDITS WITH FUNCTION KEYS">Do a few easy edits with function keys</H3>
<A HREF="#A FEW MORE FUNCTION KEYS"><SMALL>Back to </SMALL>A few more function keys</A><BR><A HREF="#A FEW MORE BASIC FUNCTION KEYS"><SMALL>Forward to </SMALL>A few more basic function keys</A><BR><BR><BR>



<P>Restart the editor:</P>

<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/Richard_III_Entire_Play.txt
</PRE>
<P>The same command also works in windowsland.</P>

<P>You should see the text appear in your terminal window - as the name suggests it's Richard III by Shakespere. This text was chosen as it's long, well known and very much out of copyright. This version was downloaded from: <A HREF="http://shakespeare.mit.edu/richardiii/full.html">http://shakespeare.mit.edu/richardiii/full.html</A> - thanks.</P>

<P>Try out a few of the edit keys mentioned in the <A HREF="#SOME BASIC FUNCTION KEYS">Some Basic Function Keys</A> section. For full details and all the other predefined keys look at <A HREF="jot_ug.html#KEYBOARD FUNCTIONS DEFINED AT STARTUP">Keyboard functions defined at startup</A>. First try hitting the cursor-control keys a few times - one surprise may be that the up and down-arrow keys move to the start of the next/previous line.</P>

<P>Now try the up/down/left/right-arrow keys while holding down the Shift key - this moves left or right by a full word or up and down in a column.</P>

<P>Try a search using &#060;&#060;<A HREF="jot_ug.html#FINDNEXT">FindNext</A>&#062;&#062; the &#123;F8&#125; function key, note that, in jot, arguments to functions are entered before hitting the function key:</P>

&#062; gloucester&#123;F8&#125;
<P>Now just hit &#123;F8&#125; a few more times with no search string - each will find the next instances of "gloucester" &#123;F7&#125; key is similar but searches back:</P>

&#062; &#123;F7&#125;
<P>Now use the &#060;&#060;<A HREF="jot_ug.html#INSERT">Insert</A>&#062;&#062; function (&#123;F6&#125;) to insert the string abcdef</P>

&#062; abcdef&#123;F6&#125;
<P>Now, using the &#060;&#060;<A HREF="jot_ug.html#SUBSTITUTE">Substitute</A>&#062;&#062; function ( &#123;F5&#125; ) to change that to 123456</P>

&#062; 123456&#123;F5&#125;
<P>Now play around with the &#060;&#060;<A HREF="jot_ug.html#FINDNEXT">FindNext</A>&#062;&#062; &#123;F8&#125;, &#060;&#060;<A HREF="jot_ug.html#FINDPREV">FindPrev</A>&#062;&#062; &#123;F7&#125;, &#060;&#060;<A HREF="jot_ug.html#INSERT">Insert</A>&#062;&#062; &#123;F6&#125; and &#060;&#060;<A HREF="jot_ug.html#SUBSTITUTE">Substitute</A>&#062;&#062; &#123;F5&#125; keys. Then re-read a clean copy of the original file with the %I command:</P>

&#062;  %i.&#123;Return&#125;
<P>This re-reads the original file into the buffer, destroying all your changes.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="A FEW MORE BASIC FUNCTION KEYS">A few more basic function keys</H3>
<A HREF="#DO A FEW EASY EDITS WITH FUNCTION KEYS"><SMALL>Back to </SMALL>Do a few easy edits with function keys</A><BR><A HREF="#ENTERING NEW TEXT"><SMALL>Forward to </SMALL>Entering new text</A><BR><BR><BR>



<P>Every editor has to have some way adjusting the view and of copying and moving slabs of text. </P>

<P>In jot cut and copy operations are done by first noting the start of the desired section and then moving to the end of the section to copy or cut (abstract in ecce-speak).</P>

<UL><P><LI> &#060;&#060;<A HREF="jot_ug.html#NOTE">Note</A>&#062;&#062; - &#123;Ctrl+Shift+F1&#125; - Remembers the current cursor position for later a Cut or Copy operation.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#CUT">Cut</A>&#062;&#062; - &#123;Ctrl+Shift+F2&#125; - moves text, starting from the previous &#060;&#060;<A HREF="jot_ug.html#NOTE">Note</A>&#062;&#062; operation to the current cursor position, text is placed in the _ buffer.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#COPY">Copy</A>&#062;&#062; - &#123;Ctrl+Shift+F3&#125; - similar to Cut except that the source buffer is unchanged.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#PASTE">Paste</A>&#062;&#062; - &#123;Ctrl+Shift+F4&#125; - text in the paste buffer ( _ ) is inserted immediately before the cursor.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#VIEWUP">ViewUp</A>&#062;&#062;, &#060;&#060;<A HREF="jot_ug.html#VIEWDOWN">ViewDown</A>&#062;&#062;, &#060;&#060;<A HREF="jot_ug.html#VIEWLEFT">ViewLeft</A>&#062;&#062; and &#060;&#060;<A HREF="jot_ug.html#VIEWRIGHT">ViewRight</A>&#062;&#062; ( &#123;Shift+UpArrow&#125;, &#123;Shift+DownArrow&#125;, &#123;Shift+LeftArrow&#125; and &#123;Shift+RightArrow&#125; respectively). These adjust the position of the text on the screen but do not effect the buffer being viewed.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#WINDOWSTRETCH">WindowStretch</A>&#062;&#062; and &#060;&#060;<A HREF="jot_ug.html#WINDOWSHRINK">WindowShrink</A>&#062;&#062; ( &#123;Ctrl+Alt+DownArrow&#125; and &#123;Ctrl+Alt+UpArrow&#125; respectively). These adjust the size of the view, not by changing the xterm dimensions but by expanding or shrinking the area dedicated to displaying the buffer.</P></LI>

<P>First move away from the start of the text image and then try the ViewUp and ViewDown functions:</P>

&#062; york&#123;F8&#125;
&#062; 10
<P>You located the next occurrence of "york" and then repeated that command a further 10 times - typing a number always gives you the specified number of repeats of the previous command.</P>

&#062; &#123;Ctrl+Shift+UpArrow&#125;
<P>This shifts the view up the screen by one line.</P>

&#062; 10&#123;Ctrl+Shift+UpArrow&#125;
<P>This shifts the view up the screen by ten lines.</P>

<P>Next try copying a section of text:</P>

&#062; &#123;Ctrl+Shift+F1&#125;
<P>This sets the note point at the start of "YORK"</P>

&#062; &#123;F7&#125;
<P>Locates the previous "YORK"</P>

&#062; &#123;Ctrl+Shift+F3&#125;
<P>This has copied the slab of text.</P>

&#062; zq&#123;return&#125;
&#062; &#123;Ctrl+Shift+F4&#125;
<P>We've moved to the buffer ( q ) and copied the text there. Now return to the main buffer.</P>

&#062; z.&#123;return&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="ENTERING NEW TEXT">Entering new text</H3>
<A HREF="#A FEW MORE BASIC FUNCTION KEYS"><SMALL>Back to </SMALL>A few more basic function keys</A><BR><A HREF="#DELETION AND RESTORATION OF TEXT"><SMALL>Forward to </SMALL>Deletion and restoration of text</A><BR><BR><BR>



<P>The recommended mode of operation for jot is the command mode (the alternative is insert mode - see <A HREF="jot_ug.html#COMMAND-MODE VS. INSERT MODE">Command-mode vs. insert mode</A>). In insert mode everything that's typed in is interpreted as text to be inserted into the document at the current cursor position.</P>

<P>To enter a new line of text, the line is first typed into the console area and then the &#060;&#060;<A HREF="jot_ug.html#ENTER">Enter</A>&#062;&#062; function is invoked - either by hitting the &#123;KP_Enter&#125; button if you have a numeric keypad, or &#123;Esc e&#125; (that's Escape followed by e).</P>

<P>Let's put "The end" at the end of the play. First go to the end of Richard III</P>

&#062; m0m-
<P>Now enter the new line.</P>

&#062;      The End&#123;Esc e&#125;
<P>A later section (<A HREF="#INSERT MODE">insert mode</A>) deals with entering text in insert mode.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="DELETION AND RESTORATION OF TEXT">Deletion and restoration of text</H3>
<A HREF="#ENTERING NEW TEXT"><SMALL>Back to </SMALL>Entering new text</A><BR><A HREF="#GETTING HELP"><SMALL>Forward to </SMALL>Getting help</A><BR><BR><BR>



<UL><P><LI>&#060;&#060;<A HREF="jot_ug.html#DELETECHRRIGHT">DeleteChrRight</A>&#062;&#062; &#123;Alt+RightArrow&#125; deletes the character under the cursor.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#DELETECHRLEFT">DeleteChrLeft</A>&#062;&#062; &#123;Alt+LeftArrow&#125; deletes the character left of the cursor.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#DELETEWORDRIGHT">DeleteWordRight</A>&#062;&#062; &#123;Alt+Shift+RightArrow&#125; deletes from the cursor to end of word.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#DELETEWORDLEFT">DeleteWordLeft</A>&#062;&#062; &#123;Shift+Alt+LeftArrow&#125; deletes from the cursor to start of word.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#DELETELINERIGHT">DeleteLineRight</A>&#062;&#062; &#123;Ctrl+Alt+RightArrow&#125; deletes from the cursor to end of line.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#DELETELINELEFT">DeleteLineLeft</A>&#062;&#062; &#123;Ctrl+Alt+LeftArrow&#125; deletes from the cursor to start of line.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#RESTORECHRRIGHT">RestoreChrRight</A>&#062;&#062; &#123;Ctrl+Shift+Alt+RightArrow&#125; restores one character under the cursor.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#RESTORECHRLEFT">RestoreChrLeft</A>&#062;&#062; &#123;Ctrl+Shift+Alt+LeftArrow&#125; restores one character left of the cursor.</P></LI>

<P>In the context of the word-orientated functions, a word is any string of ascii alphanumeric characters bounded by either non-alpha characters or the start or end of the line. At present jot treats all unicode as non-alpha characters.</P>

<P>Note that there is only one graveyard for deleted text (the % buffer). All &#060;&#060;Delete...Right&#062;&#062; functions move deleted text to the end of this buffer, all &#060;&#060;Delete...Left&#062;&#062; functions move text to it's start. This means the &#060;&#060;RestoreWord...&#062;&#062; functions will restore characters and words deleted by the &#060;&#060;DeleteChr...&#062;&#062; functions and similarly &#060;&#060;RestoreLine...&#062;&#062; functions will restore words and characters that were not part of the original deleted word.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="GETTING HELP">Getting help</H3>
<A HREF="#DELETION AND RESTORATION OF TEXT"><SMALL>Back to </SMALL>Deletion and restoration of text</A><BR><A HREF="#LINE SHUFFLING"><SMALL>Forward to </SMALL>Line shuffling</A><BR><BR><BR>



<P>Jot supports an online help system. The &#060;&#060;<A HREF="jot_ug.html#HELP">Help</A>&#062;&#062; function uses specially structured files derived from ordinary jot documents (see <A HREF="jot_tech.html#ABOUT HELP FILES">About help files</A>). The structure of these documents is quite simple, entries are bounded by fold marks '&#123;&#123;&#123;' and '&#125;&#125;&#125;' at the beginning of a line and these may be nested to any depth.</P>

<P>The help entries you are about to look at are images of files in $&#123;JOT_RESOURCES&#125;/help/...</P>

&#062; &#123;F1&#125;
<P>When the &#060;&#060;<A HREF="jot_ug.html#HELP">Help</A>&#062;&#062; function is invoked for the first time in a session, it presents you with the contents of the file $&#123;JOT_RESOURCES&#125;/help/help.hlp yours should contain some instructions and three entries:</P>

&#091;jot&#093;jot
&#091;demo&#093;play          - An (almost) empty help category for you to play with. 
&#091;your_stuff&#093;play    - For you put your own stuff in. 
<P>The square brackets indicate that this is a file fold - it is currently empty. Opening it causes the file to be read. The cursor should already be on the jot entry, open it by calling &#060;&#060;<A HREF="jot_ug.html#HELP">Help</A>&#062;&#062; again:</P>

&#062; &#123;F1&#125;
<P>It opens up similar screen but this one contains four entries - these are all help files made from jot documentation. The cursor should be on the jot_ug entry so open that one:</P>

&#062; &#123;F1&#125;
<P>This page announces that you're looking at the jot user guide and contains just two entries - these correspond to the two top-level entries in the user guide.</P>

<P>To descend another level down the hierarchy move the cursor to any part of a line starting with a fold mark and hit &#123;F1&#125;, to return back up the hierarchy move the cursor to any line without a fold mark and hit &#123;F1&#125;.</P>

<P>At any time you can return to your original work buffer e.g:</P>

&#062; z.
<P>and then return to the help entry you last looked at:</P>

&#062; z;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="LINE SHUFFLING">Line shuffling</H3>
<A HREF="#GETTING HELP"><SMALL>Back to </SMALL>Getting help</A><BR><A HREF="#USING MATCHING FUNCTIONS"><SMALL>Forward to </SMALL>Using matching functions</A><BR><BR><BR>



<P>Sometimes, perhaps we're splitting a paragraph into two, all we need to do is to push some words from the end of one line and prepend them to the next line. Or, maybe, lop words from the start of a line and append them to the previous line. These two requirements are met by the &#060;&#060;<A HREF="jot_ug.html#APPENDRIGHTNEXT">AppendRightNext</A>&#062;&#062; &#123;&#123;Alt+F10&#125; and &#060;&#060;<A HREF="jot_ug.html#APPENDLEFTPREV">AppendLeftPrev</A>&#062;&#062; ( &#123;Alt+F9&#125; ) respectively.</P>

<P>Returning to Richard III we notice that Shakespere could have achieved a more optimal text density. Given the size of a typical "complete works" there'd be loads more trees standing now if only if only he'd bothered to cram a few more words on each line. Let's sort it out for him:</P>

&#062; z.m-0  
&#062; by&#123;F9&#125;
&#062; &#123;Alt+F9&#125;
<P>That seems to have done it, but, oh dear! it doesn't seem to scan quite right now, maybe there is something to be said for his iambic pentameters after all - better put it back the way it was. Fortunately &#060;&#060;<A HREF="jot_ug.html#APPENDRIGHTNEXT">AppendRightNext</A>&#062;&#062; will do exactly that:</P>

&#062; &#123;Alt+F10&#125;
<P>Another pair of functions, useful when editing programming languages, are &#060;&#060;<A HREF="jot_ug.html#INDENTFROMNEXT">IndentFromNext</A>&#062;&#062; &#123;Ctrl+Shift+F10&#125; and &#060;&#060;<A HREF="jot_ug.html#INDENTFROMPREV">IndentFromPrev</A>&#062;&#062; &#123;Ctrl+Shift+F9&#125; - these change the indentation level of the current line to match, respectively, the previous line or the next line - first prepare some lines of differing indentation levels:</P>

&#062; z.m+20e4 mi/    /m-
<P>First inherit the indentation from the next line:</P>

&#062; &#123;Ctrl+Shift+F10&#125;
<P>then from the previous line:</P>

&#062; &#123;Ctrl+Shift+F9&#125;
<P>restore the text:</P>

&#062; &#123;DownArrow&#125;
&#062; &#123;Ctrl+Shift+F10&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="USING MATCHING FUNCTIONS">Using matching functions</H3>
<A HREF="#LINE SHUFFLING"><SMALL>Back to </SMALL>Line shuffling</A><BR><A HREF="#BUFFERS"><SMALL>Forward to </SMALL>Buffers</A><BR><BR><BR>



<P>The startup script defines some useful parenthesis and other matching functions:</P>

<UL><P><LI>&#060;&#060;<A HREF="jot_ug.html#PARAGRAPHUP">ParagraphUp</A>&#062;&#062; &#123;F3&#125; and &#060;&#060;<A HREF="jot_ug.html#PARAGRAPHDOWN">ParagraphDown</A>&#062;&#062; &#123;F4&#125;, respectively, find the start and end of the current paragraph. In this context a paragraph is taken to be any number of non-blank lines of text bounded by either a blank line or either or both of the buffer's end points.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#CODESECTIONUP">CodeSectionUp</A>&#062;&#062; &#123;Shift+F3&#125; and &#060;&#060;<A HREF="jot_ug.html#CODESECTIONDOWN">CodeSectionDown</A>&#062;&#062; &#123;Shift+F4&#125; respectively find the start of the current code section and the start of the next code section. In jot a code section is deemed to be any number of lines beginning with an alpha character in the first character of a line. Typically in computer programming language subroutines and other sections are introduced with an un-indented keyword followed by indented code.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#INDENTMATCHUP">IndentMatchUp</A>&#062;&#062; &#123;Alt+F7&#125; and &#060;&#060;<A HREF="jot_ug.html#INDENTMATCHDOWN">IndentMatchDown</A>&#062;&#062; &#123;Alt+F8&#125; respectively locate the previous and next line with the same indentation level as the current line.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#PARENMATCHLEFT">ParenMatchLeft</A>&#062;&#062; &#123;Shift+Alt+F5&#125; first searches back through the text for the previous parenthesis-end ')' then finds it's matching start '('. &#060;&#060;<A HREF="jot_ug.html#PARENMATCHRIGHT">ParenMatchRight</A>&#062;&#062; &#123;Shift+Alt+F6&#125; is similar except it searches forwards for the next '(' and then finds the matching ')'.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#CURLYMATCHLEFT">CurlyMatchLeft</A>&#062;&#062; &#123;Ctrl+Shift+Alt+F5&#125; and &#060;&#060;<A HREF="jot_ug.html#CURLYMATCHRIGHT">CurlyMatchRight</A>&#062;&#062; &#123;Ctrl+Shift+Alt+F6&#125; are similar except that they operate on curly braces ( '&#123;' and '&#125;').</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#ANGLEMATCHLEFT">AngleMatchLeft</A>&#062;&#062; &#123;Ctrl+Shift+F5&#125; and &#060;&#060;<A HREF="jot_ug.html#ANGLEMATCHRIGHT">AngleMatchRight</A>&#062;&#062; &#123;Ctrl+Shift+F6&#125; are similar except that they operate on angle braces ( ' &#060;' and '&#062;').</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#MARKUPMATCHLEFT">MarkupMatchLeft</A>&#062;&#062; &#123;Alt+F5&#125; and &#060;&#060;<A HREF="jot_ug.html#MARKUPMATCHRIGHT">MarkupMatchRight</A>&#062;&#062; &#123;Alt+F6&#125; are similar except that they operate on html/xml blocks.</P></LI>

<P>In the Richard III text play around with the ParagraphUp and ParagraphDown functions:</P>

&#062; z.
&#062; &#123;F4&#125;
&#062; &#123;F4&#125;
&#062; &#123;F4&#125;
&#062; &#123;F3&#125;
&#062; &#123;F3&#125;
&#062; ...
<P>Open the test_block.txt file in your resources area - this has some simple examples of nested blocks and indentation:</P>

&#062; %it=test_block.txt
<P>First do an indentation match:</P>

&#062; level 3 start&#123;F8&#125;
&#062; &#123;Alt+F8&#125;
<P>Another &#060;&#060;<A HREF="jot_ug.html#INDENTMATCHDOWN">IndentMatchDown</A>&#062;&#062; takes you into the curly brace match set.</P>

&#062; &#123;Alt+F8&#125;
&#062; &#123;Alt+F7&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="BUFFERS">Buffers</H3>
<A HREF="#USING MATCHING FUNCTIONS"><SMALL>Back to </SMALL>Using matching functions</A><BR><A HREF="#COPYING AND MOVING TEXT - 1"><SMALL>Forward to </SMALL>Copying and Moving Text - 1</A><BR><BR><BR>



<P>In a modern text editor, the text you see on your screen is an image of the file as it currently exists as a text buffer in the computers memory. As the edit session progresses this may not match what's currently spinning around in the filing system.</P>

<P>Jot supports a number of separate buffers each identified by a single-character key - the following buffers are accessible but some are used by jot scripts:</P>

<UL><P><LI>. the primary buffer - by default jot starts up in this buffer.</P></LI>

<P><LI>A-to-Z - not assigned any special meaning and are freely available for your use.</P></LI>

<P><LI>0-to-9 user-defined functions attached to numeric-keypad keys 0-9 but otherwise freely available for your use.</P></LI>

<P><LI>~ Temporary (stack) buffer or numeric value at top of stack - available for your use.</P></LI>

<P><LI>_@#$ - may be used and redefined by jot standard startup functions.</P></LI>

<P><LI>!"#%&'()*+-./:;&#060;=&#062;?@&#091;\&#093;_ may be used and redefined by scripts.</P></LI>

<P><LI>^ used for escape-sequence mapping - do not use or redefine.</P></LI>

<P><LI>: is used to hold the help repository.</P></LI>

<P><LI>; is used for viewing help</P></LI>

</UL><P>To change focus to another buffer we use the Z command</P>

<UL><P><LI><A HREF="jot_tech.html#Z">z</A>&#060;key&#062; - zoom (i.e. switch context) to buffer indicated by the single-character key e.g. zq will switch context to buffer q.</P></LI>

</UL><P>You should be in buffet ( t ) at present, let's go back to the primary buffer ( . ):</P>

&#062; z.&#123;Return&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="COPYING AND MOVING TEXT - 1">Copying and Moving Text - 1</H3>
<A HREF="#BUFFERS"><SMALL>Back to </SMALL>Buffers</A><BR><A HREF="#ADJUSTING FOCUS AND VIEW."><SMALL>Forward to </SMALL>Adjusting focus and view.</A><BR><BR><BR>



<P>No text editor is complete without some facility for picking up slabs of text to be moved or copied. In ecce-speak this process is abstraction.</P>

<P>The first step is to indicate the start point for abstraction with the <A HREF="jot_tech.html#N">N</A> (note) command then move the cursor and then abstract to the destination buffer with the <A HREF="jot_tech.html#A">A</A> (abstract) command.</P>

<P>Normally there is a dedicated buffer defined by the system for copying and moving slabs of text. Typically known as the paste/pick/put/copy ... buffer, in jot you can use any buffer you fancy - given that some buffers may be used by hot-key functions defined by the startup script - see <A HREF="#BUFFERS">buffers</A>. The predefined hotkey copy/paste functions use the '_' buffer.</P>

<P>The basic cut/copy and paste keys use the jot note and abstract commands:</P>

<UL><P><LI>&#060;&#060;<A HREF="jot_ug.html#NOTE">Note</A>&#062;&#062; - (normally &#123;Ctrl+Shift+F1&#125; on the mid keypad) notes one end of the text to be moved at the current cursor position.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#CUT">Cut</A>&#062;&#062; - (normally &#123;Ctrl+Shift+F2&#125; ) removes text from the note point to the current cursor position.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#COPY">Copy</A>&#062;&#062; - (normally &#123;Ctrl+Shift+F3&#125;) - copies (i.e. copies to the paste buffer without changing the original) text from the note point to the current cursor position.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#PASTE">Paste</A>&#062;&#062; (Normally &#123;Ctrl+Shift+F4) - text in the paste buffer is inserted at the current cursor position.</P></LI>

</UL><P>We're going to pick up the phrase 'glorious summer by this sun of ' from Richards opening soliloquy and reinsert them.</P>

&#062; Now is&#123;F8&#125;
&#062; &#123;Ctrl+Shift+F1&#125;
&#062; York&#123;F8&#125;
&#062; &#123;Ctrl+Shift+F2&#125;
<UL><P>The first and second lines of text, as far as York, disappears.</P>

&#062; &#123;Ctrl+Shift+F4&#125;
<P>The text reappears.</P>

</UL><P>The last two operations could have been performed by the copy function:</P>

&#062; m-0
&#062; Now is&#123;F8&#125;
&#062; &#123;Ctrl+Shift+F1&#125;
&#062; York&#123;F8&#125;
&#062; &#123;Ctrl+Shift+F3&#125;
<P>At this point, the text is still in the paste buffer and can be inserted anywhere you fancy in any of the editors buffers. You can also make the paste buffer ( _ ) the current buffer to check what's in there:</P>

&#062; z_
<P>Go back to the primary buffer ( . ):</P>

&#062; z.

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="ADJUSTING FOCUS AND VIEW.">Adjusting focus and view.</H3>
<A HREF="#COPYING AND MOVING TEXT - 1"><SMALL>Back to </SMALL>Copying and Moving Text - 1</A><BR><A HREF="#SOME FANCY FLAVOURS OF FIND - 1"><SMALL>Forward to </SMALL>Some fancy flavours of find - 1</A><BR><BR><BR>



<P>Some of these operations are best done with a file with very long lines (i.e. wider than your terminal) load the test_table.txt file into buffer w.</P>

&#062; %iw=test_table.txt
<P>Note that you did not need to type in the pathname to read this file, jot first tries to read the file from your PWD (present working directory), if it can't find it in there it tries prepending the path from the current buffer - in this case $&#123;JOT_RESOURCES&#125;, it should find $&#123;JOT_RESOURCES&#125;/test_table.txt</P>

<P>The file you've just loaded is a tab-separated tabular file designed to show up any jot bugs affecting the display of tabular text. Later we'll find out how to display this file properly. For now we'll display it as linear text, jot displays tabs (and all other control characters) as tildes ( ~ ).</P>

<P>Do a few &#060;&#060;<A HREF="jot_ug.html#DOWN">Down</A>&#062;&#062; &#123;DownArrow&#125; and &#060;&#060;<A HREF="jot_ug.html#WORDRIGHT">WordRight</A>&#062;&#062; &#123;Shift+RightArrow&#125; operations until the cursor approaches the right margin of your window. Now do another &#060;&#060;<A HREF="jot_ug.html#WORDRIGHT">WordRight</A>&#062;&#062; &#123;Shift+RightArrow&#125; watching the display carefully. The editor is scrolling the entire view rightwards to bring the currently-selected word into view. Also try &#060;&#060;<A HREF="jot_ug.html#WORDLEFT">WordLeft</A>&#062;&#062; &#123;Shift+LeftArrow&#125;</P>

<UL><P><LI>the behaviour is similar.</P></LI>

<P>You can adjust the view manually with the &#060;&#060;<A HREF="jot_ug.html#VIEWLEFT">ViewLeft</A>&#062;&#062; and &#060;&#060;<A HREF="jot_ug.html#VIEWRIGHT">ViewRight</A>&#062;&#062; functions (&#123;Ctrl+Shift+LeftArrow&#125; and &#123;Ctrl+Shift+RightArrow&#125; respectively), if you shift the view to the extent that the cursor slips off the left or right margin of the screen the editor will re-display the current section of the line in the console area.</P>

<P>Similarly, you can manually scroll up and down with the &#060;&#060;<A HREF="jot_ug.html#VIEWUP">ViewUp</A>&#062;&#062; and &#060;&#060;<A HREF="jot_ug.html#VIEWDOWN">ViewDown</A>&#062;&#062; functions (&#123;Ctrl+Shift+Up/DownArrow&#125;). Note that none of these functions affect the current editor focus, only the display - play around with these functions.</P>

<P>The &#060;&#060;<A HREF="jot_ug.html#WORDUP">WordUp</A>&#062;&#062; and &#060;&#060;<A HREF="jot_ug.html#WORDDOWN">WordDown</A>&#062;&#062; functions (&#123;Shift+UpArrow&#125; and &#123;Shift+DownArrow&#125; respectively) move up and down in a column. Now &#060;&#060;WordUp&#062;&#062; and &#060;&#060;WordDown&#062;&#062; use the ( Y ) primitive command. This will hold to the same column, ignoring the starting column. This behaviour is useful for moving up and down performing repetitive operations in tabular or similarly formatted text. But we will want to change column from time to time, this is done with the &#060;&#060;<A HREF="jot_ug.html#NEWWORDDOWN">NewWordDown</A>&#062;&#062; and &#060;&#060;<A HREF="jot_ug.html#NEWWORDUP">NewWordUP</A>&#062;&#062; functions (&#123;Ctrl+UpArrow&#125; and &#123;Ctrl+DownArrow&#125; respectively) . These reset the ( Y ) column offset to the current cursor position.</P>

<P>Now, tell the editor to display the text in this buffer as a table - we will be covering this in more detail in the next section. Just type this in:</P>

&#062; %b=tabstops -1
<P>and play around with the &#123;Shift+&#091;Left|Right|Up|Down&#093;Arrow&#125; keys. Also insert some text to make one cell wider:</P>

&#062; abcdefghijklmnopqrstuvwxyz&#123;F6&#125;
<P>and erase some characters from a cell to make it shorter than the others:</P>

&#062; e6&#123;Return&#125;
<P>Occasionally you will want to shrink the view in your console in order to display more of the system messages flying past. Especially if you are using the jot debugger. The function to do this is <A HREF="jot_ug.html#WINDOWSHRINK">WindowShrink</A> (&#123;Ctrl+Alt+UpArrow&#125;) or to expand the view there's <A HREF="jot_ug.html#WINDOWSTRETCH">WindowStretch</A> (&#123;Ctrl+Alt+DownArrow&#125; each of these adjusts the window size by one line.</P>

&#062; &#123;Ctrl+Alt+UpArrow&#125;
&#062; &#123;Ctrl+Alt+UpArrow&#125;
&#062; &#123;Ctrl+Alt+UpArrow&#125;
&#062; &#123;Ctrl+Alt+DownArrow&#125;
&#062; &#123;Ctrl+Alt+DownArrow&#125;
&#062; &#123;Ctrl+Alt+DownArrow&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="SOME FANCY FLAVOURS OF FIND - 1">Some fancy flavours of find - 1</H3>
<A HREF="#ADJUSTING FOCUS AND VIEW."><SMALL>Back to </SMALL>Adjusting focus and view.</A><BR><A HREF="#SOME FANCY FLAVOURS OF FIND - 2"><SMALL>Forward to </SMALL>Some fancy flavours of find - 2</A><BR><BR><BR>



<P>The standard startup script defines several more functions for finding text we're going to give them an outing now.</P>

<P>Return to Richard_III_Entire_Play.txt, it's in the primary buffer ( . ):</P>

&#062; z.
<P>The &#060;&#060;<A HREF="jot_ug.html#FINDEXACTNEXT">FindExactNext</A>&#062;&#062; function (normally &#123;F9&#125; ) will only match to a whole word or number - i.e. one bounded by the start or end of a line or any non-alphanumeric character, in natural-language text this would typically be whitespace or a punctuation mark. We will be searching for exact matches to the string 'our' - first go to the top of the buffer:</P>

&#062; m-0
&#062; our&#123;F9&#125;
<P>sure enough it matches to 'our' in 'Now is the winter of our discontent'</P>

&#062; &#123;F9&#125;
<P>this time it matches to 'our' in 'clouds that lour'd upon our house' notice it did not match to the word lour'd in the same line. The function &#060;&#060;<A HREF="jot_ug.html#FINDEXACTPREV">FindExactPrev</A>&#062;&#062; ( &#123;Shift+F9&#125; ) does the same sort of thing but searches backwards.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="SOME FANCY FLAVOURS OF FIND - 2">Some fancy flavours of find - 2</H3>
<A HREF="#SOME FANCY FLAVOURS OF FIND - 1"><SMALL>Back to </SMALL>Some fancy flavours of find - 1</A><BR><A HREF="#SOME FANCY FLAVOURS OF FIND - 3"><SMALL>Forward to </SMALL>Some fancy flavours of find - 3</A><BR><BR><BR>



<P>Now read the repetitive test file l99.t into buffer r, it's pretty dull but useful for demonstrating repetitive edits. Note jot is set up to respect env variables but only if they are expressed in the form $&#123;&#060;envName&#062;&#125;</P>

&#062; %ir=$&#123;JOT_RESOURCES&#125;/l99.t
<P>First set the default find string to 'abc' and the default substitute/insert string to 'Abc':</P>

&#062; abc&#123;F8&#125; 
&#062; Abc&#123;F5&#125;
<P>The &#060;&#060;<A HREF="jot_ug.html#SUBSTHENFINDNX">SubsThenFindNx</A>&#062;&#062; function will now repeat the substitution and locate the next matching substring:</P>

&#062; &#123;Shift+F8&#125;
<P>Hit &#123;Shift+F8&#125; a few more times. To repeat a command &#060;n&#062; times enter the number of repeats to the command line - let's change the next 10 occurrences of abc:</P>

&#062; 10
<P>To repeat the last command until something fails type zero:</P>

&#062; 0
<P>you should now be at the last line of the file (line 101) with all 'abc' changed to 'Abc'</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="SOME FANCY FLAVOURS OF FIND - 3">Some fancy flavours of find - 3</H3>
<A HREF="#SOME FANCY FLAVOURS OF FIND - 2"><SMALL>Back to </SMALL>Some fancy flavours of find - 2</A><BR><A HREF="#REGULAR EXPRESSIONS"><SMALL>Forward to </SMALL>Regular expressions</A><BR><BR><BR>



<P>The &#060;&#060;<A HREF="jot_ug.html#FINDINPARANEXT">FindInParaNext</A>&#062;&#062; &#123;Esc f p&#125; function finds the next paragraph containing all of the substrings in the blank-separated list argument. We're going to find the famous "A Horse, a horse my kingdom ... " speech:</P>

<PRE>
z.
</PRE>
&#062; horse king&#123;Esc f p&#125;  
<P>the first matching paragraph is not what we're looking for so try it again:</P>

&#062; &#123;Esc f p&#125;
<P>nooo! try again.</P>

&#062; &#123;Esc f p&#125;
&#062; &#123;Esc f p&#125;
<P>Note that adding a second "horse" to the word list or changing the order of the list makes no difference.</P>

<P>The &#060;&#060;<A HREF="jot_ug.html#FINDINPARAPREV">FindInParaPrev</A>&#062;&#062; function ( &#123;Esc - f p&#125; ) is similar except that it searches backwards up the buffer.</P>

<P>The &#060;&#060;<A HREF="jot_ug.html#FINDWILD">FindWild</A>&#062;&#062; function finds the next occurrence of a string in a single line using a template containing wildcards. The '*' is the wildcard, it represents any number of characters in the search, this uses the Esc f sequence:</P>

<P>The "A horse ... " speech is a single line so we can use &#060;&#060;<A HREF="jot_ug.html#FINDWILD">FindWild</A>&#062;&#062;</P>

&#062; m-0
&#062; horse*horse&#123;Esc f w&#125;
<P>That gets it on the first attempt. The &#060;&#060;<A HREF="jot_ug.html#FINDWILDPREV">FindWildPrev</A>&#062;&#062; function is similar except it searches back and it's on &#123;Esc - f w&#125;.</P>

<P>One more function, quite useful when dealing with natural-language text, is &#060;&#060;<A HREF="jot_ug.html#FINDSEQUENCE">FindSequence</A>&#062;&#062; &#123;Esc f s&#125; - this identifies a string of words irrespective of punctuation, whitespace and line breaks.</P>

&#062; m-0
&#062; him a horse&#123;Esc f s&#125;
<P>it highlights the first word of the given list of words. The function &#060;&#060;<A HREF="jot_ug.html#FINDSEQUENCEPREV">FindSequencePrev</A>&#062;&#062; ( &#123;Esc - f s&#125; ) is similar, except that it searches backwards.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="REGULAR EXPRESSIONS">Regular expressions</H3>
<A HREF="#SOME FANCY FLAVOURS OF FIND - 3"><SMALL>Back to </SMALL>Some fancy flavours of find - 3</A><BR><A HREF="#FANCY FLAVOURS OF SUBSTITUTION AND INSERTION - 1"><SMALL>Forward to </SMALL>Fancy flavours of substitution and insertion - 1</A><BR><BR><BR>



<P>Many battle-hardened unix users are quite good at regular expressions, some may even enjoy using them (see <A HREF="jot_tech.html#%F">%F</A> for details). Here we're just going to demonstrate the jot %F interface to the gnu regular-expression functions.</P>

&#062; m-0
&#062; %fa=horse.*king
<P>now search back from, the end of the buffer.</P>

&#062; m0
&#062; %f-a=horse.*king

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="FANCY FLAVOURS OF SUBSTITUTION AND INSERTION - 1">Fancy flavours of substitution and insertion - 1</H3>
<A HREF="#REGULAR EXPRESSIONS"><SMALL>Back to </SMALL>Regular expressions</A><BR><A HREF="#A DETAILED LOOK AT A TAB-SEPARATED TABLE"><SMALL>Forward to </SMALL>A detailed look at a tab-separated table</A><BR><BR><BR>



<P>An occasionally-useful function is &#060;&#060;<A HREF="jot_ug.html#OVERWRITE">Overwrite</A>&#062;&#062; (&#123;Shift+F6&#125;) which, as it's name suggests, overwrites whatever happens to be there with the given string. </P>

<P>Return to the test_block.txt this has some simple block diagrams.</P>

&#062; zt
<P>this has a couple of simple block diagrams. There are some special functions for dealing with these but, for now, the important point about these diagrams is that if you just insert text with the simple &#060;&#060;<A HREF="jot_ug.html#INSERT">Insert</A>&#062;&#062; ( &#123;F5&#125; ) function it will mess up the picture to the right of the insertion point. For this job we need the &#060;&#060;<A HREF="jot_ug.html#OVERWRITE">Overwrite</A>&#062;&#062; function - it's on &#123;Shift+F6&#125;. The first box lacks a label on it's third input:</P>

&#062; m+18r13
&#062; i3&#123;Shift+F6&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="A DETAILED LOOK AT A TAB-SEPARATED TABLE">A detailed look at a tab-separated table</H3>
<A HREF="#FANCY FLAVOURS OF SUBSTITUTION AND INSERTION - 1"><SMALL>Back to </SMALL>Fancy flavours of substitution and insertion - 1</A><BR><A HREF="#TABULAR TEXT - 1"><SMALL>Forward to </SMALL>Tabular text - 1</A><BR><BR><BR>



<P>Return to the test_table.txt file,</P>

&#062; zw
<P>as we've already discovered, this contains table entries (cells) separated by tab characters - a special control character that emulates a manual typewriters tab key.</P>

<P>Manual typewriters! - remember them? Anyone who's looked inside of one will know exactly what tabstops are - little metal pegs that select where the carriage ends up after the tab key is pressed. This ensures that addresses, headings and tabular entries all appear in the right position on the paper. In computers and text editors a similar behaviour is mechanized with logical and arithmetic operations based on the tab character.</P>

<P>In jot tabstops work in much the same was as in manual typewriters - tabstops are a list of positions where the next column in the table is to appear. e.g. for four 8-character columns we might write:</P>

<PRE>
%b=tabstops 8 16 24 32;
</PRE>
<P>But it's a real drag typing in all that stuff - this command has the same effect:</P>

<PRE>
%b=tabstops 8;
</PRE>
<P>this sets the first column width to 8 and subsequent columns inherit the same width.</P>

<P>Setting the column width to -1 is an instruction to jot to calculate an optimal set of tabstops for the section of table that's currently in view.</P>

<P>Now, for tabular text we might find it easier if the header line was fixed in the window. There is a command to do this the line of text we want to use in this example happens to be the first line try typing in this command string:</P>

&#062; m-0%b=header 'w
<P>The "m-0" element tells it to go back to the first line of the buffer, in this case, this happens to be the header line. "%b=header " is the command to set the header and the "'w" element indicates that the text to use for the header is in the current line of buffer w. With this set up we can move right down so the first line scrolls off the top of the screen and still see the header.</P>

<P>Play around with the &#060;&#060;<A HREF="jot_ug.html#WORDRIGHT">WordRight</A>&#062;&#062; &#123;Shift+RightArrow&#125;, &#060;&#060;<A HREF="jot_ug.html#WORDLEFT">WordLeft</A>&#062;&#062; &#123;Shift+LeftArrow&#125;, &#060;&#060;<A HREF="jot_ug.html#WORDUP">WordUp</A>&#062;&#062; &#123;Shift+UpArrow&#125; and &#060;&#060;<A HREF="jot_ug.html#WORDDOWN">WordDown</A>&#062;&#062; &#123;Shift+DownArrow&#125; functions.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="TABULAR TEXT - 1">Tabular text - 1</H3>
<A HREF="#A DETAILED LOOK AT A TAB-SEPARATED TABLE"><SMALL>Back to </SMALL>A detailed look at a tab-separated table</A><BR><A HREF="#TABULAR TEXT - 2"><SMALL>Forward to </SMALL>Tabular text - 2</A><BR><BR><BR>



<P>When we look at some real tabular data using, say, a spreadsheet viewer we sometimes see that a cell has been truncated because the text-width in the cell is greater than the width allocated for that column. In contrast, our simple concept of tabstops will allow the cell to overflow into the next column - not really very desirable for real tabular data. Thus we have two slightly different settings:</P>

<UL><P><LI>%b=tabstops &#060;n1&#062; &#060;n2&#062; ... ; - sets simple tabstops,</P></LI>

<P><LI>%b=tabcells &#060;n1&#062; &#060;n2&#062; ... ; - defines columns similar to spreadsheets.</P></LI>

</UL><P>Staying with the test_table.txt session, first set the tabstops all to 12 characters:</P>

&#062; %b=tabstops 12;
<P>now go to a cell on the screen and make it much wider:</P>

&#062; m-0f/colBrow15/i/This_is_now_a_very_wide_cell/
<P>The effect has been for the cell to encroach right across three columns - undesirable for tabular data like this. Of course we could set the tabstops to -1, then the editor would expand that column:</P>

&#062; %b=tabstops -1;
<P>But, what a spreadsheet viewer would do would be to mark the over-wide cell and truncate it. The tabcells setting approximates to this behaviour:</P>

&#062; %b=tabcells 12;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="TABULAR TEXT - 2">Tabular text - 2</H3>
<A HREF="#TABULAR TEXT - 1"><SMALL>Back to </SMALL>Tabular text - 1</A><BR><A HREF="#COLOUR-TAGGED TEXT"><SMALL>Forward to </SMALL>Colour-tagged text</A><BR><BR><BR>



<P>A line of tabular text consists of substrings (cells) separated by value-separator characters. By default, this separator character is Tab and tabs are represented on the screen, like any other control character, with a tilde '~'.</P>

<P>Read a more typical spreadsheet table into buffer e.g:</P>

&#062; %ie=consumertrends2012q3cvmnsa_tcm77-292466.tsv
<P>and tell the editor to display this as 6-character cells</P>

&#062; %b=tabcells 6
<P>this is equivalent to saying %b=tabcells 6 12 18 24 30 ... i.e. the default cell width is the width of the previous cell.</P>

<P>The main body of the spreadsheet should display in a nice neat tabular form with 6-character columns - not quite wide enough for some cells. In particular, the first column of the main spreadsheet is a year followed by Q&#123;1-4&#125; - this requires at least 8 columns to display clearly. When you've not given a column sufficient to display a cell, the cell is repeated in the console area of the screen. Looking a that we can see that the first column needs at least 7 characters to display properly.</P>

<P>We could ask the window manager to assign tabcells automatically, like this:</P>

&#062; %b=tabcells -1
<P>but some of the cells are very wide and tend to mess up our display.</P>

<P>Hit &#123;Shift+DownArrow&#125; and &#123;Shift+UpArrow&#125; a few more times, sufficient to scroll the screen - taking note of the way the column widths change. This is because tabcells -1 will adjust the column widths to accommodate the widest column-cell currently in view. See <A HREF="jot_tech.html#%B=LEFTOFFSET">%b=leftoffset</A> and <A HREF="jot_tech.html#ABOUT LONG LINES">about long lines</A>.</P>

<P>Try this instead:</P>

&#062; %b=tabcells 8 16 22
<P>This makes the first two columns 8 characters and subsequent columns all inherit the 6-character width assigned to column 3. Also, the initial comments are in very wide cells and much of this text has been truncated. If the cursor ends up in a cell that, for any reason, has been truncated it repeats the cell text in the console area like this:</P>

&#062; m-0f/Hairdressing/
<P>In the console area you should see something like this, showing the cursor in truncated cell and bits of it's neighbouring cells. If, as might happen in this case, you still can't see all of the cell, then press &#123;RightArrow&#125; until all of the cell is visible in the console area - it should look something like this:</P>

<PRE>
onal care~Hairdressing salons and personal grooming establishments~Electrical ap
</PRE>
<P>Finally, when scrolling through a spreadsheet it's useful to have a static header at the top. For this file we might chose the 4-character column key, this is on line 13 of the file:</P>

&#062; m+13 %b=header 'e

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="COLOUR-TAGGED TEXT">Colour-tagged text</H3>
<A HREF="#TABULAR TEXT - 2"><SMALL>Back to </SMALL>Tabular text - 2</A><BR><A HREF="#GRAPHICAL TEXT - 1"><SMALL>Forward to </SMALL>Graphical text - 1</A><BR><BR><BR>



<P>Jot supports user-specified colouring for specific strings in the text. In jot this is referred to as tagging text. There are two stages to the process first we define a colour scheme and assign it a name (see <A HREF="jot_tech.html#%B=TAGTYPE">%b=tagtype</A>) and then the tags can be added to the text (see <A HREF="jot_tech.html#%B=ADDTAG">%b=addtag</A>).</P>

<P>We're going to define two colour pairs - a foreground and background colour combination is known as a colour pair. the colours identified by numbers in the range 0 to 7 - see <A HREF="jot_tech.html#%B=TAGTYPE">%b=TagType</A> for details.</P>

&#062; %b=tagtype normal colour 7 0
&#062; %b=tagtype red colour 7 1
<P>The colour pair normal is used to switch back to normal text colour after the coloured-in cell. Now let's stick some colour on a cell:</P>

<PRE>
m+40r8 %b=addtag red; r5 %b=addtag normal;r-0
</PRE>
<P>Well it would be a real drag having to go round spreadsheets adding tags manually. In practice, the useful thing about colour tags is that they can be used to highlight important details that might otherwise have been missed.</P>

<P>Suppose we were interested in places where an entry for one row is less than the previous entry Now pick up the following, down-to and including '$ line, then drop it into the console area. It defines a little macro that highlights in red any cell that has a lower value than the corresponding cell in the previous year.</P>

<PRE>
%g$
%%Macro to highlight spreadsheet entries where on year's entry in a column is less than the previous year.
%%
%%Clear any preexisting colour tags.
m-0n.m0a@h@
%%Locate first row with digits in column 1 - assumed to be the year.
m-0(q/0-9/\m)0
%%Initialize column counter.
ol0
( %%Column loop - index to next column, initialize previous-cell value to 0 then find start of yearly entries.
</PRE>
<P>ol-1o+ ol0os m-0f/1997/ ( %%Year (Row) loop.</P>

<UL><P>mm- %%Step past the year column. ((q/0-9 Q/r)0rq/0-9/\m)0 %%Now index to the current column. o# (o~ (q/0-9/r)0 r)0 ok (rr-, okokr-0 %x=All done;) %%Pick up value from this cell and compare it to previous. os (oid oso&#062; %b=addtag normal;, %b=addtag red;) mos )0 osok )0</P>

<PRE>
:
'$
</PRE>
</UL><P>Note that these tags can not persist beyond the current session, it's all done with metadata that is not part of the plaintext file.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="GRAPHICAL TEXT - 1">Graphical text - 1</H3>
<A HREF="#COLOUR-TAGGED TEXT"><SMALL>Back to </SMALL>Colour-tagged text</A><BR><A HREF="#GRAPHICAL TEXT - 2"><SMALL>Forward to </SMALL>Graphical text - 2</A><BR><BR><BR>



<P>With this type of text, it is important to preserve the position of text to the right of the cursor. It is also important to have some line-drawing and block-move operations.</P>

<P>The most convenient way of doing this is with a numeric keypad - the startup script attaches the functions to the various numeric-keypad keys. Windows users should find these work anyway but linux users will have to set up the keypad with xmodmap - see <A HREF="jot_tech.html#X-WINDOWS SETUP">X-windows setup</A>. If you don't have a numeric keypad and you want to have a go at this, the functions are available as escape sequences but, trust me, it's a real drag doing it that way.</P>

<P>First clear buffer r by abstracting an empty string to r (it should be empty anyway) then move into it:</P>

&#062; n.arzr
<P>The buffer is completely empty, notice that the cursor-control keys (&#123;&#091;Left|Right|Up|Down&#093;Arrow&#125;) fail to shift the cursor off the top-left corner of the screen because there is no text to navigate.</P>

<P>In the empty buffer, you can navigate around using &#123;Ctrl+&#091;KP_4|KP_6|KP_8|KP_2&#093;&#125; () - these are attached to the &#060;&#060;<A HREF="jot_ug.html#LEFT">Left</A>&#062;&#062;, &#060;&#060;<A HREF="jot_ug.html#RIGHTREGARDLESS">RightRegardless</A>&#062;&#062;, &#060;&#060;<A HREF="jot_ug.html#UPREGARDLESS">UpRegardless</A>&#062;&#062; and &#060;&#060;<A HREF="jot_ug.html#DOWNREGARDLESS">DownRegardless</A>&#062;&#062; functions the latter three insert blank lines and whitespace into the buffer as necessary.</P>

<P>So first have a little play with the &#123;Ctrl+&#091;KP_4|KP_6|KP_8|KP_2&#093;&#125; keys (&#123;Esc m e&#125;, &#123;Esc m w&#125;, &#123;Esc m n&#125; and &#123;Esc m s&#125; respectively if you don't have a numeric keypad) and move the cursor to somewhere near the centre of your screen. </P>

<P>Now draw the first hyphen of an easterly line by hitting &#123;Ctrl+Shift+KP_6&#125; (the &#060;&#060;<A HREF="jot_ug.html#LINEE">LineE</A>&#062;&#062; function - users with no numeric keypad should do &#123;Esc l e&#125;. Now hit the repeat key &#123;F10&#125; five times - you should see a horizontal line of six hyphens with the cursor one place to the right of the last hyphen.</P>

<P>Now draw a vertical line down using the &#060;&#060;<A HREF="jot_ug.html#LINES">LineS</A>&#062;&#062; function, this is on &#123;Ctrl+KP_2&#125; (&#123;Esc l s&#125;) and repeat this five times by hitting &#123;F10&#125; 5 times. Notice the corner - &#060;&#060;<A HREF="jot_ug.html#LINES">LineS</A>&#062;&#062; detects the change in direction and left a blank at the corner to avoid any untidyness.</P>

<P>&#123;Ctrl+KP_4&#125; (&#123;Esc l w&#125;) will draw a horizontal line using the &#060;&#060;<A HREF="jot_ug.html#LINEW">LineW</A>&#062;&#062; function - again it detects the change in direction and puts a blank at the corner. Finally &#123;Ctrl+KP_8&#125; or &#123;Esc l n&#125; will draw a line going up, using the &#060;&#060;<A HREF="jot_ug.html#LINEN">LineN</A>&#062;&#062; function.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="GRAPHICAL TEXT - 2">Graphical text - 2</H3>
<A HREF="#GRAPHICAL TEXT - 1"><SMALL>Back to </SMALL>Graphical text - 1</A><BR><A HREF="#GRAPHICAL TEXT - 3"><SMALL>Forward to </SMALL>Graphical text - 3</A><BR><BR><BR>



<P>The &#060;&#060;<A HREF="jot_ug.html#LINENE">LineNE</A>&#062;&#062;, &#060;&#060;<A HREF="jot_ug.html#LINENW">LineNW</A>&#062;&#062;, &#060;&#060;<A HREF="jot_ug.html#LINESE">LineSE</A>&#062;&#062; and &#060;&#060;<A HREF="jot_ug.html#LINESW">LineSW</A>&#062;&#062; functions draw diagonal lines with Slash and Backslash ( / and \ ) characters. On the numeric keypad these are attached to &#123;Ctrl+KP_9&#125;, &#123;Ctrl+KP_7&#125;, &#123;Ctrl+KP_3&#125; and &#123;Ctrl+KP_1&#125; respectively (for those without a numeric keypad use the following instead: &#123;Esc \ u&#125;, &#123;Esc / u&#125;, &#123;Esc \ d&#125; and &#123;Esc / d&#125;).</P>

<P>Try drawing a few lozenge shapes with these keys and draw a few lines mixing these with the horizontal and vertical drawing functions.</P>

<P>To cut and paste blocks of this kind of text use the &#060;&#060;<A HREF="jot_ug.html#NOTE">Note</A>&#062;&#062; &#123;Ctrl+Shift+F1&#125;, &#060;&#060;<A HREF="jot_ug.html#CUTRECTANGLE">CutRectangle</A>&#062;&#062; &#123;Ctrl+Shift+Alt+F3&#125; and &#060;&#060;<A HREF="jot_ug.html#PASTERECTANGLE">PasteRectangle</A>&#062;&#062; &#123;Ctrl+Shift+Alt+F4&#125;. The note point must be at the top-left corner of the rectangle you want to cut. First position the cursor to the top-left corner of the rectangle to be cut, then hit note:</P>

&#062; &#123;Ctrl+Shift+F1&#125;
<P>then move the cursor to the bottom-right corner of the rectangle and cut the rectangle:</P>

&#062; &#123;Ctrl+Shift+Alt+F3&#125;
<P>The cursor should now be back at the original note point and all the text in the rectangle has been replaced by whitespace.</P>

<P>To restore the original text use the &#060;&#060;<A HREF="jot_ug.html#PASTERECTANGLE">PasteRectangle</A>&#062;&#062; function - &#123;Ctrl+Shift+Alt+F4&#125; before moving the cursor. Then move to the place where you want the top-right corner to go and apply &#060;&#060;<A HREF="jot_ug.html#PASTERECTANGLE">PasteRectangle</A>&#062;&#062; again.</P>

<P>To create a complete box use the &#060;&#060;<A HREF="jot_ug.html#BOX">Box</A>&#062;&#062; function, it takes two arguments, the box width and box height with the top-left corner at the current cursor position:</P>

&#062; 7 5 &#123;Esc b x&#125;
<P>This creates a box 7 characters wide by 5 lines high.</P>

<P>To create a complete lozenge with it's apex below the current cursor position use the &#060;&#060;<A HREF="jot_ug.html#LOZENGE">Lozenge</A>&#062;&#062; function:</P>

&#062; 6&#123;Esc z 1&#125;
<P>The DSLozenge function is similar except that the horizontal pitch is doubled:</P>

&#062; 6&#123;Esc z 2&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="GRAPHICAL TEXT - 3">Graphical text - 3</H3>
<A HREF="#GRAPHICAL TEXT - 2"><SMALL>Back to </SMALL>Graphical text - 2</A><BR><A HREF="#INSERT MODE"><SMALL>Forward to </SMALL>Insert mode</A><BR><BR><BR>



<P>Each of the line-drawing functions take an optional text-string argument - this allows you to draw using text strings when required. For the functions that draw right-to-left or bottom-to-top, the string is reversed to make it easier to read (left-to-right or top-to-bottom).</P>

<P>Navigate to the centre of your screen and type:</P>

&#062; This can be read top-to-bottom&#123;Esc l n&#125;
<P>Now create a small box of 7 characters wide by about 5 lines. Now navigate to anywhere in the box and insert text using the &#060;&#060;<A HREF="jot_ug.html#BOXTEXT">BoxText</A>&#062;&#062; function - either &#123;Ctrl+Alt+KP_5&#125; or &#123;Esc b t&#125;</P>

&#062; 7 4&#123;Esc b x&#125;
&#062;  Text in the box&#123;Esc bt&#125;   
<P>You should get something resembling this:</P>

<PRE>
                                   ------
                                  | Text |
                                  | in   |
                                  | the  |
                                  | box  |
                                  |      |
                                   ------
</PRE>
<P>As an example of this type of text, open the text version of the jot user guide and go to the diagram showing the mid-keypad assignments:</P>

&#062; %iz=$&#123;JOT_HOME&#125;/docs/jot_ug.txt
&#062; f/| 9          KP_9  |/r (ol1ow)12
<P>Set the note point at the top-left corner inside the box:</P>

&#062; &#123;Ctrl+Shift+F1&#125;
<P>then navigate to the bottom-right corner and &#060;&#060;<A HREF="jot_ug.html#CUTRECTANGLE">CutRectangle</A>&#062;&#062;:</P>

&#062; r17y6
&#062; &#123;Shift+Alt+F2&#125;
<P>The text disappears - it's actually in the _ buffer - take a quick look:</P>

&#062; z_
<P>Now return and restore the text:</P>

&#062; zz
&#062; &#123;Ctrl+Shift+Alt+F4&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="INSERT MODE">Insert mode</H3>
<A HREF="#GRAPHICAL TEXT - 3"><SMALL>Back to </SMALL>Graphical text - 3</A><BR><A HREF="#COMMAND-EDITING"><SMALL>Forward to </SMALL>Command-editing</A><BR><BR><BR>



<P>Up to now, everything has been types into the console area at the bottom of the screen. With, many modern editors the stuff you type in appears WYSIWYG-style (What You See Is What You Get) directly in the the text image image on the screen and, according to modern myth, WYSIWYG is always best. Indeed, if all you're doing is brain dumping your thoughts directly into a text-file image it's a pretty good way to work - see <A HREF="jot_ug.html#COMMAND-MODE VS. INSERT MODE">Command-mode vs. insert mode</A>.</P>

<P>Clear a buffer then zoom into it, put the editor into insert mode and just start typing.</P>

&#062; n.apzp   
<P>This switches the editor to insert mode:</P>

&#062; &#123;Esc I n&#125;
<P>Now just type in a few lines, each line is terminated by &#123;Return&#125; if you want to rub out something just press the &#123;Backspace&#125; key. This little nursery rhyme will do:</P>

<UL><P>Tom, Tom, the pipers son stole a pig and away did run pig was eat and Tom was beat and Tom went howling down the street.</P>

</UL><P>The cursor-control keys will all work just the same, as will most of the function keys. The exceptions are those which take parameters - e.g. &#060;&#060;<A HREF="jot_ug.html#FINDPREV">FindPrev</A>&#062;&#062; and &#060;&#060;<A HREF="jot_ug.html#FINDNEXT">FindNext</A>&#062;&#062; - these prompt you for a search string e.g:</P>

&#062; &#123;F7&#125;
<PRE>
Find string&#062; tom&#123;Return&#125;
</PRE>
<P>now try &#123;F7&#125; again and hit &#123;Return&#125; in response to the "Find string&#062;" prompt.</P>

&#062; &#123;F7&#125;
<PRE>
Find string&#062; &#123;Return&#125;
</PRE>
<P>it finds the previous occurrence of Tom ok, but better yet, use &#060;&#060;<A HREF="jot_ug.html#FINDPREVAGAIN">FindPrevAgain</A>&#062;&#062; ( &#123;Ctrl+F7 ) this repeats the search without prompting:</P>

&#062; &#123;Ctrl+F7&#125;
<P>&#123;Esc I n&#125; also exits insert mode.</P>

&#062; &#123;Esc I n&#125;
<P>In addition to the semi-perminant insert mode described above, jot offers a temporary version - &#123;Esc i n&#125; enters a insert mode that persists until the next use of any function, cursor or escape sequence.</P>

&#062; &#123;Esc i n&#125;
<P>Type in some text.</P>

&#062; &#123;LeftArrow&#125;
<P>You are now back in command-driven mode alternatively, &#123;Ctrl+c&#125; will also get you back to command mode.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="COMMAND-EDITING">Command-editing</H3>
<A HREF="#INSERT MODE"><SMALL>Back to </SMALL>Insert mode</A><BR><A HREF="#USING THE POPUP MENU"><SMALL>Forward to </SMALL>Using the popup menu</A><BR><BR><BR>



<P>There is a simple command-edit/repeat facility - it works my getting a buffer containing command-history and editing the desired command string in that buffer. By default, the command-history depth is just 20 lines, if you feel that is not enough, you can increase the size of the history buffer with the <A HREF="jot_tech.html#-HISTORY">-history</A> CLI qualifier.</P>

<UL><P><LI>&#060;&#060;<A HREF="jot_ug.html#CMDEDITSTART">CmdEditStart</A>&#062;&#062; &#123;Esc c e&#125; - Acquires command history to show the last few commands and whatever command string you were typing at the time that CmdEditStart was invoked.</P></LI>

<P><LI>&#060;&#060;<A HREF="jot_ug.html#CMDEDITGO">CmdEditGo</A>&#062;&#062; &#123;Esc c g&#125; - pushes command from history into console command buffer. You can then hit return launch it as a command or any function key that uses an argument.</P></LI>

</UL><P>Return to the Richard III text in the primary buffer and go to the start:</P>

&#062; z.
&#062; m-0
<P>Now fill the history buffer with simple commands - hold down the &#123;DownArrow&#125; key until you have passed line 20 (by default, the history buffer is 20 lines long - see <A HREF="jot_tech.html#-HISTORY">-History</A>). Then enter an easily identifiable command:</P>

&#062; %m=Hello world; r0p
<P>Now enter a few simple commands - the &#060;&#060;<A HREF="jot_ug.html#RIGHT">Right</A>&#062;&#062; function will do:</P>

&#062; &#123;RightArrow&#125;
&#062; &#123;RightArrow&#125;
&#062; &#123;RightArrow&#125;
<P>Now enter the command editor:</P>

&#062; &#123;Esc c e&#125;
<P>Now insert "%d1=" at the start of the macro - so that the command text defines the macro attached to button 1. First navigate to the start of the "Hello world" line then:</P>

&#062; %d1=&#123;F6&#125;
<P>Push the command back into the console command buffer:</P>

&#062; &#123;Esc c g&#125;
<P>You should be back in your original context and see the modified command string in the command area looking, for all the world, as though you'd just typed it in. At this point hit &#123;Return&#125; to run it.</P>

&#062; &#123;Return&#125;
<P>Take a look at the definition of macro 1 - we should see our original command:</P>

&#062; z1

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="USING THE POPUP MENU">Using the popup menu</H3>
<A HREF="#COMMAND-EDITING"><SMALL>Back to </SMALL>Command-editing</A><BR><A HREF="#PERCENT COMMANDS - 1"><SMALL>Forward to </SMALL>Percent commands - 1</A><BR><BR><BR>



<P>Jot has a simple, yet, very useful popup menu. It can, for example, be used to reproduce hard-to-spell, hard-to-remember or tedious-to-type words in documents or object names in computer coding languages. The popup menu is also used to offer spelling corrections suggested by Aspell in <A HREF="jot_coms.html#DOC.JOT">doc.jot</A></P>

<P>For details see <A HREF="jot_ug.html#POPUPSEARCH">PopupSearch</A>, <A HREF="jot_ug.html#POPUPMOUSESELECT">PopupMouseSelect</A>, <A HREF="jot_ug.html#POPUPRESTORE">PopupRestore</A>, <A HREF="jot_ug.html#POPUPPAGEUP">PopupPageUp</A> and <A HREF="jot_ug.html#POPUPPAGEDOWN">PopupPageDown</A>.</P>

<P>Fire up a session on RichardIII:</P>

<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/Richard_III_Entire_Play.txt
</PRE>
<P>Search for words containing the sting 'men':</P>

&#062; men&#123;Esc p s&#125;
<P>You will notice a list of words appear, on a blue background, in the top-right corner of the screen - this is the popup menu.</P>

<P>Now select one of these words by moving the mouse cursor into the popup area and clicking the left button on the mouse - if you are unfortunate enough to be working with a laptop touchpad there is doubtless some equivalent motion.</P>

<P>Notice that the popup menu has disappeared and that your selected word has appeared in the console area. You can now apply this word in some other jot function - say Find:</P>

&#062; &#123;F8&#125;
<P>You might equally have invoked <A HREF="jot_ug.html#FINDPREV">FindPrev</A> &#123;F7&#125;, <A HREF="jot_ug.html#FINDEXACTNEXT">FindExactNext</A> &#123;F9&#125;, <A HREF="jot_ug.html#INSERT">Insert</A> &#123;F6&#125;, <A HREF="jot_ug.html#SUBSTITUTE">Substitute</A> &#123;F5&#125;, etc.</P>

<P>When the search returns more results than can be accommodated in a 20-line popup, use the <A HREF="jot_ug.html#POPUPPAGEDOWN">PopupPageDown</A> and <A HREF="jot_ug.html#POPUPPAGEUP">PopupPageUp</A> to view more of the list:</P>

&#062; &#123;Esc p d&#125;
<P>and </P>

&#062; &#123;Esc p u&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="PERCENT COMMANDS - 1">Percent commands - 1</H3>
<A HREF="#USING THE POPUP MENU"><SMALL>Back to </SMALL>Using the popup menu</A><BR><A HREF="#THE %Q GROUP OF COMMANDS - 1"><SMALL>Forward to </SMALL>The %Q group of commands - 1</A><BR><BR><BR>



<P>These are mainly to do with housekeeping operations and system interfaces. <A HREF="jot_tech.html#%Q">%q</A> (system Query) is an important one, it supports several queries. Essentially it offers you little peepholes to see what's going on inside the editor.</P>

<P>Another important one is <A HREF="jot_tech.html#%S">%s</A> (System settings) - changes various default settings inside the editor.</P>

<P>There's also <A HREF="jot_tech.html#%B">%b</A> (Buffer settings) - changes some default state in the current buffer. Only a few key options are explored by this introduction - see <A HREF="jot_tech.html#PERCENT COMMANDS">percent commands</A> for more details.</P>

<P>Two quite handy ones are <A HREF="jot_tech.html#%M">%M</A> and <A HREF="jot_tech.html#%X">%X</A>, %m just sends a message to the console e.g.:</P>

&#062; %m=Hello world!; %m=You should also see this message.
<P>%X also sends a message but it forces an exit from whatever macro is currently running:</P>

&#062; %x=Abrupt exit.; %m=You should not see this message.

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="THE %Q GROUP OF COMMANDS - 1">The %Q group of commands - 1</H3>
<A HREF="#PERCENT COMMANDS - 1"><SMALL>Back to </SMALL>Percent commands - 1</A><BR><A HREF="#THE %Q GROUP OF COMMANDS - 2"><SMALL>Forward to </SMALL>The %Q group of commands - 2</A><BR><BR><BR>



<P>First, let's look at the words on system queries - <A HREF="jot_tech.html#%Q">%Q</A>, these report system and internal editor state. For most of these the destination buffer is mandatory, in these examples the report is directed to buffer z.</P>

&#062; %qz=version
<P>The editor focus changes to buffer z, this now contains two records, first the string 'version', followed by the editor version - this query is more useful than might be immediately apparent - it can be used by a macro to find out if it's running on windows or unix.</P>

&#062; %qz=date
<P>Buffer z now contains two records, first the string 'date', followed by the date as reported by the system.</P>

&#062; %qz=env JOT_HOME
<P>This time it replies with the current value of that env variable.</P>

&#062; %qz=buffer
<P>This replies with several lines reporting internal state for the current buffer - refer to <A HREF="jot_tech.html#QUERY BUFFER">query buffer</A> for details.</P>

&#062; %q=SameSinceIO   
<P>This does not write a report, it simply sets the failure flag if the buffer has been changed since it was last read or last saved - i.e. the image in front of you is, possibly, different to the version held by the filing system.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="THE %Q GROUP OF COMMANDS - 2">The %Q group of commands - 2</H3>
<A HREF="#THE %Q GROUP OF COMMANDS - 1"><SMALL>Back to </SMALL>The %Q group of commands - 1</A><BR><A HREF="#PERCENT COMMANDS, %B AND %E"><SMALL>Forward to </SMALL>Percent commands, %B and %E</A><BR><BR><BR>



&#062; %qz=dir $&#123;JOT_RESOURCES&#125;
<P>This extracts a directory listing for your JOT_RESOURCES area. There are several options for extracting more information about the files - see <A HREF="jot_tech.html#QUERY DIR">query dir</A> for details. Here's an example:</P>

&#062; %qz=dir -mtime -size $&#123;JOT_RESOURCES&#125;;
&#062; %b=tabcells -1
<P>If, by chance, you want the report ordered by file size, there are some options on the sort function that can help (see <A HREF="jot_tech.html#%B=TABSORT">%b=tabsort</A>):</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="PERCENT COMMANDS, %B AND %E">Percent commands, %B and %E</H3>
<A HREF="#THE %Q GROUP OF COMMANDS - 2"><SMALL>Back to </SMALL>The %Q group of commands - 2</A><BR><A HREF="#REDEFINING FUNCTION AND HOT-KEY MAPPINGS."><SMALL>Forward to </SMALL>Redefining function and hot-key mappings.</A><BR><BR><BR>



<P>The %B commands set some of the buffer attributes reported by the %qz=buffer query above. You've already encountered two of these in the section about tabular data (%b=tabcells and %b=header) - another important one is %b=pathname - this sets the default pathName used by %O and some other commands that refer to the filing-system.</P>

<P>The %E command is very useful - it passes a command down to your CLI and, optionally, collects the reply in a nominated buffer.</P>

&#062; %ez=ls -l .
<P>The unix status for the command is picked up and defines the editor failure flag.</P>

<P>Note that many useful CLI commands contain semicolons (in unixland they do anyway), and escaping these with backslashes makes it difficult to predict what actually emerges after the various layers have stuck their oars in. Hence jot passes all semicolons through to the shell as-is. %E commands can only be terminated by a break in the command line or the special terminator string ' -hereEndsThePercentCommand;'.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="REDEFINING FUNCTION AND HOT-KEY MAPPINGS.">Redefining function and hot-key mappings.</H3>
<A HREF="#PERCENT COMMANDS, %B AND %E"><SMALL>Back to </SMALL>Percent commands, %B and %E</A><BR><A HREF="#COMMAND FILES"><SMALL>Forward to </SMALL>Command Files</A><BR><BR><BR>



<P>The mapping of functions to keystrokes is performed by the standard startup script (see <A HREF="jot_tech.html#ABOUT STARTUP SCRIPTS">about startup scripts</A>). Take a quick look at this file - in particular the definition of functions in the ( ' ) buffer.</P>

&#062; %iz=$&#123;JOT_HOME&#125;/coms/startup.jot
<P>This only defines the functions. The startup script calls a secondary startup script to curses_keys_&#060;TERM&#062;.jot to define the keycodes used to recognize keystrokes. In windowsland it's WindowsNT_keys.jot, take a look at one of the relevant files:</P>

&#062; %ix=$&#123;JOT_HOME&#125;/coms/curses_keys_xterm.jot
<P>or</P>

&#062; %ix=$&#123;JOT_HOME&#125;/coms/WindowsNT_keys.jot
<P>The syntax is quite simple - each line has three entries first an 8-character keycode, a function name and finally an optional comment describing the keystroke but note that this is not a free-format file - the keycode must be passed out to 8 characters with whitespace.</P>

<P>The keycode 'xxxxxxxx' indicates that this OS does not support a key combination.</P>

<P>At the end of startup.jot we see this line</P>

<PRE>
obz@m-0 (f1/&#060;&#060;/\k, n.f1/&#062;&#062;/-a$&z:m-0f'$-n.r0a$&z@l0r8e0h$m, z@m)0 z^m-0h@ oz
</PRE>
<P>this code merges function definitions from the ( ' ) buffer with keycode definitions from the @ buffer and adds them to the key-mapping buffer ^ this is the buffer where jot has to find key-to-function mappings.</P>

<P>Essentially, to redefine your own key mappings, you should create your own startup.jot which defines any new functions and a new key-map file to replace unix_keys/WindowsNT_keys.jot with a customized key-map.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H2><P><A NAME="COMMAND FILES">Command Files</H2>
<A HREF="#REDEFINING FUNCTION AND HOT-KEY MAPPINGS."><SMALL>Back to </SMALL>Redefining function and hot-key mappings.</A><BR><A HREF="#COMMAND-FILE LIBRARY"><SMALL>Forward to </SMALL>Command-file library</A><BR><BR><BR>



</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="COMMAND-FILE LIBRARY">Command-file library</H3>
<A HREF="#COMMAND FILES"><SMALL>Back to </SMALL>Command Files</A><BR><A HREF="#THE GET SCRIPT - 1"><SMALL>Forward to </SMALL>The get script - 1</A><BR><BR><BR>



<P>There are lots of command files (scripts) designed to take on specific functions. In some cases, the scripts may be a tad over-specfic but that's OK because it's easy enough to adapt them. here's a list of the most important ones:</P>

<UL><P><LI><A HREF="jot_coms.html#GET.JOT">get.jot</A> - directory browser and file loader.</P></LI>

<P><LI><A HREF="jot_coms.html#DOC.JOT">doc.jot</A> - document preparation toolbox.</P></LI>

<P><LI><A HREF="jot_coms.html#DIC.JOT">dic.jot</A> - word lookup based on websters online dictionary.</P></LI>

<P><LI><A HREF="jot_coms.html#THES.JOT">thes.jot</A> (thesaurus) - cross-match words in the online Roget's</P></LI>

<P><LI><A HREF="jot_coms.html#C.JOT">c.jot</A> - c-code browser</P></LI>

<P><LI><A HREF="jot_coms.html#PERL.JOT">perl.jot</A> - perl-code browser.</P></LI>

<P><LI><A HREF="jot_coms.html#JOT.JOT">jot.jot</A> - jot code browser.</P></LI>

<P><LI><A HREF="jot_coms.html#DOC2HTML.JOT">doc2html.jot</A> - converts a text document to html.</P></LI>

<P><LI><A HREF="jot_coms.html#COMP.JOT">comp.jot</A> - compares two buffers.</P></LI>

<P><LI><A HREF="jot_coms.html#DO.JOT">do.jot</A> - runs a CLI command and collects the results.</P></LI>

<P><LI><A HREF="jot_coms.html#CLI.JOT">cli.jot</A> - applies CLI command to current file's pathName.</P></LI>

<P><LI><A HREF="jot_coms.html#PATH.JOT">path.jot</A> - applies CLI command to current file's path.</P></LI>

<P><LI><A HREF="jot_coms.html#MULTI_DO.JOT">multi_do.jot</A> - applies a CLI command to all files listed in buffer.</P></LI>

<P><LI><A HREF="jot_coms.html#MULTI_ED.JOT">multi_ed.jot</A> - applies a jot command to pathnames listed in buffer.</P></LI>

<P><LI><A HREF="jot_coms.html#LS2LIST.JOT">ls2list.jot</A> - converts ls output to a list for multi_do and multi_ed.</P></LI>

<P><LI><A HREF="jot_coms.html#AGE.JOT">age.jot</A> - returns current age of file in current buffer.</P></LI>

<P><LI><A HREF="jot_coms.html#SEARCHBUFFERS.JOT">searchbuffers.jot</A> - searches all open buffers for a given string.</P></LI>

<P><LI><A HREF="jot_coms.html#PURGE.JOT">purge.jot</A> - identifies and removes duplicated records in buffer.</P></LI>

<P><LI><A HREF="jot_coms.html#DUPLICATES.JOT">duplicates.jot</A> - finds next duplicated record in buffer.</P></LI>

<P><LI><A HREF="jot_coms.html#MC.JOT">mc.jot</A> - Displays the current buffer in multicolumned format.</P></LI>

<P><LI><A HREF="jot_coms.html#CAL.JOT">cal.jot</A> - gets a calendar using the cal command and adds week numbers.</P></LI>

<P><LI><A HREF="jot_coms.html#XWORD.JOT">xword.jot</A> - word-search query server, useful to crossword enthusiasts.</P></LI>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="THE GET SCRIPT - 1">The get script - 1</H3>
<A HREF="#COMMAND-FILE LIBRARY"><SMALL>Back to </SMALL>Command-file library</A><BR><A HREF="#THE GET SCRIPT - 2"><SMALL>Forward to </SMALL>The get script - 2</A><BR><BR><BR>



<P>A most useful script, it is used to interactively browse the filing system directories and archive files - see <A HREF="jot_coms.html#GET.JOT">get.jot</A> for full details. It can pick up a path from any of the following sources in the priority order listed.</P>

<P>Most of these usages of get.jot result in the editor focus changing to a list of files in the ( + ) buffer. Subdirectory names are suffixed with a slash ( / ). To select a file, or to descend another directory, navigate down to an entry and do &#123;Esc 0&#125;.</P>

<UL><P><LI>An absolute path given as a command-line argument.</P></LI>

&#062; get /*&#123;F2&#125;
<P>it shows a list of all files in the root area.</P>

<P><LI>Buffer ( . ) contains the Richard III sample from your $&#123;JOT_RESOURCES&#125; area, this one offers a list of all files here.</P></LI>

&#062; z.
&#062; get&#123;F2&#125;
<P><LI>When the current buffer has no valid pathname, it takes your PWD:</P></LI>

&#062; n.aqzq&#123;Return&#125;
&#062; get *&#123;F2&#125;
<P><LI>A path relative to your PWD.</P></LI>

&#062; get &#060;aFileOrDirNameInYourPwd&#062;&#123;F2&#125;
<P><LI>A path specified by the env GetDefaultPath.</P></LI>

<UL><P>This env is set to the default c include path by c.jot, for example.</P>

&#062; get stdlib.h&#123;F2&#125;

</UL></UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="THE GET SCRIPT - 2">The get script - 2</H3>
<A HREF="#THE GET SCRIPT - 1"><SMALL>Back to </SMALL>The get script - 1</A><BR><A HREF="#THE GET SCRIPT - 3"><SMALL>Forward to </SMALL>The get script - 3</A><BR><BR><BR>



<P>Another useful feature of get.jot is that it will descend into archive files of various sorts. In unixland tar (Tape ARchive) is a popular archive format (including compressed tarballs). In windows zip is a common one and there's also the microsoft cabextract format. In linux get.jot recognizes these files by applying the file utility, in windows it goes by file extension. Various helper co-processors are used to do this, some of which may need to be downloaded from various providers (see <A HREF="jot_coms.html#GET.JOT">get.jot</A> for details).</P>

<P>There's a few little sample archives in $&#123;JOT_RESOURCES&#125;/test_get - lets see what's in them:</P>

&#062; get $&#123;JOT_RESOURCES&#125;/test_get&#123;F2&#125;
<P>Along with various test files and subdirectories there's test_get.tar and test_get.zip - let's try pulling something from test_get.tar:</P>

&#062; test_get.tar&#123;F8&#125;
&#062; &#123;Esc 0&#125;
<P>It shows you a list of files and directories in this small test archive. Ignore the directories (entries ending with &#123;/&#125;select the file test_get/hello.c:</P>

&#062; hello(F8&#125;
&#062; &#123;Esc 0&#125;
<P>Note that the buffer has not been given a proper pathname - in window-terminator line it just says something like </P>

<PRE>
"&#091; From CLI command xls2csv ...
</PRE>
<P>this is because the archive may contain absolute pathname, as this one does, and if it came from a different filing system you will not be able to write the buffer to this path. As it is, in all cases you must set the pathname (see <A HREF="jot_tech.html#%B=PATHNAME">%b=pathname</A>) of the buffer before saving the file.</P>

<P>It's a similar story with spreadsheet file containing multiple sheets - let's take a look at the original xls file in $&#123;JOT_RESOURCES&#125;</P>

&#062; z+
&#062; ..//&#123;F7&#125;
&#062; &#123;Esc 0&#125;
&#062; xls&#123;F8&#125;
<P>It first asks you for a buffer key - we'll put the sheet in buffer z:</P>

&#062; z&#123;Return&#125;  
<P>It presents you with a list of sheets in the spreadsheet file - 12KN is the one we've looked at before:</P>

&#062; 12KN&#123;F8&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="THE GET SCRIPT - 3">The get script - 3</H3>
<A HREF="#THE GET SCRIPT - 2"><SMALL>Back to </SMALL>The get script - 2</A><BR><A HREF="#DOC - DOCUMENT PREPARATION TOOLBOX - 1"><SMALL>Forward to </SMALL>doc - document preparation toolbox - 1</A><BR><BR><BR>



<P>The get script recognizes some binary file formats and can launch co-processors to extract plaintext from them - see <A HREF="jot_tech.html#INSTALLATION">installation</A>.</P>

<P>In the $&#123;JOT_RESOURCES&#125; area are some versions of the test file t.t in various formats:</P>

<UL><P><LI>t.t - plain text.</P></LI>

<P><LI>t.doc - old-style microsoft word format.</P></LI>

<P><LI>t.docx - New-style microsoft word format (2007+).</P></LI>

<P><LI>t.pdf - guess what - a PDF version.</P></LI>

</UL><P>get.jot uses tika (a java application supported by apache) to suck meaningful text out of these files.</P>

&#062; get $&#123;JOT_RESOURCES&#125;&#123;F2&#125;
&#062; t.pdf&#123;F8&#125;
&#062; &#123;Esc 0&#125;
<P>In response to the 'Buffer key?' prompt, tell it to park the text in buffer x:</P>

&#062; x&#123;Return&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="DOC - DOCUMENT PREPARATION TOOLBOX - 1">doc - document preparation toolbox - 1</H3>
<A HREF="#THE GET SCRIPT - 3"><SMALL>Back to </SMALL>The get script - 3</A><BR><A HREF="#DOC - DOCUMENT PREPARATION TOOLBOX - 2"><SMALL>Forward to </SMALL>doc - document preparation toolbox - 2</A><BR><BR><BR>



<P>The doc script is a useful toolbox of basic functions for writers. We're going to try some out on some text written using doc.jot. First read the plaintext jot user guide:</P>

&#062; z.
&#062; %iy=jot_ug.txt
<P>this is another copy of the jot user guide, which was written using doc.jot.</P>

<P>Load the doc.jot macros and hotkeys:</P>

&#062; doc&#123;F2&#125;
<P>One of the most important hotkeys defined by doc.jot is probably &#123;Esc p a&#125;, this re-formats the current paragraph. Let's add some text and then use this to reformat a paragraph:</P>

&#062; m+54f/-&#123;Return&#125;
&#062; blah blah blah blah &#123;F6&#125;
<P>we've inserted a few words to the text, but the paragraph is now out of alignment. re-make the paragraph:</P>

&#062; &#123;Esc p a&#125;
<P>Now let's try breaking and joining paragraphs. Suppose we decided we wanted the last sentence of this line to be at the start of the next paragraph. The function we're going to use &#060;&#060;<A HREF="jot_ug.html#APPENDRIGHTNEXT">AppendRightNext</A>&#062;&#062; &#123;Alt+F10&#125;, remember, moves text to the next line past indentation.</P>

&#062; plain&#123;F7&#125;
&#062; &#123;Alt+F10&#125;
&#062; &#123;Ctrl+LeftArrow&#125;
&#062; &#123;Alt+F10&#125;
&#062; &#123;Esc p a&#125;
<P>The process can be reversed by using &#060;&#060;<A HREF="jot_ug.html#APPENDLEFTPREV">AppendLeftPrev</A>&#062;&#062; &#123;Alt+F9&#125; - </P>

&#062; a text&#123;F7&#125;
&#062; &#123;F9&#125;
&#062; &#123;Ctrl+RightArrow&#125;
&#062; &#123;Alt+F9&#125;
<P>This time merge the lines by erasing the line break - the function &#060;&#060;<A HREF="jot_ug.html#DELETECHRLEFT">DeleteChrLeft</A>&#062;&#062; &#123;Alt+LeftArrow&#125; deletes the line break when at the start of a line, as it is now:</P>

&#062; &#123;Alt+LeftArrow&#125;
&#062; &#123;Esc p a&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="DOC - DOCUMENT PREPARATION TOOLBOX - 2">doc - document preparation toolbox - 2</H3>
<A HREF="#DOC - DOCUMENT PREPARATION TOOLBOX - 1"><SMALL>Back to </SMALL>doc - document preparation toolbox - 1</A><BR><A HREF="#DOC - DOCUMENT PREPARATION TOOLBOX - 3"><SMALL>Forward to </SMALL>doc - document preparation toolbox - 3</A><BR><BR><BR>



<UL><P><LI>&#123;Esc h e&#125; - makes the current line into a section heading.</P></LI>

<P><LI>&#123;Esc h a&#125; - resets all headings, preserving header levels.</P></LI>

<P><LI>&#123;Esc h +&#125; - current line becomes a heading at an increased header level.</P></LI>

<P><LI>&#123;Esc h -&#125; - current line becomes a heading at an decreased header level.</P></LI>

<P>Go to any line of text and enter a new line:</P>

&#062; This a new heading.&#123;Esc h e&#125;
<P>Notice that the new heading has the correct header numbers relative to the previous heading - but the next heading is now wrong. This will be fixed later.</P>

<P>Add three more headings at various header levels:</P>

&#062; This is at a higher level.&#123;Esc a&#125;
&#062; &#123;Esc h +&#125;
&#062; This is at an even higher level.&#123;Esc a&#125;
&#062; &#123;Esc h +&#125;
&#062; This is going back one level.&#123;Esc a&#125;
&#062; &#123;Esc h -&#125;
<P>Having added a new section may wonder what about all those out-of-sequence section heading numbers further along? ... Well &#123;Esc H&#125; is here to help:</P>

&#062; &#123;Esc h a&#125;
<P>All the section numbers have been fixed.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="DOC - DOCUMENT PREPARATION TOOLBOX - 3">doc - document preparation toolbox - 3</H3>
<A HREF="#DOC - DOCUMENT PREPARATION TOOLBOX - 2"><SMALL>Back to </SMALL>doc - document preparation toolbox - 2</A><BR><A HREF="#DIC (DICTIONARY) AND THES (THESAURUS)"><SMALL>Forward to </SMALL>dic (dictionary) and thes (thesaurus)</A><BR><BR><BR>



<P>Spelling checks are an important part of document preparation - except for those of us who can remember all spellings and never miss-type a word. The doc.jot spelling check uses the gnu aspell programme - see <A HREF="jot_tech.html#UNIX AND LINUX SETUP">Unix and linux setup</A>,</P>

<UL><P><LI>&#123;Esc s p&#125; - checks the current paragraph for spelling mistakes.</P></LI>

<P><LI>&#123;Esc s d&#125; - checks the entire document for spelling mistakes.</P></LI>

<P><LI>&#123;Esc n i&#125; - moves to the next instance of the current misspelled word.</P></LI>

<P><LI>&#123;Esc n w&#125; - moves to the next word in list of bad spellings.</P></LI>

<P><LI>&#060;re&#062;&#123;Esc l x&#125; - this greps for the regular expression in the mini lexicon.</P></LI>

<P>First find a good-sized paragraph and drop a in few incorrect spellings.</P>

&#062; inner&#123;F8&#125;
&#062; bananaz &#123;F6&#125;&#125;
&#062; &#123;Esc s p&#125;
<P>The word "bananaz" appears in the console area. &#123;Esc s p&#125; is useful as a quick check of a freshly-updated paragraph or use &#123;Esc s d&#125; to check the whole document.</P>

<P>Now check the entire document with &#123;Esc s d&#125;:</P>

&#062; &#123;Esc s d&#125;
<P>With the full-document spelling check the list of miss-spelled words is not displayed in the console but is held in a buffer (the @ buffer). The &#060;&#060;NextMisspelledInstance&#062;&#062; function finds the next instance of the current reported word and each new application of &#123;Esc n i&#125; will find the next instance of the current reported word.</P>

&#062; &#123;Esc n i&#125;
<P>Sometimes, the word is a correctly-spelled technical term or someone's name that appears dozens of times and we just want to skip to the next reported word - the &#060;&#060;NextMisspelling&#062;&#062; function does just that:</P>

&#062; &#123;Esc n w&#125;
<P>It can, sometimes, be a long process looking up words in a dictionary. A regular expression search of the lexicon can sometimes help. Use the &#060;&#060;GrepLexicon&#062;&#062; function to find the correct spelling of a word. Results are displayed in the console area, if there are too many to see whet you're looking for, you can browse them in the $ buffer.</P>

&#062; ^ac.*mpl&#123;Esc l x&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="DIC (DICTIONARY) AND THES (THESAURUS)">dic (dictionary) and thes (thesaurus)</H3>
<A HREF="#DOC - DOCUMENT PREPARATION TOOLBOX - 3"><SMALL>Back to </SMALL>doc - document preparation toolbox - 3</A><BR><A HREF="#C, JOT, PERL, SH, CSH, SKILL, VERILOG, VHDL, TCL, EDIF, MIF - CODE BROWSERS."><SMALL>Forward to </SMALL>c, jot, perl, sh, csh, skill, verilog, vhdl, tcl, edif, mif - code browsers.</A><BR><BR><BR>



<P>These are quite useful for authors. They are indeed useful when reading text in difficult or archaic english. The dic.jot script is set to find the Gutenberg websters ebook - see <A HREF="jot_tech.html#INSTALLATION">installation</A>. The scripts are designed around the Gutenberg Ebook version of websters dictionary and Roget's. These can be downloaded from the Gutenberg project - see <A HREF="jot_coms.html#DIC.JOT">dic.jot</A> and <A HREF="jot_coms.html#THES.JOT">thes.jot</A>. The dic and thes scripts expect to find these in your JOT_RESOURCES area.</P>

&#062; dic&#123;F2&#125;
<P>The dic.jot script reads the dictionary and creates an index. Now the dictionary is pretty big - about 19MB and it takes a few moments to read. Once this is done it writes the index and, keep the faith, next time you run the dictionary script it'll go like the wind.</P>

<P>Once it's read it's book we can fire off a few queries.</P>

&#062; zythum&#123;Esc 7&#125;
<P>if you've not got a numeric keypad or it's not been set up, then this will do it:</P>

&#062; zythum&#123;Esc 7&#125;
<P>The thes script is based on the Gutenberg Roget's ebook. This script takes a list of words and returns the categories containing all of them. Queries are handled by macro 8. Note that, although the thesaurus contains phrases, the search does not currently support phrases.</P>

<P>On completion the $ buffer contains a list of headings for matching sections, the @ buffer contains copies of the complete sections.</P>

&#062; thes&#123;F2&#125;
&#062; party&#123;KP_8&#125;
<P>Now try intersecting it with another word.</P>

&#062; party clan&#123;KP_8&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="C, JOT, PERL, SH, CSH, SKILL, VERILOG, VHDL, TCL, EDIF, MIF - CODE BROWSERS.">c, jot, perl, sh, csh, skill, verilog, vhdl, tcl, edif, mif - code browsers.</H3>
<A HREF="#DIC (DICTIONARY) AND THES (THESAURUS)"><SMALL>Back to </SMALL>dic (dictionary) and thes (thesaurus)</A><BR><A HREF="#JOURNAL FILES AND RECOVERY FROM CRASHES"><SMALL>Forward to </SMALL>Journal files and recovery from crashes</A><BR><BR><BR>



<P>These all match block starts and ends in their respective machine languages. The functions are similar - &#123;KP_2&#125; (or &#123;Esc 2&#125;) searches forwards in the text for the next valid block-start token and then locates the corresponding block-end token. &#123;KP_1&#125; (or &#123;Esc 1&#125;) is similar but works backwards.</P>

<P>The browsers for c and jot have been used with recent versions of jot and are pretty bulletproof. Those further down the list have not been used much recently and may benefit from updating. We're now going to look at c and jot. First open a new editor session on some c:</P>

<PRE>
$ jot $JOT_HOME/source/ed.c
</PRE>
<P>To avoid corrupting the definitive file change the pathname:</P>

&#062; %b=pathname ./play.c
<P>Now load the c-code browser:</P>

&#062; c&#123;F2&#125;
<P>When you first hit &#123;KP_2&#125; there is a momentary pause while it maps all the blocks in the file. When it comes back, the focus has changed to a block end token ('&#125;' in c) at the end of a c function definition. Further pumping of &#123;KP_2&#125; takes us to the end of successive function definitions. The &#123;KP_1&#125; key takes us back, but this time it goes to block-start tokens.</P>

<P>If the C-code contains mismatched curly braces, c.jot will fail creating the hashtable. In these cases use the plodding versions - &#123;x KP1&#125; (or &#123;x Esc 1&#125;) and &#123;x KP_2&#125; (or &#123;x Esc 2&#125;) these work by plodding through the code counting curly-braces. The backwards-matching macro (Macro 1) is less reliable in this mode of operation because C cannot be reliably parsed in reverse - nevertheless, it gets it right most of the time.</P>

<P>To descend into a block just move the cursor anywhere inside the outer braces and hit &#123;KP_2&#125; again - Run_Sequence is a function with plenty of internal structure:</P>

&#062; f/Run_Sequence()/f/&#123;
&#062; &#123;RightArrow&#125;
&#062; &#123;KP_2&#125;
<P>The c script uses hashtables, not for speed - although this is a most welcome by-product, but to improve the reliability of reverse scanning. The main pitfall of using hashtables is when there's a mismatch somewhere and we want to locate it.</P>

<P>The &#123;Mod&#125; key (normally x ) modifies the function of &#123;KP_1&#125; and &#123;KP_2&#125; so that, instead of using hashtables, they plod through the code. These functions can be useful in the quest for mismatched braces.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="JOURNAL FILES AND RECOVERY FROM CRASHES">Journal files and recovery from crashes</H3>
<A HREF="#C, JOT, PERL, SH, CSH, SKILL, VERILOG, VHDL, TCL, EDIF, MIF - CODE BROWSERS."><SMALL>Back to </SMALL>c, jot, perl, sh, csh, skill, verilog, vhdl, tcl, edif, mif - code browsers.</A><BR><A HREF="#SOME MORE ADVANCED TOPICS."><SMALL>Forward to </SMALL>Some more advanced topics.</A><BR><BR><BR>



<P>First start a jot session with the optional qualifier -journal - this causes jot to keep a journal of your activity. Since the JOT_RESOURCES files are normally read only, first make a working copy of Richard, then launch a jot session with journal files.</P>

<PRE>
$ cp $&#123;JOT_RESOURCES&#125;/Richard_III_Entire_Play.txt .
$ jot Richard_III_Entire_Play.txt -jou
</PRE>
<P>Now open another CLI-window (another xterm or windows console). Hopefully it will also have the jot environment set up. Note: the height and width of the new screen must be at least that of the original screen.</P>

<P>Now, back in your jot session, just play around using the keys and commands you've looked at in previous sections - move around in the text, inserting, searching, substituting, copying and pasting. Also read in some other files and cut and paste from those into the primary text.</P>

<P>While you're doing all this, your activity is being recorded in a particular journal file - history.txt. In the other window, take a look at what's gone in there:</P>

<PRE>
$ jot Richard_III_Entire_Play.txt.jnl/history.txt
</PRE>
<P>It begins by noting a few details of your session and files read the startup script. Then , a few lines down, there is a line like this:</P>

&#060;&#060;Startup Sequence ends, buffer .&#062;&#062;
<P>As the words suggest, this point marks the end of startup-script activity. After this, most of the entries are of the form ~Xxxxx - if you're viewing it with jot, the escapes will be represented as tildes ( ~ ) - these are keycodes. For keys that take an argument, the argument appears as a prefix before the escape.</P>

<P>All the journal files and the journal directory are destroyed when the editor exits normally (the <A HREF="jot_tech.html#%C">%C</A> or <A HREF="jot_tech.html#%A">%A</A> commands).</P>

<P>The journal directory holds the following items:</P>

<UL><P><LI>the history.txt file - mainly your typed-in command activity,</P></LI>

<P><LI>any writable file read by the session, these are held as unique files.</P></LI>

<P><LI>copies of responses to <A HREF="jot_tech.html#%E">%E</A> commands are held as unique files,</P></LI>

<P><LI>results system queries are held as entries in the history.txt file.</P></LI>

</UL><P>In the new screen restart the editor but with the recovery script as it's startup:</P>

<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/Richard_III_Entire_Play.txt -st=recover
</PRE>
<P>you may recognize some of the activity flashing past on the screen.</P>

<P>What's happening is that the <A HREF="jot_coms.html#RECOVER.JOT">recover.jot</A> script has read the raw record of your original activity from the history.txt file and has creates a new script ( ./recover_now.jot, in your PWD), it's now following your original activity. Whenever it needs to read a file, it reads the archived version from the journal - see also <A HREF="jot_tech.html#ABOUT JOURNAL FILES">about journal files</A>.</P>

<P>While in recovery mode, jot %i and %e reads are intercepted and take files held in the journal directory. Also jot writes are disabled to avoid corrupting anything.</P>

<P>When it's finished, all buffers in the recovered session should be exactly the same as in your original session and reading and writing are back to normal. You may continue with the session as if nothing had happened, new commands will be appended to the history.txt file and file reads and writes behave as normal.</P>

<P>A quick way of comparing the recovered version of the file and version in the original session is to use <A HREF="jot_coms.html#COMP.JOT">comp.jot</A> go back to the original session and write the current buffer, then in the recovery session type this:</P>

&#062; comp&#123;F2&#125;  
<P>The comparison script splits the screen to display both versions side by side. On completion both windows should be displaying an identical view of the end of the file.</P>

<P>Note that, in a genuine recovery situation, the original session is dead and will never return. In our demonstration example the original session is very much alive and has no way of detecting the recovery session so there may be two entirely divergent sessions appending to the history.txt, this would make for a very confusing history file.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H2><P><A NAME="SOME MORE ADVANCED TOPICS.">Some more advanced topics.</H2>
<A HREF="#JOURNAL FILES AND RECOVERY FROM CRASHES"><SMALL>Back to </SMALL>Journal files and recovery from crashes</A><BR><A HREF="#A PROFILING MACRO"><SMALL>Forward to </SMALL>A profiling macro</A><BR><BR><BR>



<P>The following sections are of more interest to those seeking to write their own macro-commands, scripts and redefinitions of the startup files.</P>

<P>This section shows a few macro commands of moderate complexity , takes them to pieces and analyzes them.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="A PROFILING MACRO">A profiling macro</H3>
<A HREF="#SOME MORE ADVANCED TOPICS."><SMALL>Back to </SMALL>Some more advanced topics.</A><BR><A HREF="#HOW DOES THIS WORK - 2"><SMALL>Forward to </SMALL>How does this work - 2</A><BR><BR><BR>



<P>Suppose we were interested in the distribution of words in this text - we might want to count how frequently each word appears in there - something like this will generate such a report in the @ buffer.</P>

<P>Begin by copying the text into the @ buffer and changing all alpha characters to lower case.</P>

&#062; m-0n.m0r0a@&z@ m-0(q/A-Z/c, r, m)0 
<P>Place each word on a separate line then sort them alphabetically.</P>

&#062; m-0(q/a-z/(q//r)0b, rl(q/a-z/\e)0, j)0     
&#062; %b=sort
<P>Finalize the report by counting instances of each word</P>

&#062;  m-0 (r\j)0 l0 (n.r0a$&ol1m(v'$r0v-'$o~k)0 m-oo/%5d - /m)0

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="HOW DOES THIS WORK - 2">How does this work - 2</H4>
<A HREF="#A PROFILING MACRO"><SMALL>Back to </SMALL>A profiling macro</A><BR><A HREF="#MACROS"><SMALL>Forward to </SMALL>Macros</A><BR><BR><BR>



<P>There were four lines of code involved:</P>

<PRE>
m-0n.m0r0a@&z@ m-0(q/A-Z/c, r, m)0 
m-0(q/a-z/(q//r)0b, rl(q/a-z/\e)0, j)0     
%b=sort
m-0 (r\j)0 l0 (n.r0a$&ol1m(v'$r0v-'$o~k)0 m-oo/%5d - /m)0
</PRE>
<P>In the first line:</P>

<UL><P><LI>m-0 - this sends the cursor to the beginning of line 1.</P></LI>

<P><LI>n. makes a note of the cursor position (at the very start of the buffer the subsequent abstraction will move text to the nearest character.</P></LI>

<P><LI>m0r0 takes us to the very end of the buffer.</P></LI>

<P><LI>a@& abstracts (copies) all the text from the note point to the current cursor position, to the @ buffer. Without the & suffix, the a command would cut - i.e. remove the text from the original buffer.</P></LI>

<P><LI>The "q/A-Z/" command checks for upper-case alpha characters.</P></LI>

<P><LI>For upper-case alphas, the c command changes them to lower case and all commands from the comma up to the end of the block are ignored.</P></LI>

<P><LI>For other characters the Q command fails so commands following the next comma are obeyed.</P></LI>

<P><LI>The r command moves the cursor right by one character.</P></LI>

<P><LI>The next comma indicates the commands to handle the situation when the r fails (i.e. at the very end of a line).</P></LI>

<P><LI>The m command moves to the start of the next line.</P></LI>

<P><LI>( ... )0 - this is a block of commands that keeps repeating until an untrapped failure occurs - in this case the final m command will fail at the last line of a buffer.</P></LI>

</UL><P>The second line chops up sentences to yield a list of all the words in the original file in their original order. Again, the q command detects non-alpha characters then the ( b ) command breaks up the lines on the word boundaries removing any more adjacent non-alpha characters with the ( e ) command.</P>

<UL><P>In the third line, the %b=sort calls the system quicksort service (see <A HREF="jot_tech.html#%B=SORT">%b=sort</A>).</P>

<P>In the final line there are a few new commands:</P>

<UL><P><LI>the backslash after the r command reverses the success/failure state.</P></LI>

<P><LI>j joins the current line with the next.</P></LI>

<P><LI>ol1 loads the value 1 onto the stack.</P></LI>

<P><LI>v verifies that the string following the cursor is the same as that given in the argument. In this case the argument is an indirect reference to the $ buffer.</P></LI>

<P><LI>The v- is similar, except that it looks back, at characters left of the cursor.</P></LI>

<P><LI>The o~ command increments the value on the stack.</P></LI>

<P><LI>The k command deletes (kills) the current line.</P></LI>

<P><LI>the oo command outputs the value on the stack using the given format string, in this case "%5d - ".</P></LI>


</UL></UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="MACROS">Macros</H3>
<A HREF="#HOW DOES THIS WORK - 2"><SMALL>Back to </SMALL>How does this work - 2</A><BR><A HREF="#THE STACK - 1"><SMALL>Forward to </SMALL>The stack - 1</A><BR><BR><BR>



<P>We could scoop up all of those commands into a buffer. That would then become a macro command to generate a similar report for any text. Macros 0 to 9 are attached to numeric-keypad buttons 0 to 9 - so, for this example we're putting the commands into buffer 3 and adding some commentary.</P>

<P>The <A HREF="jot_tech.html#%G">%g</A> command is a good way of doing this - it copies all text from the keyboard into the specified buffer, until terminated with a colon ( : ).</P>

&#062; %g3
<PRE>
%%Copy text to @ and change all alphas to lower case.
m-0n.m0r0a@&z@ m-0(q/A-Z/c, r, m)0 
</PRE>
<PRE>
%%Place each word on a separate line then sort them alphabetically.
m-0(q/a-z/(q//r)0b, rl(q/a-z/\e)0, j)0     
%b=sort
</PRE>
<PRE>
%%Finally, count up instances of each word 
m-0 (r\j)0 l0(n.r0a$&ol1m(v'$r0v-'$o~k)0 m-oo/%5d - /m)0
:
</PRE>
<P>Now go to the original text and run the macro - KP_3 denotes button 3 in the numeric-keypad - if your keyboard lacks a numeric keypad then use &#123;Esc 3&#125; - the escape key followed by 3</P>

&#062; z.
&#062; &#123;KP_3&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="THE STACK - 1">The stack - 1</H3>
<A HREF="#MACROS"><SMALL>Back to </SMALL>Macros</A><BR><A HREF="#THE STACK - 2"><SMALL>Forward to </SMALL>The stack - 2</A><BR><BR><BR>



<P>The simplest usage of the stack is just a temporary parking place for various fragments of numerical and textual data. It can also be used to perform simple arithmetic and logical operations including counting.</P>

<P>One common problem in the design of macro commands is that we need to switch context to some buffer to pick up some information and then return to the original focus - the stack is there to help.</P>

&#062; ob %q~=date; m os oz i'~ ok
<UL><P><LI><A HREF="jot_tech.html#OB">ob</A> - puts the buffer key onto the stack.</P></LI>

<P><LI>%q~=... puts the reply in a temporary buffer and leaves a pointer to that buffer at the top of the stack - see <A HREF="jot_tech.html#ABOUT COMMAND PARAMETERS">about command parameters</A>.</P></LI>

<P><LI><A HREF="jot_tech.html#OS">os</A> swaps the top two items on the stack, so the buffer key is now at the top.</P></LI>

<P><LI><A HREF="jot_tech.html#OZ">oz</A> changes focus to the buffer indicated by the key at the top of the stack.</P></LI>

<P><LI>the '~ expression in the insert command means insert the current record from that buffer - see <A HREF="jot_tech.html#ABOUT COMMAND PARAMETERS">about command parameters</A>.</P></LI>

<P><LI><A HREF="jot_tech.html#OK">ok</A> removes the top item, in this case it's a temporary buffer so the buffer is also deleted.</P></LI>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="THE STACK - 2">The stack - 2</H3>
<A HREF="#THE STACK - 1"><SMALL>Back to </SMALL>The stack - 1</A><BR><A HREF="#BLOCKS - 1"><SMALL>Forward to </SMALL>Blocks - 1</A><BR><BR><BR>



<P>Sometimes we need to go off somewere else in the same buffer and find our way back:</P>

&#062; oconf/fred/r4n.f1/ /a$ono-omor 
<UL><P><LI><A HREF="jot_tech.html#OC">oc</A> puts the current-character column on the top of the stack.</P></LI>

<P><LI><A HREF="jot_tech.html#ON">on</A> puts the current line number onto the stack.</P></LI>

<P><LI>to get back to that place, get the new line number subtract and that is the displacement to give <A HREF="jot_tech.html#OM">om</A> to move back to the original line.</P></LI>

<P><LI><A HREF="jot_tech.html#OR">or</A> moves right to get back exactly to where we started.</P></LI>

</UL><P>Notice it did a little bit of arithmetic there, on puts the current line number on the top of the stack, it subtracted one from the other and calculated the displacement to give om which takes it back to the original line.</P>

<P>It can also pick up numerical values from the text. This involves a text-to-numeric conversion - oid performs a decimal conversion, oix hex oio octal and oif floating-point. Here, we're going to pick up a value from the spreadsheet and insert it into some text using the formatted output <A HREF="jot_tech.html#OO">oo</A>:</P>

&#062; zem-0f/2011/r5
&#062; oid z. oo/ In 2011, it was %d  /

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="BLOCKS - 1">Blocks - 1</H3>
<A HREF="#THE STACK - 2"><SMALL>Back to </SMALL>The stack - 2</A><BR><A HREF="#BLOCKS - 2"><SMALL>Forward to </SMALL>Blocks - 2</A><BR><BR><BR>



<P>Many editors have some special search-and-replace mode for repetitive changes to the text. Jot has no such magic mode - because it's got something much better: a block structure. It's the block structure that gives this editor it's real power.</P>

<P>Here you will find it useful to know about the following commands and syntactic objects:</P>

<UL><P><LI><A HREF="jot_tech.html#V">v</A>/&#060;string&#062;/ - (verify) succeeds if the string immediately right of the cursor matches the given string, v-/&#060;string&#062;/verifies the text to the left of the cursor.</P></LI>

<P><LI><A HREF="jot_tech.html#Q">q</A>/&#060;chrs&#062;/ - (qualify) succeeds if the character immediately right of the cursor is one of those in the list, q-/&#060;chrs&#062;/ looks the other way.</P></LI>

<P><LI><A HREF="jot_tech.html#(">(</A> &#060;commandSequence&#062; <A HREF="jot_tech.html#)">)</A></P></LI>

<P><LI><A HREF="jot_tech.html#,">,</A> (else) - the commands following the comma take control if some earlier command failed.</P></LI>

<P><LI><A HREF="jot_tech.html#?">?</A> - changes the status of the previous command to success.</P></LI>

<P><LI><A HREF="jot_tech.html#\">\</A> - reverses the status of the previous command.</P></LI>

<P><LI>' - Invokes a macro command - see <A HREF="jot_tech.html#ABOUT MACROS">about macros</A> (i.e. a sequence of jot commands in another buffer).</P></LI>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="BLOCKS - 2">Blocks - 2</H3>
<A HREF="#BLOCKS - 1"><SMALL>Back to </SMALL>Blocks - 1</A><BR><A HREF="#WORKING WITH LARGE FILES"><SMALL>Forward to </SMALL>Working with large files</A><BR><BR><BR>



<P>Here's a few examples:</P>

&#062; (f/fred/ l0 f1/jim/\)0
<UL><P><LI>This block is designed to locate lines containing both of the strings 'fred' and 'jim', it works by locating the next line containing 'fred' the status of the 'jim' find is reversed so that it exits the infinite loop with success. Note that it also exits with success when the end of buffer is reached - even if the line contains neither fred or jim.</P></LI>

&#062; (f/fred/ l0 f1/jim/\)0 v/jim/
<P><LI>A bulletproof version of the above, in the sense that it fails if the last line does not match.</P></LI>

&#062; (f1/fred/\ f1/jim/\ f1/bill/\ m)0
<P><LI>This sniffs through the buffer and stops when it reaches a record containing any one of the strings 'fred', 'jim' or 'bill'</P></LI>

&#062; (rle0j, j)      
<P><LI>This deletes to the end of the current line, if not already at the end of the line. Otherwise joins with next line. The initial r is only used to test for the for the end of line.</P></LI>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="WORKING WITH LARGE FILES">Working with large files</H3>
<A HREF="#BLOCKS - 2"><SMALL>Back to </SMALL>Blocks - 2</A><BR><A HREF="#WORKING WITH COLLECTIONS OF SOURCE FILES"><SMALL>Forward to </SMALL>Working with collections of source files</A><BR><BR><BR>



<P>Jot has limited support for very large files - a very large file is one that's too big to load in a normal editor session - see <A HREF="jot_tech.html#ABOUT LARGE FILES">About large files</A>. The approach adopted assumes that most of the time we are only browsing these files in search of an answer to questions such as "why this timing violation" or "why that error".</P>

<P>Here you will generate a sample large file of fairly simple structure, perform a few operations on it and write it back to the filing system.</P>

<P>First make a sample file, not too large one or two Gb is OK - you will later use diff to check a modified version of the file. The following command will generate hex dumps linux binaries in /usr, the command can be adapted for windows systems. In the jot -init command string, the initial "ol1000000000" sets the requested upper limit on the destination file size.</P>

<PRE>
$ rm big_file.txt
$ jot /dev/null -in="%eq=ls -RF /usr/lib64; %r=ls2list; \
</PRE>
<P>ol1000000000 m-0((%i.='q -binary 64; i'qbr0b %o=big_file.txt -append;, ) %q$=file big_file.txt; f/ size = /-oid o&#062; zqm)0"</P>

<P>The index can be built with these two shell commands:</P>

<PRE>
$ grep -b "/usr" big_file.txt &#062; big_file.txt_index
$ jot big_file.txt_index -quiet -in="(f1/:/-n.r0f-1./.-aam)0 %c"
</PRE>
<P>After it's been generated the index remains good until the main file is rebuilt or modified. Subsequent sessions can be started like this:</P>

<PRE>
$ jot /dev/null -in="%r=big_file -file=big_file.txt; %qz=keys;"
</PRE>
<P>The file it's actually reading is the index file we've just created, it uses this to populate a hash table with entries for each named section in the big file. If you want a different name for the index file you could say this:</P>

<PRE>
$ jot /dev/null -in="%r=big_file -file=big_file.txt -index=&#060;myPathName&#062;;"
</PRE>
<P>Before we read any of the real file let's check to see what's in the hash table, the command-line suggested above lists all keys in the ( z ) buffer. Alternatively do this:</P>

&#062; z. %qz=keys;
<P>Notice each entry has a key, a seek offset and a bytecount, at the end of this report you will notice a few data objects defined by the big_file script, "pathName", for example is the main-file pathname.</P>

<P>Now pick up any name you fancy from the list of keys in buffer Z and pull in it's hex dump - I'm picking "grep" for no particular reason:</P>

&#062; grep&#123;Esc 7&#125;
<P>The screen should now be filled with a hex dump of the grep-command binary. Note that big_file.jot has added a separator line of the form:</P>

------------------------------------------ &#060;keyString&#062;
<P>These are important because they are target points for hash-table entries that find sections later - if, at some later point, query "grep" again, instead of re-reading the dump for grep it will direct you to this section again. These target points are also used if ever you want to write a modified file back to the filing system.</P>

<P>Now, if this were a useful big file, such as a CDL netlist some EDIF parasitic file, we might be more interested in referencing sections by features inside the sections like net names, model names ... whatever. In our case we look for features in the binary dumps - like this:</P>

&#062; E8 AE&#123;Esc 8&#125;
<P>This greps for sections containing that sequence of bytes and pulls them all in.</P>

<P>Finally let's make a few changes and write our modified version back to the filing system, add a few strings that are easily detectable with grep or diff:</P>

&#062; f/00 00/s/ZZ ZZ/
<P>Now write the file, note that original order in which you read the sections is unimportant and that all sections in memory will be written irrespective of whether you've actually changed them. Macro 9 will copy sections from the original file to the new file replacing any that have been read with the relevant section from memory.</P>

&#062; &#123;Esc 9&#125;
<P>The file is copied to a new version of big_file.txt, the original is still available for comparison - it's been renamed to big_file.txt_orig. Now close the session and return to the CLI - check the differences between the two files:</P>

<PRE>
$ diff big_file.txt big_file.txt_orig
</PRE>
<P>Note: In general, once you have written a new version of the file you should re-index the file because the edits may have altered the length of your modified sections and hence will change the seek offsets for later sections.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="WORKING WITH COLLECTIONS OF SOURCE FILES">Working with collections of source files</H3>
<A HREF="#WORKING WITH LARGE FILES"><SMALL>Back to </SMALL>Working with large files</A><BR><A HREF="#FIRST WITH JOT INDEX FILES"><SMALL>Forward to </SMALL>First with jot index files</A><BR><BR><BR>



<P>The notion of index files has been broadened to encompass large collections of files which, together, define a complicated system. The first requirement, when faced with such a system, is to gain an understanding of how the various modules interact with each other. The script <A HREF="jot_coms.html#MULTI_FILE.JOT">multi_file.jot</A> has been designed to address this problem and a similar script <A HREF="jot_coms.html#CTAGS.JOT">ctags.jot</A> which uses ctags files generated by the Exuberant Ctags programme.</P>

<P>The multi_file.jot script, like <A HREF="jot_coms.html#BIG_FILE.JOT">big_file.jot</A> is driven by an index file but these index files refer to any number of source files. Remember that, for large files, the file was opened and the filehandle was associated with the buffer using hash-table objects that only need indicate a seek offset and section length in bytes. Now, for collections of files we need a different hashtable object that also holds the file pathname. These objects are set up using the <A HREF="jot_tech.html#HASHTABLE SETFSECT">hashtable setfsect</A> command.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="FIRST WITH JOT INDEX FILES">First with jot index files</H4>
<A HREF="#WORKING WITH COLLECTIONS OF SOURCE FILES"><SMALL>Back to </SMALL>Working with collections of source files</A><BR><A HREF="#NOW A CTAGS-GENERATED INDEX"><SMALL>Forward to </SMALL>Now a Ctags-generated index</A><BR><BR><BR>



<P>The following should work for any GNU download - in this case I chose an ncurses 4.2 download:</P>

<PRE>
$ ls -laRF .../ncurses-4.2 | jot -in="%r=multi_file -indextype=c;"
</PRE>
&#062; z@
<P>You should now be looking at an image of the file ./multi_file_index in buffer ( @ ).</P>

<P>The index file has been written to your PWD, to re-use the same index file, exit and restart thusly:</P>

<PRE>
$ jot /dev/null -in="%r=multi_file"
</PRE>
<P>Now take a look at the file-sections (C-functions) it has defined in the index:</P>

&#062; z. %qz=keys;
<P>For ncurses I see over 1000 listed in the keys report. Now pick any likely function name - for C the function 'main' would be a good starting point:</P>

&#062; main&#123;Esc 7&#125;
<P>The view should change to buffer ( . ) with a copy of the main() function. &#123;Esc 7&#125; ran macro_7 which immediately calls &#060;&#060;multi_file_simpleQuery&#062;&#062; - a jot function defined by multi_file.jot.</P>

<P>But hang on, I hear someone say, it's quite common for systems to have several main() routines - Quite right, the indexation process detects such name collisions and uniquifies the names by suffixing with a number (the index-file line number). The main() definition you're looking at happened to be the first one read from the index file. You can see the others by querying names matching "main" using the jot function &#060;&#060;multi_search_section_names&#062;&#062; which, for your convenience, is called by macro_8 - let's see if there are any more main() functions:</P>

&#062; main&#123;Esc 8&#125;
<P>For ncurses v4.2 I get 19 matches in total. In addition to the one we've just loaded there's 17 with numeric suffixes, these are all listed as being of type SetfsectObj. There's also a main_InText that's listed as being type FindObj, this is the hashtable entry for the image we just loaded.</P>

<P>If we were to query main again, rather than re-reading the same text, it just re-focuses to the original function.</P>

<P>Now pick up a few function names at random and load these using &#060;&#060;multi_file_simpleQuery&#062;&#062; or &#123;Esc 7&#125;</P>

<P>If you want to keep several index files in one directory, you can specify unique names for them:</P>

<PRE>
$ ls -aRF | jot -in="%r=multi_file -indextype=c -index=my_index;"
</PRE>
<P>and restart with:</P>

<PRE>
$ jot /dev/null -in="%r=multi_file -index=my_index;"
</PRE>

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="NOW A CTAGS-GENERATED INDEX">Now a Ctags-generated index</H4>
<A HREF="#FIRST WITH JOT INDEX FILES"><SMALL>Back to </SMALL>First with jot index files</A><BR><A HREF="#THE STARTUP SCRIPT"><SMALL>Forward to </SMALL>The startup script</A><BR><BR><BR>



<P>The process with Ctags is very similar, after you have downloaded a curses tree:</P>

<PRE>
$ ctags -R &#060;absolutePathToNcursesRoot&#062;/*
</PRE>
<P>You should now be the proud owner of a ctags file in your PWD - read this into a jot session:</P>

<PRE>
$ jot tags -in=%r=ctags
</PRE>
<P>You should see an image of your tags file but, hidden from view, jot has created an internal hashtable database it can use to pick up your source files for you. You can examine this with this command:</P>

&#062; %qz=keys;
<P>This lists the hashtable keys - each entry corresponds to a function or constant definition in the source-code tree.</P>

<P>Now lets pull in a source file. Selecting the function "MyMenu" at random - you can chose any of the keys listed in your hashtable-keys report:</P>

&#062; MyMenu&#123;Esc 7&#125;
<P>Pick a few more functions and constants - you can return to the keys report with this command</P>

&#062; z.
<P>You can return to your last-viewed function with this command:</P>

&#062; z~
<P>Unfortunately ctags.jot, by default, loads into an internal datastructure that does not permit the use of the <A HREF="jot_tech.html#Z">Z</A> command for navigation between source files - each one is placed at the top of the stack by macro ( 7 ).</P>

<P>Running ctags.jot with the -AtoZ qualifier fixes this but it imposes a session-maximum limit of 26 files active being viewed. This is not too restrictive when, even though a source library contains hundreds of files, you only want to view a few of them.</P>

<PRE>
$ jot tags -in=%r=ctags -AtoZ;
</PRE>
<P>Now when you launch queries, every time it needs to read a new file, it is assigned a new buffer so you can quickly return to views of other files using the Z command.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="THE STARTUP SCRIPT">The startup script</H3>
<A HREF="#NOW A CTAGS-GENERATED INDEX"><SMALL>Back to </SMALL>Now a Ctags-generated index</A><BR><A HREF="#METADATA"><SMALL>Forward to </SMALL>Metadata</A><BR><BR><BR>



<P>The assignment of editing functions to keys is easily changed to match whatever editor you happen to be accustomed to - see <A HREF="jot_tech.html#TRANSLATION OF KEYBOARD EVENTS TO ACTIONS">translation of keyboard events to actions</A> and <A HREF="jot_tech.html#ABOUT STARTUP SCRIPTS">about startup scripts</A>. Also, it's easy enough to roll your own editor functions and attach then to keys in your own personalized startup script.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="METADATA">Metadata</H3>
<A HREF="#THE STARTUP SCRIPT"><SMALL>Back to </SMALL>The startup script</A><BR><A HREF="#COLOUR TAGS"><SMALL>Forward to </SMALL>Colour Tags</A><BR><BR><BR>



<P>Jot is strictly a plaintext editor in the sense that it only reads plain-text and only writes plain text - anything to do with fancy fonts etc. is strictly for word processors.</P>

<P>It is possible and sometimes useful, to add bits of metadata to the internal representation of the text to highlight sections of text with colour or to link sections of text in some way.</P>

<P>In jot such metadata is implemented with tags (see about <A HREF="jot_tech.html#ABOUT TAGGED TEXT">about tagged text</A>). Three types of tags are supported by jot:</P>

<UL><P><LI>Colour tags - causes a substring in a line of text to be displayed with a specified foreground and background colour combination.</P></LI>

<P><LI>Text tags - a string is held internally and invisible in the display, this string can be picked up and used for any purpose.</P></LI>

<P><LI>Target points - a hashtable can redirect the editor cursor to a point indicated by the tag (see <A HREF="jot_tech.html#ABOUT HASHTABLES">about hashtables</A>). In jot, hashtables are only used to implement hypertext jumps between different sections of a document or several documents in one or more buffers.</P></LI>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="COLOUR TAGS">Colour Tags</H4>
<A HREF="#METADATA"><SMALL>Back to </SMALL>Metadata</A><BR><A HREF="#TEXT TAGS"><SMALL>Forward to </SMALL>Text tags</A><BR><BR><BR>



<P>First lets add a bit of colour to the Richard III example.</P>

<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/Richard_III_Entire_Play.txt
</PRE>
<P>We're going to sniff through the text identifying each new scene and colour tag those lines. First we have to define a colour pair with the <A HREF="jot_tech.html#%B=TAGTYPE">%b=tagtype</A> command:</P>

&#062; %b=tagtype SceneStart colour 7  5;
<P>This colour pair is white foreground on a magenta background.</P>

<P>Now find each new scene and add the tag with the <A HREF="jot_tech.html#%B=ADDTAG">%b=addtag</A> command:</P>

&#062; m-0((v/ /r)0v/SCENE /r0ocl0ou %b=addtag SceneStart; m, m)0
<P>Notice that the extent of the colour tag is set by first defining a substring in the text.</P>

<P>To remove a colour tag, use the <A HREF="jot_tech.html#%B=REMOVE_TAG">%b=remove_tag</A> command:</P>

&#062; m-0f/ SCENE I./r0ocl0ou %b=remove_tag colour SceneStart;
<P>The remove tag command first checks all the details given (tag type must be 'colour' tag name must be 'SceneStart' and the start and end points of the text string mus all exactly match those of the tag or the command fails.</P>

<P>The colour can be used for any purpose - maybe just to add a static highlight to sections of text - but they are particularly useful when used to indicate hypertext links.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="TEXT TAGS">Text tags</H4>
<A HREF="#COLOUR TAGS"><SMALL>Back to </SMALL>Colour Tags</A><BR><A HREF="#REC 15"><SMALL>Forward to </SMALL>Rec 15</A><BR><BR><BR>



<P>Text tags allow the programmer to hide strings in the editors internal record structure. They can be used for any purpose but they are most useful when used with hash tables to hide keys behind the text.</P>

<P>Here we're going to hide the short string "This is a short string" behind the first line of the play.</P>

<P>Read Richard III into a new session:</P>

<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/Richard_III_Entire_Play.txt
</PRE>
<P>Find the first line and make all of the text a substring:</P>

&#062; f/Now is the winter/ocr0ocoso#l0oro-ou
<P>Now add the string:</P>

&#062; %b=addtag -text=This is a short string;
<P>Now retrieve the string with <A HREF="jot_tech.html#QUERY TAGS">query tags</A> with the -here qualifier this restricts the report to tags directly below the current character.</P>

&#062; %q$=tags -here;
<P>The report should read like this:</P>

<PRE>
tags -here
Reporting tags at Line no. 15 Character no. 4, Buffer .
</PRE>
</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H5><P><A NAME="REC 15">Rec 15</H5>
<A HREF="#TEXT TAGS"><SMALL>Back to </SMALL>Text tags</A><BR><A HREF="#MOUSE EVENTS - 1"><SMALL>Forward to </SMALL>Mouse Events - 1</A><BR><BR><BR>



<P>" Now is the winter of our discontent" Type text from chr 4 to 39 = "This is a short string"</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="MOUSE EVENTS - 1">Mouse Events - 1</H4>
<A HREF="#REC 15"><SMALL>Back to </SMALL>Rec 15</A><BR><A HREF="#MOUSE EVENTS - 2"><SMALL>Forward to </SMALL>Mouse Events - 2</A><BR><BR><BR>



<P>By default, all mouse events are disabled - linux users can then use all the normal X-windows selection facilities. Mouse events are enabled by setting the mouse mask - this is a bit-mapped mask selecting mouse actions that are required see <A HREF="jot_tech.html#%S=MOUSEMASK">%s=mousemask</A>.</P>

<P>When a mouse event is encountered, it is delivered as an escape sequence which allows the programmer to define a handler for the event. A left-button-click, for example is encoded as M0004 - see the relevant key-setup file for the full list (e.g. $&#123;JOT_HOME&#125;/coms/unix_keys.jot).</P>

<P>When a left-click-event happens the editor picks up the escape sequence &#123;Esc&#125;M0004 to locate the mouse-click position in text use the <A HREF="jot_tech.html#OP">OP</A> command this adds three items to the stack - the buffer key, the line number and character number. For this example we are just going to report these values in the console area:</P>

&#062; z^m-0i/M0004   opn.a$z$ oo"Mouse click in buffer %c, "lr oo"Line no. %d, "lr oo"character no. %d" pz./b
<P>To enable just the left-click event (in linux/X-windows) we would set a mouse mask of 0004:</P>

&#062; %s=mousemask 0004;
<P>For windows, all mouse events are enabled together with this:</P>

&#062; %s=mousemask -1;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="MOUSE EVENTS - 2">Mouse Events - 2</H4>
<A HREF="#MOUSE EVENTS - 1"><SMALL>Back to </SMALL>Mouse Events - 1</A><BR><A HREF="#HASH TABLES"><SMALL>Forward to </SMALL>Hash tables</A><BR><BR><BR>



<P>We can set up a simple menu-driven system by defining a secondary window containing clickable menu items. A simple form of popup menu can be mechanised using a jot popup window.</P>

<P>First define a new startup file named menu_startup.jot. Pick up the following and drop into a bourne-shell session (doubtless windows users know some way of doing this in windowsland):</P>

<PRE>
$ cat - &#062; menu_startup.jot &#060;&#060;endOfFile
%%This jot script sets up a simple menu-driven editing environment.
%%
%%First Run the normal startup.
%r=/home/jone/ed//coms/startup.jot;
%%
%%Buffer M will be the menu - define the colour tags.
n.amzm %b=tagtype Button 4 7;
%%Define button text.
i/ /20r0b2m-0
r5i/FindAgain/ %b=addtag Button; %b=addtag -text=M_FindAgain;
r5i/Find/ %b=addtag Button; %b=addtag -text=M_Find;
r5i/SubsAgain/ %b=addtag Button; %b=addtag -text=M_SubsAgain;
r5i/Subs/ %b=addtag Button; %b=addtag -text=M_Subs;
%%
%%Remove all windows from the screen, add a 1-line static window on buffer M followed by a floating window.
%q~=window; f/screenHeight = /- oidol5o-z.osok %w; %w 1 m; %w '~; %w 0; w
%%
%g0
%%Mouse-event handler.
%%
%%Get mouse coordinates and check for tags.
ob op ozono-om or
( %q$=tags -here;
</PRE>
<P>f/Type text from chr/f1/"/- v/M_FindAgain/ zmm+2o#ozf'm?zmm-0 oz, v/M_Find/ zmm+2 %s=prompt Find string&#062; ; gm- o#ozf'm?zmm-0 oz, v/M_SubsAgain/ zmm+3o#ozs'm?zmm-0 oz, v/M_Subs/ zmm+3 %s=prompt Substitute string&#062; ; gm- o#ozs'm?zmm-0 oz, oz %x=Error: Invalid mouse click.; )</P>

<PRE>
:
%%Attach the handler to left-button-click events (M0004 - linux, MB1c - Windows).
obz^m-0(%q=windows; f/MB1c    /-?, f/M0004   /-)e0i/'0/ oz
%%Enable mouse events.
%s=mousemask 0004;
endOfFile
</PRE>
<P>This can be run by using it as a startup script:</P>

<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/l99.t -st=./menu_startup.jot
</PRE>
<P>First click on "Find" and specify a search string - say "abc". Then click on "Subs" (substitute) and specify any string to replace the matched substring.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="HASH TABLES">Hash tables</H3>
<A HREF="#MOUSE EVENTS - 2"><SMALL>Back to </SMALL>Mouse Events - 2</A><BR><A HREF="#PLAYING WITH HASH TABLES"><SMALL>Forward to </SMALL>Playing With Hash tables</A><BR><BR><BR>



<P>In the implementation of hypertext links, hashtables are useful, but not essential they avoid the necessity of repeating complicated string matches for every query and, for *very* large files they can speed up individual queries - but the setup times can get excessive.</P>

<P>Now jot will only read simple plaintext files, so all the so the links are set up in some initialization phase. In this example we're going to add a scene-contents page to the Richard III text. This example sets up simple hypertext links between a separate table-of-contents buffer and the main text.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="PLAYING WITH HASH TABLES">Playing With Hash tables</H4>
<A HREF="#HASH TABLES"><SMALL>Back to </SMALL>Hash tables</A><BR><A HREF="#PLAYING WITH DATA OBJECTS"><SMALL>Forward to </SMALL>Playing with Data Objects</A><BR><BR><BR>



<P>Read Richard III into a new session:</P>

<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/Richard_III_Entire_Play.txt
</PRE>
<P>Set up the hashtable - allocating 100 entries, in fact it needs less than 30.</P>

&#062; %h=create 100;
<P>Define the table-of-contents colour tag.</P>

&#062; n.aczc %b=tagtype TOCLine colour 7 5;
<P>Enable mouse left-button clicks, and define a mouse-event handler function.</P>

<P>This goes to the mouse-click position and picks up a text tag - this is the hash-table key required to look up the scene. In fact this example could have been implemented without text tags - since the contents-table entry is identical to the key hidden in the text tag. In general, however this is not the case.</P>

&#062; %s=mousemask 0004; z^m-0i/M0004   opozono-omor %q$=tags -here; f.Type text from.f1.".-bf1.".b-z.m0w %h=jump '$; l0/b
<P>Now sniff through the text locating each new scene, make a hashtable entry for it, add a line to the contents list and tag it with the text and the TOCLine colour.</P>

&#062; z.m-0((v/ /r)0v/SCENE /n.r0a$& %h=add '$; zch$b-ocl0ou %b=addtag TOCLine; %b=addtag -text='$; z.m, m)0
<P>Finish off at the start of the table of contents.</P>

&#062; zcm-0

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="PLAYING WITH DATA OBJECTS">Playing with Data Objects</H4>
<A HREF="#PLAYING WITH HASH TABLES"><SMALL>Back to </SMALL>Playing With Hash tables</A><BR><A HREF="#PLAYING WITH DATA TREES"><SMALL>Forward to </SMALL>Playing with data trees</A><BR><BR><BR>



<P>Data objects are copied to and from hash-table entries and the stack. And can be used in a similar way to variables in normal programming languages. There are three data types allowed on the stack - integers, reals (floating-point numbers) and buffers.</P>

<P>A data entry is created with the <A HREF="jot_tech.html#HASHTABLE CREATE">hashtable create</A> command, values are defined using the <A HREF="jot_tech.html#OV">OV</A> command, which copies the value at the top of the stack to the object and values are referenced by the <A HREF="jot_tech.html#OQ">OQ</A> command. The declaration does not define the data type but once assigned a value, all later assignments must be of the same type (integer, real or buffer)</P>

<P>Here's a few things to try:</P>

&#062; %h=create My_int; ol123 ov/My_int/
<P>We've defined the hashtable entry pushed the number 123 onto the stack and then popped that stack entry to define the value of data object My_int. At any time we can redefine the value with another OV/My_int:</P>

&#062; il456 ov/My_int/
<P>Now that they've been defined their type is also defined so this will fail:</P>

&#062; ol123.456 ov/My_int/
<P>The process for real numbers is pretty similar but, for buffers we might chose to use the <A HREF="jot_tech.html#%D">%D</A> command to define a new buffer at the top of the stack:</P>

&#062; %h=create My_buf; %d~=This is the string in My_buf; ov/My_buf/
<P>Or, we might chose to use an abstraction to define the buffer - something like this: n. ... a~</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="PLAYING WITH DATA TREES">Playing with data trees</H4>
<A HREF="#PLAYING WITH DATA OBJECTS"><SMALL>Back to </SMALL>Playing with Data Objects</A><BR><A HREF="#FUNCTIONS"><SMALL>Forward to </SMALL>Functions</A><BR><BR><BR>



<P>Since jot allows buffers to dangle off the hashtables of other buffers, there exists the possibility of creating huge trees of unlimited complexity. Well that's probably not a good plan, but there's a lot to be said for building relatively modest trees.</P>

<P>In order to facilitate navigation around such trees there's a path-descriptor syntax that can divine any data point in trees of any complexity. Given that the starting point is always a single (frequently but not necessarily alpha) character and the remaining path elements, each separated by some system-defined character. The path-specification syntax being: &#091;&#060;bufferKey&#062;&#093;=&#060;pathElem1&#062;&#091;|&#060;PathElem2&#062;&#091; ... &#093;&#093;</P>

<UL><P><LI>bufKey - the single-character buffer-ID which identifies the root buffer (a-z, 0-9, !"$%&*,.:;@#...)</P></LI>

<P><LI>Each pathElem is the name of a data object in the hashtable of some intermediate buffer.</P></LI>

</UL><P>The hashtables are created one at a time. in this example we're creating three levels of hierarchy - "Top", "Mid" and "Bot" dangling off the top-level buffer Q:</P>

&#062; %h=create 100;
<P>This creates a hashtable big enough for at least 100 entries in buffer Q.</P>

<P>Next, we have to create the hashtable entry "Top" in our freshly-minted hashtable:</P>

&#062; %h=data q=Top;
<P>Then we have to set up a dummy buffer for the next level:</P>

&#062; %d~=Top dummy; ov/q=Top/
<P>Set up the next-level buffer and create a new hashtable there:</P>

&#062; %h=create 100 q=Top; %h=data q=Top|Mid; %d~=Mid dummy; ov/q=Top|Mid/ 
<P>Finally create the bottom level:</P>

&#062; %h=create 100 q=Top|Mid; %h=data q=Top|Mid|Bot; %d~=Bot dummy; ov/q=Top|Mid|Bot/ 
<P>Then, if we want to do hashtable operations here, it had better have a hashtable:</P>

&#062; %h=create 100 q=Top|Mid|Bot;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="FUNCTIONS">Functions</H3>
<A HREF="#PLAYING WITH DATA TREES"><SMALL>Back to </SMALL>Playing with data trees</A><BR><A HREF="#WORKING WITH IDE.JOT"><SMALL>Forward to </SMALL>Working with ide.jot</A><BR><BR><BR>



<P>Jot uses hash tables to implement function calls. By convention, function names appear at the head of the routine code, enclosed by double angle brackets:</P>

&#060;&#060;MyRoutine&#062;&#062;
<PRE>
%%This routine just says hello world and exits.
%m=Hello world.
</PRE>
<P>These are held in a buffer known as a repository, by convention this is the ( ' ) buffer - but any other will work. A hashtable target-point tag is added to the end of the function-name line. This tag is important for two reasons:</P>

<UL><P><LI>Any <A HREF="jot_tech.html#HASHTABLE CALL">hashtable call</A> to use the tag to find the the function start.</P></LI>

<P><LI>Less obviously there is no explicit code element marking the end of a function. Historically macrocommands and scripts terminate at the end of the macro's buffer or the scripts EOF. In code-repository functions, the function end is indicated by the tag belonging to the next function.</P></LI>

</UL><P>There is a special function, provided by the normal startup script, that registers and tags new functions - it's &#060;&#060;AddNewFunctions&#062;&#062;. This function copies one or more functions from the ( @ ) buffer and registers them in the code-repository buffer ( ' ). We're going to do this for &#060;&#060;MyRoutine&#062;&#062;:</P>

&#062; %G@
&#062; &#060;&#060;MyRoutine&#062;&#062;
&#062; %%This routine just says hello world and exits.
&#062; %m=Hello world.
&#062; :
&#062; %h'=call AddNewFunctions;
<P>Now call the routine:</P>

&#062; %h'=call MyRoutine;
<P>It sends the message "Hello world" to the console.</P>

<P>Note there is no "return" or similar command - control must be allowed to trickle down to the end of the routine.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="WORKING WITH IDE.JOT">Working with ide.jot</H3>
<A HREF="#FUNCTIONS"><SMALL>Back to </SMALL>Functions</A><BR><A HREF="#THE HELLO PROJECT"><SMALL>Forward to </SMALL>The hello project</A><BR><BR><BR>



<P><A HREF="jot_coms.html#IDE.JOT">ide.jot</A> is a simple IDE for gdb and winedbg. It can support projects with a single source file or it may be combined with <A HREF="jot_coms.html#CTAGS.JOT">ctags.jot</A> to support projects with source libraries indexed with ctags.</P>

<P>There is a demonstration development tree at $&#123;JOT_RESOURCES&#125;/IDE, this contains two subdirectories - work, which contains various project files and a startup.jot and a directory ed which contains only a hello.c source file - guess what this does.</P>

<P>The ide.jot file is run from the startup script, it sets up a simple menu bar containing the following buttons:</P>

<UL><P><LI>File - pops up a submenu</P></LI>

<P><LI>Save - writes the source file.</P></LI>

<P><LI>Compile - runs the compiler.</P></LI>

<P><LI>Run - runs the executable as a subprocess.</P></LI>

<P><LI>dbg_start - fires up a gdb/winedbg session.</P></LI>

<P><LI>dbg_run - gives gdb/winedbg the "run" command.</P></LI>

<P><LI>dbg_continue - gives gdb/winedbg the "continue" command.</P></LI>

<P><LI>dbg_quit - quits gdb/winedbg using the "quit" command.</P></LI>

<P><LI>dbg_break - sets a breakpoint at the current line in the source file.</P></LI>

<P><LI>dbg_command - prompts for a gdb/winedbg command and passes it back to the gdb session.</P></LI>

<P>First copy the projects tree from the resources to somewhere convenient to you.</P>

<PRE>
$ cp -R $&#123;JOT_RESOURCES&#125;/ide .
</PRE>

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="THE HELLO PROJECT">The hello project</H4>
<A HREF="#WORKING WITH IDE.JOT"><SMALL>Back to </SMALL>Working with ide.jot</A><BR><A HREF="#THE IDE_HELLO PROJECT"><SMALL>Forward to </SMALL>The ide_hello project</A><BR><BR><BR>




</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="THE IDE_HELLO PROJECT">The ide_hello project</H4>
<A HREF="#THE HELLO PROJECT"><SMALL>Back to </SMALL>The hello project</A><BR><A HREF="#THE TREE PROJECT"><SMALL>Forward to </SMALL>The tree project</A><BR><BR><BR>



<P>The startup file re-reads your project notes into buffer ( S ) and reads just one more file - the source code, and parks it in buffer ( . ).</P>

<P>You can compile it with gcc or use the Makefile.</P>

<P>Fire up a jot session using the ide_hello-project setup:</P>

<PRE>
$ cd projects
$ jot ide_hello
</PRE>

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="THE TREE PROJECT">The tree project</H4>
<A HREF="#THE IDE_HELLO PROJECT"><SMALL>Back to </SMALL>The ide_hello project</A><BR><A HREF="#THE NCURSES PROJECT"><SMALL>Forward to </SMALL>The ncurses project</A><BR><BR><BR>



<P>This is a simple IDE example of a source tree using an ctags-generated index file. If you've not already done so, copy the example projects tree - see <A HREF="#THE HELLO PROJECT">The hello project</A></P>

<PRE>
$ cd ide/tree
$ ctags -R *
$ cd ../projects
$ jot ide_tree
</PRE>
<P>The startup script in buffer ( F ) contains pathnames which may need adjustment.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="THE NCURSES PROJECT">The ncurses project</H4>
<A HREF="#THE TREE PROJECT"><SMALL>Back to </SMALL>The tree project</A><BR><A HREF="#THE JOT PROJECT"><SMALL>Forward to </SMALL>The jot project</A><BR><BR><BR>



<P>This IDE project uses a real code project - ncurses.</P>

<P>If you've not already done so, copy the example projects tree - see <A HREF="#THE HELLO PROJECT">The hello project</A>.</P>

<P>First cd to the ncurses directory then download and unpack an ncurses-4.2 (although any version will probably do). Note that <A HREF="jot_coms.html#CTAGS.JOT">ctags.jot</A> must find the tags file in the ncurses root directory and that it requires the pathnames to be absolute.</P>

<PRE>
$ cd &#060;path&#062;/ncurses-4.2
$ ctags -R `pwd`/*
</PRE>
<P>Now edit the startup.jot file - in the tags_curses project find the line:</P>

<UL><P>%i.=/home/jone/Downloads/ncurses-4.2/tags</P>

</UL><P>change the pathname to match your installation.</P>

<PRE>
$ jot ide_curses
</PRE>
<P>Pull the file containing, say, the MyMenu function.</P>

&#062; MyMenu&#123;Esc 7&#125;

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="THE JOT PROJECT">The jot project</H4>
<A HREF="#THE NCURSES PROJECT"><SMALL>Back to </SMALL>The ncurses project</A><BR><A HREF="#THE DEBUGGER"><SMALL>Forward to </SMALL>The debugger</A><BR><BR><BR>



<P>This sets up the editor for jot-code development. This requires a copy of the jot source code in ed/source - If you've not already done so, copy the example projects tree - see <A HREF="#THE HELLO PROJECT">The hello project</A>. </P>

<P>The startup.jot reads several files into various buffers in the jot session, where they are easily accessible using the <A HREF="jot_tech.html#Z">Z</A> command.</P>

<UL><P><LI>. - $&#123;JOT_HOME&#125;/source/jot.c - The jot source file </P></LI>

<P><LI>o - A write-locked copy of the original source file. </P></LI>

<P><LI>d - $&#123;JOT_HOME&#125;/docs/jot_ug.txt - The jot user guide. </P></LI>

<P><LI>t - $&#123;JOT_HOME&#125;/docs/jot_tech.txt - The jot technical guide. </P></LI>

<P><LI>g - $&#123;JOT_HOME&#125;/docs/jot_walkthrough.txt - The walkthrough training course. </P></LI>

<P><LI>h - $&#123;JOT_HOME&#125;/docs/jot_qr.txt - The jot quick-reference document. </P></LI>

<P><LI>c - $&#123;JOT_HOME&#125;/docs/jot_coms.txt - Guide to some of the more important jot scripts. </P></LI>

<P><LI>v - $&#123;JOT_HOME&#125;/docs/index.txt - The plaintext source for the jot web-page. </P></LI>

<P><LI>b - $&#123;JOT_HOME&#125;/docs/jot_eval.txt - Evaluation of jot against other popular editors. </P></LI>

<P><LI>r - $&#123;JOT_HOME&#125;/READMEs/releasenote.txt - The draft releasenote for the next version. </P></LI>

<P><LI>e - %&#123;JOT_HOME&#125;/coms/test.jot - The basic test script. </P></LI>

<P><LI>z - %&#123;JOT_HOME&#125;/coms/startup.jot - The standard startup script. </P></LI>

<P><LI>x - %&#123;JOT_HOME&#125;/coms/&#060;arch&#062;_keys.jot - The key-map file for your host. </P></LI>



</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H2><P><A NAME="THE DEBUGGER">The debugger</H2>
<A HREF="#THE JOT PROJECT"><SMALL>Back to </SMALL>The jot project</A><BR><A HREF="#ADDING AN EXPLICIT BREAK-POINT TO A MACRO"><SMALL>Forward to </SMALL>Adding an explicit break-point to a macro</A><BR><BR><BR>



<P>Below is a broken version of that little profiling macro from an earlier section:</P>

&#062; %g3
<PRE>
%%Copy text to @ and change all alphas to lower case.
m-0n.m0r0a@&z@ m-0(q/A-Z/c, r, m)0 
</PRE>
<PRE>
%%Place each word on a separate line then sort them alphabetically.
m-0(q/a-z/(q//r)0b, rr-(q/a-z/\e)0, j)0     
%b=sort
</PRE>
<PRE>
%%Finally, count up instances of each word 
%%m-0 (r\j)0 r-0(n.r0a$&ol1m(v'$r0v-'$o~k)0 m-oo/%5d - /m)0
m-0 (r\j)0 r-0(n.r0a$&ol1m(v'$r0v-'$o~k)0 m-oo/%5d - /m, m-0)0
:
</PRE>
<P>The difference is this one runs for much longer and then exits with a stack overflow message:</P>

&#062; '3
<PRE>
...
</PRE>
&#123;Stack overflow (line 9 of buffer 3)&#125;m-0 (r\j)0 l0(n.r0a$&&#091;ol1&#093;m(v'$r0v-'$o~k)0 m-oo/%5d - /m, m-0)0
<P>(The highlighting in the message has been replaced with square brackets)</P>

<P>Oh dear, it looks serious - how are we going to fix this? First we might find it useful to know which line it's failing on. Well that's easy the message says line 9. We can also see that the failing command was trying to load a zero on the stack but that's not the command that's giving us grief. As usual the error message points to the smoke not the fire.</P>

<P>We can see at a glance that that the problem is the addition of ", m-0" at the end of the final loop. This means the loop will *never* exit since m-0 is guaranteed never to fail.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="ADDING AN EXPLICIT BREAK-POINT TO A MACRO">Adding an explicit break-point to a macro</H3>
<A HREF="#THE DEBUGGER"><SMALL>Back to </SMALL>The debugger</A><BR><A HREF="#SETTING THE COMMAND COUNTER"><SMALL>Forward to </SMALL>Setting the command counter</A><BR><BR><BR>



<P>To see what's going on in a complicated command sequence, you could do worse than single-step them in <A HREF="jot_tech.html#THE JOT DEBUGGER">the jot debugger</A>. This can be set to single-step through the commands as you hit the &#123;Return&#125; button.</P>

<P>When you run your command sequence, the debugger halts at every jot command, dumps the contents of the stack and prints the current record, in the console area. When it reaches a break point it prompts with this string:</P>

<PRE>
Debug Command&#062; 
</PRE>
<P>To continue running normally, we have to set the trace vector back to zero.</P>

<PRE>
Debug Command&#062; %s=trace 0
</PRE>
<P>Which lets it run on to the next explicit t command.</P>

<P>To avoid typing all that in every time, there's a hotkey set up by the startup script:</P>

<PRE>
Debug Command&#062; &#123;Esc q&#125;
</PRE>
<P>To exit the debugger hit &#123;Ctrl+c&#125; at the debugger prompt.</P>

<P>To see all of the trace text you may find it helpful to reduce the window size so that more of the screen is dedicated to the console display (assuming your terminal is 40 lines or more):</P>

&#062; %w; %w 20; %w 0
<P>This changes your window size to just 20 lines, for a 40-line xterm the startup script sets the window size to 36 lines, with a one-line terminator. Leaving just 3 lines in the console area. After this hit return a few times to see the effect of the new window setting.</P>

<P>First go to the start of the Richard III sample an type t, or insert a t command into your command sequence:</P>

&#062; zq m-0 o@ t
<P>Now hit &#123;Shift+RightArrow&#125; - this is a complicated function because it has to deal with tabular and normal text.</P>

<P>Hit &#123;Return&#125; a few times while looking at what's going on in the console area - you will see it plodding through the commands of the &#060;&#060;<A HREF="jot_ug.html#WORDRIGHT">WordRight</A>&#062;&#062; function and displaying the stack and the current line at each step.</P>


</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="SETTING THE COMMAND COUNTER">Setting the command counter</H3>
<A HREF="#ADDING AN EXPLICIT BREAK-POINT TO A MACRO"><SMALL>Back to </SMALL>Adding an explicit break-point to a macro</A><BR><A HREF="#BACKTRACING"><SMALL>Forward to </SMALL>Backtracing</A><BR><BR><BR>



<P>Now, when debugging a long complicated macro or script, it may be more useful delay the trigger until we're getting close to the point where it goes wrong. This is the definition of a macro similar to one we've already looked at in the macros section:</P>

<P>Well, the problem is probably somewhere in the loop - lets start off by putting an explicit breakpoint in it:</P>

&#062; z3m+9f/n.r0/i/t /
<P>Line nine of the macro should now look like this:</P>

<PRE>
m-0 (r\j)0 l0(t n.r0a$&ol1m(v'$r0v-'$o~k)0 m-oo/%5d - /m, m-0)0
</PRE>
<P>So, re-spin it (first reset the stack):</P>

&#062;o@ z.'3
<P>After hitting &#123;Return&#125; a few (hundred) times we we don't seem to be getting very far. So let's try delaying the explicit debug call by a few zillion and restart it. But first we've got to get out of this &#123;Ctrl+c&#125; will do that:</P>

&#062; %s=tracecounter 1000000
&#062; o@ z. '3
<P>It crashed again but we can now find out how many times it went past the t command by looking at the current value in the trace counter:</P>

&#062; %qa=system
<P>Will tell us where the trace counter got to - 946974 in this case. Some arithmetic will extract the number we want in the trace counter. This sequence will work it out for us - note the new value (53026) we will need this if ever we re-run the debugger with this setup:</P>

&#062; o@ %qa=system; f/Trace counter = /-oid ol1000000 o- ol0 os o- %s=tracecounter '~
<PRE>
Trace counter was 946974, now set to 53026
</PRE>
<P>Re-spin it and it reaches a breakpoint at the start of the fatal iteration.</P>

&#062; o@ z. '3

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H3><P><A NAME="BACKTRACING">Backtracing</H3>
<A HREF="#SETTING THE COMMAND COUNTER"><SMALL>Back to </SMALL>Setting the command counter</A><BR><A HREF="#LINE 1 OF MACRO C"><SMALL>Forward to </SMALL>Line 1 of macro C</A><BR><BR><BR>



<P>Backtrace reports can be useful when diagnosing problems and can be used to show the call stack when debugging a script or macro command.</P>

<P>The problem with backtracing is that failures occur hundreds of times in the operation of a normal jot macro command, the interesting one is the one that unexpectedly causes the entire macro to fail.</P>

<P>Fire up a jot session with a bigger than usual console area:</P>

<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/l99.t -in="%w; %w 15; %w 0;"
</PRE>
<P>Backtracing is turned on with the Trace_Backtrace bit of the trace-mode bitmask. Try turning it on for a while and see what happens:</P>

&#062; %s=trace 7804;
<P>That's turned on backtracing along with:</P>

<UL><P><LI>Trace_Source - shows the line of source code at each trace point,</P></LI>

<P><LI>Trace_Print - prints the current line of the current buffer at each trace point and</P></LI>

<P><LI>Trace_Stack - does a stack dump at each trace point.</P></LI>

</UL><P>It has selected only Trace_Failures as a trace point - this triggers the specified trace activity (Trace_Source, Trace_Print, Trace_Stack and Trace_Backtrace) immediately after any command fails.</P>

<P>Now set up a few simple macros - notice macro c is pretty-much guaranteed to result in a failure:</P>

&#062; %da=r-0rr-rr-rr-rr-'brr-rr-rr-rr-rr-;
&#062; %db=rr-rr-'crr-rr-
&#062; %dc=rr- p r999rr-
&#062; 'a  
<P>In the console area, along with lots of other chatter, you should see something like this:</P>

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="LINE 1 OF MACRO C">Line 1 of macro C</H4>
<A HREF="#BACKTRACING"><SMALL>Back to </SMALL>Backtracing</A><BR><A HREF="#LINE 1 OF MACRO B"><SMALL>Forward to </SMALL>Line 1 of macro B</A><BR><BR><BR>



<P>rr- p &#091;r999&#093;rr-</P>

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="LINE 1 OF MACRO B">Line 1 of macro B</H4>
<A HREF="#LINE 1 OF MACRO C"><SMALL>Back to </SMALL>Line 1 of macro C</A><BR><A HREF="#LINE 1 OF MACRO A"><SMALL>Forward to </SMALL>Line 1 of macro A</A><BR><BR><BR>



<P>rr-rr-&#091;'c&#093;rr-rr-</P>

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="LINE 1 OF MACRO A">Line 1 of macro A</H4>
<A HREF="#LINE 1 OF MACRO B"><SMALL>Back to </SMALL>Line 1 of macro B</A><BR><A HREF="#LINE 21 OF CONSOLE C"><SMALL>Forward to </SMALL>Line 21 of console c</A><BR><BR><BR>



<P>r-0rr-rr-rr-rr-&#091;'b&#093;rr-rr-rr-rr-rr-</P>

</UL><IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<H4><P><A NAME="LINE 21 OF CONSOLE C">Line 21 of console c</H4>
<P>&#091;'a&#093;</P>

<P>The top line, as is the convention with backtracing, is the line of code and call frame nearest to the error, the next one down shows how that code object was called ... etc.</P>

<P>The top line tells us that it was the r999 command that was the culprit - well no surprises there. </P>

<P>The 2nd. line down says the macro in buffer ( C ) was called by a macro in buffer ( B ).</P>

<P>...</P>
<A HREF="#LINE 1 OF MACRO A"><SMALL>Back to </SMALL>Line 1 of macro A</A><BR><BR><BR><BR>


<IMG SRC="Made"><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
