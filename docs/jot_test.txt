

1 JOT Tests
-----------
  This document describes the pre-release tests used to verify a  new  version
  of jot. These are regression tests - they cannot prove that a version of jot
  is correct, they just test for regressions in specific areas.
  
  Typically, a new version of jot  will  be  assigned  the  name  jot_dev  (or
  jot_dev.exe for a windows version).

1.1 test.jot
------------
$ ./jot_dev ${JOT_RESOURCES}/t.t -in=%r=test  
  
  This runs basic regression tests on all jot commands and  command  variants.
  It is totally autonomous and, on completion, should display the message
    "Successfully completed all tests"

1.2 test_visual.jot
-------------------
$ ./jot_dev t.t -in=%r=test_visual
  
  This runs a series of tests designed to detect any regression in the way  it
  drives the screen. In olden times this was literally a  visual  test  -  the
  intrepid tester had to sit and check each several dozen screenshots to  make
  sure  nothing  was  going  wrong.  These  days,  though,   it's   all   done
  automatically using the `query window` command.

1.3 monkey_test.jot
-------------------
$ ./jot_dev t.t -in='n.a$z$i"%% -tests=100000 -exit" %r=monkey_test'
  
  This constructs test  scripts  containing  thousands  of  randomly-generated
  valid but meaningless commands. These are designed to detect any crashyness.
  As one script completes  successfully  it  constructs  a  new  one  using  a
  different random sequence of commands. 
  
  The monkey_test.jot script can also be set up to  generate  smaller  scripts
  of, maybe only a few hundred commands, for  checking  with  valgrind  -  see
  http:\\valgrind.org for details.
  
  At the start of day, it resets the pseudorandom generator using the  current
  date-time stamp, the value of this seed is reflected  in  the  name  of  the
  generated script. To regenerate a script it is possible to force it to  take
  a predefined seed with the -seed=N modifier.
  
  The monkey_test-generated scripts can be very large -  shorter  scripts  are
  less effective since  they  are  less  likely  to  contain  combinations  of
  commands that might trigger some hidden data sensitivity.  To  identify  the
  commands actively provoking the crash there is a  script  `error_search.jot`
  that does a binary search of the script, typically boiling  it  down  to  10
  lines or less. However searching very large scripts is impracticable due  to
  the enormous search times - about 10000 tests per script is  a  pretty  good
  compromise.
  
  Valid monkey_test.jot qualifiers.
    -seed=<value>       
      uses the predefined seed (by default, it  constructs  one  from  current
      time) exits after completing the new script.
    -script=<pathName>  
      runs the preexisting command script and exits on completion.
    -tests=<n>          
      specifies number of tests to be generated in each test script - defaults
      to 10000.
    -trace=<x>          
      specifies trace mode (in hex) at start of test run, defaults to 6002.
    -head="<commands>"  
      specifies a command sequence to be applied after normal initialization.
    -tail="<commands>"  
      specifies a command sequence to be  applied  before  normal  test-script
      exit.
    -subprocess         
      Launches test in a subprocess
    -commandcounter=n   
      Inserts a command to set the command counter before launching script  in
      the subprocess.
    -noloop             
      exits after first test script (-noloop is implicit with  -script=...  or
      -seed=... options.
    -label              
      Labels each command line with %%Line <lineNo>
    -pause              
      enters debugger on completion of each pass.
    -nowin              
      Suppresses window view.
    -subprocess
      Launches test in a subprocess
    -xterm
      Launches test in an xterm
    -subprocess
      Launches test in a subprocess
    -gdb
      Launches test in a subprocess supervised by gdb
    -valgrind
      Launches test in a subprocess supervised by valgrind

1.4 error_search.jot
--------------------
$ jot ${JOT_RESOURCES}/l99.t -in="%r=error_search [-gdb|-valgrind|-xterm]
    [ -failif=<jotCommands>]
      -script=<scriptPath1>[ +<scriptPath2>[ +...]]"
  
  When a script generated by monkey_test.jot fails - either it's  crashed  or,
  when used with valgrind, it's done something  naughty  but  not  immediately
  fatal, revealing a data sensitive bug. By analysing the generated script  we
  might be able to spot what's going on, maybe  with  the  aid  of  gdb  or  a
  similar debugger.
  
  By default, the test sessions are  launched  as  a  simple  subprocess,  the
  -xterm qualifier launches it in an xterm so you can keep an  eye  on  what's
  happening, the -gdb qualifier launches the test monitored by gdb session and
  -valgrind monitors with valgrind.
  
  The error_search script detects that it misbehaved by  searching  the  reply
  from the child process. You can specify a  different  failure  criterion  by
  specifing your own comparator commands in the -failif modifier.
  
  Often it's not that obvious what's going on and it would be useful  to  know
  exactly which commands are trigger the error.  Now,  it's  trivial  to  find
  which was the last command before it crashed but, several  earlier  commands
  were involved in creating the conditions for the crash. Normally, it's  less
  than a dozen or so commands out of the  many  thousands  of  randomly-chosen
  commands. The error_search.jot script performs a binary search, slicing down
  the generated script and repeating with progressively smaller slices,  until
  it finds the minimum required to provoke the error.
  
  Demonstration of error_search
    - First generate a script with a randomly-placed error, the -crash  option
      is only used to generate a crashing script for this purpose:
$ jot t.t -st -ini="%r=monkey_test -crash -tests=1000 -seed=1234567890"
    - Now search the script for line(s) causing the crash:
$ jot t.t -in="%r=error_search -gdb -script=test1234567890.jot"
    - This should generate the script test1234567890.jot_pruned -  a  copy  of
      your original script containing only the lines contribution to the error
      condition - in this case just the line inserted by the -crash option  to
      monkey_test:
o@ol123 oo/%n/   %%Crash now.
  
  Typical usage:
$ ./jot t.t -in="%r=error_search -valgrind -script=./test108110917.jot"
  The  error_search.jot  script  runs  your  test   script   (in   this   case
  test108110917.jot) and,  if  the  full  script  results  in  valgrind  error
  reports, the script is whittled down to the minimum  set  of  commands  that
  still results in valgrind errors.

1.6 test.sh
-----------
$ ./test.sh
  
  Some simple tests for the linux version in simulated real-life situations.
  
  - Test 1 - `test.jot`   
  
  - Test 2 - Streaming out to stdout
  
  - Test 3 - Accepting input from stdin stream - in -tty mode.
  
  - Test 3a - Accepting input from stdin stream - in non-tty mode.
  
  - Test 4 - Accepting input from stream and piping to stdout - in -tty mode.
  
  - Test 5 - Read from command, -tty mode
  
  - Test 5a - Read from command - in non-tty mode.
  
  - Test 6 - Filter mode -tty mode
  
  - Test 6a - Filter mode - in non-tty mode
  
  - Test 7 - streamed-in commands -tty mode
  
  - Test 7a - streamed-in commands - in non-tty mode
  
  - Test 8 - journal-keeping and recovery
  
  - Test 9 - -asConsole
  
  - Test 10 - get.jot -  tests  the  get.jot  script  in  the  most  important
    configurations.

1.7 test.bat
------------
  This runs tests similar to `test.sh` but in order to sidestep some  problems
  with wine, the tests are set up and results compared by the  calling  script
  (either `test_win.sh` or `test_win.bat`).
  
  Note that this script does not run directly from a wine or windows console -
  it is called by either `test_win.bat` (wine/windows) or `test_win.sh`  (from
  linux, using a wine console).

1.8 test_win.sh
---------------
$ test_win.sh
  
  This runs the windows version of the command-line test script `test.bat` but
  from a linux command line, using a wine console.

1.9 test_win.bat
----------------
$ test_win
  
  This runs the windows version of the command-line test script `test.bat` 
  from a windows (or wine) console.

