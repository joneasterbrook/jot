<! Made with jot using doc2html >
<link rel="stylesheet" href="main.css" type="text/css">


</UL><H2><A NAME="JOT USER GUIDE">JOT User Guide</H2>
<P>This is a guide aimed at those who just want to find out how to use an editor that works. A more detailed technical guide can be found at <A HREF="jot_tech.html#JOT TECHNICAL GUIDE">jot technical guide</A> or, for real-life examples, there's <A HREF="jot_walkthrough.html#JOT WALKTHROUGH">jot walkthrough</A>.</P>

</UL><H3><A NAME="DESCRIPTION OF THE EDITOR">Description of the Editor</H3>
<P>Jot is a command-driven text editor with a modern viewer and a simple concise language.</P>


</UL><H3><A NAME="BACKSTORY">Backstory</H3>
<P>The jot editor owes much to the Edinburgh Compatible Context Editor (ECCE). ECCE was designed back in the days of teletypwriters and consequently has a somewhat old-fashioned look and feel compared to editors designed for modern video terminals.</P>

<P>What ECCE does have is a terse, easy and, above all, powerful command language. This language forms the basis of jot - see the <A HREF="jot_tech.html#JOT PROGRAMMING">Jot Programming</A> section for details.</P>


</UL><H3><A NAME="WHAT IS A TEXT EDITOR AND WHY DO I NEED ONE?">What is a text editor and why do I need one?</H3>
<P>Modern computers have a filing system holding a great many files. Many of these files are binaries - meaningful to the computer but incomprehensible gobbledygook to you and me but many files are plain text. This is because someone has decided that, although it would have been easier to write this information in some sort of binary code, it would help if we humans could also read them and try to make sense of them and, in some cases, rectify any incorrect assumptions.</P>

<P>Many windows users have encountered notepad - this an editor with a simple command structure that can search for a substring, substitute some other substring, to do a global search & replace and, er, that's about it. Often we have an enormous file with thousands of simple substring matches but only a minority match some wider context specification. We've either got to manually wade through thousands of potential matches or switch to an editor with better context-matching.</P>

<P>A text editor is an essential tool for altering (i.e. editing) these plain text files and a good one can be very helpful for viewing and analysing their inner meaning. Note that the text on the screen (and in the editors memory) is just an image of the text file. During an editing session the original file usually remains unchanged until you decide to save your edited version.</P>

<P>A common feature of all modern editors is that they display text in a window on the computer screen with a cursor showing the current focus. They also obey simple instructions to alter the text and to change the focus in the text - typically with the cursor-control keys (Up, Down Left, Right, Page Up and Page Down). They can search the text for specified combinations of characters (strings), insert new text strings, erase and substitute strings.</P>


</UL><H3><A NAME="ABOUT THE CURRENT CHARACTER AND SUBSTRINGS">About the current character and substrings</H3>
<P>The editor places a special marker, the cursor, in the text to indicate it's current focus. This is the point where text might be inserted or the start point for searches.</P>

<P>On completion of a successful find, verify, substitution or insertion (see <A HREF="jot_tech.html#F">F</A>, <A HREF="jot_tech.html#V">V</A>, <A HREF="jot_tech.html#S">S</A> and <A HREF="jot_tech.html#I">I</A> commands). The relevant substring is highlighted on the screen and, internally, some special pointers are set up). Some subsequent substitute command can then replace the currently-selected substring with some new substring - see also <A HREF="jot_tech.html#%U">%U</A>. Also the selected substring can be set by the <A HREF="jot_tech.html#OU">ou</A> stack operation.</P>

<P>Any command that involves moving the current character pointer will remove this highlighting and reset the internal pointers.</P>

<P>The current-character cursor is displayed in reverse video. This cursor reflects the state of internal current-record and current-character pointer. This is allowed to go one character position past the end of the line. At this point there is no character to highlight. When this happens, a tilde ( ~ ) is displayed at the end of lines to indicate this situation. </P>

<P>Some may wonder why the cursor is allowed to go past the end of the real text. Well fear not, it's all been thought about. By allowing the cursor to go past the line end, jot avoids the necessity for special flavours of commands operating at and after the current character. Eg. jot has only one insert command ( <A HREF="jot_tech.html#I">I</A> ) which inserts before the current character and there's no need for a magic mode or another command to insert after the current character.</P>

<P>When a substring has been selected (e.g. by a find command) the substring and the substring is displayed with underscores with the current character in reverse video. Of the commands which define a substring, some leave the cursor at the start of the substring (e.g. find - see <A HREF="jot_tech.html#F">F</A>) others leave it at the end. For these commands the current character is the character immediately following the substring (e.g. traverse <A HREF="jot_tech.html#T">T</A> and insert <A HREF="jot_tech.html#I">I</A>).</P>

<P>In tty mode (see <A HREF="jot_tech.html#-TTY">-tty</A>) The current line is printed and below it the carat character ( ^ ) indicates the current character, and tildes ( ~ ) indicate the currently-selected substring.</P>


</UL><H3><A NAME="COMMAND-MODE VS. INSERT MODE">Command-mode vs. insert mode</H3>
<P>Jot is essentially a command-driven editor. In other words, you give it a command and a parameter and it does something to your text. You might, for example give it the command to insert text, by typing something in or pressing some button, and the parameter would be the text you want inserting.</P>

<P>Maybe typing-to-screen is OK for capturing a brain dump - when the task involves searching and doing several fiddly tweaks to the content of a text-file image then you will need to exiting and re-entering the screen mode to enter whatever search or command parameters are required. This is a real drag most of of the time and can be a right-royal pain at others. Nevertheless, jot does offer a fully-functional insert-mode environment.</P>

<P>In it's command mode, all native jot commands as well as jot editing functions are available for use - jot functions are little bits of jot code attached to function keys etc. Typically, to invoke a function:</P>

<UL><P><LI>First type in the parameter to the console area (if any) then</P></LI>

<P><LI>hit the function hotkey.</P></LI>

</UL><P>Jot also has a direct insert mode which also allows jot functions but not native jot commands. Also arrangements or passing parameters are different - see <A HREF="jot_tech.html#ABOUT COMMAND PARAMETERS">about command parameters</A>. In the insert mode, any typed-in text goes directly to the screen but to invoke editor functions the process is as follows:</P>

<UL><P><LI>hit the function key,</P></LI>

<P><LI>type in the parameter then</P></LI>

<P><LI>hit return.</P></LI>

</UL><P>This is not the way most modern editors and word-processors work. You will probably be accustomed to always typing directly to the text and occasionally invoking editor functions via function keys and menus below the banner bar. Typically there will be a strictly-defined set of functions that *only* work in command mode and another set that *only* work in screen-entry mode.</P>


</UL><H3><A NAME="ABOUT HELP">About help</H3>
<P>The jot help system is based on fold marks - a sequence of three open braces ( &#123; ) at the start of a line is a fold start, a sequence of three close braces ( &#125; ) is a fold-end mark. Folds can be nested to any level.</P>

<P>Another type of fold mark is the file-fold mark - these take the following form:</P>

&#091;&#060;pathstub&#062;&#093;&#060;filename&#062;
<P>The pathstub is a subpath in the filing system starting at the path of the current file fold (typically $&#123;JOT_RESOURCES&#125;/help/... ) and the file &#060;filename&#062;.hlp must exist in this directory. When opened the file is merged into the help repository.</P>

<P>The &#060;&#060;Help&#062;&#062; function (normally attached to &#123;F1&#125;) looks at the current line in the display.</P>

<UL><P><LI>If the current line begins with an open-fold mark '&#123;&#123;&#123;' it uses the current line as a key and searches the help repository buffer ( : ) for a matching entry. It copies the entry to the help view buffer ( ; ) for viewing.</P></LI>

<P><LI>If the current record does not have a fold mark but the current buffer is the help viewing buffer ( ; ) then the Help function exits the current fold, returning to the parent fold.</P></LI>

<P><LI>If the current record contains a file-fold mark ( &#091;&#060;subpath&#062;&#093; at the beginning of the line) and the current buffer is the help viewing buffer ( ; ) then the file is opened and it's contents added to the help repository buffer ( : ).</P></LI>

<P><LI>In all other cases the Help function will open the top-level help entry.</P></LI>

<P>For details about the format and construction of help files see <A HREF="jot_tech.html#ABOUT HELP FILES">About help files</A>.</P>


</UL><H3><A NAME="ABOUT COMMAND EDITING">About command editing</H3>
<P>Jot is a command-driven text editor so, since it is probably most used for editing scripts in the command language for other text-driven computer applications, it should be pretty good at editing it's own command language right? Er ... well maybe.</P>

<P>The problem is that it's not easy to define a syntax for commands to be used for editing the same commands for the same command console of the same system. Suppose, for example, we wanted to fix up the sort of CLI command-line editing we're all familiar with. Even limiting it's scope to just the four cursor-control keys the delete key reveals some pretty horrendous syntactic problems for a text editor editing the text requires the same cursor-control operations as the command-editing operations.</P>

<P>Jot gets over this by copying the current contents of the command console buffer into an editable buffer so that you can then correct and perfect your code to achieve your desired result. When you think you've got there, it copies the result of your labours back into the console buffer ready for you to try again.</P>

<P>The standard startup script defines two functions for command editing - <A HREF="#CMDEDITSTART">CmdEditStart</A> and <A HREF="#CMDEDITGO">CmdEditGo</A>.</P>

<P>CmdEditStart ( &#123;Esc c e&#125; ) acquires a list of recent commands and whatever you've been typing to the console area and displays this in a temporary buffer. In this view you can use normal editing functions to select and, if required, modify a command string.</P>

<P>When the selected command has been suitably modified, use <A HREF="#CMDEDITGO">CmdEditGo</A> ( &#123;Esc c g&#125; ) push your selected and edited command string back into the console buffer, ready for you to use in whatever way you fancy.</P>

<P>The editor maintains an internal history log containing the last few commands. By default this holds the last 20 commands but this limit can be changed with the <A HREF="jot_tech.html#-HISTORY">-history</A> CLI qualifier.</P>

<P>Note that the command history is viewed and edited in the ( ! ) buffer. Now one other function also uses the ( ! ) buffer - &#060;&#060;<A HREF="#ADDNEWFUNCTIONS">AddNewFunctions</A>&#062;&#062; hence you avoid using this function while editing commands. In practice this restriction should not prove overly burdensome since that function is only used by scripts to add new functions to the code repository.</P>


</UL><H3><A NAME="ABOUT NOT LOSING YOUR WORK">About not losing your work</H3>
<P>There are many and varied ways of mistakenly losing or corrupting work in an editing session - jot offers a few methods of making this a bit less easy to do:</P>

<UL><P><LI>Setting the buffer attribute writeifchanged (see <A HREF="jot_tech.html#%B=WRITEIFCHANGED">%b=writeifchanged</A>), if the buffer has been changed in any way the %c and %A commands will fail with a message telling you which buffers require writing. When an editing session has many active buffers it's not all that easy to remember which have been updated - this tells you. To unset this attribute use <A HREF="jot_tech.html#%B=UNRESTRICTED">%b=unrestricted</A>.</P></LI>

<P><LI>Setting the buffer attribute readonly (see <A HREF="jot_tech.html#%B=READONLY">%b=readonly</A>), if the file is only to be used as a reference - any attempt to change it will fail.</P></LI>

<P><LI>Request an optional journal file - this is part of the journal-recovery system and is designed to protect against power failures, flat batteries, crashes etc. (see <A HREF="jot_tech.html#ABOUT JOURNAL FILES">about journal files</A>)</P></LI>

</UL><P>Where one of the attribute-setting approaches is relevant, to insure this *always* gets done, add these commands to your project-area startup.jot file - see <A HREF="jot_tech.html#ABOUT PROJECT FILES">about project files</A>.</P>


</UL><H3><A NAME="ABOUT MULTI-WINDOW WORKING">About multi-window working</H3>
<P>Jot allows the usable screen area to be allocated to any number of areas known here as windows. The screen may be split horizontally or vertically to create displays of some complexity by repeatedly using the <A HREF="jot_tech.html#%W">%W</A> command. The range of window types available using functions defined in the startup script is more limited - a simple one-window display, screen split into any number of equal-sized horizontal strips or the screen split into any number of equal-sized vertical slices.</P>

<P>The <A HREF="#WINDOWONE">WindowOne</A> function gives a simple single-window display, the <A HREF="#WINDOWHORIZSPLIT">WindowHorizSplit</A> and <A HREF="#WINDOWVERTSPLIT">WindowVertSplit</A> will split the screen.</P>

<P>Various functions operate on specific windows eg: <A HREF="#PAGEUP">PageUp</A>, <A HREF="#PAGEDOWN">PageDown</A>, <A HREF="#WINDOWREASSIGN">WindowReassign</A>, <A HREF="#WINDOWSTRETCH">WindowStretch</A> and <A HREF="#WINDOWSHRINK">WindowShrink</A> - when there is more than one screen these functions need to identify the window to be adjusted.</P>

<P>Windows are allocated a window number - this number appears in <A HREF="jot_tech.html#QUERY WINDOW">query window</A> reports at the start of each window-description line. Alternatively, you can just count windows from 0, starting from the top-left of the screen working from left-to-right and then top-to-bottom.</P>


</UL><H3><A NAME="ABOUT JOT DEBUGGING">About jot debugging</H3>
<P>Jot supports a simple debugging environment. It is possible to display the current state of the stack, the current record and breakpoint on a number of predefined conditions - see <A HREF="jot_tech.html#THE JOT DEBUGGER">the jot debugger</A>, <A HREF="jot_tech.html#%S=TRACE">%S=trace</A> and <A HREF="jot_tech.html#%S=TRACEDEFAULT">%s=tracedefault</A>.</P>

<P>Typically, one might request a breakpoint, a stack dump and display of the current record at each trace point. With a trace point at every command or every new command line. It is also possible to put an explicit debugger request (the <A HREF="jot_tech.html#T">T</A> command) in the command string.</P>

<P>The debugger is controlled by the following commands:</P>

<UL><P><LI><A HREF="jot_tech.html#%S=TRACE">%s=trace</A> - redefines the trace vector with immediate effect.</P></LI>

<P><LI><A HREF="jot_tech.html#%S=TRACEDEFAULT">%s=tracedefault</A> - defines the trace vector to be set by <A HREF="jot_tech.html#T">T</A> commands, the command counter <A HREF="jot_tech.html#%S=COMMANDCOUNTER">%s=commandcounter</A> and (optionally - see below) a &#123;Ctrl+c&#125; interrupt.</P></LI>

<P><LI><A HREF="jot_tech.html#T">T</A> - An explicit debugger request a T command can be inserted at any point in a macro or directly in the command line, this changes the trace vector to the value defined by <A HREF="jot_tech.html#%S=TRACEDEFAULT">%s=tracedefault</A>. To exit the debug prompt loop, reset the trace vector with %s=trace 0, or &#123;Esc q&#125;.</P></LI>

<P><LI>The normal behaviour for &#123;Ctrl+c&#125; interrupts is to exit all macros and command files and return to the jot prompt. Setting Trace_Int (see <A HREF="jot_tech.html#%S=TRACE">%s=trace</A>) will cause it instead go to the interactive debugger. here you can single-step and use any valid jot commands to investigate what's going on. You exit this with the <A HREF="#QUITDEBUGGER">QuitDebugger</A> function. In order for Trace_Int to work properly you need to set this bit in both the trace-mode and the tracedefault-mode masks. e.g:</P></LI>

&#062; %s=trace 0020; %s=tracedefault F021;
<P><LI>Often, the explicit trace command is buried in a complicated loop and control structure which makes it necessary to continue many, possibly hundreds of times before reaching the iteration causing the problem. The %s=commandcounter command (see <A HREF="jot_tech.html#%S=COMMANDCOUNTER">%s=commandcounter</A>) sets the initial state of an internal counter which triggers a trace point when it reaches zero.</P></LI>

<P>The internal command counter is normally reset to zero as each new command line is read from the console. The counter is unsigned long long so it normally takes a very long time to reach zero again. The %s=commandcounter command automatically calculates the correct value to stop at the specified point. Note that, for the purposes of command counting, the block and logical constructs " ( ) , ? and \ " all count as commands.</P>

<P><LI>Changing the verbosity level (see <A HREF="jot_tech.html#%S=VERBOSE">%s=verbose</A>) may help - setting this to 2 causes more information about failures to be displayed. By default, it only displays the messages from the outermost failing block, level-2 verbosity displays all of them as it unwinds. e.g:</P></LI>

<PRE>
$ jot t.t -in="(ol123)1000"
</PRE>
&#123;-init sequence failed. (line 1 of buffer i)&#125; (ol123)1000
<P>Clearly it's a stack overflow that's the problem - but it's only reporting that the outer block failed - now try this:</P>

<PRE>
$ jot t.t -in="%s=verbose 2; (ol123)1000"
</PRE>
&#123;Stack overflow (line 1 of buffer i)&#125; %s=verbose 2; (ol123)1000
&#123;-init sequence failed. (line 1 of buffer i)&#125; %s=verbose 2; (ol123)1000
<P><LI>jot has a simple backtrace facility - see <A HREF="jot_tech.html#QUERY BACKTRACE">query backtrace</A>, <A HREF="jot_coms.html#BT.JOT">bt.jot</A> and also the notes on Trace_Backtrace in <A HREF="jot_tech.html#%S=TRACE">%s=trace</A>.</P></LI>


</UL><H3><A NAME="ABOUT BLOCK GRAPHICS">About block graphics</H3>
<P>Jot offers some limited support for the creation of simple line-drawing diagrams, flow-charts electrical schematics etc.</P>

<P>The support consists of functions for drawing horizontal, vertical and diagonal lines, some some cursor positioning functions specific to line drawings and a block move function.</P>

<P>If, while drawing, an attempt is made to go above the top or below the bottom boundary of the buffer or there is an attempt to draw past the end of a line then additional lines and/or whitespace is automatically added.</P>

<P>If the diagrams are to be part of a document to be processed by the <A HREF="jot_coms.html#DOC.JOT">doc.jot</A> family of scripts (<A HREF="jot_coms.html#DOC.JOT">doc.jot</A>, <A HREF="jot_coms.html#DOC2HTML.JOT">doc2html.jot</A>, <A HREF="jot_coms.html#DOC2FOLD.JOT">doc2fold.jot</A> and <A HREF="jot_coms.html#HTML2DOC.JOT">html2doc.jot</A>) then it is important that the first character of each line in the graphical section begins with any character other than an ascii space - an ASCII VT (tab) will do.</P>

<P>It attempts to tidy corners when shifting between horizontal and vertical lines and similarly with diagonals. Hence a series of &#060;&#060;LineE&#062;&#062; followed by a &#060;&#060;LineS&#062;&#062; will remove the last hyphen ( - ) and replace it with whitespace. Diagonals join up tidily without extra whitespace but the drawing functions adjust the cursor position as appropriate e.g:</P>

<PRE>
     ----      /\     \     ----                                  \
    |    |    /  \     \   |    |     \        /        /\          \
    |    |   /    \    /   |    |       \    /        /    \        /
     ---              /     ----          \/        /        \    /
</PRE>
<P>For details take a look at:</P>

<UL><P><LI><A HREF="#LINEN">LineN</A>, <A HREF="#LINES">LineS</A>, <A HREF="#LINEE">LineE</A>, <A HREF="#LINEW">LineW</A> - functions for drawing north, south east and west, <A HREF="#LINENE">LineNE</A>, <A HREF="#LINENW">LineNW</A>, <A HREF="#LINESW">LineSW</A>, <A HREF="#LINESE">LineSE</A> functions for drawing simple diagonals.</P></LI>

<P><LI><A HREF="#DSLINENE">DSLineNE</A>, <A HREF="#DSLINENW">DSLineNW</A>, <A HREF="#DSLINESW">DSLineSW</A>, <A HREF="#DSLINESE">DSLineSE</A> (Double Spaced) - similar to the other diagonal-drawing functions except that they add extra whitespace in order to get the diagonal at something more like 45deg. to the horizontal.</P></LI>

<P><LI><A HREF="#CUTRECTANGLE">CutRectangle</A> and <A HREF="#PASTERECTANGLE">PasteRectangle</A> - these deal with copying and moving rectangular blocks of text.</P></LI>

<P><LI><A HREF="#UPREGARDLESS">UpRegardless</A> and <A HREF="#DOWNREGARDLESS">DownRegardless</A> these are cursor-moving functions unconstrained by the text envelope. They add more lines and/or whitespace as they go.</P></LI>

<P><LI>The <A HREF="#OVERWRITE">Overwrite</A> function is also useful when handling block graphics as it preserves the position of succeeding characters on the line.</P></LI>


</UL><H2><A NAME="KEYBOARD FUNCTIONS DEFINED AT STARTUP">Keyboard functions defined at startup</H2>
<P>The startup.jot script defines the functions described in the following sections.</P>

<P>In the description of functions dealing with paragraphs, a paragraph is deemed to be a block of lines bounded by completely blank lines - i.e. a line which does not even contain whitespace.</P>

<P>In the description of functions dealing with code sections, a code section is deemed to be a block of indented text, headed by an unindented line. The code section may contain any number of blank lines.</P>

<P>In the description of functions dealing with words, JOT defines a word as a string containing upper and lower-case alpha characters, digits and underscores. Unfortunately, at present, all unicode characters are treated as non-alpha characters.</P>

<P>The functions described here are defined by the <A HREF="jot_coms.html#STARTUP.JOT">startup.jot</A> file which also links then to the keyboard, the keycodes are are defined in a separate file <A HREF="jot_coms.html#CURSES_KEYS_&#060;TERM&#062;.JOT">curses_keys_&#060;TERM&#062;.jot</A> and <A HREF="jot_coms.html#WINDOWSNT_KEYS.JOT">WindowsNT_keys.jot</A>.</P>


</UL><H3><A NAME="HELP FUNCTIONS.">Help functions.</H3>
<P>Jot help reads a top-level help menu at startup time. This is displayed on the first call for help. A help category is selected by navigating to a line, using the cursor-control keys and hitting the help button (normally F1) once more.</P>

<P>The initial help categories are file folds - they all have a pathname specification of the form &#091;&#060;path&#062;&#093;&#060;name&#062;, as the file folds are opened, the relevant file is read and it's top-level fold headings is displayed. The internal fold headings begin with '&#123;&#123;&#123;' at the start of the line. These can be opened and descended into by navigating the cursor to them and hitting the help button again.</P>

<P>The help structure can be ascended by navigating to and non-fold line and hitting the help button once more.</P>

<P>In addition to the <A HREF="#HELP">Help</A>, <A HREF="#FINDALLHELP">FindAllHelp</A> and <A HREF="#REMOVEHELPFOLD">RemoveHelpFold</A> the following scripts may be useful <A HREF="jot_coms.html#UPDATEHELP.JOT">updatehelp.jot</A>, <A HREF="jot_coms.html#FINDHELP.JOT">findhelp.jot</A> and <A HREF="jot_coms.html#DOC2HELP.JOT">doc2help.jot</A></P>

</UL><H4><A NAME="HELP">Help</H4>
&#062; &#091;&#060;helpQuery&#062;&#093;&#123;F1&#125;
<P>Searches the help database for an entry with a name matching the helpKey - if no helpKey specified but the cursor is on a help fold the fold is opened if not on a help fold then the current help fold is closed - see <A HREF="#ABOUT HELP">about help</A>.</P>

</UL><H4><A NAME="FINDALLHELP">FindAllHelp</H4>
&#062;  &#091;&#060;string&#062;&#093;&#123;Shift+F1&#125;
<P>Searches the currently-opened help documents in the help repository (the : buffer) for matches with string, help menu is set up with matching entries.</P>

</UL><H4><A NAME="REMOVEHELPFOLD">RemoveHelpFold</H4>
&#062; &#123;Ctrl+F1&#125;
<P>The contents of the current fold is removed, if it's a file fold then the file-fold marker is restored.</P>


</UL><H3><A NAME="DELETE AND RESTORE">Delete and Restore</H3>
<P>The functions to do with deletion of bits of text are all attached to the left/right keys.</P>

<P>Text is deleted by moving it to the delete-bin buffer ( % ). When deleting left it goes to the front of the buffer, when deleting right it is moved to the end of the delete-bin buffer. The distinction is important because, to preserve the original order, text is restored character-by-character in the reverse direction.</P>

<P>The restore functions all restore to the current character position - they will effectively reinstate the original text provided:</P>

<UL><P><LI>1/ the cursor is in the same position as when the deletion finished,</P></LI>

<P><LI>2/ you don't overdo it and restore some other old junk from some earlier delete operation</P></LI>

</UL><P>It is, of course, possible to use the select and restore functions to move text by first deleting, moving the cursor and then restoring.</P>

</UL><H4><A NAME="DELETECHRLEFT">DeleteChrLeft</H4>
&#062; &#123;Alt+LeftArrow&#125;
<P>The character immediately to the left of the cursor is moved to the delete bin. If the cursor is at the start of a line, the current line is joined with the previous one.</P>

</UL><H4><A NAME="DELETECHRRIGHT">DeleteChrRight</H4>
&#062; &#123;Alt+RightArrow&#125;
<P>The character immediately below the cursor is moved to the delete bin. If the cursor is at the end of a line, the current line is joined with the next.</P>

</UL><H4><A NAME="DELETEWORDLEFT">DeleteWordLeft</H4>
&#062; &#123;Shift+Alt+LeftArrow&#125;
<P>The word immediately to the left of the cursor is moved to the start of the delete bin. If the cursor is at the start of a line, the current line is joined with the previous one and it's last word is deleted.</P>

</UL><H4><A NAME="DELETEWORDRIGHT">DeleteWordRight</H4>
&#062; &#123;Shift+Alt+RightArrow&#125;
<P>The word immediately to the right of the cursor is moved to the end of the delete bin. If the cursor is at the end of a line, the current line is joined with the next and it's first word is deleted.</P>

</UL><H4><A NAME="DELETELINELEFT">DeleteLineLeft</H4>
&#062; &#123;Ctrl+Alt+LeftArrow&#125;
<P>All of the line immediately to the left of the cursor is moved to the start delete bin. If the cursor is at the start of a line, the current line is joined with the previous one.</P>

</UL><H4><A NAME="DELETELINERIGHT">DeleteLineRight</H4>
&#062; &#123;Ctrl+Shift+Alt+RightArrow&#125;
<P>All of the line immediately to the right of the cursor is moved to the end of the delete bin. If the cursor is at the end of a line, the current line is joined with the next one.</P>

</UL><H4><A NAME="RESTORECHRLEFT">RestoreChrLeft</H4>
&#062; &#123;Ctrl+Shift+Alt+LeftArrow&#125;
<P>The first character in the delete-bin buffer is moved to the current-character position of the current buffer.</P>

</UL><H4><A NAME="RESTOREWORDLEFT">RestoreWordLeft</H4>
&#062; &#123;Esc - r w&#125;
<P>The first word in the delete-bin buffer is moved to the current-character position of the current buffer.</P>

</UL><H4><A NAME="RESTORELINELEFT">RestoreLineLeft</H4>
&#062; &#123;Esc - r l&#125;
<P>The first line in the delete-bin buffer is moved to the current-character position of the current buffer.</P>

</UL><H4><A NAME="RESTORECHRRIGHT">RestoreChrRight</H4>
&#062; &#123;Ctrl+Shift+Alt+RightArrow&#125;
<P>The last character in the delete-bin buffer is moved to the current-character position of the current buffer and becomes the new current character.</P>

</UL><H4><A NAME="RESTOREWORDRIGHT">RestoreWordRight</H4>
&#062; &#123;Esc r w&#125;
<P>The last word in the delete-bin buffer is moved to the current-character position of the current buffer.</P>

</UL><H4><A NAME="RESTORELINERIGHT">RestoreLineRight</H4>
&#062; &#123;Esc r l&#125;
<P>The last line in the delete-bin buffer is moved to the current-character position of the current buffer.</P>


</UL><H3><A NAME="FIND, SUBSTITUTE AND INSERT">Find, substitute and insert</H3>
<P>Arguably the most basic of all editor functions are finding and replacing text F5 to F9 are used for these operations with a few special flavours obtained using the Shift, Ctrl and Alt keys.</P>

</UL><H4><A NAME="FINDNEXT">FindNext</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;F8&#125;
<P>Find the next occurrence of the specified string, if no string is specified then the string used in the last find is used.</P>

</UL><H4><A NAME="SUBSTHENFINDNX">SubsThenFindNx</H4>
&#062; &#123;Shift+F8&#125;
<P>Parameterless, repeats last substitution then find next. i.e. repeat previous substitution, then repeat last find.</P>

</UL><H4><A NAME="FINDNEXTAGAIN">FindNextAgain</H4>
&#062; &#123;Ctrl+F8&#125;
<P>In insert mode, the FindNext function will always prompt for the search string. FindNextAgain will just apply the last-used search-string parameter once again.</P>

<P>This function is provided for the benefit of insert-mode users - repeats the most recent search without re-prompting. It's entirely useless when in command mode - these users need only dab F8 again to repeat the search.</P>

</UL><H4><A NAME="FINDEXACTNEXT">FindExactNext</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;F9&#125;
<P>The buffer is searched until the next exact-match occurrence of the word is found - in this context an exact match is where the matching substring is bounded by non-alphanumeric characters.</P>

</UL><H4><A NAME="FINDEXACTPREV">FindExactPrev</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Shift+F9&#125;
<P>Similar to above, except that it searches backwards.</P>

</UL><H4><A NAME="SETFINDSTRING">SetFindString</H4>
&#062; &#123;Ctrl+F9&#125;
<P>The word below the cursor is picked up and defines the find string for the next find (or find exact) operation.</P>

</UL><H4><A NAME="FINDPREV">FindPrev</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;F7&#125;
<P>Find the previous occurrence of the specified string, if no string is specified then the string used in the last find is used.</P>

</UL><H4><A NAME="SUBSTHENFINDPV">SubsThenFindPv</H4>
&#062; &#123;Shift+F7&#125;
<P>Parameterless substitute then find previous. i.e repeat previous substitution then find previous occurrence of last-found string.</P>

</UL><H4><A NAME="FINDPREVIND">FindPrevInd</H4>
&#062; &#123;Ctrl+F7&#125;
<P>Find indirect - find the previous occurrence of the string defined by the current line of the _ buffer (paste buffer).</P>

</UL><H4><A NAME="FINDPREVAGAIN">FindPrevAgain</H4>
&#062; &#123;Alt+F7&#125;
<P>In insert mode, the FindPrev function will always prompt for the search string. FindPrevAgain will just apply the last-used search-string parameter once again.</P>

<P>This function is provided for the benefit of insert-mode users - repeats the most recent search without re-prompting. It's entirely useless when in command mode - these users need only dab F7 again to repeat their search.</P>

</UL><H4><A NAME="FINDWILD">FindWild</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Esc f w&#125;
<P>This searches for the next occurrence of a string containing one or more wildcards ( * ). The argument list is parsed and held in buffer @.</P>

<P>If no argument is given then it matches to whatever happens to be in the @ buffer.</P>

</UL><H4><A NAME="FINDWILDPREV">FindWildPrev</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Esc - f w&#125;
<P>This searches for the previous occurrence of a string containing one or more wildcards ( * ). The argument list is parsed and held in buffer @.</P>

<P>If no argument is given then it matches to whatever happens to be in the @ buffer.</P>

</UL><H4><A NAME="FINDINPARANEXT">FindInParaNext</H4>
&#062; &#091;&#060;substring1&#062;&#091; &#060;substring2&#062;&#091; &#060;substring3&#062;&#091; ...&#093;&#093;&#093;&#123;Esc f p&#125;
<P>Locates the next paragraph containing all of the substrings in the substrings list. On successful completion, it highlights the last substring in your parameter list. If unsuccessful, the cursor is left at the end of the file image and a message is issued.</P>

<P>The list of substrings is delimited by blanks, sequences of two or more blanks are treated as a single blank. If a substring contains blanks these are escaped with a backslash character ( \ ) e.g:</P>

&#062; substring1 substring2 substring\ containing\ blanks lastSubstring&#123;Esc f p&#125;
<P>The argument list is parsed and held in buffer @. If no argument is given then it matches to whatever happens to be in the @ buffer - hopefully the parsed argument list from the last such search.</P>

<P>In this context, a paragraph is deemed to be any number of lines separated by blank lines or lines containing only whitespace.</P>

</UL><H4><A NAME="FINDINPARAPREV">FindInParaPrev</H4>
&#062; &#091;&#060;substring1&#062;&#091; &#060;substring2&#062;&#091; &#060;substring3&#062;&#091; ...&#093;&#093;&#093;&#123;Esc - f p&#125;
<P>Similar to <A HREF="#FINDINPARANEXT">FindInParaNext</A> except that the file image is searched backwards from the current cursor position towards the begining of the file image..</P>

</UL><H4><A NAME="FINDSEQUENCE">FindSequence</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Esc f s&#125;
<P>The editor will search for the sequence of words ignoring any non-alphanumeric delimiters including line breaks. One or more words can be represented by the wildcard character ( * ). The argument list is parsed and held in buffer @.</P>

<P>If no argument is given then it matches to whatever happens to be in the @ buffer.</P>

<P>This is function is useful for locating sequences of words after they have been reformatted in some way, with wildcards it is also useful for locating expressions in programming code.</P>

</UL><H4><A NAME="FINDSEQUENCEPREV">FindSequencePrev</H4>
&#062; &#091;&#060;string&#062;&#093; &#123;Esc - f s&#125; 
<P>Similar to FindPhrase except that it searches back towards the start of the file.</P>

</UL><H4><A NAME="FDINLINEORD">FdInLineOrd</H4>
&#062; &#091;&#060;substr1&#062;&#091; &#060;substr2&#062;&#091; ... &#093;&#093;&#123;Esc f o&#125;
<P>This finds the next occurrence of a line containing that sequence of substrings in the order specified.</P>

<P>The list of substrings is delimited by blanks, sequences of two or more blanks are treated as a single blank. If a substring contains blanks these are escaped with a backslash character ( \ ) e.g:</P>

&#062; substring1 substring2 substring\ containing\ blanks lastSubstring&#123;Esc f p&#125;
</UL><H4><A NAME="FDINLINEORDPREV">FdInLineOrdPrev</H4>
&#062; &#091;&#060;substr1&#062;&#091; &#060;substr2&#062;&#091; ... &#093;&#093;&#123;Esc - f o&#125;
<P>This is similar to <A HREF="#FDINLINEORD">FdInLineOrd</A> except that it works back from the current line towards the start of the file image.</P>

</UL><H4><A NAME="FDINLINEUN">FdInLineUn</H4>
&#062; &#091;&#060;substr1&#062;&#091; &#060;substr2&#062;&#091; ... &#093;&#093;&#123;Esc f u&#125;
<P>Very similar to <A HREF="#FDINLINEORD">FdInLineOrd</A> except that it matches to a line containing the given substrings in any order. On successful completion, it highlights the last of the given substrings. If it fails to find a matching line, it leaves the cursor at the end of the file image.</P>

<P>The list of substrings is delimited by blanks, sequences of two or more blanks are treated as a single blank. If a substring contains blanks these are escaped with a backslash character ( \ ) e.g:</P>

&#062; substring1 substring2 substring\ containing\ blanks lastSubstring&#123;Esc f p&#125;
</UL><H4><A NAME="FDINLINEUNPREV">FdInLineUnPrev</H4>
&#062; &#091;&#060;substr1&#062;&#091; &#060;substr2&#062;&#091; ... &#093;&#093;&#123;Esc - f u&#125;
<P>Very similar to <A HREF="#FDINLINEUN">FdInLineUn</A> except that it searches backwards from the current line towards the start of the file image.</P>

</UL><H4><A NAME="FDINNLINESUN">FdInNLinesUn</H4>
&#062; &#091;&#060;apertureSize&#062; &#091;&#060;substr1&#062;&#091; &#060;substr2&#062;&#091; ... &#093;&#093;&#123;Esc f n&#125;
<P>Similar to <A HREF="#FDINLINEUN">FdInLineUn</A> except that it allows the substrings to be scattered over a specified number of lines. The aperture size (maximum number of lines) includes any blank and any other non-text lines, this must be in decimal.</P>

<P>E.g the following:</P>

&#062; 5 wonderful super\ duper amazing&#123;Esc f n&#125;
<P>will search the document for the strings </P>

<UL><P>"wonderful", "super duper" and "amazing"</P>

</UL><P>which may appear in any order and must appear in a block of 5 lines or less.</P>

</UL><H4><A NAME="FDINNLINESUNPREV">FdInNLinesUnPrev</H4>
&#062; &#091;&#060;apertureSize&#062; &#091;&#060;substr1&#062;&#091; &#060;substr2&#062;&#091; ... &#093;&#093;&#123;Esc - f n&#125;
<P>Similar to <A HREF="#FDINNLINESUN">FdInNLinesUn</A> except that it searches back from the current cursor position, towards the start of the file image.</P>

</UL><H4><A NAME="SUBSTITUTE">Substitute</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;F5&#125;
<P>Replaces currently-selected substring with the specified string, if no string is specified then the last-substituted or inserted string is used.</P>

</UL><H4><A NAME="REMOVE">Remove</H4>
&#062; &#123;Shift+F5&#125;
<P>The previously-selected string (following a find, substitute etc.), is removed altogether.</P>

</UL><H4><A NAME="SUBSTITUTEAGAIN">SubstituteAgain</H4>
&#062; &#123;Alt+F5&#125;
<P>In insert mode, the Substitute function will always prompt for the search string. SubstituteAgain will just apply the last-used substitute-string parameter once again.</P>

<P>This function is provided for the benefit of insert-mode users as it repeats a substitution without re-prompting. It's entirely useless when in command mode - where it is only necessary to dab F5 again to repeat the substitution at some new location.</P>

</UL><H4><A NAME="INSERT">Insert</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;F6&#125;
<P>Inserts specified text at the current-character position, if no string is specified then the last-substituted or inserted string is used.</P>

</UL><H4><A NAME="OVERWRITE">Overwrite</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Shift+F6&#125;
<P>The characters under and to the right of the current cursor are replaced by the specified string. If no string is specified, then the last string used in an insert or substitute operation is used.</P>

<P>The overwrite function is useful when editing tabular data.</P>

</UL><H4><A NAME="INSERTAGAIN">InsertAgain</H4>
&#062; &#123;Alt+F6&#125;
<P>In insert mode, the Insert function will always prompt for the insert string. InsertAgain will just apply the last-used insert-string once again.</P>

<P>This function is provided for the benefit of insert-mode users as it repeats an insert without re-prompting. It's entirely useless when in command mode - where it is only necessary to dab F6 again to repeat the insert at some new location.</P>

</UL><H4><A NAME="INSERTWITHBACKTICK">InsertWithBackTick</H4>
&#062; &#091;&#060;String&#062;&#093;&#123;Esc ’&#125;
<P>The <A HREF="#INSERT">Insert</A> function can insert any string that does not contain the ASCII backtick (or grave) character ( ’ ). That's because the Insert function uses this character as a delimiter to introduce the user-specified string. This is not usually a problem but, if it is, the InsertWithBackTick function is designed to fill that gap.</P>

<P>InsertWithBackTick inserts the specified string, appends a backtick and then sets the substring to cover the string and backtick. If the optional string arg is omitted, it inserts only the backtick.</P>

 <CODE>&lt;</CODE>P<CODE>></CODE>Note:<CODE>&lt;</CODE>/P<CODE>></CODE>

<P>This section may not display properly, even if it does, sharp-eyed readers will have noticed backtick-like character used here is not a backtick (ASCII code 96) but unicode left-single-quote character (UTF-8 code E2, 80, 9C). This is because backticks are reserved for the introduction of hyperlinks in these documents.</P>


</UL><H3><A NAME="TEXT DOCUMENT PREPARATION">Text Document Preparation</H3>
<P>The <A HREF="jot_coms.html#DOC.JOT">doc.jot</A> script offers a suite of basic text-document preparation functions. These functions perform simple shifting of text across lines while preserving indentation and for inheriting indentation from neighbouring lines.</P>

</UL><H4><A NAME="ENTER">Enter</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;KP_Enter&#125;
<P>or</P>

&#062; &#091;&#060;string&#062;&#093;&#123;Esc e&#125;
<P>The string is inserted as a new line with indent level inherited from previous line. If no string is given then creates a blank line at the same indent level as the line above. This function only useful in command mode.</P>

</UL><H4><A NAME="APPENDLEFTPREV">AppendLeftPrev</H4>
&#062; &#123;Alt+F9&#125;
<P>Appends text to the left of the current character to the end of the previous line, preserving indentation of both lines.</P>

</UL><H4><A NAME="APPENDRIGHTNEXT">AppendRightNext</H4>
&#062; &#123;Alt+F10&#125;
<P>Appends text under and to the right of the current character, to the start of the next line, preserving the indentation of both lines.</P>

</UL><H4><A NAME="JOINLEFTPREV">JoinLeftPrev</H4>
&#062; &#123;Shift+Alt+F9&#125;
<P>Joins current line to end of previous line, excluding indentation whitespace. It also adds a gratuitous blank if it deems this necessary.</P>

</UL><H4><A NAME="JOINRIGHTNEXT">JoinRightNext</H4>
&#062; &#123;Shift+Alt+F10&#125; 
<P>Joins current line to the start of the next line, excluding indentation whitespace. It also adds a gratuitous blank if it deems this necessary.</P>

</UL><H4><A NAME="INDENTFROMPREV">IndentFromPrev</H4>
&#062; &#123;Ctrl+Shift+F9&#125;
<P>Removes all indentation blanks from the current line and replaces them with those from the previous line.</P>

</UL><H4><A NAME="INDENTFROMNEXT">IndentFromNext</H4>
&#062; &#123;Ctrl+Shift+F10&#125;
<P>Removes all indentation blanks from the current line and replaces them with those from the next line.</P>

</UL><H4><A NAME="BREAK">Break</H4>
&#062; &#123;Shift+F10&#125;
<P>This breaks the current line at the current character position. Text to the right of the break ends up on the next line, this inherits indentation from the original line.</P>

</UL><H4><A NAME="JOIN">Join</H4>
&#062; &#123;Ctrl+F10&#125;
<UL><P>This joins the current line with the line immediately below it. Any trailing whitespace and the original indentation whitespace are replaced by a single space.</P>


</UL><H3><A NAME="COPY PASTE AND RELATED FUNCTIONS">Copy Paste and Related Functions</H3>
<P>The mapping of functions to the mid keypad approximates to most of the key-cap functions but not, perhaps, the meaning IBM originally intended.</P>

<UL><P><LI>Delete and Insert become Cut and Paste respectively,</P></LI>

<P><LI>End is the Note key and</P></LI>

<P><LI>Page Up/Down work as advertised.</P></LI>

</UL><P>Users lacking the mid keypad need not despair, for the benefit of them and their tiny laptops, the cut and paste operations are also available on function keys. Users lacking a mid keypad need not despair, most of these functions are also available as escape sequences.</P>

</UL><H4><A NAME="NOTE">Note</H4>
&#062; &#123;Ctrl+Shift+F1&#125;
<P>or</P>

&#062; &#123;Home&#125;
<P>or</P>

&#062; &#123;Esc n o&#125;
<P>The current character position is noted for a later cut or copy operation.</P>

</UL><H4><A NAME="CUT">Cut</H4>
&#062; &#123;Ctrl+Alt+F2&#125;
<P>or</P>

&#062; &#123;Delete&#125;
<P>or</P>

&#062; &#123;Esc c u&#125;
<P>Text from the last-defined note point up to the current character position is moved the paste buffer - this the the _ buffer in jot.</P>

</UL><H4><A NAME="COPY">Copy</H4>
&#062; &#123;Ctrl+Shift+F3&#125;
<P>or</P>

&#062; &#123;End&#125;
<P>or</P>

&#062; &#123;Esc c o&#125;
<P>Text from the last-defined note point up to the current character position is copied to the paste buffer. This operation is permitted for Readonly buffers - see <A HREF="jot_tech.html#%B=READONLY">%b=readonly</A> where the <A HREF="#CUT">Cut</A> operation is guaranteed to fail.</P>

</UL><H4><A NAME="PASTE">Paste</H4>
&#062; &#123;Ctrl+Shift+F4&#125;
<P>or</P>

&#062; &#123;Insert&#125;
<P>or</P>

&#062; &#123;Esc p t&#125;
<P>The contents of the paste buffer is inserted into the text at the current character position.</P>

</UL><H4><A NAME="CUMULATIVECOPY">CumulativeCopy</H4>
&#062; &#123;Shift+Alt+F3&#125;
<P>or</P>

&#062; &#123;Shift+End&#125;
<P>Text from the last-defined note point up to the current character position is appended to the end of the paste buffer. This operation is permitted for Readonly buffers (see <A HREF="jot_tech.html#%B=READONLY">%b=readonly</A>). If no note point was set, then the complete line is copied to the paste buffer.</P>

</UL><H4><A NAME="CUTTABULAR">CutTabular</H4>
&#062; &#123;Ctrl+Shift+Alt+F2&#125;
<P>or</P>

&#062; &#123;Ctrl+Delete&#125;
<P>CutTabular removes the selected text to the paste buffer but the text is replaced by blanks. The intention is to preserve the structure of a whitespace-separated table.</P>

</UL><H4><A NAME="CUMULATIVECUT">CumulativeCut</H4>
&#062; &#123;Shift+Alt+F2&#125;
<P>or</P>

&#062; &#123;Shift+Delete&#125;
<P>The CumulativeCut function removes the selected text, appending it to the end of the paste buffer.</P>

</UL><H4><A NAME="PASTEOVER">PasteOver</H4>
&#062; &#123;Shift+Alt+F4&#125;
<P>or</P>

&#062; &#123;Ctrl+Insert&#125;
<P>The contents of the paste buffer are written over the text to the right of the cursor. If the paste buffer contains more than one line of text, subsequent lines overwrite from the first character.</P>

</UL><H4><A NAME="CUTRECTANGLE">CutRectangle</H4>
&#062; &#123;Shift+Alt+F2&#125;
<P>or</P>

&#062; &#123;Alt+Delete&#125;
<P>or</P>

&#062; &#123;Esc c r&#125;
<P>First go to the top left corner of the rectangle and note the position with <A HREF="#NOTE">Note</A>, then move the cursor to the bottom-right corner of the rectangle and apply <A HREF="#CUTRECTANGLE">CutRectangle</A>. The text is removed and replaced by blanks leaving the current character at the original note point (the top-left corner of the cut text).</P>

<P>To restore the text at it's original position apply <A HREF="#PASTERECTANGLE">PasteRectangle</A> immediately after CutRectangle.</P>

</UL><H4><A NAME="PASTERECTANGLE">PasteRectangle</H4>
&#062; &#123;Ctrl+Shift+Alt+F4&#125;
<P>or</P>

&#062; &#123;Alt+Insert&#125;
<P>or</P>

&#062; &#123;Esc p r&#125;
<P>The paste buffer is assumed to contain some graphical or tabular text (i.e. some lines of text where both the horizontal and vertical placement of characters is significant). The picture is inserted at the current character position and in the same column of succeeding lines, text to the right of the inserted block retains it's original position. The <A HREF="#CUTRECTANGLE">CutRectangle</A> function can be used to extract the block of text.</P>


</UL><H3><A NAME="DO FUNCTIONS">Do Functions</H3>
<P>This group of functions is about running jot command files. </P>

</UL><H4><A NAME="DO">Do</H4>
&#062; &#091;&#060;pathName&#062;&#093;&#123;F2&#125;
<P>Run a command file. The default path is your current working directory, if the named file does not exist there then it searches for it in $&#123;JOT_HOME&#125;/coms, the default file extension is .jot</P>

</UL><H4><A NAME="SCRIPTBYNAME">ScriptByName</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Shift+F2&#125;
<P>Searches all scripts in $&#123;JOT_HOME&#125;/coms and your pwd for those with names matching the string. If no string given then lists all scripts with .jot name extension.</P>

</UL><H4><A NAME="SCRIPTBYFUNC">ScriptByFunc</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Shift+F2&#125;
<P>Searches the first-line comments of all scripts in $&#123;JOT_HOME&#125;/coms and your pwd for those with functions matching the string. If no string given then lists all scripts with .jot name extension and their first lines.</P>


</UL><H3><A NAME="MATCHING FUNCTIONS">Matching Functions</H3>
<P>The simplest of these are simply to navigate to the start or end of the current paragraph or code section. Others are about finding matching brackets of various kinds. e.g. Finding the closing ')' matching the '(' under the cursor.</P>

</UL><H4><A NAME="PARAGRAPHUP">ParagraphUp</H4>
&#062; &#123;F3&#125;
<P>Searches for the previous paragraph start i.e. a block of text with a totally blank line above it - it passes by lines containing only whitespace.</P>

</UL><H4><A NAME="PARAGRAPHDOWN">ParagraphDown</H4>
&#062; &#123;F4&#125;
<P>Searches down the text for the next paragraph start - i.e. a block of text preceeded by a completely blank line - it passes by lines containing only whitespace.</P>

</UL><H4><A NAME="CODESECTIONUP">CodeSectionUp</H4>
&#062; &#123;Shift+F3&#125;
<P>Searches back up the text for the start of the next code section. Code sections begin with a non-whitespace character in column 1.</P>

</UL><H4><A NAME="CODESECTIONDOWN">CodeSectionDown</H4>
&#062; &#123;Shift+F4&#125;
<P>Searches down the text for the next code section - code sections begin with a non-whitespace character in column 1.</P>

</UL><H4><A NAME="INDENTMATCHUP">IndentMatchUp</H4>
&#062; &#123;Ctrl+F3&#125;
<P>Searches back up the text for the previous line at the same indent level as the current line. Initially the cursor may be anywhere in the line, on completion it is left on the first non-blank character of the line.</P>

</UL><H4><A NAME="INDENTMATCHDOWN">IndentMatchDown</H4>
&#062; &#123;Ctrl+F4&#125;
<P>Searches forwards in the text for the next line at the same indentation level as the current line. Initially the cursor may be anywhere in the line, on completion it is left on the first non-blank character of the line.</P>

</UL><H4><A NAME="ANYMATCH">AnyMatch</H4>
&#062; &#123;Alt+F5&#125;
<P>This function matches some form of brace character with it's mate, the cursor must be positioned over a brace character.</P>

<P>The cursor must initially be placed over one of the following characters: (, &#123;, &#091;, &#060;, ), &#125;, &#093; or &#062;. The AnyMatch function then calls the appropriate matching function (respectively <A HREF="#PARENMATCHLEFT">ParenMatchLeft</A>, <A HREF="#CURLYMATCHLEFT">CurlyMatchLeft</A>, <A HREF="#SQUAREMATCHLEFT">SquareMatchLeft</A>, <A HREF="#ANGLEMATCHLEFT">AngleMatchLeft</A>, <A HREF="#PARENMATCHRIGHT">ParenMatchRight</A>, <A HREF="#CURLYMATCHRIGHT">CurlyMatchRight</A>, <A HREF="#SQUAREMATCHRIGHT">SquareMatchRight</A> or <A HREF="#ANGLEMATCHRIGHT">AngleMatchRight</A>) to locate the matching character in the text. On completion the cursor is placed over the matching brace character.</P>

</UL><H4><A NAME="PARENMATCHLEFT">ParenMatchLeft</H4>
&#062; &#123;Shift+Alt+F5&#125;
<P>If the cursor is above a parenthesis close character ')', then the cursor is moved back (leftwards and upwards) to the corresponding parenthesis open. This works by plodding through the text, counting open and close braces ( and ), until the corresponding parenthesis-open character is found.</P>

<P>Between the initial ')' and it's matching '(', parenthesis characters in strings delimited by double quotes ( " ) are ignored as are matching pairs of parenthesis characters which may be nested to any depth.</P>

<P>If the cursor is not above a parenthesis-close character, then the buffer is searched back to find the previous parenthesis close and the cursor moved to the corresponding parenthesis open.</P>

</UL><H4><A NAME="PARENMATCHRIGHT">ParenMatchRight</H4>
&#062; &#123;Shift+Alt+F6&#125;
<P>If cursor is above a parenthesis open '(' character, then cursor is moved forwards (rightwards and downwards) to the corresponding parenthesis close ')'. This works by plodding through the text, counting open and close braces ( and ), until the corresponding parenthesis-close character is found.</P>

<P>Between the initial '(' and it's matching ')', parenthesis characters in strings delimited by double quotes ( " ) are ignored as are matching pairs of parenthesis characters which may be nested to any depth.</P>

<P>If the current character is not above a parenthesis-open character, then it searches forwards for one and then finds the corresponding parenthesis close character.</P>

</UL><H4><A NAME="CURLYMATCHLEFT">CurlyMatchLeft</H4>
&#062; &#123;Ctrl+Shift+Alt+F5&#125;
<P>Similar to &#060;&#060;ParenMatchLeft&#062;&#062;, above, except matches &#123; and &#125;.</P>

<P>Note, if intending to traverse C code, <A HREF="jot_coms.html#C.JOT">c.jot</A> is preferable as this script will ignore any curly brackets in C comments and strings.</P>

</UL><H4><A NAME="CURLYMATCHRIGHT">CurlyMatchRight</H4>
&#062; &#123;Ctrl+Shift+Alt+F6&#125;
<P>Similar to &#060;&#060;ParenMatchRight&#062;&#062;, above, except matches &#123; and &#125;.</P>

<P>Note, if intending to traverse C code, <A HREF="jot_coms.html#C.JOT">c.jot</A> is preferable as this script will ignore any curly brackets in C comments and strings.</P>

</UL><H4><A NAME="ANGLEMATCHLEFT">AngleMatchLeft</H4>
&#062; &#123;Ctrl+Shift+F5&#125;
<P>Similar to &#060;&#060;ParenMatchLeft&#062;&#062;, above, except matches &#060; and &#062;.</P>

</UL><H4><A NAME="ANGLEMATCHRIGHT">AngleMatchRight</H4>
&#062; &#123;Ctrl+Shift+F6&#125;
<P>Similar to &#060;&#060;ParenMatchRight&#062;&#062;, above, except matches &#060; and &#062;.</P>

</UL><H4><A NAME="SQUAREMATCHLEFT">SquareMatchLeft</H4>
&#062; &#123;Ctrl+Shift+Alt+F7&#125;
<P>Similar to &#060;&#060;ParenMatchLeft&#062;&#062;, above, except matches &#091; and &#093;.</P>

</UL><H4><A NAME="SQUAREMATCHRIGHT">SquareMatchRight</H4>
&#062; &#123;Ctrl+Shift+Alt+F8&#125;
<P>Similar to &#060;&#060;ParenMatchRight&#062;&#062;, above, except matches &#091; and &#093;.</P>

</UL><H4><A NAME="MARKUPMATCHLEFT">MarkupMatchLeft</H4>
&#062; &#123;Shift+Alt+F7&#125;
<P>This is for use with HTML and XML. MarkupMatchLeft, working back from the current cursor position, first locates the previous "&#060;/" string - indicating a block end in HTML and XML. It then picks up the block-type tag and finds the corresponding block-start.</P>

</UL><H4><A NAME="MARKUPMATCHRIGHT">MarkupMatchRight</H4>
&#062; &#123;Shift+Alt+F8&#125;
<P>This is for use with HTML and XML. MarkupMatchRight, working forwards from the current cursor position, it first locates the next "&#060;" character - indicating a block start in HTML and XML. It then picks up the block-type tag and finds the corresponding block-end.</P>


</UL><H3><A NAME="THE CURSOR-CONTROL KEYS">The Cursor-control keys</H3>
<P>In addition to navigating around the text, there are also functions for adjusting the view.</P>

</UL><H4><A NAME="UP">Up</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;UpArrow&#125;
<P>Move up by n lines (defaults to 1) - the current line becomes the line n lines above original current line, the current character is the first character.</P>

</UL><H4><A NAME="WORDUP">WordUp</H4>
&#062; &#123;Shift+UpArrow&#125;
<P>Moves up one column, for tab-separated tabular text, this moves to the cell immediately above the currently-selected cell, for normal text it moves up in a column - see <A HREF="#NEWWORDUP">NewWordUp</A>. If that line has insufficient characters then the cursor is left at the end of the line (but see <A HREF="#UPREGARDLESS">UpRegardless</A>).</P>


</UL><H4><A NAME="NEWWORDUP">NewWordUp</H4>
&#062; &#123;Ctrl+UpArrow&#125;
<P>Sets the column for the <A HREF="#WORDUP">WordUp</A> function, subsequent invocations of WordUp will attempt to stay in the same column as the current character - see the <A HREF="jot_tech.html#Y">Y</A> command.</P>

</UL><H4><A NAME="HOME">Home</H4>
<P>Not currently assigned to any key.</P>

<P>The current line is set to the first line in the file, the current character is the first character of the line.</P>

</UL><H4><A NAME="VIEWUP">ViewUp</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;Ctrl+Shift+UpArrow&#125;
<P>Shifts the view up by n lines (defaults to 1) without changing the current line, character or selected substring.</P>

</UL><H4><A NAME="DOWN">Down</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;DownArrow&#125;
<P>Move down by n (defaults to 1) lines - the current line pointer is shifted down, the current character becomes the first character of the new line.</P>

</UL><H4><A NAME="WORDDOWN">WordDown</H4>
&#062; &#123;Shift+DownArrow&#125;
<P>Attempts to move down one column, for tab-separated tabular text, this moves to the cell immediately below the currently-selected cell, for normal text it moves down in a column - see <A HREF="#NEWWORDDOWN">NewWordDown</A>. If the next line has insufficient characters then the cursor is left at the end of the line (but see <A HREF="#DOWNREGARDLESS">DownRegardless</A>).</P>

</UL><H4><A NAME="NEWWORDDOWN">NewWordDown</H4>
&#062; &#123;Ctrl+DownArrow&#125;
<P>Sets the column for the <A HREF="#WORDDOWN">WordDown</A> function, subsequent invocations of WordDown will attempt to stay in the same column as the current character - see the <A HREF="jot_tech.html#Y">Y</A> command.</P>

</UL><H4><A NAME="END">End</H4>
<P>Not currently assigned to any key.</P>

<P>The view is change to the last page in the file, the current line is the last line of the buffer, the current character becomes the first character of this line.</P>

</UL><H4><A NAME="VIEWDOWN">ViewDown</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;Ctrl+Shift+DownArrow&#125;
<P>Shifts the view down by n lines (defaults to 1) without changing the current line, character or selected substring.</P>

</UL><H4><A NAME="LEFT">Left</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;LeftArrow&#125;
<P>or</P>

&#062; &#091;&#060;n&#062;&#093;&#123;Ctrl+KP_4&#125;
<P>or</P>

&#062; &#123;Esc m w&#125;
<P>Move the cursor n (defaults to 1) characters left of it's original position.</P>

<P>The same function is attached to &#123;Ctrl+KP_4&#125; and &#123;Esc m w&#125; for consistency and for the benefit of those navigating a line drawing. It's easier to hold the Ctrl key down while using the other line-drawing navigation functions on &#123;Ctrl+KP_2&#125;, &#123;Ctrl+KP_8&#125; and &#123;Ctrl+KP_6&#125;</P>

</UL><H4><A NAME="WORDLEFT">WordLeft</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;Shift+LeftArrow&#125;
<P>For tabular text, i.e. the current line contains Tab characters, this moves the cursor to the cell left of the current cell and, if necessary, adjusts leftoffset to bring all of the cell into view.</P>

<P>For non-tabular text, this moves the cursor to the start of previous word. If the cursor is not currently above a word the cursor moves to the start of the current word.</P>

<P>If n is given the process is repeated that many times.</P>

</UL><H4><A NAME="LINELEFT">LineLeft</H4>
&#062; &#123;Ctrl+LeftArrow&#125;)
<P>Moves to the start of the current line, if already at the start of line moves to the start of the previous line.</P>

</UL><H4><A NAME="RIGHT">Right</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;RightArrow&#125;
<P>Move the cursor n (defaults to 1) characters right of it's original position.</P>

</UL><H4><A NAME="WORDRIGHT">WordRight</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;Shift+RightArrow&#125;
<P>For tabular text, i.e. the current line contains Tab characters, this moves the cursor to the cell right of the current cell and, if necessary, adjusts leftoffset to bring all of the cell into view.</P>

<P>For non-tabular text, this moves the cursor to the start of next word. If the cursor is not currently above a word the cursor moves to the start of the current word.</P>

<P>If n is given the process is repeated that many times.</P>

</UL><H4><A NAME="LINERIGHT">LineRight</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;Ctrl+RightArrow&#125;
<P>Moves to the end of the current line, if already at the end of a line it move to the end of the next line.</P>

</UL><H4><A NAME="PAGEUP">PageUp</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;PageUp&#125;
<P>or</P>

&#062; &#091;&#060;n&#062;&#093;&#123;Page Up&#125;
<P>The view changed to show the page above the previously-displayed page of text, the current-line is changed according to the current window size and the character pointer is set to the first character of the new line.</P>

</UL><H4><A NAME="PAGEDOWN">PageDown</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;Page Down&#125;
<P>The view is changed to the page below the current page.</P>

</UL><H4><A NAME="GOTOFOLDSTART">GotoFoldStart</H4>
<P>Not currently assigned to any key.</P>

<P>Find matching fold-start. In a file with fold marks, when at a fold end, this will search back for the corresponding fold start.</P>

</UL><H4><A NAME="GOTOFOLDEND">GotoFoldEnd</H4>
<P>Not currently assigned to any key.</P>

<P>Find matching fold end. In a file with &#123; &#123; &#123; and &#125; &#125; &#125; fold marks, when at a fold start, this will search for the corresponding fold end.</P>


</UL><H3><A NAME="MACROS 0 TO 9">Macros 0 to 9</H3>
-----------------                    
<P>For users lacking a numeric keypad, typically those with small laptops, the basic functions 0-9 are obtained using Escape then a numeric key the appropriate numeric key - e.g. for Macro 8 - hit the escape key followed by the 8 key - denoted by &#123;Esc 8&#125;. Alternatively, many linux distributions seem to map &#123;Alt+F&#060;n&#062;&#125; as &#123;Esc F&#060;n&#062;&#125;.</P>

<P>In windows, each key on the numeric keypad is uniquely identifiable by it's keycode. In linux/curses the keys map to identical codes to the normal numeric keys or to those on the mid keypad according to the state of NumLock see <A HREF="jot_tech.html#X-WINDOWS SETUP">X-windows setup</A>).</P>


</UL><H3><A NAME="LINE-DRAWING FUNCTIONS">Line-drawing Functions</H3>
<P>The following line-drawing functions are provided. Many are driven by the numeric keypad, unix users will have to set these up - see <A HREF="jot_tech.html#X-WINDOWS SETUP">X-windows setup</A>. </P>

<P>See <A HREF="jot_walkthrough.html#GRAPHICAL TEXT - 1">Graphical text - 1</A> ...</P>

</UL><H4><A NAME="UPREGARDLESS">UpRegardless</H4>
&#062; &#123;Ctrl+KP_8&#125;
<P>or</P>

&#062; &#123;Esc m n&#125;
<P>This is intended for line-drawings. When editing these it is essential that, as the cursor moves up or down, it remains in the same column. This is achieve by adding extra whitespace to the end of lines too short to maintain the cursor position.</P>

<P>Also, if the original line was the first line in the buffer, a new blank line is inserted and populated with whitespace.</P>

</UL><H4><A NAME="DOWNREGARDLESS">DownRegardless</H4>
&#062; &#123;Ctrl+KP_2&#125;
<P>or</P>

&#062; &#123;Esc m s&#125;
<P>This is intended for navigating around line-drawings. When editing these it is essential that, as the cursor moves up or down, it remains in the same column. This is achieve by adding extra whitespace to the end of lines too short to maintain the cursor position.</P>

<P>Also, if the original line was the last line in the buffer, a new blank line is inserted and populated with whitespace.</P>

</UL><H4><A NAME="RIGHTREGARDLESS">RightRegardless</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;Ctrl+KP_6&#125;
<P>or</P>

&#062; &#123;Esc m e&#125;
<P>Moves the cursor one character to the right, if the cursor is already at the end of a line then inserts one blank. This behaviour is designed to facilitate navigation around line drawings - see also &#060;&#060;<A HREF="#UPREGARDLESS">UpRegardless</A>&#062;&#062; and &#060;&#060;<A HREF="#DOWNREGARDLESS">DownRegardless</A>&#062;&#062;.</P>

</UL><H4><A NAME="LINENW">LineNW</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Ctrl+Alt+KP_7&#125;
<P>or</P>

&#062; &#091;&#060;string&#062;&#093;&#123;Esc \ u&#125;
<P>A line-drawing function. Draws string, from the current-character position in a north-westerly direction. If &#060;string&#062; is unspecified, draws a single backslash ( \ ).</P>

<P>As with other drawing functions, &#060;&#060;LineNW&#062;&#062; always creates new lines and inserts padding whitespace where necessary but will fail when the cursor is in column 1 (the first character of a line).</P>

</UL><H4><A NAME="LINEN">LineN</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Ctrl+Alt+KP_8&#125;
<P>or</P>

&#062; &#091;&#060;string&#062;&#093;&#123;Esc l n&#125;
<P>A line-drawing function. Draws string, from the current-character position in a northerly direction. If &#060;string&#062; is unspecified, draws a single vertical bar ( | ).</P>

</UL><H4><A NAME="LINENE">LineNE</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Ctrl+Alt+KP_9&#125;
<P>or</P>

&#062; &#091;&#060;string&#062;&#093;&#123;Esc / u&#125;
<P>A line-drawing function. Draws string, from the current-character position in a north-easterly direction. If &#060;string&#062; is unspecified, draws a single slash ( / ).</P>

</UL><H4><A NAME="LINEE">LineE</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Ctrl+Alt+KP_4&#125;
<P>or</P>

&#062; &#091;&#060;string&#062;&#093;&#123;Esc l e&#125;
<P>A line-drawing function. Draws string, from the current-character position in a easterly direction. If &#060;string&#062; is unspecified, draws a single hyphen (</P>

<UL><P><LI>).</P></LI>

</UL><H4><A NAME="LINEW">LineW</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Ctrl+Alt+KP_6&#125;
<P>or</P>

&#062; &#091;&#060;string&#062;&#093;&#123;Esc l w&#125;
<P>A line-drawing function. Draws string, from the current-character position in a westerly direction. If &#060;string&#062; is unspecified, draws a single hyphen (</P>

<UL><P><LI>).</P></LI>

</UL><H4><A NAME="LINESW">LineSW</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Ctrl+Alt+KP_1&#125;
<P>or</P>

&#062; &#091;&#060;string&#062;&#093;&#123;Esc / d&#125;
<P>A line-drawing function. Draws string, from the current-character position in a south-easterly direction. If &#060;string&#062; is unspecified, draws a single slash ( / ).</P>

<P>As with other drawing functions, &#060;&#060;LineSW&#062;&#062; always creates new lines and inserts padding whitespace where necessary but will fail when the cursor is in column 1 (the first character of a line).</P>

</UL><H4><A NAME="LINES">LineS</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Ctrl+Alt+KP_2&#125;
<P>or</P>

&#062; &#091;&#060;string&#062;&#093;&#123;Esc l s&#125;
<P>A line-drawing function. Draws string, from the current-character position in a southerly direction. If &#060;string&#062; is unspecified, draws a single backslash ( \ ).</P>

</UL><H4><A NAME="LINESE">LineSE</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Ctrl+Alt+KP_3&#125;
<P>or</P>

&#062; &#091;&#060;string&#062;&#093;&#123;Esc \ d&#125;
<P>A line-drawing function. Draws string, from the current-character position in a south-easterly direction. If &#060;string&#062; is unspecified, draws a single backslash ( \ ).</P>

</UL><H4><A NAME="DSLINENW">DSLineNW</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Esc \ n&#125;
<P>A line-drawing function similar to LineNE except that it inserts extra whitespace to draw at something like 45deg - the actual angle depends on your font size.</P>

</UL><H4><A NAME="DSLINESE">DSLineSE</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Esc \ s&#125;
<P>A line-drawing function similar to LineSE except that it inserts extra whitespace to draw at something like 45deg - the actual angle depends on your font size.</P>

</UL><H4><A NAME="DSLINESW">DSLineSW</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Esc / s&#125;
<P>A line-drawing function similar to LineSE except that it inserts extra whitespace to draw at something like 45deg - the actual angle depends on your font size.</P>

</UL><H4><A NAME="DSLINENE">DSLineNE</H4>
&#062; &#091;&#060;string&#062;&#093;&#123;Esc / n&#125;
<P>A line-drawing function similar to LineNE except that it inserts extra whitespace to draw at something like 45deg - the actual angle depends on your font size.</P>

</UL><H4><A NAME="BOX">Box</H4>
&#062; &#091;&#060;width&#062; &#060;height&#062;&#093;&#123;Esc b x&#125;
<P>This draws a box, using hyphens ( - ) and vertical bars ( | ), with the top-left corner of the box at the current cursor position. If the dimensions are not specified, the box size defaults to 10 characters wide by 5 lines high.</P>

</UL><H4><A NAME="LOZENGE">Lozenge</H4>
&#062; &#091;&#060;size&#062;&#093;&#123;Esc z 1&#125;
<P>This draws a lozenge shape using slashes ( / ) and backslashes ( \ ). The size is the number of slashes down any side, and defaults to 5.</P>

</UL><H4><A NAME="DSLOZENGE">DSLozenge</H4>
&#062; &#091;&#060;size&#062;&#093;&#123;Esc z2&#125;
<P>Similar to the <A HREF="#LOZENGE">Lozenge</A> function except that it uses double-spacing.</P>

</UL><H4><A NAME="BOXTEXT">BoxText</H4>
&#062; &#060;string&#062;&#123;Ctrl+Alt+KP_5&#125;
<P>or</P>

&#062; &#060;string&#062;&#123;Esc b t&#125;
<P>This inserts text into an area bounded my line drawn with Hyphens ( - ), Vertical bars ( | ), or slashes ( / and \ ). It is intended to simplify the process of labelling boxes where the label requires more than one line in the box.</P>


</UL><H3><A NAME="HOUSEKEEPING FUNCTIONS">Housekeeping Functions</H3>
</UL><H4><A NAME="AGAIN">Again</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;F10&#125;
<P>Repeats last command or hotkey once by default or n times if n is specified if n is zero then the command is repeated to exhaustion.</P>

</UL><H4><A NAME="INSERTMODE">InsertMode</H4>
&#062; &#123;Esc I n&#125;
<P>Enters insert mode, mode persists until &#123;Ctrl+c&#125; or next &#123;Esc I n&#125;.</P>

</UL><H4><A NAME="TEMPINSERTMODE">TempInsertMode</H4>
&#062; &#123;Esc i n&#125;
<P>Temporarily enters insert mode, mode persists until next escape-sequence or function-key operation.</P>

</UL><H4><A NAME="QUITDEBUGGER">QuitDebugger</H4>
&#062; &#123;Esc q&#125;
<P>Exits the debugger prompt loop and continues to the next <A HREF="jot_tech.html#T">T</A> command - see also <A HREF="#ABOUT JOT DEBUGGING">About jot debugging</A>.</P>

</UL><H4><A NAME="CMDEDITSTART">CmdEditStart</H4>
&#062; &#123;Esc c e&#125;
<P>Switches from your current view to a list of recent commands followed by whatever you might have been typing to the console. By default only the last 20 commands are saved this limit can be changed with the <A HREF="jot_tech.html#-HISTORY">-History</A> command-line qualifier. </P>

<P>Select one of these command lines for re-execution by placing the cursor anywhere in the line and invoking <A HREF="#CMDEDITGO">CmdEditGo</A>. The line can be edited if necessary using normal editing functions - see <A HREF="#ABOUT COMMAND EDITING">about command editing</A>.</P>

</UL><H4><A NAME="CMDEDITGO">CmdEditGo</H4>
&#062; &#123;Esc c g&#125;
<P>Returns from the command-edit screen (see <A HREF="#CMDEDITSTART">CmdEditStart</A>) to your original context and leaves the selected command string in the console - (see <A HREF="#ABOUT COMMAND EDITING">about command editing</A>).</P>

</UL><H4><A NAME="CMDSTRING">CmdString</H4>
&#062; &#060;JotCommandString&#062;&#123;Esc c s&#125;
<P>This is only useful when the editor is being used in insert mode. It offers a route for manually-entered commands. In insert mode the escape sequence is typed in first, then the command string is entered in response to a prompt - see <A HREF="jot_tech.html#ABOUT COMMAND PARAMETERS">about command parameters</A>.</P>

</UL><H4><A NAME="VIEWLEFT">ViewLeft</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;Ctrl+Shift+LeftArrow&#125;
<P>Shifts the buffer view n columns leftwards, n defaults to 1.</P>

</UL><H4><A NAME="VIEWRIGHT">ViewRight</H4>
&#062; &#091;&#060;n&#062;&#093;&#123;Ctrl+Shift+RightArrow&#125;
<P>Shifts the buffer view n columns rightwards, n defaults to 1.</P>

</UL><H4><A NAME="WINDOWONE">WindowOne</H4>
&#062; &#123;Esc w 1&#125;
<P>Restores display to a simple window showing current buffer.</P>

<P>Window height is calculated so as to leave 4 lines for the console display. The size of the window can be adjusted using the <A HREF="#WINDOWSHRINK">WindowShrink</A> function, to increase the size of the console area at the expense of the window or <A HREF="#WINDOWSTRETCH">WindowStretch</A> function, to increase the size of the window at the expense of the console.</P>

<P>See also <A HREF="#WINDOWHORIZSPLIT">WindowHorizSplit</A> and <A HREF="#WINDOWVERTSPLIT">WindowVertSplit</A> functions.</P>

</UL><H4><A NAME="WINDOWHORIZSPLIT">WindowHorizSplit</H4>
&#062; &#123;Esc w h&#125;
<P>Horizontal split display to one more window than is currently on display.</P>

<P>This function counts the total number of windows &#060;n&#062; currently displayed on screen, irrespective of their current configuration, and redefines the windows as &#060;n+1&#062; horizontal strips, leaving a 1-line console area. The size of a window can be adjusted using <A HREF="#WINDOWSHRINK">WindowShrink</A> and <A HREF="#WINDOWSTRETCH">WindowStretch</A> - note the optional window-selection argument to these functions.</P>

<P>The new-window focus is initially set to the current buffer - this may be displayed by some other window. Any focus-change operation (<A HREF="jot_tech.html#Z">Z</A>, <A HREF="jot_tech.html#%I">%I</A>, <A HREF="jot_tech.html#%Q">%Q</A> etc. ) will affect the bottom window on the display.</P>

<P>See also <A HREF="#WINDOWONE">WindowOne</A> and <A HREF="#WINDOWVERTSPLIT">WindowVertSplit</A> functions.</P>

</UL><H4><A NAME="WINDOWVERTSPLIT">WindowVertSplit</H4>
&#062; &#123;Esc w v&#125;
<P>Vertical split of the display terminal into one more window slices than is currently on display.</P>

<P>This function counts the total number of windows &#060;n&#062; currently displayed on screen, irrespective of their current configuration, and creates slices the whole screen into &#060;n+1&#062; vertical slices. The slice width is calculated to give the correct number of equal-width slices. The width of the slice can be adjusted using the <A HREF="#WINDOWSHRINK">WindowShrink</A> and <A HREF="#WINDOWSTRETCH">WindowStretch</A> functions - note the optional window-selection argument to these functions. The slice-heights are designed to give a 1-line console area.</P>

<P>Window height is calculated so as to leave 4 lines for the console display. To change the height of all slices in the slice group you must specify a new height for the first (leftmost) slice in the group - see <A HREF="jot_tech.html#%W">%W</A> - typically this will be window 0, In this case, the command to change the height would be:</P>

&#062; %w= -winno=0 -height=&#060;newHeight&#062;;
<P>See also <A HREF="#WINDOWONE">WindowOne</A> and <A HREF="#WINDOWHORIZSPLIT">WindowHorizSplit</A> functions.</P>

</UL><H4><A NAME="WINDOWALIGNTOP">WindowAlignTop</H4>
&#062; &#123;Esc w t&#125;
<UL><P>Adjusts view to bring the current line to the top of the viewing window.</P>

</UL><H4><A NAME="WINDOWALIGNCENT">WindowAlignCent</H4>
&#062; &#123;Esc w c&#125;
<UL><P>Adjusts view to bring the current line to the centre of the viewing window. If the current character is not visible (ie. outside the window's left and right margins - see <A HREF="jot_tech.html#ABOUT LONG LINES">about long lines</A>) then the left offset is adjusted to bring the current character into view.</P>

</UL><H4><A NAME="WINDOWALIGNBOT">WindowAlignBot</H4>
&#062; &#123;Esc w b&#125;
<UL><P>Adjusts view to bring the current line to the bottom of the viewing window.</P>

</UL><H4><A NAME="WINDOWSHRINK">WindowShrink</H4>
&#062; &#091;&#060;winno&#062;&#093;&#123;Ctrl+Alt+UpArrow&#125;
<P>or</P>

&#062; &#091;&#060;winno&#062;&#093;&#123;Esc w -&#125;
<P>Reduces the height of the specified &#091;or current&#093; window by 1 line. If the window ends up with a width of 0 or less, then the window is deleted.</P>

<P>Normally there will be only one window, where there is more than one window and no window number is specified then the first window displaying the current buffer is shrunk. Note that slices (vertically split screens) it is the width of the specified slice that is adjusted.</P>

<P>See also <A HREF="#WINDOWSTRETCH">WindowStretch</A>.</P>

</UL><H4><A NAME="WINDOWSTRETCH">WindowStretch</H4>
&#062; &#091;&#060;winno&#062;&#093;&#123;Ctrl+Alt+DownArrow&#125;
<P>or</P>

&#062; &#091;&#060;winno&#062;&#093;&#123;Esc w +&#125;
<P>Increases the height of the specified &#091;or current&#093; window by 1 line.</P>

<P>Normally there will be only one window, where there is more than one window and no window number is specified then the first window displaying the current buffer is stretched. Note that slices (vertically split screens) it is the width of the specified slice that is adjusted.</P>

<P>See also <A HREF="#WINDOWSHRINK">WindowShrink</A>.</P>

</UL><H4><A NAME="WINDOWDOWN">WindowDown</H4>
&#062; &#123;Esc w d&#125;
<UL><P>Shifts focus to the next window - windows are ordered left-to-right then top-to-bottom as they appear on the screen. If the current focus is already in the last (rightmost, bottommost) window, then focus is switched to the first (topmost and leftmost) window.</P>

</UL><H4><A NAME="WINDOWUP">WindowUp</H4>
&#062; &#123;Esc w u&#125;
<P>Essentially the same as <A HREF="#WINDOWDOWN">WindowDown</A>, above, except that it moves through the windows from right-to-left and from bottom-to-top.</P>

</UL><H4><A NAME="WINDOWREASSIGN">WindowReassign</H4>
&#062; &#060;windowNo&#062;&#091; &#060;bufferKey&#062;&#093;&#123;Esc w r&#125;
<P>Changes the buffer binding for the specified window. If a buffer key is given then the window is bound to that buffer otherwise, the window is set to be floating - it displays whatever happens to be the current buffer.</P>

</UL><H4><A NAME="VIEWSAVE">ViewSave</H4>
&#062; &#091;&#060;viewName&#062;&#093;&#123;Esc v s&#125;  
<P>This function sets up a jump object and a data object (see <A HREF="jot_tech.html#ABOUT HASHTABLES">about hashtables</A>) named ViewJump_&#060;viewName&#062; and ViewJump_FirstLine_&#060;viewName&#062; respectively in the code repository hashtable. Where &#060;viewName&#062; is the given viewname - this name, rather imaginatively, defaults to "default". The view can be restored using the <A HREF="#VIEWRESTORE">ViewRestore</A> function.</P>

<P>In the event of a non-unique viewname, the new view replaces the original view.</P>

<P>Many different views can be held by assigning each a unique name, the actual limit is set by the total capacity of the code-repository-buffer ( ' ) hashtable, normally set to 1000, of which about 200 are used for the function names. View names may be of any length.</P>

</UL><H4><A NAME="VIEWRESTORE">ViewRestore</H4>
&#062; &#091;&#060;viewName&#062;&#093;&#123;Esc v r&#125;  
<P>This function restores a previously-saved view answering to the name &#060;viewName&#062;, as with <A HREF="#VIEWSAVE">ViewSave</A> the default view name is "default".</P>

</UL><H4><A NAME="ADDNEWFUNCTIONS">AddNewFunctions</H4>
&#062; %h'=call AddNewFunctions;
<P>This function is used by jot scripts to add new functions to the code repository. It assumes that the new functions have been defined in the @ buffer, it appends the contents of @ to the code repository and makes the correct hash-table entries.</P>

<P>For an example of usage look at $&#123;JOT_HOME&#125;/coms/get.jot.</P>


</UL><H3><A NAME="MOUSE-EVENT BINDINGS">Mouse-Event Bindings</H3>
<P>In Linux, where X-windows provides useful mouse functions, mouse-button events are all ignored by jot allowing them to be picked up by X-windows. In Windows, which has virtually no useful mouse actions, all normal mouse events are picked up by jot. This behaviour is defined in the startup script (see <A HREF="jot_coms.html#STARTUP.JOT">startup.jot</A>) and can be changed by adopting a custom startup script.</P>

</UL><H4><A NAME="NOTEFROMMOUSE">NoteFromMouse</H4>
&#062; &#123;Button2Down&#125; (&#123;Button1Down&#125; in windows).
<P>This picks up and notes the the coordinates of the button-press and sets a note point there.</P>

</UL><H4><A NAME="COPYFROMMOUSE">CopyFromMouse</H4>
&#062; &#123;Button2Up&#125; (&#123;Button1Up&#125; in windows).
<P>The note point is assumed to have been set by the Button-down event (see <A HREF="#NOTEFROMMOUSE">NoteFromMouse</A>).This picks up and notes the coordinates of the button-release and abstracts from the current note point to the position indicated by the mouse at Button-Up time.</P>

</UL><H4><A NAME="FOCUSTOMOUSE">FocusToMouse</H4>
&#062; &#123;Button2DoubleClick&#125;
<P>This picks up and notes the coordinates of the button-press and sets the editor focus point to the position indicated.</P>

</UL><H4><A NAME="INSERTHEREMOUSE">InsertHereMouse</H4>
&#062; &#123;Button3Click&#125;
<P>This picks up and notes the the coordinates of the button-press and inserts the contents of the _ buffer there.</P>


</UL><H3><A NAME="MOUSE-EVENT BINDINGS - WINDOWS">Mouse-Event Bindings - Windows</H3>
<P>One of the many crosses born by windows users is the lack of useful mouse actions. Especially selections and most particularly in windows consoles. The functions described below are not anything like as useful as X-windows selections but there we are ... any port in a storm.</P>

</UL><H4><A NAME="SELECTIONSTART">SelectionStart</H4>
&#062; &#123;Button1Down&#125;
<P>The mouse cursor position is noted - the real action takes place as the button is released.</P>

</UL><H4><A NAME="SELECTIONEND">SelectionEnd</H4>
&#062; &#123;Button1Up&#125;
<P>The new mouse cursor position is noted and, if it is on the same line as for the &#123;Button1Down&#125; event the text between the two points is copied to a selection buffer without affecting the editors cursor.</P>

</UL><H4><A NAME="SELECTIONFREE">SelectionFree</H4>
&#062; &#123;Button1Click&#125;
<P>Any text in the selection buffer is deleted.</P>

</UL><H4><A NAME="SELECTIONWORD">SelectionWord</H4>
&#062; &#123;Button1DoubleClick&#125;
<P>The mouse-cursor position is noted and, if it corresponds to a word in the text, then that word is copied to the selection buffer. In this context a word is deemed to be any string consisting of alphanumeric characters or underscores.</P>

</UL><H4><A NAME="SELECTIONPUT">SelectionPut</H4>
&#062; &#123;Button2Click&#125;
<P>The position of the mouse cursor is irrelevant, the contents of the selection buffer is dumped into the command line.</P>


</UL><H3><A NAME="THE POPUP-MENU FUNCTIONS">The popup-menu functions</H3>
<P>The startup script defines <A HREF="#POPUPSEARCH">PopupSearch</A> and<A HREF="#POPUPINCREMENTALSEARCH">PopupIncrementalSearch</A> - functions that search and list matching words in the popup menu. The popup can be driven by other scripts (eg <A HREF="jot_coms.html#DOC.JOT">doc.jot</A> - which uses it to pass spelling corrections suggested by Aspell). See also <A HREF="jot_walkthrough.html#USING THE POPUP MENU">Using the popup menu</A> for a quick tutorial on the popup.</P>

<P>Clicking on a popup-menu item launches "PopupMouseSelect" - the popup callback function which pushes the selected item back into the console area where it can be used as a parameter to any jot function that takes a string argument. It also clears the popup from the screen to get it back again call PopupRestore.</P>

<P>The two search functions "PopupSearch" and "PopupIncrementalSearch" both search the current buffer in different ways and report their results in the form of a popup menu. various functions defined by the <A HREF="jot_coms.html#DOC.JOT">doc.jot</A> script also handle popup menus.</P>

<P>In the event of the popup menu being longer than the popup window, two popup-scrolling functions are provided <A HREF="#POPUPPAGEUP">PopupPageUp</A> and <A HREF="#POPUPPAGEDOWN">PopupPageDown</A>.</P>

</UL><H4><A NAME="POPUPRESTORE">PopupRestore</H4>
&#062; &#123;Esc p r&#125;
<P>This restores the popup menu following a mouse-click event (see <A HREF="#POPUPMOUSESELECT">PopupMouseSelect</A>) or can be called directly by some script that has set up something to be displayed as a popup menu.</P>

<P>A new popup menu must be predefined in the ( - ) buffer, in the form of a list of menu items with each item on a new line. Items may contain whitespace but any leading or trailing whitespace is removed before display.</P>

<P>If no new popup is defined ( the ( - ) buffer is empty) then the last-used menu is used, this is held in the data object "'=PopupMenu".</P>

<P>The PopupRestore function is called by <A HREF="#POPUPSEARCH">PopupSearch</A> and by the <A HREF="jot_coms.html#DOC.JOT">doc.jot</A> script, which offers suggested spelling corrections via the popup menu.</P>

</UL><H4><A NAME="POPUPSEARCH">PopupSearch</H4>
&#062; &#060;substring&#062;&#123;Esc p s&#125;
<P>This searches the current buffer for words matching the given string. Matching words (any string consisting of ASCII alphanumeric characters and underscores) are displayed in the popup menu and may be selected by a click of the left mouse button (see <A HREF="#POPUPMOUSESELECT">PopupMouseSelect</A>).</P>

</UL><H4><A NAME="POPUPINCREMENTALSEARCH">PopupIncrementalSearch</H4>
&#062; &#123;Esc p i&#125;
<P>This performs an incremental search - incremental in the sense that it prompts and picks up characters one at a time updating the popup as the search string grows.</P>

<P>Each time a new character is entered it is appended to the search string and the whole file is scanned for words containing the revised search string. The list of matching words is displayed in the popup.</P>

<P>The function is UTF-8 friendly and respects the backspace key. Terminate the incremental search with the &#123;Return&#125; key.</P>

<P>As usual, with jot popups, clicking on a popup line feeds that word into the console, where it can be used as an argument to any jot function that takes a text-string argument.</P>

</UL><H4><A NAME="POPUPMOUSESELECT">PopupMouseSelect</H4>
&#062; &#123;Left-click in popup menu&#125;
<P>This function is set up as the callback for a left-click event. It identifies the menu item and copy's it into the console command stream. Then it can be used by any function that picks up an argument from the console. It could be used to substitute the current word with &#123;F5&#125; - see <A HREF="#SUBSTITUTE">Substitute</A></P>

</UL><H4><A NAME="POPUPPAGEUP">PopupPageUp</H4>
&#062; &#123;Esc p u&#125;
<P>or</P>

&#062; &#123;Ctrl+Alt+PageUp&#125;
<P>Scrolls the popup window to reveal the page above the currently-visible page and reports current position.</P>

</UL><H4><A NAME="POPUPPAGEDOWN">PopupPageDown</H4>
&#062; &#123;Esc p d&#125;
<P>or</P>

&#062; &#123;Ctrl+Alt+PageDown&#125;
<P>Scrolls the popup window to reveal the page below the currently-visible page and reports current position.</P>
