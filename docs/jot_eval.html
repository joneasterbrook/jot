<! Made with jot using doc2html >
<link rel="stylesheet" href="main.css" type="text/css">
</UL><H1><A NAME="JOT EVALUATION">Jot Evaluation</H1>

</UL><H2><A NAME="TEXT-EDITOR EVALUATION AND COMPARISON">Text-editor evaluation and comparison</H2>
<P>This note compares jot to several popular text editors. See also</P>

<UL><P>https://en.wikipedia.org/wiki/Editor_war</P>

</UL><P>and</P>

<UL><P>https://en.wikipedia.org/wiki/Comparison_of_text_editors</P>

</UL><P>On my linux installation (a Fedora 27) the vi command launches a vim:</P>

<PRE>
$ vi --version
VIM - Vi IMproved 8.0 (2016 Sep 12, compiled Oct  6 2017 15:20:00)
...
</PRE>
<P>The editors included in this comparison were:</P>

<UL><P><LI>jot v2.3.1</P></LI>

<P><LI>vim 8.0</P></LI>

<P><LI>gvim v8.0.1573</P></LI>

<P><LI>emacs 25.3.1</P></LI>

<P><LI>nano 2.8.7</P></LI>


</UL><H3><A NAME="METHODOLOGY">Methodology</H3>
<P>The performance assessments were done on an otherwise idle quad-core Intel 64-bit linux box the only other user processes running were top and vmstat:</P>

<PRE>
$ uname -a
Linux localhost.localdomain 4.13.9-300.fc27.x86_64 #1 SMP Mon Oct 23 13:41:58 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
</PRE>
<P>For editors that allow commands to be entered via the CLI (jot, vim and gvim) this method was used as it avoids including the time taken to fumble with the mouse and keyboard.</P>

<P>emacs has a non-interactive mode - not really quite the same thing as an interactive editor that allows initialization commands from the command line and we're trying to compare like with like. Anyway, most tests include two results for emacs - one for a non-interactive lisp script and another for normal interactive mode. In some cases the lisp-script version was several orders of magnitude faster - far more than could be explained away by my slow typing or the requirement to update the screen. The lisp-script version gives the impression of being an entirely different editor.</P>

<P>The vim installation came out of the box with my linux (Fedora 27) masquerading as vi, the gvim and emacs were the default downloads from Fedora, nano was also out of the box.</P>

<P>In general, for quick-running tests (anything under about 2 minutes) the test was repeated and the quoted results are for the best of three. The only exceptions were the image-activation tests. For these, in order to clear the cache and swap files, the computer was restarted and each editor was fired up only once. In the case of emacs, the system was restarted for each case.</P>

<P>Any test that dragged on for more than 30 minutes was killed.</P>

<P>I used GNU time 1.7 - this has the option to collect other performance data</P>

<UL><P><LI>although this additional data was not as significant as the elapsed-time</P></LI>

<P>result, it gives some insight into what was going on for under-performing tests.</P>

<P>Both jot and nano are, by default case insensitive whereas vim, gvim and emacs are case sensitive. Case sensitive searches are simpler and one would expect them to run a little faster. All jot runs include a command to make searches case sensitive.</P>

<P>The values in the <A HREF="#TEXT DENSITY">text density</A> section were obtained from the RSS field of the time reports in the <A HREF="#LOADING A BIG FILE">Loading a big file</A> section. The numbers were verified using /usr/bin/pmap which gave roughly the same results.</P>

<P>In all cases the session was abandoned without writing back to the filing system.</P>


</UL><H3><A NAME="IMAGE SIZE">Image size</H3>
<P>The image sizes refer to the executable-image size for the most recent linux-64 versions. This just looks at the size of the main image, in the case of emacs, after following links, then ls -l.</P>

<UL><P><LI>jot 521216 The stripped version with dynamically-linked ncurses is 191512</P></LI>

<P><LI>vim 1102216</P></LI>

<P><LI>gvim 3320904</P></LI>

<P><LI>emacs 16913736</P></LI>

<P><LI>nano 239944</P></LI>

</UL><P>Of course image size depends on how the image is linked. All are dynamically linked to /usr/lib64 libraries, interestingly, while jot, gvim and nano link to the gnu ncurses lib, vim and emacs seem to make their own arrangements. Yet, strangely, gvim uses ncurses and it's a much bigger image than vim.</P>


</UL><H3><A NAME="IMAGE ACTIVATION TIME">Image activation time</H3>
<P>The elapsed time is not particularly reliable in the case of emacs and nano, since these do not seem to offer any options to enter editor commands from the command line. For nano and emacs the session was quickly closed using interactive commands.</P>

<UL><P><LI>jot </P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot t.t -in="%a"
  0:00.14 elapsed, 0.01 user, 0.00 system, 10% CPU, (3 major + 347 minor) faults, 1520 io, 3892 rss
</PRE>
</UL><P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi t.t -c:q
  0:00.05 elapsed, 0.00 user, 0.00 system, 5% CPU, (8 major + 206 minor) faults, 2160 io, 4064 rss
</PRE>
<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim t.t -v -c:q
  0:00.29 elapsed, 0.02 user, 0.01 system, 14% CPU, (26 major + 1411 minor) faults, 7488 io, 18556 rss
</PRE>
<UL><P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs -nw t.t
</PRE>
<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<PRE>
  0:02.96 elapsed, 0.09 user, 0.04 system, 4% CPU, (216 major + 4175 minor) faults, 69840 io, 50212 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "t.t")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
  0:02.01 elapsed, 0.09 user, 0.04 system, 6% CPU, (211 major + 3049 minor) faults, 67808 io, 48396 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano t.t
  0:00.51 elapsed, 0.02 user, 0.00 system, 5% CPU, (2 major + 715 minor) faults, 9328 io, 9220 rss
</PRE>

</UL><H3><A NAME="LOADING A BIG FILE">Loading a big file</H3>
<P>A sample file was created by jot using these commands:</P>

<PRE>
$ rm big_file.txt
$ jot /dev/null -in="%eq=ls -RF /usr/lib64; %r=ls2list; \
</PRE>
<P>ol1000000000 m-0((%i.='q -binary 64; i'qbr0b %o=big_file.txt -append;, ) %q$=file big_file.txt; f/ size = /-oid o&#062; zqm)0"</P>

<P>It turns out that the actual file size was 1000679059. It contained 75300980 instances of the string "00" and 20422442 instances of the string "99".</P>

<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in=%a
0:03.47 elapsed, 2.01 user, 1.05 system, 88% CPU, (8 major + 638535 minor) faults, 98216 io, 2556520 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c:q
0:07.44 elapsed, 3.87 user, 0.81 system, 62% CPU, 23 faults, 795248 io, 1251080 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c:q
0:04.13 elapsed, 3.43 user, 0.62 system, 98% CPU, 0 faults, 680 io, 1265032 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
</PRE>
<P><LI>y - Yes I really do want to read a big file.</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<PRE>
0:05.19 elapsed, 3.55 user, 0.53 system, 78% CPU, (2 major + 276771 minor) faults, 104 io, 1149140 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_file.txt")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
0:03.73 elapsed, 3.23 user, 0.49 system, 99% CPU, (0 major + 272060 minor) faults, 0 io, 1123744 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
</PRE>
<P>&#123;Ctrl+x&#125; - to exit.</P>

<PRE>
0:37.28 elapsed, 36.16 user, 0.90 system, 99% CPU, 5 faults, 9880 io, 2459268 rss
</PRE>

</UL><H3><A NAME="TEXT DENSITY">Text density</H3>
<P>See <A HREF="#METHODOLOGY">methodology</A> notes.</P>

<UL><P><LI>jot - 2556520 2.556520</P></LI>

<P><LI>vim - 1251080 1.251080</P></LI>

<P><LI>gvim - 1265032 1.265032</P></LI>

<P><LI>emacs - 1149140 1.149140 (interactive)</P></LI>

<P><LI>emacs - 1123744 1.123744 (.el-lisp script)</P></LI>

<P><LI>nano - 2459268 2.459268</P></LI>


</UL><H3><A NAME="LOADING A BIG FILE AND SEARCHING FORWARDS">Loading a big file and searching forwards</H3>
<P>The big_file.txt is loaded again and this time each editor is set to search the entire file for a nonexistent string.</P>

<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="%s=case 1; f/zzz/? %a"
0:09.27 elapsed, 6.35 user, 1.21 system, 81% CPU, (10 major + 638534 minor) faults, 740488 io, 2556728 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c/zzz/ +:q
0:18.72 elapsed, 14.49 user, 1.29 system, 84% CPU, 19 faults, 820568 io, 1251312 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c/zzz/ +:q
0:09.31 elapsed, 8.59 user, 0.70 system, 99% CPU, (0 major + 313416 minor) faults, 0 io, 1265224 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
</PRE>
<P><LI>y - Yes I really do want to read a big file.</P></LI>

<P><LI>&#123;Ctrl+s&#125;zzz&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<PRE>
0:12.98 elapsed, 10.48 user, 0.53 system, 84% CPU, (0 major + 277001 minor) faults, 16 io, 1150076 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_file.txt")
(search-forwards "zzz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
0:03.71 elapsed, 3.20 user, 0.49 system, 99% CPU, (0 major + 272229 minor) faults, 0 io, 1124272 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
</PRE>
<P><LI>&#123;Ctrl+w&#125;zzz</P></LI>

<P><LI>&#123;Ctrl+x&#125;</P></LI>

<PRE>
2:18.92 elapsed, 135.42 user, 0.93 system, 98% CPU, 0 faults, 159784 io, 2459172 rss
</PRE>

</UL><H3><A NAME="LOADING A BIG FILE AND DOING A GLOBAL SEARCH AND REPLACE - 1">Loading a big file and doing a global search and replace - 1</H3>
<P>In this case the replacement string is the same length as the original. My big_file.txt had 96860652 instances if the search string "00".</P>

<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="%s=case 1; (f/00/s/zz/)0 %a"
0:22.67 elapsed, 20.38 user, 1.14 system, 94% CPU, (7 major + 638536 minor) faults, 462272 io, 2556464 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c:%s/00/zz/g +:q!
0:54.96 elapsed, 34.97 user, 3.83 system, 70% CPU, 4606 faults, 957048 io, 3552576 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c:%s/00/zz/g +:q!
1:19.04 elapsed, 39.14 user, 3.79 system, 54% CPU, 5426 faults, 2421776 io, 3583744 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
</PRE>
<P><LI>y - Yes I really want to open a big file.</P></LI>

<P><LI>&#123;Alt+x&#125;replace-string&#123;Return&#125;00&#123;Return&#125;zz&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<P><LI>n - I don't want the file image writing out.</P></LI>

<P><LI>yes&#123;Return&#125; - I still don't want the file image writing and I still want to get out of emacs.</P></LI>

<PRE>
17:06.93 elapsed, 1002.50 user, 1.98 system, 97% CPU, (2 major + 816832 minor) faults, 480 io, 1181416 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_file.txt")
(replace-string "00" "zz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
15:14.29 elapsed, 910.98 user, 0.79 system, 99% CPU, (0 major + 283041 minor) faults, 56 io, 1143092 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
</PRE>
<P><LI>&#123;Ctrl+\&#125;00&#123;Return&#125;zz&#123;Return&#125;a&#123;Return&#125;</P></LI>

<P><LI>After about 10 minutes it crashed my linux session.</P></LI>


</UL><H3><A NAME="LOADING A BIG FILE AND DOING A GLOBAL SEARCH AND REPLACE - 2">Loading a big file and doing a global search and replace - 2</H3>
<P>In this case the replacement string is the longer than the original. This is an important difference since our editors must somehow shuffle the text and allocate more memory for the extended lines.</P>

<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="%s=case 1; (f/00/s/abcdefghi/)0 %a"
0:34.34 elapsed, 30.26 user, 1.77 system, 93% CPU, (31 major + 943014 minor) faults, 384776 io, 3559384 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c:%s/00/abcdefghi/g +:q!
12:36.20 elapsed, 78.23 user, 13.76 system, 12% CPU, (46370 major + 1311186 minor) faults, 6721408 io, 3531524 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c:%s/00/abcdefghi/g +:q!
17:49.37 elapsed, 607.37 user, 16.02 system, 58% CPU, (66980 major + 1694965 minor) faults, 8311200 io, 3542908 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
</PRE>
<P><LI>y - Yes I really want to open a big file.</P></LI>

<P><LI>&#123;Alt+x&#125;replace-string&#123;Return&#125;00&#123;Return&#125;zz&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<P><LI>n - I don't want the file image writing out.</P></LI>

<P><LI>yes&#123;Return&#125; - I still don't want the file image writing and I still want to get out of emacs.</P></LI>

<PRE>
17:06.93 elapsed, 1002.50 user, 1.98 system, 97% CPU, (2 major + 816832 minor) faults, 480 io, 1181416 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_file.txt")
(replace-string "00" "abcdefghi")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
20:55.74 elapsed, 1165.36 user, 2.45 system, 92% CPU, (396 major + 814215 minor) faults, 2255032 io, 1185052 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt  
</PRE>
<P><LI>&#123;Ctrl+\&#125;00&#123;Return&#125;abcdefghi&#123;Return&#125;a&#123;Return&#125;</P></LI>

<P><LI>As before, after a few minutes it crashed my linux session.</P></LI>


</UL><H3><A NAME="LOADING A BIG FILE AND DOING A GLOBAL REGEX-SEARCH AND REPLACE">Loading a big file and doing a global regex-search and replace</H3>
<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="(%f=&#091;^a-zA-Z0-9&#093;00&#091;^a-zA-Z0-9&#093;;s/ zz /)0 %a;"
14:01.91 elapsed, 834.67 user, 1.59 system, 99% CPU, (2 major + 695160 minor) faults, 1353128 io, 2783112 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c":%s/&#091;^a-zA-Z0-9&#093;00&#091;^a-zA-Z0-9&#093;/ zz /g" +:q!
2:35.86 elapsed, 110.08 user, 34.62 system, 92% CPU, (2742 major + 932154 minor) faults, 146392 io, 3551876 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c":%s/&#091;^a-zA-Z0-9&#093;00&#091;^a-zA-Z0-9&#093;/ zz /g" +:q!
2:41.29 elapsed, 119.19 user, 18.48 system, 85% CPU, (2176 major + 969954 minor) faults, 2273216 io, 3569676 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
</PRE>
<P><LI>y - Yes I really want to open a big file.</P></LI>

<P><LI>&#123;Alt+x&#125;replace-string&#123;Return&#125;00&#123;Return&#125;zz&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<P><LI>n - I don't want the file image writing out.</P></LI>

<P><LI>yes&#123;Return&#125; - I still don't want the file image writing and I still want to get out of emacs.</P></LI>

<PRE>
17:06.93 elapsed, 1002.50 user, 1.98 system, 97% CPU, (2 major + 816832 minor) faults, 480 io, 1181416 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_file.txt")
(replace-regexp "&#091;^a-zA-Z0-9&#093;00&#091;^a-zA-Z0-9&#093;" " zz ")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
10:13.22 elapsed, 610.94 user, 0.60 system, 99% CPU, (1 major + 282484 minor) faults, 280 io, 1140232 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt  
</PRE>
<P>nano was excluded from this test.</P>


</UL><H3><A NAME="LOADING A FILE AND MOVING RIGHT TO THE END">Loading a file and moving right to the end</H3>
<P>The only reason for doing this is to obtain an accurate measurement of the reverse-search time.</P>

<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="m0 %a"
0:06.55 elapsed, 3.04 user, 1.34 system, 67% CPU, (3 major + 695168 minor) faults, 628648 io, 2782912 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c:G +:q!
0:08.26 elapsed, 4.16 user, 0.89 system, 61% CPU, (8 major + 312040 minor) faults, 1083528 io, 1251204 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim -v big_file.txt -c:G +:q!
0:04.08 elapsed, 3.44 user, 0.60 system, 99% CPU, (0 major + 313412 minor) faults, 8 io, 1265332 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
</PRE>
<P><LI>y - Yes I really do want to read a big file.</P></LI>

<P><LI>&#123;Esc &#062;&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<PRE>
0:29.68 elapsed, 20.23 user, 0.54 system, 70% CPU, (0 major + 276972 minor) faults, 0 io, 1149696 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_file.txt")
(goto-char (point-max))
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
0:03.72 elapsed, 3.19 user, 0.49 system, 99% CPU, (0 major + 272082 minor) faults, 0 io, 1124112 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
</PRE>
<P>&#123;Ctrl+_&#125;&#123;Ctrl+v&#125;&#123;Ctrl+x&#125;</P>

<PRE>
0:33.93 elapsed, 33.05 user, 0.83 system, 99% CPU, (0 major + 563730 minor) faults, 0 io, 2261060 rss
</PRE>

</UL><H3><A NAME="LOADING A FILE, MOVING RIGHT TO THE END THEN SEARCHING BACK">Loading a file, moving right to the end then searching back</H3>
<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="%s=case 1; m0 f-/zzz/? %a"
0:07.17 elapsed, 6.15 user, 0.99 system, 99% CPU, (0 major + 638540 minor) faults, 0 io, 2556580 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c:G +?zzz? +:q!
0:12.28 elapsed, 8.50 user, 0.98 system, 77% CPU, (21 major + 312038 minor) faults, 752872 io, 1251380 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c:G +?zzz? +:q!
0:10.61 elapsed, 8.15 user, 0.72 system, 83% CPU, (128 major + 313414 minor) faults, 29304 io, 1264924 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
</PRE>
<P><LI>y - Yes I really do want to read a big file.</P></LI>

<P><LI>&#123;Esc &#062;&#125;</P></LI>

<P><LI>&#123;Ctrl+r&#125;zzz</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<PRE>
0:29.68 elapsed, 20.23 user, 0.54 system, 70% CPU, (0 major + 276972 minor) faults, 0 io, 1149696 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_file.txt")
(goto-char (point-max))
(search-backward "zzz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
0:04.97 elapsed, 4.46 user, 0.49 system, 99% CPU, (0 major + 272229 minor) faults, 0 io, 1124180 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
</PRE>
<P><LI>&#123;Ctrl+_&#125;&#123;Ctrl+v&#125;</P></LI>

<P><LI>&#123;Alt+b&#125;</P></LI>

<P><LI>&#123;F6&#125;zzz&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;</P></LI>

<PRE>
2:26.64 elapsed, 135.73 user, 0.93 system, 93% CPU, (5 major + 613280 minor) faults, 147232 io, 2459312 rss
</PRE>

</UL><H3><A NAME="LOADING, CUTTING AND PASTING AND PASTING ALL OF A BIG FILE">Loading, cutting and pasting and pasting all of a big file</H3>
<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="n.m0aaha %a;"
0:35.42 elapsed, 6.35 user, 3.44 system, 27% CPU, (43 major + 1276767 minor) faults, 1960328 io, 3578088 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt
</PRE>
<UL><P><LI>v - enter visual-selection mode.</P></LI>

<P><LI>G&#123;Return&#125; - goto end of file</P></LI>

<P><LI>d - cut all the highlighted text.</P></LI>

<P><LI>P - paste it all back again.</P></LI>

<P><LI>:q!</P></LI>

<PRE>
1:57.08 elapsed, 14.33 user, 5.97 system, 17% CPU, (94996 major + 1804828 minor) faults, 6984168 io, 3578132 rss
</PRE>
</UL><P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v
</PRE>
<UL><P><LI>v - enter visual-selection mode.</P></LI>

<P><LI>G&#123;Return&#125; - goto end of file</P></LI>

<P><LI>d - cut all the highlighted text.</P></LI>

<P><LI>P - paste it all back again.</P></LI>

<P><LI>:q!</P></LI>

<PRE>
8:42.73 elapsed, 19.09 user, 16.60 system, 6% CPU, (248435 major + 3119208 minor) faults, 12886392 io, 3553940 rss
</PRE>
</UL><P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
</PRE>
<P><LI>y - Yes I really do want to read a big file.</P></LI>

<P><LI>&#123;Ctrl+@&#125; - to set a mark.</P></LI>

<P><LI>&#123;Esc &#062;&#125; - goto end</P></LI>

<P><LI>&#123;Ctrl+w&#125; - Cut</P></LI>

<P><LI>(Ctrl+y&#125; - Paste it back again.</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<P><LI>n - no I don't want to write the file</P></LI>

<P><LI>yes&#123;Return&#125; - let me out.</P></LI>

<PRE>
2:07.87 elapsed, 16.30 user, 6.12 system, 17% CPU, (33165 major + 1471901 minor) faults, 4204560 io, 3556208 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_file.txt")
(kill-region 1 (point-max))
(yank)
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
0:09.22 elapsed, 3.39 user, 1.07 system, 48% CPU, (144 major + 497113 minor) faults, 980416 io, 2021192 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
</PRE>
<UL><P><LI>&#123;Ctrl+^&#125; - to set a mark.</P></LI>

<P><LI>&#123;Alt+/&#125; - move to end</P></LI>

<P><LI>&#123;Ctrl+Shift+k&#125; - to cut</P></LI>

<P><LI>&#123;Ctrl+Shift+u&#125; - to paste</P></LI>

<P><LI>&#123;Ctrl+x&#125; - to exit.</P></LI>

</UL><P>Crashed the linux session after about 5 minutes.</P>


</UL><H3><A NAME="LOADING A FILE WITH VERY LONG LINES - A FAT FILE">Loading a file with very long lines - a fat file</H3>
<P>A file of just over 100MB was created with these command:</P>

<PRE>
$ rm fat_file.txt
$ jot /dev/null -in="%eq=ls -RF /usr/lib64; %r=ls2list; \
</PRE>
<P>ol100000000 m-0((%i.='q -binary 64; (m-0(jm)0m-)0 r-0i'qbr0b %o=fat_file.txt -append;, ) %q$=file fat_file.txt; f/ size = /-oid o&#062; zqm)0"</P>

<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot fat_file.txt -in=%a
0:00.32 elapsed, 0.26 user, 0.06 system, 99% CPU, (0 major + 33337 minor) faults, 0 io, 131980 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi fat_file.txt -c:q
0:04.54 elapsed, 3.07 user, 1.41 system, 98% CPU, (8 major + 1405333 minor) faults, 2160 io, 116448 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim fat_file.txt -v -c:q
0:04.66 elapsed, 3.17 user, 1.46 system, 99% CPU, (0 major + 1410216 minor) faults, 0 io, 143440 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs fat_file.txt
</PRE>
<P><LI>y - Yes I really do want to read a big file.</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<PRE>
0:03.10 elapsed, 0.36 user, 0.09 system, 14% CPU, (265 major + 27970 minor) faults, 75000 io, 147784 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "fat_file.txt")
(search-forwards "zzz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
0:00.41 elapsed, 0.35 user, 0.06 system, 99% CPU, (0 major + 28152 minor) faults, 0 io, 148308 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano fat_file.txt
</PRE>
<P><LI>&#123;Ctrl+x&#125; - to exit.</P></LI>

<PRE>
0:04.43 elapsed, 4.21 user, 0.08 system, 97% CPU, (1 major + 51042 minor) faults, 8856 io, 186912 rss
</PRE>

</UL><H3><A NAME="LOADING A FAT FILE AND SEARCHING">Loading a fat file and searching</H3>
<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot fat_file.txt -in="%s=case 1; f/zzz/? %a;"
0:00.67 elapsed, 0.59 user, 0.07 system, 99% CPU, (0 major + 33007 minor) faults, 0 io, 131864 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi fat_file.txt -c/zzz/ +:q
0:11.55 elapsed, 6.76 user, 4.75 system, 99% CPU, (0 major + 4755463 minor) faults, 0 io, 219552 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim fat_file.txt -v -c/zzz/ +:q
0:11.80 elapsed, 6.99 user, 4.76 system, 99% CPU, (0 major + 4781384 minor) faults, 0 io, 232112 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs fat_file.txt
</PRE>
<P><LI>y - Yes I really do want to read a big file.</P></LI>

<P><LI>&#123;Ctrl+s&#125;zzz&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<PRE>
0:06.58 elapsed, 1.29 user, 0.09 system, 21% CPU, (0 major + 32913 minor) faults, 0 io, 174632 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "fat_file.txt")
(search-forwards "zzz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
0:00.40 elapsed, 0.35 user, 0.05 system, 99% CPU, (0 major + 28144 minor) faults, 0 io, 148224 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano fat_file.txt
</PRE>
<P><LI>&#123;Ctrl+w&#125;zzz</P></LI>

<P><LI>&#123;Ctrl+x&#125; - to exit.</P></LI>

<PRE>
0:21.73 elapsed, 16.65 user, 0.10 system, 77% CPU, (0 major + 51012 minor) faults, 0 io, 186892 rss
</PRE>

</UL><H3><A NAME="LOADING A FAT FILE AND AND DOING A GLOBAL SEARCH AND REPLACE - 1">Loading a fat file and and doing a global search and replace - 1</H3>
<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot fat_file.txt -in="%s=case 1; (f/00/s/zz/)0 %a"
0:02.28 elapsed, 2.20 user, 0.07 system, 99% CPU, (0 major + 33010 minor) faults, 0 io, 131984 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi fat_file.txt -c:%s/00/zz/g +:q!
</PRE>
</UL><H4><A NAME="KILLED AT 30">Killed at 30</H4>
<P>56.24 elapsed, 1836.23 user, 1.51 system, 99% CPU, (0 major + 1427388 minor) faults, 0 io, 158044 rss</P>

<UL><P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim fat_file.txt -v -c:%s/00/zz/g +:q!
</PRE>
</UL><H4><A NAME="KILLED AT 30">Killed at 30</H4>
<P>28.54 elapsed, 1807.12 user, 1.75 system, 98% CPU, (26 major + 1416782 minor) faults, 8008 io, 170140 rss</P>

<UL><P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs fat_file.txt
</PRE>
<P><LI>y - Yes I really want to open a big file.</P></LI>

<P><LI>&#123;Alt+x&#125;replace-string&#123;Return&#125;00&#123;Return&#125;zz&#123;Return&#125;</P></LI>

</UL><H4><A NAME="KILLED AT 34">Killed at 34</H4>
<P>30.12 elapsed, 2016.00 user, 0.64 system, 97% CPU, (4 major + 86817 minor) faults, 199328 io, 204116 rss</P>

<UL><P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "fat_file.txt")
(replace-string "00" "zz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
1:32.63 elapsed, 92.22 user, 0.09 system, 99% CPU, (0 major + 33939 minor) faults, 0 io, 167012 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano fat_file.txt
</PRE>
<P><LI>&#123;Ctrl+\&#125;00&#123;Return&#125;zz&#123;Return&#125;a&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;</P></LI>

</UL><H4><A NAME="CRASHED AT 7">Crashed at 7</H4>
<P>32.92 elapsed, 403.85 user, 2.40 system, 89% CPU, (149 major + 1840211 minor) faults, 37648 io, 3579632 rss</P>


</UL><H3><A NAME="LOADING A FAT FILE AND AND DOING A GLOBAL SEARCH AND REPLACE - 2">Loading a fat file and and doing a global search and replace - 2</H3>
<P>This time the substitute string is a bit longer than the original but, to make it a bit easier for our editors, they're searching for a less commonly-occurring string "99" instead of "00" as before.</P>

<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot fat_file.txt -in="%s=case 1; (f/99/s/abcdefghi/)0 %a"
1:29.93 elapsed, 89.09 user, 0.10 system, 99% CPU, (0 major + 53370 minor) faults, 0 io, 152272 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi fat_file.txt -c:%s/99/abcdefghi/g +:q!
2:16.07 elapsed, 129.89 user, 4.91 system, 99% CPU, (0 major + 4827378 minor) faults, 0 io, 457824 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim fat_file.txt -v -c:%s/99/abcdefghi/g +:q!
2:17.18 elapsed, 131.03 user, 4.89 system, 99% CPU, (0 major + 4853298 minor) faults, 0 io, 470248 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs fat_file.txt
</PRE>
<P><LI>y - Yes I really want to open a big file.</P></LI>

<P><LI>&#123;Alt+x&#125;replace-string&#123;Return&#125;99&#123;Return&#125;zz&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<P><LI>n - I don't want the file image writing out.</P></LI>

<P><LI>yes&#123;Return&#125; - I still don't want the file image writing and I still want to get out of emacs.</P></LI>

<PRE>
0:59.38 elapsed, 12.12 user, 0.27 system, 20% CPU, (113 major + 80831 minor) faults, 31176 io, 188152 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "fat_file.txt")
(replace-string "99" "abcdefghi")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
0:07.65 elapsed, 7.11 user, 0.49 system, 99% CPU, (0 major + 276715 minor) faults, 32 io, 1139720 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano fat_file.txt
</PRE>
<P><LI>&#123;Ctrl+\&#125;99&#123;Return&#125;abcdefghi&#123;Return&#125;a&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;</P></LI>

<PRE>
6:56.64 elapsed, 396.59 user, 2.41 system, 95% CPU, (715 major + 1841675 minor) faults, 377632 io, 3588260 rss
</PRE>

</UL><H3><A NAME="LOADING A BIG FAT FILE - BIG_FAT_FILE.TXT">Loading a big fat file - big_fat_file.txt</H3>
<P>A file of just over 1GB was created with these commands:</P>

<PRE>
$ rm big_fat_file.txt
$ jot /dev/null -in="%eq=ls -RF /usr/lib64; %r=ls2list; \
</PRE>
<P>ol1000000000 m-0((%i.='q -binary 64; (m-0(jm)0m-)0 r-0i'qbr0b %o=big_fat_file.txt -append;, ) %q$=file big_fat_file.txt; f/ size = /-oid o&#062; zqm)0"</P>

<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_fat_file.txt -in=%a
0:01.16 elapsed, 0.55 user, 0.59 system, 99% CPU, (0 major + 271742 minor) faults, 0 io, 1020488 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_fat_file.txt -c:q
0:19.97 elapsed, 16.87 user, 3.00 system, 99% CPU, (0 major + 2575870 minor) faults, 0 io, 1008944 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_fat_file.txt -v -c:q
0:20.20 elapsed, 17.04 user, 3.06 system, 99% CPU, (0 major + 2581583 minor) faults, 0 io, 1039776 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_fat_file.txt
</PRE>
<P><LI>y - Yes I really do want to read a big file.</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<PRE>
0:05.18 elapsed, 3.16 user, 0.50 system, 70% CPU, (0 major + 254962 minor) faults, 0 io, 1059484 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_fat_file.txt")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
0:03.24 elapsed, 2.78 user, 0.44 system, 99% CPU, (0 major + 250083 minor) faults, 0 io, 1036432 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_fat_file.txt
</PRE>
<P><LI>&#123;Ctrl+x&#125; - to exit.</P></LI>

<PRE>
0:33.70 elapsed, 32.99 user, 0.46 system, 99% CPU, (3 major + 259449 minor) faults, 10352 io, 1020272 rss
</PRE>

</UL><H3><A NAME="LOADING A BIG FAT FILE AND SEARCHING">Loading a big fat file and searching</H3>
<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_fat_file.txt -in="%s=case 1; f/zzz/? %a;"
0:04.56 elapsed, 3.93 user, 0.61 system, 99% CPU, (0 major + 271744 minor) faults, 0 io, 1020440 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_fat_file.txt -c/zzz/ +:q
0:25.80 elapsed, 22.77 user, 2.91 system, 99% CPU, (0 major + 2575873 minor) faults, 8 io, 1008952 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_fat_file.txt -v -c/zzz/ +:q
0:25.86 elapsed, 22.69 user, 3.06 system, 99% CPU, (0 major + 2581579 minor) faults, 0 io, 1039444 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_fat_file.txt
</PRE>
<P><LI>y - Yes I really want to open a big file.</P></LI>

<P><LI>&#123;Ctrl+s&#125;zzz&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<PRE>
0:12.58 elapsed, 10.26 user, 0.47 system, 85% CPU, (0 major + 254895 minor) faults, 0 io, 1062112 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_fat_file.txt
</PRE>
<P><LI>y - Yes I really do want to read a big file.</P></LI>

<P><LI>&#123;Ctrl+s&#125;zzz&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<PRE>
0:11.01 elapsed, 9.07 user, 0.49 system, 86% CPU, (0 major + 254816 minor) faults, 0 io, 1060732 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_fat_file.txt")
(search-forwards "zzz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
0:03.25 elapsed, 2.80 user, 0.44 system, 99% CPU, (0 major + 250268 minor) faults, 0 io, 1036408 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_fat_file.txt
</PRE>
<P><LI>&#123;Ctrl+w&#125;zzz</P></LI>

<P><LI>&#123;Ctrl+x&#125; - to exit.</P></LI>

<PRE>
2:07.22 elapsed, 125.34 user, 0.48 system, 98% CPU, (0 major + 259416 minor) faults, 0 io, 1020316 rss
</PRE>

</UL><H3><A NAME="LOADING A BIG FAT FILE AND AND DOING A GLOBAL SEARCH AND REPLACE - 1">Loading a big fat file and and doing a global search and replace - 1</H3>
<P>None of the editors performed particularly well at this test - to make things easier for them the search string was changed from "00" to the less commonly-occurring "99"</P>

<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_fat_file.txt -in="%s=case 1; (f/99/s/zz/)0 %a"
0:04.87 elapsed, 4.21 user, 0.65 system, 99% CPU, (0 major + 271743 minor) faults, 0 io, 1020448 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_fat_file.txt -c:%s/99/zz/g +:q!
5:21.72 elapsed, 315.29 user, 3.45 system, 99% CPU, (0 major + 2868852 minor) faults, 0 io, 1980576 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_fat_file.txt -v -c:%s/99/zz/g +:q!
5:22.95 elapsed, 313.89 user, 3.78 system, 98% CPU, (27 major + 2869893 minor) faults, 1971856 io, 1992508 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_fat_file.txt
</PRE>
<P><LI>y - Yes I really want to open a big file.</P></LI>

<P><LI>&#123;Alt+x&#125;replace-string&#123;Return&#125;99&#123;Return&#125;zz&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;&#123;Ctrl+c&#125;</P></LI>

<P><LI>n - No I don't want the file writing out.</P></LI>

<P><LI>yes&#123;Return&#125; - I still don't want the file image writing and I still want to get out.</P></LI>

<PRE>
2:17.23 elapsed, 118.42 user, 1.55 system, 87% CPU, (0 major + 504104 minor) faults, 0 io, 1083284 rss
</PRE>
<P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_fat_file.txt")
(replace-string "99" "zz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
0:09.79 elapsed, 6.20 user, 0.50 system, 68% CPU, (339 major + 254609 minor) faults, 86936 io, 1052068 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_fat_file.txt
</PRE>
<P><LI>&#123;Ctrl+\&#125;99&#123;Return&#125;zz&#123;Return&#125;a&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;</P></LI>

<P>This seems to have crashed at 13:43.55 elapsed, 596.73 user, 210.35 system, 98% CPU, (4 major + 194487152 minor) faults, 1966208 io, 1051672 rss</P>


</UL><H3><A NAME="LOADING A BIG FAT FILE AND AND DOING A GLOBAL SEARCH AND REPLACE - 2">Loading a big fat file and and doing a global search and replace - 2</H3>
<P>This time the substitute string is a bit longer than the original.</P>

<UL><P><LI>jot</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_fat_file.txt -in="%s=case 1; (f/99/s/abcdefghi/)0 %a"
13:19.73 elapsed, 586.50 user, 206.95 system, 99% CPU, (0 major + 194487229 minor) faults, 0 io, 1051324 rss
</PRE>
<P><LI>vim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_fat_file.txt -c:%s/99/abcdefghi/g +:q!
6:07.71 elapsed, 343.47 user, 20.50 system, 98% CPU, (8 major + 18713246 minor) faults, 2440 io, 2004156 rss
</PRE>
<P><LI>gvim</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_fat_file.txt -v -c:%s/99/abcdefghi/g +:q!
6:08.00 elapsed, 343.71 user, 20.07 system, 98% CPU, (26 major + 18714702 minor) faults, 7472 io, 2017948 rss
</PRE>
<P><LI>emacs (interactive)</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_fat_file.txt
</PRE>
<P><LI>y - Yes I really want to open a big file.</P></LI>

<P><LI>&#123;Alt+x&#125;replace-string&#123;Return&#125;99&#123;Return&#125;abcdefghi&#123;Return&#125;</P></LI>

</UL><H4><A NAME="GAVE UP - OUT OF MEMORY 2">Gave up - out of memory 2</H4>
<P>24.20 elapsed, 123.52 user, 1.83 system, 86% CPU, (1 major + 752843 minor) faults, 168 io, 1102836 rss</P>

<UL><P><LI>emacs (.el-lisp script)</P></LI>

<PRE>
$ cat - &#062; x.el &#060;&#060; end-of-lisp
(insert-file-contents "big_fat_file.txt")
(replace-string "99" "abcdefghi")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
Gave up, out of memory at   1:04.16 elapsed, 15.53 user, 5.05 system, 32% CPU, (1020 major + 2732208 minor) faults, 103768 io, 3551296 rss
</PRE>
<P><LI>nano</P></LI>

<PRE>
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_fat_file.txt
</PRE>
<P><LI>&#123;Ctrl+\&#125;99&#123;Return&#125;abcdefghi&#123;Return&#125;a&#123;Return&#125;</P></LI>

<P><LI>&#123;Ctrl+x&#125;</P></LI>

<P>Crashed after 5:40.93</P>


</UL><H3><A NAME="ANALYSIS OF PERFORMANCE COMPARISON.">Analysis of performance comparison.</H3>
<UL><P><LI><A HREF="#IMAGE SIZE">Image size</A> No-one, well no-one that's anyone, er. well hardly anyone, frets about the size of executables in this day and age but, if it were important, then jot would win hands down. All the other images have been stripped (symbolic debugging data removed) so, in the interests of comparing like with like, the size of a stripped jot with links to the sharable ncurses libraries has been included. A non-stripped jot with shared curses was used in the performance comparisons.</P></LI>

<P><LI><A HREF="#IMAGE ACTIVATION TIME">Image activation time</A> While there was some variation in the image-activation times, the biggest surprise was nano - one of the smallest executables but much slower than vim and gvim. Even, so this makes no real difference to the price of eggs. The biggest non-surprise was that emacs took considerably longer than all the others put together.</P></LI>

<P><LI><A HREF="#LOADING A BIG FILE">Loading a big file</A> To asses the reading speed which, for practical purposes includes the time taken to build the internal image structure, a fairly large file (about 1Gb) was used. Most of our editors were reasonably quick, although nano is just starting to look like the two-ounce weakling of the group.</P></LI>

<P><LI><A HREF="#TEXT DENSITY">Text density</A> This shows that the vims and emacs have compact internal data structures. This, in turn, suggests, that for any given system, they should capable of swallowing much bigger files. The actual capacity, for any given system, depends on system tuning. Meanwhile jot and nano have about half the data density and we'd expect them to reach system-defined limits with files roughly half the size of the vims and emacs. On my PC, vim and emacs can (eventually) load a 5GB file and jot and nano can not.</P></LI>

<P>Jot's internal record structure facilitates jot tags, hashtable jumps, sorting and various other useful features including support for files too big for vim to swallow. Yet the fact remains - vim can load 10GB files and jot can not.</P>

<P><LI><A HREF="#LOADING A BIG FILE AND SEARCHING FORWARDS">Loading a big file and searching forwards</A> Now we start to do something with our file image, search it for something, in this case, we see a continuation of the trend established in the previous batch of tasks</P></LI>

<UL><P><LI>namely that nano struggles with big files. The rest of our interactive</P></LI>

<P>editors all performed reasonably well, the non-interactive emacs being the star performer.</P>

</UL><P><LI><A HREF="#LOADING A BIG FILE AND DOING A GLOBAL SEARCH AND REPLACE - 1">Loading a big file and doing a global search and replace - 1</A> While both vim and emacs each have a built-in function for doing global search and replace. It would seem reasonable to expect these to outperform the jot interpretive approach - which essentially consists of find-string, replace-string and repeat to exhaustion. So how surprising was it that jot came an easy first in this task - by a country mile, in the case of emacs. Poor old nano, unfortunately, fell by the wayside.</P></LI>

<P><LI><A HREF="#LOADING A BIG FILE AND DOING A GLOBAL SEARCH AND REPLACE - 2">Loading a big file and doing a global search and replace - 2</A> In the previous task, the substituted string was the same length as the search string. This is not always the case, when the text shrinks or grows, text may have to be shifted, depending on the internal data structure. Furthermore, allowing the text to grow implies that more memory must be allocated and efficiently deployed. The next task is designed to sort the men from the boys. This time vim, gvim and emacs were all more-or-less comparable with jot an order of magnitude faster and, oh dear! nano...</P></LI>

<P><LI><A HREF="#LOADING A BIG FILE AND DOING A GLOBAL REGEX-SEARCH AND REPLACE">Loading a big file and doing a global regex-search and replace</A> This shows that jot's regular-expression engine is far less speedy than vim's. The non-interactive emacs managed to finish well ahead of the interactive version both emacs times being comparable to jot's.</P></LI>

<P><LI><A HREF="#LOADING A FILE, MOVING RIGHT TO THE END THEN SEARCHING BACK">Loading a file, moving right to the end then searching back</A> It could be that backwards-searching performs differently to forwards searching - thes results should be compared to the earlier section <A HREF="#LOADING A BIG FILE AND SEARCHING FORWARDS">Loading a big file and searching forwards</A>. Interestingly, emacs was much slower in reverse, the other editors were pretty much the same in either direction.</P></LI>

<P><LI><A HREF="#LOADING A FILE WITH VERY LONG LINES - A FAT FILE">Loading a file with very long lines - a fat file</A> Long lines can present special difficulties for editors. All of our editors swallowed this moderately large file (100MB) in good time.</P></LI>

<P><LI><A HREF="#LOADING A FAT FILE AND SEARCHING">Loading a fat file and searching</A> - All of the editors did this in reasonably good time although, some, less-so than others.</P></LI>

<P><LI><A HREF="#LOADING A FAT FILE AND AND DOING A GLOBAL SEARCH AND REPLACE - 1">Loading a fat file and and doing a global search and replace - 1</A> for this task, our editors were instructed to change all instances of "00" to "zz". Only jot and the lisp-script emacs managed to complete this task in under 30 minutes, vim and gvim fell over as did the usual suspect: nano.</P></LI>

<P><LI><A HREF="#LOADING A FAT FILE AND AND DOING A GLOBAL SEARCH AND REPLACE - 2">Loading a fat file and and doing a global search and replace - 2</A> In this test we set our editors the task of change every instance of the string "99" to "abcdefghi". Since there are quite a lot less of these, the editors might find this slightly easier. Most editors have to work harder when the new string is a different size to the original, especially when it's longer. The editors all completed this in reasonable time, once again, nano was far behind the main pack.</P></LI>

<P><LI><A HREF="#LOADING A BIG FAT FILE - BIG_FAT_FILE.TXT">Loading a big fat file - big_fat_file.txt</A> All editors swallowed this file in reasonable time, although nano was significantly slower than the rest.</P></LI>

<P><LI><A HREF="#LOADING A BIG FAT FILE AND SEARCHING">Loading a big fat file and searching</A> Jot was a bit faster than vim, gvim and the interactive emacs session, nano was much slower.</P></LI>

<P><LI><A HREF="#LOADING A BIG FAT FILE AND AND DOING A GLOBAL SEARCH AND REPLACE - 1">Loading a big fat file and and doing a global search and replace - 1</A> Jot was quite a lot faster, nano crashed but vim, gvim and interactive-emacs all got there in the end.</P></LI>

<P><LI><A HREF="#LOADING A BIG FAT FILE AND AND DOING A GLOBAL SEARCH AND REPLACE - 2">Loading a big fat file and and doing a global search and replace - 2</A></P></LI>

<P>Now performing substitutions on very long lines can present difficulties for text editors that rely in text shuffling as line-lengths change - jot is one such.</P>

<P>For this relatively small file (only about 100MB) jot won hands down, but the tables were turned later when they had to do the same thing but with a much bigger file.</P>


</UL><H2><A NAME="COMMAND STRUCTURE">Command structure</H2>
<UL><P><LI>Number of primitives - jot 62 basic primitives, 133 counting the 71 options for %S, %B, %Q and</P></LI>

<UL><P>%H commands.</P>

</UL><P><LI>emacs - hard to say, probably all primitive functions in whatever version of lisp it happens to be using.</P></LI>

<UL><P><LI>vim - It looks as though vim just has functions.</P></LI>

</UL><P><LI>basic number of user functions (ie. default no. of functions).</P></LI>

<UL><P><LI>jot 117</P></LI>

<P><LI>emacs - 483 (number of functions found in emacs info pages)</P></LI>

<P><LI>vim 59 (for vimscript language, counted in</P></LI>

<UL><P>http://www.adp-gmbh.ch/vim/scripting/built_in_functions.html)</P>

</UL></UL><P><LI>Basic number of defined keystrokes/hotkeys/escape sequences</P></LI>

<UL><P><LI>jot 160</P></LI>

<P><LI>emacs 634 (number of keystrokes mentioned in emacs info pages, some of these are duplicates containing metasyntax from the info text)</P></LI>

<P><LI>vim 631 listed in http://vimdoc.sourceforge.net/htmldoc/quickref.html#quickref</P></LI>


</UL></UL><H2><A NAME="MORE">More</H2>
<UL><P><LI>Line wrapping:</P></LI>

<UL><P><LI>jot: only supports truncated view</P></LI>

<P><LI>emacs defaults to line-wrapping, can be turned off to give a truncated view with M-x toggle-truncate-lines</P></LI>

</UL><P><LI>Split windows:</P></LI>

<UL><P><LI>jot: horizontal splits are easy, vertical splits impossible.</P></LI>

<P><LI>emacs: both horizontal and vertical splits possible.</P></LI>

</UL><P><LI>Annoying features: They've all got some, trouble is, it's easier to see these in other people's efforts.</P></LI>

<UL><P><LI>jot:</P></LI>

<UL><P><LI>I guess many will find the complicated Ctrl, Shift and/or Alt + Function/cursor key combinations more than a little tiresome. This is probably more of a problem for touch typists than for hunt-and-peck typists such as myself.</P></LI>

</UL><P><LI>emacs:</P></LI>

<UL><P><LI>emacs - that stupid "Oh golly! that's a big file" query for file of 1Mb or more and anyway what's so special about 1Mb files in this day and age? Similarly, there,s not just one but two annoying popups when trying to abandon a session.</P></LI>

<P><LI>Oh, and on the subject of stupid questions, the use of blue highlights makes these almost invisible on my (reverse video) xterms.</P></LI>

</UL><P><LI>vim:</P></LI>

<UL><P><LI>It's a minefield of special cases, special modes and special features and the what where and when of how they apply is not always uniformly intuitive. Not to mention the funny little historical quirks that were in some old-testament version of vi. While some might be prepared dedicate their professional lives to mastering it all, the rest of us have coding to be done. Interestingly, the jot command language is based on ecce which predates even the dawn of unix.</P></LI>
</UL></UL></UL>
