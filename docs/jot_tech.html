<! Made with jot using doc2html >
<link rel="stylesheet" href="main.css" type="text/css">


</UL><H2><A NAME="JOT TECHNICAL GUIDE">JOT Technical Guide</H2>
<P>This guide is rather more technical in nature. It goes into some details of the design and internals of the editor, it's command structure, it's primitive commands and installation. For a general user guide take a look at <A HREF="jot_ug.html#JOT USER GUIDE">jot user guide</A> and <A HREF="jot_walkthrough.html#JOT WALKTHROUGH">jot walkthrough</A>.</P>


</UL><H3><A NAME="ABOUT JOT COMMANDS">About jot commands</H3>
<P>There are two clearly identifiable groups of jot commands - those text manipulation and those for interfacing with the operating system and for internal housekeeping.</P>

<P>The basic text manipulation commands are all single characters, e.g. <A HREF="#F">F</A>- find, <A HREF="#S">S</A> - substitute, <A HREF="#I">I</A> - insert, <A HREF="#M">M</A> - move (up/down), <A HREF="#R">R</A> - move right. There is also an important group of commands to do with creating programme structures e.g. <A HREF="#(">(</A> - block start, <A HREF="#)">)</A> - block end and <A HREF="#,">,</A> - introduces a logical else clause.</P>

<P>The housekeeping commands can be for probing and setting system state or calling system services. These are generally prefixed with a percent ( % ) character e.g:</P>

<UL><P><LI><A HREF="#%I">%I</A> - input - reads a file from the filing system,</P></LI>

<P><LI><A HREF="#%O">%O</A> - output - writes a file to the filing system,</P></LI>

<P><LI><A HREF="#%Q">%Q</A> - query - returns reports or values reflecting the internal state of the editor,</P></LI>

<P><LI><A HREF="#%S">%S</A> - System settings and services - these affect all buffers.</P></LI>

<P><LI><A HREF="#%B">%B</A> - Buffer settings and services - these affect only the current buffer.</P></LI>


</UL><H3><A NAME="ABOUT COMMAND PARAMETERS">About command parameters</H3>
<P>Numeric parameters are generally specified in decimal e.g:</P>

&#062; m123
<P>String parameters may use any non-alphanumeric ASCII character as a delimiter provided the delimiter does not occur in the string. Note that most (see <A HREF="#Q">Q</A>) of these commands will accept ISO-8859-x or UTF-8 characters in the parameter string but UTF-8 characters cannot be used as delimiters.</P>

<P>If there is no further text on the command line then the string may be left unterminated. These examples all find the next instance of the string £1234:</P>

&#062; f/£1234/
&#062; f/£1234
&#062; f@£1234@
&#062; f"£1234"
<P>Most commands that accept a string parameter will also accept a reference to a buffer by replacing the string and delimiters with '&#060;key&#062; in the command line (e.g. F'@ ) in this case the string used is the entire current line of the secondary buffer. The input parameters to many of the percent commands (mainly those which take pathNames) may also be defined indirectly in this way (e.g. %ia='$; %qb=file '$ ) but the destination buffer cannot be the same as the pathName buffer. Where this type of indirection is used, there is an upper limit of 1024 on the allowable length of parameter strings.</P>

<P>The indirect reference can be to a buffer on the operand stack (see <A HREF="#ABOUT THE OPERAND STACK">about the operand stack</A>). </P>

<P>In this example, the value of env FRED is used to define a search string:</P>

&#062; %q~=env FRED; mz. f'~
<P>All references to numerical items on the stack cause the to item to be removed, references to buffers on the stack do not delete the buffer. In this example, the top item on the stack contains a numerical value used to set the size of a hashtable:</P>

&#062; %h=create '~;
<P>In jot's direct insert mode (see <A HREF="jot_ug.html#COMMAND-MODE VS. INSERT MODE">command-mode vs. insert mode</A>), you cannot enter commands. You can only type text straight onto the screen or fire off the editor functions attached to hot-keys and control keys. If an editor function requires an parameter it will prompt you for it. Type it into the console area and hit &#123;Return&#125;. See <A HREF="#%S=COMMANDMODE">%s=commandmode</A> for details about jot's type-into screen mode.</P>


</UL><H3><A NAME="ABOUT PARAMETERS TO MACROS AND JOT SCRIPTS">About parameters to macros and jot scripts</H3>
<P>The <A HREF="#%R">%R</A> command picks up any parameters from the command line and copies them to the $ buffer where they can be examined by the script.</P>

<P>The <A HREF="jot_coms.html#CLI.JOT">cli.jot</A> script, for example, take an ordinary CLI command executes it and returns the result in the @ buffer. For example:</P>

&#062; %r=cli ls -l;
<P>On completion the @ buffer contains a directory listing of your PWD. The &#060;&#060;<A HREF="jot_ug.html#DO">Do</A>&#062;&#062; function is just a wrapper for the %R command.</P>

<P>The native jot language does not define how parameters find their way from the keyboard via the console area to macros or functions (see <A HREF="#HASHTABLE CALL">hashtable call</A>). For the most important of these Macro1 to Macro9 the startup script (See <A HREF="#ABOUT STARTUP SCRIPTS">about startup scripts</A>) arranges for parameters to be copied into the ( $ ) buffer.</P>

<P>It's a similar story for the more complex functions held in the code repository (see <A HREF="#CALLING SUBROUTINES BY NAME">calling subroutines by name</A>) The <A HREF="jot_ug.html#FINDSEQUENCE">FindSequence</A> function, for example, takes a list of words from the command line - these are picked up from console area and copied to the $ buffer and the FindSequence function picks them up from there.</P>

<P>When in insert mode (see <A HREF="jot_ug.html#COMMAND-MODE VS. INSERT MODE">Command-mode vs. insert mode</A>) the startup script arranges for the correct prompt to appear - see <A HREF="#TRANSLATION OF KEYBOARD EVENTS TO ACTIONS">translation of keyboard events to actions</A></P>


</UL><H3><A NAME="ABOUT TEXT BUFFERS">About text buffers</H3>
<P>In jot, a text buffer is an internal data structure containing an image of some text. Each buffer is identified by a single-character buffer key. The following buffers are accessible but some are used by command file scripts. Buffers may contain a file image, fragments of text or jot command strings - otherwise known as macro commands.</P>

<UL><P><LI>( . ) is the primary buffer, this contains an image of the file you gave on the shell command line.</P></LI>

<P><LI>( A ) to ( Z ) available without restriction, note that these are case insensitive i.e. a and A are the same buffer.</P></LI>

<P><LI>( 0 ) to ( 9 ) user-defined functions attached to Numeric keypad keys 0 to 9 (&#123;Esc 0&#125; to&#123;Esc 9&#125; for those lacking a numeric keypad) but, if you don't want to use these as macros, they are available for any other purpose.</P></LI>

<P><LI>( $ ) used to pass parameters to function keys, scripts and macros.</P></LI>

<P><LI>( ^ ) set up by startup script - defines function-key mapping.</P></LI>

<P><LI>( ' ) Set up by startup script - hosts the code repository and it's hashtable. It's hashtable is also used to hold bits of global data - like the jump addresses for <A HREF="jot_ug.html#VIEWSAVE">ViewSave</A> and <A HREF="jot_ug.html#VIEWRESTORE">ViewRestore</A>.</P></LI>

<P><LI>( : ) Set up by the startup script, is the help repository - see <A HREF="#ABOUT HELP FILES">about help files</A>.</P></LI>

<P><LI>( $ ! " # % & ( ) * + - . / ; &#060; = &#062; ? @ &#091; \ &#093; _ ) are all available but may be used by scripts or functions hence they can only be relied on for temporary storage.</P></LI>

<P><LI>The ( ! $ % ; @ ) buffers are used by the standard setup script, so they may contain something after the startup has run - but may be redefined without causing problems.</P></LI>

<P><LI>The buffers ( ^ ' : ) are defined by the standard setup script (see above), changing these may cause things to not work properly.</P></LI>

<P><LI>The ( & ) buffer is dedicated to the <A HREF="jot_coms.html#DOC.JOT">doc.jot</A> script a simple document-processing utility.</P></LI>

<P><LI>The ( = ) buffer is available but cannot be used as a destination buffer for the <A HREF="#%Q">%Q</A>, <A HREF="#%F">%F</A> and, possibly, other percent commands with an optional buffer-key, since it would confuse the command parser.</P></LI>

<P><LI>The ( ; ) buffer is used to display help pages but it can be used for temporary storage, the syntax gets a bit messy when used in percent commands since the semicolon is used to terminate percent commands.</P></LI>

<P><LI>The ( ? ) buffer is defined by many scripts to give brief help information on the script.</P></LI>

</UL><P>See <A HREF="#A">A</A>, <A HREF="#H">H</A> and <A HREF="#ABOUT COMMAND PARAMETERS">about command parameters</A>.</P>


</UL><H3><A NAME="TRANSLATION OF KEYBOARD EVENTS TO ACTIONS">Translation of keyboard events to actions</H3>
<P>Like most modern editors jot attaches editor functions to various function keys, escape sequences and and various combinations of the Shift, Ctrl and Alt keys with function and other keys. The key-to-function translation table is held in the text buffer ( ^ ) defined at startup time - see <A HREF="#ABOUT STARTUP SCRIPTS">about startup scripts</A>.</P>

<P>As a function key is pressed, signals trickle through various layers of the OS (maybe xkb followed by terminfo) until they reach the editor in the form of a keycode or an escape sequence.</P>

<UL><P><LI>Simple ASCII characters are a keycode byte indicating the ASCII code,</P></LI>

<P><LI>unicode characters appear as a series of bytes indicating their UTF-8 sequence,</P></LI>

<P><LI>simple function keys and mid-keypad keys appear as a single-byte keycode as defined in ncurses.h and</P></LI>

<P><LI>keys modified by Ctrl, Shift and/or Alt, use this scheme:</P></LI>

<UL><P><LI>&#123;F1-12&#125; yields key_f1-key_f12,</P></LI>

<P><LI>&#123;Shift F1-12&#125; yields key_f13-key_f24,</P></LI>

<P><LI>&#123;Ctrl F1-12&#125; yields key_f25-key_f36,</P></LI>

<P><LI>&#123;Ctrl+Shift F1-12&#125; yields key_f37-key_f48,</P></LI>

<P><LI>&#123;Alt F1-12&#125; yields key_f49-key_f60,</P></LI>

<P><LI>&#123;Shift+Alt F1-3&#125; yields key_f61-key_f63,</P></LI>

<P><LI>&#123;UpArrow&#125;, &#123;DownArrow&#125;, &#123;LeftArrow&#125;, &#123;RightArrow&#125;, &#123;Insert&#125;, &#123;Home&#125;, &#123;Delete&#125;, &#123;End&#125;, &#123;PageUp&#125; and &#123;PageDown&#125; Keycodes for all of the above are defined in ncurses.h</P></LI>

</UL><P><LI>The following keys, however, usually generate unique key sequences (but even uniqueness is not guaranteed) determined by your OS configuration. Furthermore some may be hardwired as system shortcuts (especially &#123;Ctrl+Alt+F1-12&#125;) and some combinations of &#123;Up/DownArrow&#125;.</P></LI>

<UL><P><LI>&#123;Shift+Alt F3-12&#125;</P></LI>

<P><LI>&#123;Ctrl+Alt F1-12&#125;</P></LI>

<P><LI>&#123;Ctrl+Shift+Alt F1-12&#125;</P></LI>

<P><LI>&#123;&#060;AnyModifier&#062;+&#060;AnyMid-keypadKey&#062;&#125;</P></LI>

</UL><P>The point to note about system-defined escape sequences is that they are liable to change from one linux to another. It's not even guaranteed that these will yield any usable key code at all and sometimes they have been known to collide with other keycodes/escape sequences from the same system. See <A HREF="jot_coms.html#DEFINE_KEYMAP.JOT">define_keymap.jot</A> for details of how to redefine the jot key mapping for your system. The <A HREF="jot_coms.html#CURSES_KEYS_&#060;TERM&#062;.JOT">curses_keys_&#060;TERM&#062;.jot</A> in the jot distribution was set up using a Fedora-27 with TERM set to xterm.</P>

</UL><P>After a key event is received, jot will attempt to match the received keycode with codes in the ^ buffer (see <A HREF="jot_coms.html#STARTUP.JOT">startup.jot</A>). Some keys return a simple numerical value, others return an escape sequence - an &#123;Esc&#125; character followed by a few ordinary printable characters. Alternatively, the user may type in &#123;Esc&#125; followed by two or more characters - essentially another form of escape sequence.</P>

<P>Where a parameter is required, e.g. for the &#060;&#060;Do&#062;&#062; function the script name parameter is represented in the function definition by a pair of adjacent hash characters. For in a typical linux installation this key will be defined by this entry in the ^ buffer:</P>

<PRE>
X010A   %r=##"Command file pathName&#062; ";
</PRE>
<P>In command mode, the name of the script is typed in *before* hitting &#123;F2&#125;, thus the function key doubles up as a delimiter for the parameter string, saving you the bother of hitting &#123;Return&#125;.</P>

<P>In insert mode, however, it is necessary to prompt for the pathname and the prompt is, of course, the string following the double hash. If the prompt string is omitted then no prompt is issued.</P>

<P>The startup script builds the key translation table in buffer ( ^ ) - see <A HREF="jot_coms.html#STARTUP.JOT">startup.jot</A>.</P>

<P>In the normal startup script, for example, we find this definition of the &#060;&#060;Remove&#062;&#062; function (this removes the currently-selected substring):</P>

&#060;&#060;Remove&#062;&#062;(s/ /e-)
<P>Then, further along in the startup.jot script we see this:</P>

&#060;&#060;Remove&#062;&#062;            &#123;Shift+F5&#125;
<P>This says that the &#060;&#060;Remove&#062;&#062; function should be activated by pressing the F5 function key while the Shift key is held down.</P>

<P>In the curses_keys_xterm script we find this line:</P>

<PRE>
X0119                        -- &#123;Shift+F5&#125;
</PRE>
<P>In the WindowsNT_keys script we find this line - functionally similar but a different keycode.</P>

<PRE>
X374                         -- &#123;Shift+F5&#125;
</PRE>
<P>these give the specific key code for &#123;Shift+F5&#125;. Finally, looking in the key-translation buffer ( ^ ) of a linux session we should see this:</P>

<PRE>
X0119   (s/ /e-)
</PRE>
<P>The sequence of events is thus:</P>

<UL><P><LI>You select a substring,</P></LI>

<P><LI>you press &#123;Shift+F5&#125;,</P></LI>

<P><LI>the system detects this event and generates a binary the code determined by terminfo to be 0x119,</P></LI>

<P><LI>jot translates the code 0x119 to the escape sequence &#123;Esc 0 1 1 9&#125;,</P></LI>

<P><LI>jot matches the internally-generated escape sequence and finds the jot command sequence (s/ /e-) by searching the ( ^ ) buffer,</P></LI>

<P><LI>jot then executes that little bit of code and, finally,</P></LI>

<P><LI>you see the substring disappear from the screen</P></LI>


</UL><H3><A NAME="ABOUT STARTUP SCRIPTS">About startup scripts</H3>
<P>As we hit keys, various layers of hardware and the operating system perform a translation from electrical impulses in the keyboard to keycodes that can be understood by whatever software is reading them - in this case jot.</P>

<P>For windows the situation appears to be that all flavours of NT-windows running on any machine connected to any compatible keyboard will always yield the same keycodes.</P>

<P>For linux, the recent history of unix intrudes, as video terminals became popular a great many firms entered the market with competing and, well, incompatible devices which all had to be connected to unix servers. This was the necessity that gave birth to the invention of termcaps. Later there was terminfo - an improved version of termcaps.</P>

<P>With termcaps/info it became possible for many users, all connected to a unix server using a variety of terminals and for the system to communicate reliably with all of them. But only if each has properly announced which terminal type they have by setting their $TERM env.</P>

<P>However ... most linux installations run on PCs with only one keyboard and only one monitor but the unix distros have provided a plethora of terminal types and many distros set up the default TERM to xterm. But no! ... not all distros provide a complete description of the capabilities of an IBM-compatible keyboard and worse yet, not all agree on what keycodes result from various combinations of function and control keys.</P>

<P>This is resolved in the startup script (See <A HREF="jot_coms.html#STARTUP.JOT">startup.jot</A>), which runs different keycode-setup scripts according to your curses version (see <A HREF="jot_coms.html#WINDOWSNT_KEYS.JOT">WindowsNT_keys.jot</A> and <A HREF="jot_coms.html#CURSES_KEYS_&#060;TERM&#062;.JOT">curses_keys_&#060;TERM&#062;.jot</A>).</P>

<P>The mapping of function key events to editor functions is determined various layers of OS and, in particular your terminfo file and, finally, by the editor startup file. See also <A HREF="#X-WINDOWS SETUP">X-windows setup</A></P>

<P>The approximate sequence of events, in the <A HREF="jot_coms.html#STARTUP.JOT">startup.jot</A> file is:</P>

<UL><P><LI>The appropriate curses_keys_&#060;TermName&#062;.jot script is run - this defines the mapping of keycodes (either numerical keycodes or escape sequences) to the names printed on the keycaps. This table is set up in the ( @ ) buffer.</P></LI>

<P><LI>The startup script then defines functions in the code repository buffer ( ' ).</P></LI>

<P><LI>The startup script then defines the mapping of functions to key names in buffer ( ! ).</P></LI>

<P><LI>If you have specified a function and keymap modification script using the -keyfuncs=&#060;pathName&#062; qualifier then that script is run at this point.</P></LI>

<P><LI>The startup script merges the keycodes map, the functions map and the functions to create the key translation table in buffer ( ^ ) - this is used to map hotkeys function keys and escape sequences to actual code and function calls.</P></LI>


</UL><H3><A NAME="ABOUT JOT STREAMS">About jot streams</H3>
<P>Jot is normally used to edit text files held on the filing system but it can pick up text from the stdin stream (see <A HREF="#-">-</A>) and it can direct text to the stdout stream when <A HREF="#-TTY">-tty</A> is set.</P>

<P>Currently the <A HREF="#-">-</A> qualifier is only required by the windows version, and the incoming stream is detected automatically by the linux version.</P>

<P>In normal usage, the <A HREF="#P">P</A> command prints line in the console area. When the editor is stared in stream-out mode the printed lines are sent to stdout, where they can be directed to a file or piped to another process. The stream-out operation is detected automatically when stdout is set to anything except your xterm (or windows console). e.g (this matches a specific class of error message with the function name):</P>

<PRE>
$ jot message.log -quiet -tty -init="t(f/warning: unused variable/onf-/in function/n.r2f1/:/aa&ono-omhapm)0 %a" | cat
</PRE>
<P>This would also cause it to enter stream-out mode:</P>

<PRE>
$ jot message.log -q -tty -in="t(f/warning: unused variable/onf-/in function/n.r2f1/:/aa&ono-omhapm)0 %a" &#062; errors.lis
</PRE>
<P>Note the use of the -tty and -quiet qualifiers in these two examples - -tty this prevents xterm escape sequences appearing in stdout, -quiet suppresses many normal messages that would otherwise appear in the output stream.</P>

<P>In stream-out mode the records selected by the <A HREF="#P">P</A> command is sent off down stdout where it can be piped off to some other process. This mode of operation is used in the 99 bottles of beer demonstration. (see <A HREF="http://99-bottles-of-beer.net">http://99-bottles-of-beer.net</A>)</P>

<P>99 bottles of beer is a simple drinking song:</P>

<PRE>
99 bottles of beer on the wall, 99 bottles of beer.
Take one down and pass it around, 98 bottles of beer on the wall.
   ...   
2 bottles of beer on the wall, 2 bottles of beer.
Take one down and pass it around, 1 bottle of beer on the wall.
  
1 bottle of beer on the wall, 1 bottle of beer.
Take one down and pass it around, no more bottles of beer on the wall.
  
No more bottles of beer on the wall, no more bottles of beer.
Go to the store and buy some more, 99 bottles of beer on the wall.
</PRE>
<P>The object of the exercise is to write some code in your favourite language to generate the lyrics correctly - this is one way of doing it in jot:</P>

<PRE>
cat - | jot /dev/null -tty -obey &#060;&#060; EndOfJotCommands
i/$ bottles of beer on the wall, $ bottles of beer./b
i/Take one down and pass it around, $ bottles of beer on the wall./b2
m-0nm2aaha99
m-0ol99(f/$/o#oo/%d/)2 (ol1o-(f/$/o#oo/%d/)3)98
(f-0/1 bottles/-e-)3 (f/$/s/no/)3l0c
mki/Go to the store and buy some more, 99 bottles of beer on the wall./m-0b-p0
%a
EndOfJotCommands
</PRE>

</UL><H3><A NAME="ABOUT HELP FILES">About help files</H3>
<P>The help files are structured in a similar fashion to occam folded files.</P>

<P>The top help file normally contains only file folds. If, for example, the JOT_RESOURCES env is set to /home/my_home/resources, there should be a top-level helpfile help.hlp in the help subdirectory:</P>

<UL><P>/home/my_home/resources/help/help.hlp</P>

</UL><P>Inside that file we might find this line:</P>

<UL><P>&#091;unix&#093;unix - Notes on a few unix commands.</P>

</UL><P>When When a user queries this help entry (by moving the cursor to somewhere in the line and hitting F1) the &#091;unix&#093;unix element is transformed into the path:</P>

<UL><P>/home/my_home/resources/help/unix/unix.hlp</P>

</UL><P>Within the child help files are folded sections like this:</P>

&#062; &#123;&#123;&#123; Section name
&#062;   Section text.
&#062;   ...
&#062; &#125;&#125;&#125;
<P>These help sections are nestable.</P>

<P>The help files can be typed in manually, but it is easy to make mistakes in the fold nesting. It is recommended that help files be prepared as plain-text documents using <A HREF="jot_coms.html#DOC.JOT">doc.jot</A> with the section hierarchy defined by section header levels (i.e. the section levels indicated by the section numbers).</P>

<P>There are some text-processing scripts to help with this:</P>

<UL><P><LI><A HREF="jot_coms.html#DOC.JOT">doc.jot</A> - the main document processing script.</P></LI>

<P><LI><A HREF="jot_coms.html#DOC2FOLD.JOT">doc2fold.jot</A> - Creates a help file from a text document.</P></LI>

<P><LI><A HREF="jot_coms.html#FOLD2DOC.JOT">fold2doc.jot</A> - reverse of doc2fold - only use this when the source text is not available.</P></LI>

<P><LI><A HREF="jot_coms.html#UPDATEHELP.JOT">updatehelp.jot</A> - pushes simple modifications to a help fold back to the helpfile.</P></LI>

<P><LI><A HREF="jot_coms.html#FINDHELP.JOT">findhelp.jot</A> &#060;word&#062; - searches all help entries for the given word.</P></LI>


</UL><H3><A NAME="ABOUT LONG LINES">About long lines</H3>
<P>The maximum length line that can be displayed properly is limited by the display window. When the editor has to display a longer line the behaviour is as follows:</P>

<UL><P><LI>If current character and all of any selected substring are in within the terminal width then the line, the current character and the substring are displayed normally. Any text to the right of the window right margin is silently ignored.</P></LI>

<P><LI>If the current character or some part of the selected substring is at or beyond the terminal width then the line is displayed in the console area of the screen.</P></LI>

<P><LI>If a LeftOffset is set for the buffer (see <A HREF="#%B=LEFTOFFSET">%b=leftoffset</A>) then the left margin of the display is aligned to somewhere right of the first character. If the current character or some part of the currently selected substring falls outside the defined screen area then, again, the relevant section of the record is displayed in the console area.</P></LI>

<P><LI>When a script or macro has to ensure that the current character is in view use %q=inview - see <A HREF="#QUERY INVIEW">Query inView</A>.</P></LI>

<P><LI>The &#060;&#060;CellLeft&#062;&#062; and &#060;&#060;CellRight&#062;&#062; actions (normally &#123;Shift+LeftArrow&#125; and &#123;Shift+RightArrow&#125; respectively), will check for visibility using %q=inview and will adjust leftoffset accordingly.</P></LI>

<P><LI>The &#060;&#060;ViewLeft&#062;&#062; and &#060;&#060;ViewRight&#062;&#062; actions (normally &#123;Ctrl+Shift+LeftArrow&#125; and &#123;Ctrl+Shift+RightArrow&#125; respectively), can be used to manually adjust leftoffset.</P></LI>


</UL><H3><A NAME="ABOUT THE JOT CONSOLE AND DISPLAY WINDOWS">About the jot console and display windows</H3>
<P>In jot documentation, a window is a viewing area of the terminal. By default, the startup script creates a single window which displays whatever happens to be the current buffer. The area at the bottom of the screen is the console area, used to display system messages etc. and prompts for your typed-in commands. In the event of a long line with the current character being off to the right of the screen then the console area is used to repeat an appropriate section of the line.</P>

<P>The standard startup script (see <A HREF="#ABOUT STARTUP SCRIPTS">about startup scripts</A>) will use your screen dimensions to calculate the size of a single window that will leave a one-line console area at the bottom of the screen. It also sets up the screen so that various message can temporarialy encroach into the window area - see the <A HREF="#%S=CONSOLE">%s=console</A> command. When this happens, the window will be restored to it's full size on the next command - or by hitting &#123;return&#125;.</P>

<P>When the console area is set up with two or more lines, lines of text scroll up the console up to the bottom line of the last window. If the console is set up with one line but allowing it to temporarialy encroach on the windows, then the console will borrow lines up to the specified limit.</P>

<P>For debugging scripts, especially when using <A HREF="#THE JOT DEBUGGER">the jot debugger</A>, it is useful to set up windows for a fairly large console window. For normal usage a one-line console area is useful since this maximizes the text view.</P>

<P>The size of a window can be adjusted with the <A HREF="jot_ug.html#WINDOWSTRETCH">WindowStretch</A> and <A HREF="jot_ug.html#WINDOWSHRINK">WindowShrink</A> functions. The view can be adjusted left, right up or down with the functions - see <A HREF="jot_ug.html#VIEWUP">ViewUp</A>, <A HREF="jot_ug.html#VIEWDOWN">ViewDown</A>, <A HREF="jot_ug.html#VIEWLEFT">ViewLeft</A> and <A HREF="jot_ug.html#VIEWRIGHT">ViewRight</A> respectively.</P>

<P>It is possible to split the viewing area between more than one window with one or more windows dedicated to displaying specified buffers. The screen may be split either vertically or horizontally - see <A HREF="jot_ug.html#ABOUT MULTI-WINDOW WORKING">about multi-window working</A> and <A HREF="jot_ug.html#WINDOWONE">WindowOne</A>, <A HREF="jot_ug.html#WINDOWHORIZSPLIT">WindowHorizSplit</A> and <A HREF="jot_ug.html#WINDOWVERTSPLIT">WindowVertSplit</A> functions.</P>


</UL><H3><A NAME="ABOUT TABULAR TEXT">About Tabular text</H3>
<P>Jot supports text two types of text containing tabs - normally the ascii VT character, here referred to as tab. The first form uses tabs simply to align text into predefined columns, the second form aligns tab-delimited text cells. Cells often contain numerical data, so the text is right-justified and over-long strings are truncated to maintain the tabular structure.</P>

<P>See <A HREF="#%B=TABSTOPS">%b=tabstops</A>, <A HREF="#%B=TABCELLS">%b=tabcells</A> and <A HREF="#%B=TABSORT">%b=tabsort</A>. It also generates tab-separated tables (see <A HREF="#QUERY DIR">Query dir</A>).</P>

<P>When viewing tabular data it is often useful to have a header line showing the meaning of each column - the window headers provided by <A HREF="#%B=HEADER">%b=header</A> will follow tabstops set in the text body eg:</P>

<PRE>
$ jot $&#123;JOT_RESOURCES&#125;/consumertrends2012q3cvmnsa_tcm77-292466.tsv \
</PRE>
<UL><P>-in="m+13 %b=header '.; %b=tabcells -1; wol12ow"</P>

</UL><P>The header is also useful for wide blank-separated tables eg:</P>

<PRE>
$ pmap -XX &#060;anyValidPid&#062; | jot -in="m %b=header '.;"
</PRE>
<P>In addition to <A HREF="#%B=TABSTOPS">%b=tabstops</A> and <A HREF="#%B=TABCELLS">%b=tabcells</A>, there are two more options for representing tabular text. </P>

<UL><P><LI>By default, jot will treat tabs as it does any other control characters and will represent them with tildes ( ~ ) - not a especially helpful option for most uses - but it is sometimes useful to see where they are.</P></LI>

<P><LI>The following scripts will reformat documents, guided by temporary tabs: <A HREF="jot_coms.html#AUTOTAB.JOT">autotab.jot</A> <A HREF="jot_coms.html#AUTOTABDP.JOT">autotabdp.jot</A> <A HREF="jot_coms.html#AUTOTABJUST.JOT">autotabjust.jot</A> <A HREF="jot_coms.html#RETAB.JOT">retab.jot</A> <A HREF="jot_coms.html#RETABHERE.JOT">retabhere.jot</A></P></LI>

</UL><P>If the width of the table execeeds that of your window, you can set the leftoffset - see <A HREF="#ABOUT LONG LINES">about long lines</A> and <A HREF="#%B=LEFTOFFSET">%b=leftoffset</A> this is all taken care of by the &#060;&#060;<A HREF="jot_ug.html#WORDRIGHT">WordRight</A>&#062;&#062; and &#060;&#060;<A HREF="jot_ug.html#WORDLEFT">WordLeft</A>&#062;&#062; functions.</P>

<P>A good example is the output of the linux dumpkeys command - the keycodes section consists of 256 entries per line with 20 or more characters per entry, to view these with a header showing the modifier values try this:</P>

<PRE>
$ sudo dumpkeys -f | jot -in="(f/ /s/\t/(v//e)0)0m-0 %b=tabstops -1; \
</PRE>
<P>ol0z\$m-0k0(i/\t/)3 (o#oo/\t%2X/r0o~ol256o&#060;)0 z.%b=header '$;"</P>

<P>You may then navigate the table using <A HREF="jot_ug.html#WORDLEFT">WordLeft</A>, <A HREF="jot_ug.html#WORDRIGHT">WordRight</A>, <A HREF="jot_ug.html#WORDUP">WordUp</A> and <A HREF="jot_ug.html#WORDDOWN">WordDown</A> - &#123;Shift+LeftArrow&#125;, &#123;Shift+RightArrow&#125;, &#123;Shift+UpArrow&#125; and &#123;Shift+DownArrow&#125; respectively.</P>

<P>As with linear text, if the current character ends up outside the visible area of the screen (i.e. left of the buffers leftoffset setting, or right of the right margin), the relevant section is repeated in the console area. Also, if any part of the cell is out of the viewing area or the tabstops are set to narrow to properly display a cell, the cell text is truncated and displayed prefixed with a pling ( ! ) character. The section of text is also repeated in the console area - see <A HREF="#ABOUT LONG LINES">about long lines</A>.</P>

<P>While the %b=tabstops command affects only the way tables are represented on the screen in the current edit session, There are scripts available to permanently change the text file - see <A HREF="jot_coms.html#AUTOTAB.JOT">autotab.jot</A>, <A HREF="jot_coms.html#AUTOTABJUST.JOT">autotabjust.jot</A>, <A HREF="jot_coms.html#AUTOTABDP.JOT">autotabdp.jot</A> and <A HREF="jot_coms.html#RETAB.JOT">retab.jot</A>.</P>


</UL><H3><A NAME="OF MICE AND MENUS">Of Mice and Menus</H3>
<P>Jot offers a Text-based User Interface (TUI) which can support mouse-click and menu-driven applications. Although the plain-text menus might look quite crude and clonky by modern standards but that doesn't make them less useful than their slick counterparts. Take a look at the coding of <A HREF="jot_coms.html#MENU.JOT">menu.jot</A> and <A HREF="jot_coms.html#LINKDOCS.JOT">linkdocs.jot</A> for examples of how this might be done.</P>

<UL><P><LI>Firstly, to enable mouse events, the mousemask must be set up - see <A HREF="#%S=MOUSEMASK">%s=mousemask</A>.</P></LI>

<P><LI>It is usual to highlight clickable target points with an easily identifiable visible marker, in jot this requires the application of a colour tag (see <A HREF="#%B=ADDTAG">%b=addtag</A>). If popup menus are being used this is essential in order to avoid confusion as the popup overwrites normal text.</P></LI>

<P><LI>Mouse-clicks trigger the delivery of an escape sequence in much the same way as a function key - these are picked up and are normally set up to call a mouse-event handler function - see <A HREF="#TRANSLATION OF KEYBOARD EVENTS TO ACTIONS">translation of keyboard events to actions</A>.</P></LI>

<P><LI>The mouse-event handler must first identify the buffer, column and line number ( X and Y) where the mouse cursor was pointing at the time of the mouse event. This information is provided by th <A HREF="#OP">OP</A> command.</P></LI>

<P><LI>Having determined the mouse-event coordinates, we now have to identify the correct action associated with the identified mouse event and the event location. A text tag is assigned to the clickable region and the mouse-event handler checks the event point for text tags - see <A HREF="#%B=ADDTAG">%b=addtag</A>. Following a mouse event, the event-point text can be checked for text tags using the <A HREF="#QUERY TAGS">query tags</A> using the -here qualifier to select the correct text region.</P></LI>

<P>For menus, there will be a wide range of follow-on actions, then the tag is effectively a callback selector - see <A HREF="jot_coms.html#MENU.JOT">menu.jot</A> for examples. For hypertext applications the tag simply gives the link destination - possibly in the form of a hashtable key - see <A HREF="jot_coms.html#LINKDOCS.JOT">linkdocs.jot</A>.</P>


</UL><H4><A NAME="ABOUT MOUSE EVENTS">About Mouse Events</H4>
<P>By default, any mouse activity (movements, clicks, drags etc.) are ignored since in X the default mouse functions (selections) are reasonably useful. If however, some application needs to handle mouse events, these can be enabled. An example of a script that does this would be <A HREF="jot_coms.html#LINKDOCS.JOT">linkdocs.jot</A>.</P>

<P>Jot is normally driven by keyboard events with mouse-button events disabled. When mouse events are enabled, these are treated as keyboard events with special mouse event codes prefixed with 'M@. In linux, it is possible to select mouse events in the <A HREF="#%S=MOUSEMASK">%s=mousemask</A> command, in windows this either enables or disables all mouse events.</P>

<P>The normal startup sequence defines four functions</P>

<PRE>
M0040   &#060;&#060;CopyFromMouse&#062;&#062;    -- &#123;Button2Up&#125;
M0080   &#060;&#060;NoteFromMouse&#062;&#062;    -- &#123;Button2Down&#125;
M0200   &#060;&#060;FocusToMouse&#062;&#062;     -- &#123;Button2DoubleClick&#125;
M4000   &#060;&#060;InsertHereMouse&#062;&#062;  -- &#123;Button3Click&#125;
</PRE>
<P>these are intended to be demonstrators rather than useful functions - enable them for use with the mousemask command:</P>

&#062; %s=mousemask 42A0
<P>To integrate these in a useful way - e.g. for mouse clicks to perform useful processing some metadata is often required - e.g. to perform a jump to some place in another buffer on a mouse click we might need a hash-table key. This key can be associated with a launch point by adding a text tag in the launch point with the<A HREF="#%B=ADDTAG">%b=addtag</A> command using the -text=&#060;string&#062; modifier.</P>

<P>See also <A HREF="#OP">OP</A>, <A HREF="#%S=MOUSEMASK">%s=mousemask</A> and <A HREF="#%B=ADDTAG">%b=addtag</A></P>


</UL><H4><A NAME="ABOUT MENUS">About Menus</H4>
<P>Menus are normally but not exclusively driven by mouse events - normally clicks. Menu items are normally highlighted by choosing a different colour pair for them - see <A HREF="#%B=TAGTYPE">%b=tagtype</A> and <A HREF="#%B=ADDTAG">%b=addtag</A>.</P>

<P>For menus each menu item will require a different callback - this is normally determined by tagging menu items with a text tag (see <A HREF="#%B=ADDTAG">%b=addtag</A>) that identifies the callback. Alternatively, the click-event handler might simply pick up the visible text from the menu buffer and identify the follow-on action from that.</P>

<P>Popup menus can be set up using popup windows - see the -popup option of the <A HREF="#%W">%W</A> command.</P>


</UL><H3><A NAME="ABOUT UNICODE">About unicode</H3>
<P>Back in the days of teletypewriters and paper tape it was all so easy. The American Standard Code for Information Interchange (ASCII) would represent every character you could ever want with just 7 bits - so long as you weren't a mathematician, an engineer or anyone working in a non-english-speaking part of the world.</P>

<P>Mapping the 7-bit ASCII code to 8-track paper tape code left one extra bit which was sometimes used for checking - early modems, electro-mechanical tape punches and readers were not especially reliable. Since that time, the 8-bit unit (one byte) has become the industry-standard unit for organization of computer memory. </P>

<P>Modern computer hardware is much less error prone and, where error-checking schemes are employed, nowadays they are usually cyclic-redundancy systems that can detect and correct multiple errors. Also modern modern transmission protocols include error detection and correction. So the 8-th. bit is not required as a check for storage or transcription errors.</P>

<P>Unicode (or Universal Character Set - UCS) - an industry-standard encoding scheme for most characters in the alphabets of most written languages, including many symbols used in mathematics and engineering. The range of characters is so vast that, in practice, it is necessary to encode characters as sequences of one-byte tokens. Some tokens indicate the existence of yet more tokens to come, in UTF-8, UTF-16 and UTF-7. In common with many mail and unix systems jot uses UTF-8 to represent unicode characters. </P>

<P>It's important to note that whereas UCS is basically a vast character set, UTF-8, UTF-16, UTF-7 ... are coding schemes designed for efficient(ish) transmission, storage and handling of characters belonging to that set by encoding them as sequences of bytes in the range 128-255.</P>

<P>UTF-8 is a back-compatible expansion of the usual 8-bit, non-parity ASCII character set utilizing the, now redundant, 8th. bit and two or more bytes to yield an encoding space for many thousands of unique character codes. These can be used to represent all of the unicode characters. Both the windows and linux versions of jot support UTF-8 encoding.</P>

<P>UCS-2 is an early attempt at a unicode encoding scheme - unfortunately whereas UCS-2 can address a character space of 64K characters (at most, and in practice far less) the full chinese character set has in excess of 70K characters. This resulted in UTF-16 and UTF-32, UTF-32 abandons all pretence of packing efficiency and just gives each character 32 bits (a full word in most modern computers). UTF-16, like UTF-8 is a variable-length scheme which can address most of the current unicode characters.</P>

<P>While ICS-2 and UTF-16, may not be actually obsolete they were never really much good. Consequently jot offers only very limited support for UCS-2, it's slightly more intelligent younger sibling UTF-16 or it's obese brother UTF-32. UTF-16 is essentially UCS-2 with some complicated variable-length coding.</P>

<P>Jot makes no attempt to make sense of any of these encodings. The recommended solution for UCS-2, UTF-16 and UCF-32 is to convert them using iconv (linux) or a similar windows file-format converter. The filing-system explorer <A HREF="jot_coms.html#GET.JOT">get.jot</A> automatically uses iconv to read these formats as UTF-8 but to be consistent with the jot policy of not making unrequested changes to files, the pathname is changed in the editor session.</P>

<P>Various earlier schemes, designed for users working in their own languages, allows an additional character space (theoretically up to a further 128 characters) by setting the parity bit. This scheme, enshrined in microsoft code pages, became popular because it allowed several sets of non-roman alphabets with the minimum of fuss and still preserves the ancient principle of one byte equals one character - very important for developers of text-handling tools. This is fine for those, like most of us, who never have to write in more than one non-roman alphabet in any one document. There are now various ISO-8859-x standards covering these character sets.</P>


</UL><H4><A NAME="PRACTICALITIES OF UNICODE ETC. AND JOT.">Practicalities of unicode etc. and jot.</H4>
<P>The linux version of jot of jot can read and manipulate files containing mixed UTF-8 and ISO-8859-x character encodings. For correct rendering of ISO-8859-x you must have your locale set correctly - see <A HREF="#-LOCALE">-locale</A>. Any text entered will be encoded in UTF-8.</P>

<P>The windows version can properly display files containing either UTF-8 or those containing ISO-8859-x - but not both in the same document. This version requires the correct code-page setting for the file - see <A HREF="#%B=CODEPAGE">%b=codepage</A> and <A HREF="#-CODEPAGE">-Codepage</A>, by default it's set to codepage 65001 - that's UTF-8 to you and me. Again, any text entered will be encoded in UTF-8.</P>

<P>The linux version can only read and display UTF-8 but, if it is required to view or modify a UTF-n file there is a little script <A HREF="jot_coms.html#ICONV.JOT">iconv.jot</A> which, as it's name suggests, uses the unix utility iconv to transform the file to something that can be read, it will also write the file in it's original format.</P>

<P>To enter UTF-8 characters into the command line use the jot script uc_basic.jot - this recognizes sequences of keystrokes and converts them to the relevant UTF-8 byte sequence. To generate the euro symbol ( € ), for example:</P>

&#062; &#123;Esc u = E&#125;
<P>In command mode, <A HREF="jot_coms.html#UC_BASIC.JOT">uc_basic.jot</A> translates this sequence on the command line, so start off by loading the basic unicode:</P>

&#062; uc_basic&#123;F2&#125;
<P>Then, for example, to search for the the string "cost €123.456", type:</P>

&#062; cost &#123;Esc u = E&#125;123.456F8
<P>The uc_basic.jot script added the u=E escape string to your key translations list and it substituted the UTF-8 encoding for € in the command line.</P>

<P>Many IBM-compatible keyboards supplied in non-english-speaking parts of the world, have non-roman characters. Assuming your system is set up correctly, in linux, these keystrokes are converted to the correct UTF-8 sequence by the OS. If, for whatever reason, your linux locale (or Windows codepage) does not match your keyboard, you can specify a different locale with the <A HREF="#-LOCALE">-locale</A> (or <A HREF="#-CODEPAGE">-Codepage</A>) qualifier. If you have some ISO-8859-x encoded in a different locale, you can change the locale of a buffer with the <A HREF="#-LOCALE">-locale</A> CLI modifier.</P>

<P>To suppress conversion of unicode, turn off unicode support for that buffer with the <A HREF="#%B=UNICODE">%b=unicode</A> command. This renders each non-ASCII byte as a tilde ( ~ ).</P>


</UL><H4><A NAME="UNICODE - THE GRUESOME DETAILS">Unicode - the gruesome details</H4>
<P>Internally, jot stores characters in whatever way as they were transported and then stored in the filing system. This is important because it means that files written by jot will preserve the original encoding of the original. To be quite clear on this, jot does *not* plant BOMs (byte-order marks) or change any character encoding except when explicitly requested or for characters you have changed or inserted in your edit session. By default, the latter end up as UTF-8.</P>

<P>When jot reads a UCS-2, UTF-16 or UTF-32 file, jot saves the BOM (which is a two or four-byte prefix added by microsoft and most other windows tools), it saves the BOM internally and re-prefixes the text as it is written back out.</P>

<P>For example, the UTF-8 encoding for the euro sign ( € ) is E2, 82, AC - jot will recognize these characters as UTF-8 and convert them to the correct coding for the euro symbol for display on the screen. It's left to your terminal emulator to correctly interpret the UTF-8 string to present the correct image on the screen.</P>

<P>Note that the <A HREF="#R">R</A> and <A HREF="#OR">OR</A> commands will normally traverse the specified number of characters irrespective of how many bytes have been used to represent each character. Similarly the <A HREF="#E">E</A> command normally erases the specified number of characters irrespective of their byte count. This behaviour is modified by the <A HREF="#%B=UNICODE">%b=unicode</A> command, which can be used to turn off all unicode support - with unicode disabled, R, OR and E commands count bytes not characters. Erasing bytes belonging to UTF-8 characters is not recommended - there is no guarantee that the line will display properly when unicode-support is turned back on.</P>


</UL><H3><A NAME="ABOUT JOURNAL FILES">About Journal Files</H3>
<P>Jot's journal files are designed to recreate a session following a crash. The journal file, along with a cache of files and queries read by the original session, can be used to retrace all your activity in a recovery session so that you end up with an editing environment identical to that in the crashed session. In the future, journal files might provide the basis for some sort of undo function - although it would be rather slow by modern standards.</P>

<P>By default no journal is maintained - the editor is not particularly crashy and modern computers and power grids are generally reasonably reliable. The endurance of battery-powered devices is also quite good these days. From time to time however, a can't-happen event demonstrates how these need to be reclassified as infrequent events and it's pretty distressing to see hours of work wiped out like that.</P>

<P>With the CLI qualifier <A HREF="#-JOURNAL">-journal</A> is set, jot maintains a history file and snapshots of all the files it reads - these files are normally deleted on exit from the editor.</P>

<P>In the event of a crash the journal files remain and the original session is re-created by reading in snapshots of the original files and re-running the interactive commands.</P>

<P>The process for a session editing myfile.txt is described below.</P>

<UL><P><LI>1 Start the editor with journal files enabled:</P></LI>

<PRE>
$ jot myfile.txt -journal &#091; -&#060;any other valid args&#062;&#093;
</PRE>
<P><LI>2 After crashing, restart the editor but run the recovery script recover.jot - any other args will be ignored, the recovery process will restart with your original arg list:</P></LI>

<PRE>
$ jot myfile.txt -st=recover
</PRE>
<P><LI>3 If there are problems, then edit the command script recover_now.jot in your current directory and re-run the recovery using that:</P></LI>

<PRE>
$ jot myfile.txt  -init="%r=./recover_now.jot -asConsole"
</PRE>
</UL><P>See <A HREF="jot_ug.html#ABOUT NOT LOSING YOUR WORK">about not losing your work</A> and <A HREF="jot_coms.html#RECOVER.JOT">recover.jot</A> for full details of the journal/recovery process.</P>


</UL><H3><A NAME="ABOUT TAGGED TEXT">About Tagged Text</H3>
<P>Tags are used to mark sections of text with some special attribute. Typically, this will be display colour but tags are also used internally to identify and to protect hash-table target points or to add metadata to points in the text. The metadata is in the form of a text string, this is an essential ingredient in jot mouse and menu-driven interfaces where the tag metadata is used to identify a mouse-event callback.</P>

<P>Those familiar with vim and Emacs tags (of the sort generated by exuberant ctags), should note that jot tags are nothing to do with that. In jotspeak these are index files - see <A HREF="#ABOUT INDEX FILES">about index files</A>.</P>

<P>Each colour tag indicates a colour pair (i.e. a foreground and a background colour) to be associated with the tag see <A HREF="#%B=TAGTYPE">%b=tagtype</A>. The tags are added to test with the <A HREF="#%B=ADDTAG">%b=addtag</A> command.</P>

<P>The colours associated with the tags are defined in the <A HREF="#%B=TAGTYPE">%b=tagtype</A> command</P>

<UL><P><LI>this associates a colour pair with a user-supplied name which can be</P></LI>

<P>referenced by the <A HREF="#%B=ADDTAG">%b=addtag</A> command. The names must not exceed 12 characters.</P>

<P>The <A HREF="#%B=ADDTAG">%b=addtag</A> command adds a pair of tags into the internal record data - one identifies a start point and another the end of the tagged substring.</P>

<P>The tag definitions are associated with the buffer and are displayed by the <A HREF="#QUERY BUFFER">query buffer</A> query. The tags can be listed using the <A HREF="#QUERY TAGS">query tags</A> query.</P>

<P>For windows there is no limit on the number of named tags you can define - although there seems little point in going beyond the 256 unique colour pair combinations that are possible with windows.</P>

<P>For linux, there are only 64 possible colour-pair combinations and the curses system allows only 63 user-defined colour pairs. The 63-colour-pair limit is a system limit - the total number of colour pairs in all buffers cannot exceed this.</P>

<P>This is what happens if the text is changed on a line containing tagged text:</P>

<UL><P><LI>If a change is made after (i.e. right-of) the tagged text there is no effect on the tagging.</P></LI>

<P><LI>If the change happens before (i.e. left-of) the tagged text any tags then the tags are shifted left or right as appropriate.</P></LI>

<P><LI>If text is inserted deleted or substituted in a tagged substring, the extent (n. of characters) of the tag remains unaffected but text covered is changed.</P></LI>

<P><LI>If the record is broken mid tag (e.g. by a B or A command) then the extent of the tag is reduced to match the new record length.</P></LI>

<P><LI>If a new colour tag starts inside the scope of some outer colour tag the display effect is not guaranteed but, with the current version of the editor, the inner tag is invisible even if it's end point is after the end of the first tag.</P></LI>


</UL></UL><H3><A NAME="ABOUT HASHTABLES">About Hashtables</H3>
<P>Each buffer can have an associated hashtable. Hashtables are referenced by keyword - the keyword can be any unique string and each hashtable entry may point to one of the following classes of data object:</P>

<UL><P><LI>A pointer to some point in the text - a FindObj,</P></LI>

<P><LI>a stack-frame image - a DataObj,</P></LI>

<P><LI>a file section (a seek offset and a byte count) - a SetsectObj, </P></LI>

<P><LI>a file section (a pathName, seek offset and a byte count) - a SetfsectObj,</P></LI>

<P><LI>a deleted object - a ZombieObj.</P></LI>

</UL><P>The FindObj is essentially an index which allows fast references to indexed text. Hashtables are a useful alternative to searching with the <A HREF="#F">F</A> command when the buffer is extremely large or when a macro makes many references to moderately large buffer making the searching a significant proportion of a macros execution time (see <A HREF="#HASHTABLE JUMP">hashtable jump</A>)</P>

<P>The DataObj is a stack-frame that has been detached from the top of the stack and can be copied back to the stack as required, this works for any stack-frame type - integer, float or buffer (see <A HREF="#HASHTABLE DATA">hashtable data</A>, <A HREF="#OV">OV</A> and <A HREF="#OQ">OQ</A> commands). Data objects can be swapped between the stack and the hashtables, note that the data-object buffers can also have hashtables, leading to the possibility of unlimited hierarchies of hashtables.</P>

<P>For data objects assigned to one of the main buffers, the syntax is pretty simple - to extract the value of an object named "fred" hanging off the current buffer it would be:</P>

&#062; ov/fred/
<P>But to access an object named 'fred' hanging off data-object-buffer named 'jim', which is itself hanging off another data-object-buffer named 'brian' hanging off the primary buffer ( . ) - then we might just plod through the hierarchy:</P>

&#062; z.oq/brian/z~ oq/jim/z~ oq/fred/
<P>That's pretty painful - so there is a path-specification syntax designed for buffer hierarchies:</P>

<UL><P>&#091;&#060;bufferKey&#062;=&#093;&#091;&#060;PathElement1&#062;&#091;|&#060;pathElement2&#062;&#091;| ... &#093;&#093;&#093;</P>

</UL><P>eg:</P>

&#062; oq/.=brian|jim|fred/
<P>While this syntax simplifies usage, it still requires three relatively expensive hashtable operations to locate the data. Note that that, although some path depth may be desirable - possibly essential for some recursive functions, it can get expensive and programmers should strive too keep their data structures as flat as possible.</P>

<P>The SetsectObj is intended for the handling of very large files, it defines the byte-offset and byte-count of sections of files - see <A HREF="#HASHTABLE SETSECT">hashtable setsect</A>, <A HREF="#HASHTABLE SETFSECT">hashtable setfsect</A> and the -section=&#060;hastableKey&#062; section of the <A HREF="#%I">%I</A> command.</P>

<P>The SetfsectObj is similar to SetsectObj except that it also includes a pathname and is intended for support of collections of files - see <A HREF="#ABOUT LARGE COLLECTIONS OF FILES">about large collections of files</A></P>

<P>Typically what happens is the text is first scanned to identify the target points, and create hashtable entries. When queried, the editor picks up a reference to the original target point an restores the editor focus to that at the time when the entry was created.</P>

<P>The ZombiObj exists because the gnu hashtables do not support removal of entries. When a <A HREF="#HASHTABLE DELETE">hashtable delete</A> request is made, the hashtable entry is left in place but the object it points to becomes a zombie.</P>

<P>When a buffer object is duplicated on the stack it is said to be cloned. The original and the clone are identical and point have pointers to the same underlying data structure.</P>

<P>Note that stack-based buffer that has already been used to define one data object cannot be used to define another. This restriction is, hopefully, not very onerous since the same data can be accessed via the first data object. The restriction comes about because, put simply, an object can only have one parent tree. In practice, as the hash-table trees are deleted, a data object shared between two different trees would acquire an undefined status.</P>

<P>When a hashtable is destroyed by <A HREF="#HASHTABLE DESTROY">hashtable destroy</A> or it's parent buffer is cleared (eg by the <A HREF="#A">A</A>, <A HREF="#%D">%D</A>, <A HREF="#%Q">%Q</A>, <A HREF="#%I">%I</A>, ... commands), then all of it's it's objects and any descendants are also destroyed. There may be clones of destroyed buffers on the stack or the current buffer may be a clone of a buffer previously dangling off a destroyed hashtable. These remain effective and usable - but their hashtable path is removed as their parent buffers no longer exist.</P>

<P>For more details on hashtables, take a look at <A HREF="#USING HASHTABLES">Using Hashtables</A>.</P>


</UL><H3><A NAME="ABOUT PROJECT FILES">About project files</H3>
<P>Jot can be used to maintain a stand-alone file or, for big complicated projects, a suite of files including source, documentation and whatever other text files that might constitute a code-development project.</P>

<P>Project files should be placed in a dedicated directory (the project-file directory) with a startup file containing all project-specific startup commands. The actual project files are usually ignored by the editor, they may be used for storing informal project-specific notes, to-do-lists, checklists etc.</P>

<P>An example project directory, startup file and project files are to be found at $&#123;JOT_RESOURCES&#125;/ide/... this directory was set up as an example for the <A HREF="jot_coms.html#IDE.JOT">ide.jot</A> script. It has the following subdirectories:</P>

<UL><P><LI>hello - a work directory for the hello project,</P></LI>

<P><LI>ed - a work directory for testing a development version of jot.</P></LI>

<P><LI>tree - a work directory containing a a simple suite of source files for demonstration and testing of ide.jot and</P></LI>

<P><LI>projects - the project-file directory, this contains the following:</P></LI>

<UL><P><LI>ide_hello - the project file for the hello.c project using ide.jot</P></LI>

<P><LI>ide_jot - the project file for jot development using ide.jot</P></LI>

<P><LI>ide_tree - the project file for the simple tree project using ide.jot</P></LI>

<P><LI>jot - the non-ide project file for jot development and</P></LI>

<P><LI>startup.jot - contains project-specific jot commands for all projects in this project directory.</P></LI>

</UL></UL><P>Th example projects in $&#123;JOT_RESOURCES&#125;/ide/projects are structured such that the work directory sits alongside the projects directory, in practice the work area can be anywhere convenient to you.</P>

<P>To initiate a project session, first cd to the projects directory then start the editor with the appropriate project file. The projects-directory startup.jot will set up the session using commands specified for your chosen project file. Note that the contents of the project file are usually ignored, you can use the project file for informal notes, tests, examples checklists and to-do lists.</P>


</UL><H3><A NAME="ABOUT INDEX FILES">About index files</H3>
<P>Index files contain pointers to specific points in one or more text files and are used to facilitate rapid and convenient context changes.</P>

<P>Jot supports two types of index files - the native jot format which is used to drive the <A HREF="#%I">%I</A> command with a seek and section-size specification and the vim-style tags file generated by the ctags unix command.</P>

<P>The native-jot index files are optimised for navigating *very* large files, where it would be impossible, or very inconvenient, to load and search the whole file - see <A HREF="#ABOUT LARGE FILES">about large files</A>. The native-jot index form has also been adapted for use with large collections of files eg the source-file tree for a complicated programming project - see <A HREF="#ABOUT LARGE COLLECTIONS OF FILES">about large collections of files</A>.</P>

<P>Jot also supports the vim-style tags files, these can be conveniently generated by generated by ctags.</P>

<P>The native-jot indexes supported by the jot scripts <A HREF="jot_coms.html#BIG_FILE.JOT">big_file.jot</A> and <A HREF="jot_coms.html#MULTI_FILE.JOT">multi_file.jot</A> are significantly faster for very large files since they use a filing-system seek to access the files and only read the sections of interest. The downside is that writing modified versions of the files requires special care. Writing is supported by big_file.jot, the modified file will usually require re-indexing as the seek points will have changed.</P>

<P>In contrast, vim-style tags files read the entire file to a buffer making it easy to write an updated version but, because it needs to search the entire file for each new section heading, it can be slow if there are any very big files in the tree - this is most unlikely for normal source-code trees.</P>


</UL><H3><A NAME="ABOUT LARGE FILES">About Large Files</H3>
<P>A working definition of a very large file is one big enough to exceed the capacity of a text editor as supported by our system. That definition takes into account various system configuration and tuning considerations like memory size swap size disc bandwidth cache size and all that sort of stuff.</P>

<P>The main problem with *very* large text files is not changing them but just viewing them. Although These files are generally both generated and read by machine they are presented in a text form because people need to work on them when something goes wrong.</P>

<P>These files are frequently used as intermediaries in CAD design flows using design systems from rival vendors. Many are based on spice netlists and a spice netlist of just a section of a modern chip is never going to be a small file.</P>

<P>So the way jot approaches this problem is to acknowledge that nobody, pondering the problem of "what went wrong" or "why am I seeing that error report" or "why that timing violation" is ever going to want to look at all xxxGb of a file - only the bits that an investigation leads to. So we need a method that lets us pull in the relevant bits of information. There are several qualifiers to the %I command that allow us to pull in selected parts of a big file and make it viewable - even if not editable. In any case modifying these files wouldn't do us much good - we'd be corrupting the design flow.</P>

<P>The <A HREF="#%I">%I</A> command has a number of qualifiers that are designed to facilitate the reading big files by the spoonful but this is of little use unless we already know which bits to read and precisely where they are. In %I, the -hold, -bytes and -block qualifiers can be used to read large files by the spoonful (or, indeed, by the bucketful) for filtering or generating an index, as in the <A HREF="jot_coms.html#BIG_FILE.JOT">big_file.jot</A> script. This script gives a more-or-less normal editing environment for specified sections of large files.</P>


</UL><H3><A NAME="ABOUT LARGE COLLECTIONS OF FILES">About Large Collections of Files</H3>
<P>Many modern editors offer methods of maintaining source-code trees using some sort of index file. In vim and Emacs thes index files are called tags files but in jotland we like to keep things simple, and jot index files are just called index files.</P>

<P>When working on some big complicated project, involving lots of source files or maybe, after downloading some source-code, one of the first things many of us like to do is to browse the source code to get some idea of how it works. </P>

<P>Unfortunately, the more complicated systems consist of a large number of source files and, without some prior knowledge of how the sources are structured, it can be difficult to see what's going on. The scripts <A HREF="jot_coms.html#MULTI_FILE.JOT">multi_file.jot</A> and <A HREF="jot_coms.html#CTAGS.JOT">ctags.jot</A> are designed to help with this problem.</P>

<P>These scripts each support a separate index-file format, multi_file.jot supports one based on an extension of the form used for large files (see <A HREF="#ABOUT LARGE FILES">about large files</A>) and ctags.jot supports vim-style tags files which can be conveniently generated by Exuberant Ctags.</P>


</UL><H2><A NAME="JOT PROGRAMMING">Jot Programming</H2>
</UL><H3><A NAME="SUCCESS, FAILURE AND ERRORS">Success, Failure and Errors</H3>
<P>Most commands set a success/failure flag. Failures are quite normal in JOT - many commands are used simply to locate structures in the text and these failures are normally handled in the command sequence. One may, for example want to test if the cursor is at the end of a record, then we might use the move right (<A HREF="#R">R</A>) command and check it's status - a failure can only happen when the cursor is at the end of a line.</P>

<P>Errors are more serious (typically a syntax error in your coding or an I/O operation that failed), these result in an immediate exit from the command sequence with a message in the console area. By default, errors will stop execution of the current command sequence with a message indicating what's gone wrong - these can be suppressed using <A HREF="#%S=VERBOSE">%s=verbose</A> or <A HREF="#-QUIET">-quiet</A>.</P>

<P>There is a message associated with failures too but these are suppressed by default. If a command sequence ends with the error flag set then the termination message "&#123;Command-sequence failed.&#125;" is issued with a simple diagnostic indicating which command failed.</P>

<P>If a command fails and no command is found to handle the failure, then the block or macro fails, if the failing command was not in a block or macro then a message like this appears at the console:</P>

&#062; &#123;Command-sequence failed.&#125;...&#060;failingcommand&#062;...
<P>See <A HREF="#%S=VERBOSE">%s=verbose</A> for details on controlling the level of error reporting.</P>

<P>Failing commands are handled as follows:</P>

<UL><P><LI>If the next command is the ignore-failures command <A HREF="#?">?</A>, the failure is ignored and processing continues.</P></LI>

<P><LI>If a failure handler exists (see the <A HREF="#,">,</A> command), then the failure-handler code is executed</P></LI>

<P><LI>If there is no failure handler, then the current block exits (see <A HREF="#JOT COMMAND STRUCTURE">Jot command structure</A> and <A HREF="#(">(</A> <A HREF="#)">)</A> ).</P></LI>

<P>If the block was an infinite loop i.e. '( ... )0' then the loop exits without passing on the failure, all other types of blocks fail.</P>

<P><LI>The reverse status command <A HREF="#\">\</A> reverses the status of the preceding command you can also reverse the status of a command that's already had it's status reset by the <A HREF="#?">?</A> command - in this case the command *always* fails - which can sometimes be useful.</P></LI>


</UL><H3><A NAME="JOT COMMAND STRUCTURE">Jot command structure</H3>
<P>Jot allows users to construct macro-commands which can apply tests make decisions and return results - they can also, of course, alter your text.</P>

<P>Most commands are capable of failure, by looking at the status returned by a command we can often deduce something useful about the text we're working on. If, for example, the <A HREF="#R">r</A> command fails it can only mean that the cursor is already at the end of a line, if <A HREF="#F">f</A>/&#060;string&#062;/ fails then it means that string does not exist. When writing a macro-command these failures are not so much disasters as potentially useful results.</P>

<P>Jot commands are organized into blocks bounded by round brackets. Optionally, the sequence of commands within a block may be broken by commas, the sequence following the comma take control if a failure occurs in the sequence before the comma - giving us an if-else structure. Since the else-sequence might fail successive commas can be deployed giving us an if ... elseif ... elseif ... structure. Ultimately, if the last sequence in the block fails then the *entire* block returns a failure. Blocks may be nested to any number of levels.</P>

<P>Jot blocks, like most jot commands, can be given a repeat count. As with jot commands this may be infinite the repeat count for a block must be a decimal literal immediately after the end brace. As with other jot commands for an infinitely repeating block, set the repeat count to zero. In the event of an unhandled failure occurring in a repeated block, the block exits immediately even if it has not gone through all it's iterations. In these circumstances a block with a finite repeat count returns a failure, an infinitely-repeating block always returns success.</P>

<P>A sequence of commands can be enclosed within parenthesis (see <A HREF="#(">(</A> and <A HREF="#)">)</A> ), this has the following effects:</P>

<UL><P><LI>The block can be used to define the extent of <A HREF="#SUCCESS, FAILURE AND ERRORS">success, failure and errors</A> - in the phrase (r, m) ... , for example, if the r command fails (because we're at the end of a line), then it moves to the next line.</P></LI>

<P><LI>The block can repeat commands for a predefined number of iterations - for example, the phrase (mi/#/)10 will insert a # at the start of the next 10 lines. If a command in this type of block should fail, then the loop exits early and the block sets the failure flag.</P></LI>

<P><LI>The block can be repeated to exhaustion - i.e. until something fails - for example l0(q/A-Z/c, r)0 will change the case of all upper-case characters on the line. In this case, a failing command will also cause the block to exit, but the failure flag is reset.</P></LI>

<P><LI>The block's status can be handled like the status of any other command:</P></LI>

<UL><P><LI>( ... )? and ( ... )123? - resets the failure flag following a failure.</P></LI>

<P><LI>( ... )\ and ( ... 123)\ reverse the status on exit.</P></LI>

<P><LI>( ... )?\ and ( ... )123?\ - these blocks will always fail.</P></LI>

<P><LI>( abc ) def , ghi - if the '( abc )' block fails then commands ghi are executed, otherwise it takes commands def.</P></LI>

</UL><P>Here's a few examples:</P>

<UL><P><LI>( ... , )0 - this block will loop indefinitely.</P></LI>

<P><LI>( ... ,) and ( ... )? - these two have an identical effect,</P></LI>


</UL></UL><H4><A NAME="FINITE REPEAT BLOCK EXAMPLE">Finite Repeat Block Example</H4>
<P>(f/fred/s/bill/)23 - is a finite repeat block, it seeks the next 23 occurrences of fred and substitutes bill. If there are less then 23 freds in the text then the F command fails and so to does the complete block. If there are more than 23 then, on completion, there will still be some fred's left.</P>


</UL><H4><A NAME="CONDITIONAL REPEAT BLOCK EXAMPLE">Conditional Repeat Block Example</H4>
<P>(f/fred/s/william/)0 - is a conditional repetitive block, the thing keeps on finding freds and substituting williams until all freds have been found, then the <A HREF="#F">F</A> command fails, the block exits but in this case the block exits successfully.</P>


</UL><H4><A NAME="STATUS CHECKING EXAMPLE">Status Checking Example</H4>
<P>(f1/fred/s/bill/, f1/jim/s/dave/) - If the current line has a fred at or to the right of the current character, it will get changed to bill. If there is no fred then the failed f1 command leaves the current character unchanged and searches the line for jim, if found then it gets changed to dave.</P>


</UL><H3><A NAME="ABOUT MACROS">About macros</H3>
<P>Any buffer can hold sequence of commands, the commands in the buffer can be executed as a macro command. Macro commands can call other macros - but recursive macro calls (where a macro, or one of it's children, calls itself) are not allowed. The command to run a macro is a single quote ( ' ) followed by the buffer key.</P>

<P>To run a macro place the macro-buffer key it in a command string prefixed by a single quotemark ( ' ) e.g:</P>

&#062; %d3=f/my_string/
<P>this macro is run as follows:</P>

&#062; '3 

</UL><H3><A NAME="CALLING SUBROUTINES BY NAME">Calling subroutines by name</H3>
<P>Jot offers a primitive form of subroutine support, Sequences of commands may be entered in a buffer and then referenced using the <A HREF="#HASHTABLE CALL">hashtable call</A> command.</P>

<P>Code can be designed to operate only on the stack resulting in procedure-like behaviour. There is no formally-defined parameter-passing mechanism - programmers may use the stack or global buffers. But, it should be noted, that there is no protection of stack objects - programmers must be very careful to maintain strict discipline in their stack operations. Also, the only way back to the calling macro is to reach the end of the called sequence - there is no return command.</P>

<P>The code repository set up by <A HREF="jot_coms.html#STARTUP.JOT">startup.jot</A> is in the ' buffer. The first line of the code is, by convention, assumed to be the routine name and is ignored by the %h=call command. </P>

<P>Where there are many routines defined by the normal startup script (see <A HREF="jot_coms.html#STARTUP.JOT">startup.jot</A>) saved in a buffer, there is no explicit mark denoting the end of each. Instead, the first line of the next routine is used as an end marker. The %h=call behaviour detects the end of a routine by checking for the existence of tags on each record. Any tag is assumed to be the hash-table target for the next routine in the repository. This very simple approach breaks if, for any reason, other tags have been added - so do not apply the <A HREF="jot_coms.html#JOT.JOT">jot.jot</A> to the code repository.</P>


</UL><H3><A NAME="ABOUT THE OPERAND STACK">About the Operand Stack</H3>
<P>The operand stack allows simple arithmetic operations and tests to be performed on objects (typically integer quantities) held in a push-down stack. It can also hold temporary buffers created by the system query commands. The full range of operations is described in <A HREF="#STACK OPERATIONS">Stack Operations</A>.</P>

<P>The underlying C-language type for integer values is long long, for real values it's double.</P>

<P>For the benefit of those not familiar with the notion of stacks in computing. Stacks are analogous to those spring-loaded plate stacks so beloved of institutional caterers. As clean plates are delivered, the stack gets pushed down, as plates are taken off the next one pops up. Note that, as plates are added individually, the last one on is the first one off - this is a key property of computer stacks. </P>

<P>And so it is, with our operand stack, new values are 'pushed' onto the stack and later 'popped' off for processing. Each item on the jot stack is wrapped up in a little data structure called a stack frame, which play the part of plates in the above description.</P>

<P>Essentially the stack can be loaded with values from (see <A HREF="#STACK OPERATIONS">Stack operations</A> for the full list):</P>

<UL><P><LI>Integer or real numbers picked up from the text (e.g. with <A HREF="#OI">oi</A>),</P></LI>

<P><LI>Integers or real numbers literals from the command line (see <A HREF="#OL">OL</A>),</P></LI>

<P><LI>Integers generated by the random-number generator (see <A HREF="#OA">OA</A>),</P></LI>

<P><LI>Integers describing the current focus point (i.e. buffer i.e., line number <A HREF="#ON">ON</A> and character number<A HREF="#OC">OC</A>),</P></LI>

<P><LI>Integers, Reals or Buffers held by hashtable data objects (see <A HREF="#USING HASHTABLE DATA">Using hashtable data</A>)</P></LI>

<P><LI>A temporary buffer created for as a destination buffer for any command that directs it's output to a buffer eg: %q~=date;.</P></LI>

<P><LI>Arithmetic and logical operations can be performed on numerical values (see <A HREF="#O+">O+</A>, for example.</P></LI>

<P><LI>Values and strings can be written to the buffer text (see <A HREF="#OO">OO</A>).</P></LI>

<P><LI>Numerical values can be extracted by indirect references - eg: %w '~; - sets the window size to an integer picked up from the stack. If the top stack frame is a buffer, then the current character of that buffer must be pointing to one or more digits for conversion to an integer - see also <A HREF="#ABOUT COMMAND PARAMETERS">About command parameters</A>.</P></LI>

</UL><P>If performing a straightforward abstraction or maybe a query to stack with %q~=... (see <A HREF="#%Q">%Q</A>), a new buffer stack frame will be created at the top of the stack. If, however, you are doing a cumulative abstraction (i.e. a~+,a~- or a~. - see <A HREF="#A">A</A>) then the item at the top of the stack must be a buffer stack frame.</P>

<P>Jot supports the usual arithmetic and logical operations and can use values in the stack to control programme flow or values can be written to the text. Addition, for example, pops the top two values and pushes their sum back onto the stack (see <A HREF="#O+">O+</A>).</P>

<P>All arithmetic and comparison operations will work with integer or real values, for mixed operations integers are first converted to reals and the results of such arithmetic is always real. Any attempt to perform arithmetic on a buffer-type will fail.</P>


</UL><H3><A NAME="ABOUT METASYNTAX">About metasyntax</H3>
<P>The following metasyntax has been used in this user guide:</P>

<UL><P><LI>a '$' in the first column represents a CLI prompt, the following text is something for you to type in response to whatever prompt your CLI uses.</P></LI>

<P><LI>a '&#062;' in the first column represents a jot prompt, the following string is something you type to the editor.</P></LI>

<P><LI>A key name in curly brackets indicates that this is a button, or sequence of buttons to press e.g:</P></LI>

&#062; fred&#123;F8&#125;        - type the word 'fred' then hit the F8 function key
&#062; fred&#123;Shift+F8&#125;  - type 'fred' then hold the Shift key and hit F8
&#062; fred&#123;Ctrl+F8&#125;   - type 'fred' then hold the Control key and hit F8
&#062; fred&#123;Alt+F8&#125;    - type 'fred' then hold the Alt key and hit F8
&#062; 7 12&#123;Esc b x&#125; - type 7 a blank then 12 then hit the Escape key followed by
<P>the letter b followed by the letter x.</P>

<P><LI>Anything else in angle brackets is intended to represent some class of command or command argument. e.g. &#060;failingCommand&#062; denotes some command that failed, &#060;n&#062; any number, &#060;alphaString&#062; - any number of alphabetical characters.</P></LI>

<P><LI>Something in double angle brackets (e.g. &#060;&#060;this&#062;&#062;) represents a jot function defined in the startup file - normally you will be given the key bindings to type in. You will see these mentioned in the user guide $&#123;JOT_HOME&#125;/docs/jot_ug.html and in the startup scripts $&#123;JOT_HOME&#125;/coms/startup.jot and $&#123;JOT_HOME&#125;/coms/curses_keys_&#060;TERM&#062;.jot</P></LI>

<P><LI>Something in square brackets is optional &#091; -bells&#093;&#091; -whistles&#093; indicating that it's valid to give -bells and/or -whistles or neither. In some cases they are nested - e.g.: &#091; -bells&#091; -whistles&#093;&#093; - in this case valid usage would be give -bells, -bells and -whistles or neither.</P></LI>

<P><LI>A list of things, separated by vertical bars ( | ) are valid options, in some cases you must give at least on of them - the accompanying text should clarify this.</P></LI>


</UL><H3><A NAME="PERCENT-COMMAND SYNTAX">Percent-command syntax</H3>
<P>Typical syntax of a percent command (for details see <A HREF="#PERCENT COMMANDS">percent commands</A>):</P>

<PRE>
%da=f/example/;
</PRE>
<P>The first character after '%' is the command character, 'd' in this case defines a buffer. As with many percent commands, the next character is a buffer key. The text following the '=' is normally a string argument for the command.</P>

<P>For most of these commands, all or part of the text following the equals sign ( = ) may contain an indirect reference to the current line of some other buffer e.g:</P>

<PRE>
%d$=dir /home
%q~=dir '$
</PRE>
<P>or, more usefully:</P>

<PRE>
%q$=env JOT_HOME; m
%q~=dir '$
</PRE>
<P>The main exception is <A HREF="#%E">%E</A> - the single-quote character ( ' ) being very important in unix shell commands so any ' characters are passed through to the CLI unchanged.</P>

<P>Historically, these commands occupied a complete command line on their own with no terminating character. This made it difficult to incorporate percent commands in command sequences, so now they may be terminated by a semicolon ( ; ) and other commands may follow, in the same line. The only exceptions are comments - where all text to the right of the %% is ignored.</P>

<P>Unfortunately, the string argument may contain semicolons or apostrophes - these are quite commonly occurring characters in various percent commands. Semicolons and apostrophes in the command text can be escaped by prefixing with a backslash ( \ ) thus:</P>

&#062; %da=123\;456\\;789;
<P>this should result in buffer ( A ) being set to "123;456\;789". Sometimes, of course we might want to use an apostrophe as an apostrophe - then this too can be escaped with a backslash:</P>

&#062; %x=The system\\'s broken - sorry!
<P>Now that's OK for programming jot code, unfortunately users will sometimes want to define parameters containing semicolons. All parameters to jot function-key functions pass through a a %d - users would find it to be a real drag having to remember to escape these every time they are entered. To avoid this, there is an explicit command terminator syntax that's only for picking up parameters: " -hereEndsThePercentCommand;".</P>

<P>A function requiring a parameter that might include a semicolon might pick it up in buffer ( $ ) like this:</P>

<UL><P>%d$=##" Insert string&#062; " -hereEndsThePercentCommand; ...</P>

<P><LI>A semicolon escaped by a backslash works in %E:</P></LI>

&#062; %ea=( cd JOT_RESOURCES&#125; \; ls -l ); f/ t.t/

</UL><H3><A NAME="USING HASHTABLES">Using Hashtables</H3>
<P>Hashtables offer a good way of rapidly accessing data objects scattered around in an unstructured mass. Although initially introduced to the editor as a way of finding predetermined points in a large file image (see <A HREF="#USING HASHTABLES TO LOCATE TEXT">Using Hashtables to Locate Text</A>), their range has been expanded to calling jot functions (see <A HREF="#CALLING SUBROUTINES BY NAME">calling subroutines by name</A>), fast access of large files (see <A HREF="#ABOUT LARGE FILES">about large files</A>), accessing large collections of moderately-sized files (see <A HREF="#ABOUT LARGE COLLECTIONS OF FILES">about large collections of files</A>) and storage and retrieval of generic data (see <A HREF="#USING HASHTABLE DATA">using hashtable data</A>).</P>

<P>All %h commands can refer to hashtables belonging to other buffers e.g. the command "%hz=jump fred;'" will search for an entry "fred" in the hashtable associated with buffer z, whereas "%h=jump fred;" will search the hashtable in the current buffer. </P>


</UL><H4><A NAME="USING HASHTABLES TO LOCATE TEXT">Using Hashtables to Locate Text</H4>
<P>The <A HREF="#HASHTABLE ADD">hashtable add</A> and <A HREF="#HASHTABLE JUMP">hashtable jump</A> commands provide a method of indexing and rapidly returning to sections on the text image.</P>

<P>Internally, this works by storing internal memory addresses of text targets in the hashtable. The hashtable entry points to a record descriptor which remains constant even if text has been added or removed in the buffer and a target-point tag is inserted in the record metadata.</P>

<P>The target is the selected substring at the time when the hash-table entry was first created. Now future changes to the text may change the record containing the target but the target substring must match the hashtable entry. In this context there are two important classes of change to consider</P>

<UL><P><LI>changes which only move the target to a new location and changes that</P></LI>

<P>delete the target string.</P>

<P>The <A HREF="#HASHTABLE JUMP">hashtable jump</A> command returns to same focus point as when the entry was created with the <A HREF="#HASHTABLE NEW">hashtable new</A> or <A HREF="#HASHTABLE ADD">hashtable add</A> commands. It also maintains the original line number - this might now be wrong since changes to the target buffer may have altered the actual line number - but the linenumber entry in the hashtable is out of date. If this is a problem then use the <A HREF="#HASHTABLE FIX">hashtable fix</A> command to update line numbers held in hashtables.</P>

<P>When the context switch happens, the line number in the target buffer is set to the line number at the time when the entry was created. This may now be incorrect if records have been added or deleted between the hash-table target points.</P>

<P>The editor automatically adjusts hashtable entries when changes have moved the target. It offers several options for situations when the target string has been deleted.</P>

<P>The simplest method is to make the target buffer readonly (the buffer containing the target string - see <A HREF="#%B=READONLY">%b=readonly</A>). Making the buffer ReadOnly is a simple and totally effective but it is quite restrictive.</P>

<P>Another option is to automatically destroy the hashtable when target records are deleted - this is appropriate when the usage implies that any change requires a hashtable rebuild - see <A HREF="#HASHTABLE CREATE">hashtable create</A>.</P>

<P>Another option is to protect records containing the target strings from deletion - see <A HREF="#HASHTABLE CREATE">hashtable create</A>.</P>

<P>Another option is for the hashtable target points to be adjusted to point to the next available point in the text - see adjust in <A HREF="#HASHTABLE CREATE">hashtable create</A>.</P>

<P>Finally, the default option, is to just remove the hash-table entries pointing to deleted targets, this is the default behaviour - see delete in <A HREF="#HASHTABLE CREATE">hashtable create</A>.</P>

<P>For examples of %h=jump - look at $&#123;JOT_HOME&#125;/coms/qr.jot (see <A HREF="jot_coms.html#QR.JOT">qr.jot</A>).</P>


</UL><H4><A NAME="USING HASHTABLE DATA">Using Hashtable data</H4>
<P>The primary focus for arithmetic and logical operations is the stack (see <A HREF="#ABOUT THE OPERAND STACK">about the operand stack</A>) - values and strings can be placed on the stack, manipulated and either written to some buffer or used to control programme flow. The <A HREF="#HASHTABLE DATA">hashtable data</A> command is essentially the declaration of a data object. The value of this object can be copied to and from the top of the stack.</P>

<P>Once defined by the hashtable data command, a value can be assigned using the <A HREF="#OV">OV</A> command which pops the stack and copies the value to the data object.</P>

<P>Note that the hashtable data command does not require the specification of a data type - the type of data (an integer value, a real value or a string) is defined at the time when a value is assigned. In fact it is possible to change the type of a data object any number of times.</P>

<P>The value can be retrieved using the <A HREF="#OQ">OQ</A> command, essentially the reverse of OV, the value is copied to a new stack frame and pushed onto the stack.</P>


</UL><H3><A NAME="THE JOT DEBUGGER">The jot debugger</H3>
<P>The editor has various features designed for the monitoring of execution flow and the location and analysis of bugs. There are various methods of probing the internal state of the editor and various methods for selecting break points. It supports a simple single-step debugger with various options for controlling the step range and the amount of information displayed at each step - see <A HREF="jot_ug.html#ABOUT JOT DEBUGGING">About jot debugging</A>. The break point can be defined in the following ways:</P>

<UL><P><LI>explicitly by inserting the <A HREF="#T">T</A> command in the code what this does is to set the trace vector (see <A HREF="#%S=TRACE">%s=trace</A> and <A HREF="#%S=TRACEDEFAULT">%s=tracedefault</A>),</P></LI>

<P><LI>by setting the command counter - see <A HREF="#%S=COMMANDCOUNTER">%s=commandcounter</A> or</P></LI>

<P><LI>by selecting one of a set of predefined event classes - see <A HREF="#%S=TRACE">%s=trace</A>.</P></LI>

</UL><P>The T command is easily inserted into the source code of any script, macro or command line. Where this is not selective enough, the T command can be made conditional e.g.: ... (v/fred/t, ) ... will only trigger the trap when the text at the current character matches the string "fred".</P>

<P>The command counter method is useful when a data-sensitive failure occurs deep into many re-iterations of programme loops. In order to use this method successfully it is first necessary to identify the command count just before the point of failure. The <A HREF="#%S=VERBOSE">%s=verbose</A> command can be used to call for failure reports from all failing commands, along with associated command counts. Under these circumstances many thousands of messages might be generated but, normally, it is only the last two or three that are significant. It's a good plan to reduce the size of the display window (see <A HREF="jot_ug.html#WINDOWSHRINK">WindowShrink</A>) in order to maximize the size of the console area of the screen. It may even be necessary to run in -tty mode so that all of the messages can be scanned.</P>

<P>Finally, one can set a breakpoint to go off every time a particular event occurs:</P>

<UL><P><LI>a new line is read from the command stream,</P></LI>

<P><LI>a new script has started (see <A HREF="#%R">%R</A>),</P></LI>

<P><LI>a new macro-command has been called,</P></LI>

<P><LI>A Ctrl+C interrupt has been received,</P></LI>

<P><LI>a command failure has occurred or</P></LI>

<P><LI>every new command.</P></LI>


</UL><H3><A NAME="JOT FOR EXPERIENCED ECCE USERS">Jot for experienced ecce users</H3>
<P>The first, most obvious difference between jot and ecce is that jot is a screen editor - it maintains a window as an accurate reflection of the what the file image is currently looking like.</P>

<P>The next significant difference is that, whereas ecce would only use printing characters for controlling the editor, jot also utilizes function keys and, where available, the numeric and mid keypads.</P>

<P>Internally, the structure is quite different, ecce used the buffer-gap structure which made good use of simple memory schemes available in 1960's minicomputers. In contrast jot uses a less efficient but more flexible record-descriptor structure better suited to modern approaches to memory management.</P>

<P>Comparing the command set of ecce with jot, we see a few old favourites have been culled (D, T, U have been abolished or reassigned new meanings). However, for the percent commands, the cull is more like a total bloodbath - only %A, %C, %I and %O remain in anything like their original forms.</P>

<UL><P><LI><A HREF="#A">A</A> - can now abstract to the nearest character (see <A HREF="#N">N</A>), and has new '+', '-', '.', '*' and '&' qualifiers.</P></LI>

<P><LI><A HREF="#B">B</A>, <A HREF="#C">C</A> - identical.</P></LI>

<P><LI>D Abolished.</P></LI>

<P><LI><A HREF="#E">E</A>, <A HREF="#F">F</A>, <A HREF="#G">G</A> - pretty much unchanged.</P></LI>

<P><LI><A HREF="#H">H</A> - has new '*' qualifier.</P></LI>

<P><LI><A HREF="#I">I</A>, <A HREF="#J">J</A>, <A HREF="#K">K</A> and <A HREF="#M">M</A> - unchanged.</P></LI>

<P><LI>L - abolished - use <A HREF="#R">R</A>- instead.</P></LI>

<P><LI><A HREF="#N">N</A> has new '.' qualifier for abstraction to nearest character.</P></LI>

<P><LI><A HREF="#M">M</A> - has new '*' qualifier (move window).</P></LI>

<P><LI>O - Reassigned - now prefix for <A HREF="#STACK OPERATIONS">stack Operations</A>.</P></LI>

<P><LI><A HREF="#P">P</A>, <A HREF="#Q">Q</A>, <A HREF="#R">R</A> and <A HREF="#S">S</A> - unchanged.</P></LI>

<P><LI><A HREF="#T">T</A> Reassigned as Trace point, traverse replaced by f/&#060;string&#062;/- .</P></LI>

<P><LI>U - abolished.</P></LI>

<P><LI><A HREF="#V">V</A> - unchanged.</P></LI>

<P><LI><A HREF="#W">W</A> - new command - refresh Window.</P></LI>

<P><LI>X - was macro-X call, now abolished.</P></LI>

<P><LI><A HREF="#Y">Y</A> - was macro Y call, now Y command (move in column).</P></LI>

<P><LI><A HREF="#Z">Z</A> - was macro Z call, now zoom (i.e. change current buffer).</P></LI>

<P><LI><A HREF="#%A">%A</A> - Now accepts exit status and exit message.</P></LI>

<P><LI><A HREF="#%C">%C</A> - essentially unchanged.</P></LI>

<P><LI><A HREF="#%D">%D</A> - Reassigned, now defines a one-line macro/text buffer.</P></LI>

<P><LI><A HREF="#%F">%F</A> - Reassigned - now regular-expression search.</P></LI>

<P><LI><A HREF="#%G">%G</A> - Reassigned - now defines (Gets) multi-line macro/buffer.</P></LI>

<P><LI><A HREF="#%H">%H</A> - New Command - for hashtable maintenance.</P></LI>

<P><LI><A HREF="#%I">%I</A> - unchanged, new options.</P></LI>

<P><LI><A HREF="#%L">%L</A> - Reassigned - (case sensitivity set by %S) now defines terminal line length.</P></LI>

<P><LI><A HREF="#%M">%M</A> - Reassigned prints message to console area.</P></LI>

<P><LI>%N - Abolished.</P></LI>

<P><LI><A HREF="#%O">%O</A> - Still outputs to filing system but with new options.</P></LI>

<P><LI><A HREF="#%Q">%Q</A> - Reassigned - now system Query.</P></LI>

<P><LI><A HREF="#%R">%R</A> - Reassigned - now Run a command script (file).</P></LI>

<P><LI><A HREF="#%S">%S</A> - Replaced by <A HREF="#Z">Z</A> command, %S now System interaction.</P></LI>

<P><LI>%T - Abolished.</P></LI>

<P><LI><A HREF="#%U">%U</A> - Reassigned - (now use %S to set case sensitivity) now reverses last substitution.</P></LI>

<P><LI><A HREF="#%W">%W</A> - Reassigned - now assigns buffers to windows.</P></LI>

<P><LI><A HREF="#%X">%X</A> - Reassigned - now prints specified message in the console area and eXits.</P></LI>

<P><LI>%Z - Abolished.</P></LI>


</UL><H2><A NAME="EDITOR COMMANDS">Editor commands</H2>
<P>JOT has the following commands, meta-commands and modifiers, most are capable of failing in some way, failures normally result in the raising of the failure flag (see <A HREF="#SUCCESS, FAILURE AND ERRORS">success, failure and errors</A>), this can affect execution flow:</P>

<UL><P><LI><A HREF="#A">A</A> - Abstract (remove or copy) all Text From Note Point (see <A HREF="#N">N</A>).</P></LI>

<P><LI><A HREF="#B">B</A> - Break Line At Current Character e.g. b2</P></LI>

<P><LI><A HREF="#C">C</A> - Change Case e.g. c5</P></LI>

<P><LI><A HREF="#E">E</A> - Erase bytes &#091;defaults to 1&#093; e.g. e5</P></LI>

<P><LI><A HREF="#F">F</A> - Find Substring e.g. f/fred/</P></LI>

<P><LI><A HREF="#G">G</A> - Get (read) Some Lines From Terminal e.g. g3</P></LI>

<P><LI><A HREF="#H">H</A> - Here (copy Text Buffer Here) e.g. hq</P></LI>

<P><LI><A HREF="#I">I</A> - Insert Substring e.g. i/fred/</P></LI>

<P><LI><A HREF="#J">J</A> - Join This Line With Next/previous Line(s) e.g. j-3</P></LI>

<P><LI><A HREF="#K">K</A> - Kill (delete) record(s) e.g. k</P></LI>

<P><LI><A HREF="#M">M</A> - Move To A New Line e.g. m</P></LI>

<P><LI><A HREF="#N">N</A> - Note This Point In Text For A Later Abstract Operation e.g. n</P></LI>

<P><LI>O - <A HREF="#STACK OPERATIONS">Stack Operations</A></P></LI>

<P><LI><A HREF="#P">P</A> - Print Line(s) e.g. p9</P></LI>

<P><LI><A HREF="#Q">Q</A> - Qualify (tests next chr. for membership of string) e.g. q/a-zA-z/</P></LI>

<P><LI><A HREF="#R">R</A> - Move Cursor Right e.g. r</P></LI>

<P><LI><A HREF="#S">S</A> - Substitute current substring for given string e.g. s/fred/</P></LI>

<P><LI><A HREF="#T">T</A> - enter (Trace) debug (single-step) mode e.g. t</P></LI>

<P><LI><A HREF="#V">V</A> - Verify (tests immediate for match with substring) e.g. v/fred/</P></LI>

<P><LI><A HREF="#Y">Y</A> - Move Cursor In Y Axis e.g. y3</P></LI>

<P><LI><A HREF="#Z">Z</A> - Zoom to Another Buffer e.g. zq</P></LI>

<P><LI><A HREF="#(">(</A> - Block start e.g. (f/fred/s/jim/)0</P></LI>

<P><LI><A HREF="#)">)</A> - Block end e.g. (f/fred/s/jim/)0</P></LI>

<P><LI><A HREF="#,">,</A> - Else clause e.g. f/fred/, f/jim/.</P></LI>

<P><LI><A HREF="#\">\</A> - Reverse status of previous command e.g. v/fred/\</P></LI>

<P><LI><A HREF="#?">?</A> - Ignore status of previous command e.g. f/fred/?.</P></LI>

<P><LI>% - Mainly housekeeping - see <A HREF="#PERCENT COMMANDS">percent commands</A></P></LI>


</UL><H3><A NAME="R">R</H3>
<PRE>
R&#091;n&#093; - shift Right by n characters (bytes if unicode support is turned 
</PRE>
<P>off - see <A HREF="#UNICODE - THE GRUESOME DETAILS">Unicode - the gruesome details</A>).</P>

<P>Move character pointer n&#091;1&#093; places to the right, it fails and raises the failure flag if there is an attempt to go past the end of the line. For non-unicode characters one byte is equivalent to one character. For unicode characters, if unicode support has been turned off (see the <A HREF="#%B=UNICODE">%b=unicode</A> command) the current-character pointer may be left pointing to a mid-unicode byte. See also <A HREF="#OR">OR</A> command and <A HREF="#ABOUT UNICODE">about unicode</A>.</P>


</UL><H3><A NAME="M">M</H3>
<PRE>
M&#091;&#091;=|-&#093;n&#093;|&#091;*&#091;-&#093;&#093; - Move to start of specified line.
</PRE>
<UL><P><LI>M moves forwards by one line.</P></LI>

<P><LI>M&#060;n&#062; Moves forwards by n lines.</P></LI>

<P><LI>M* Moves forwards sufficient lines to view next page on screen.</P></LI>

<P><LI>M- moves back by 1 line.</P></LI>

<P><LI>M-&#060;n&#062; moves back by n lines.</P></LI>

<P><LI>M*- (or M-*) Moves back sufficient lines to view previous page on screen.</P></LI>

<P><LI>M0 moves to last line of file.</P></LI>

<P><LI>M-0 move to first line of file.</P></LI>

<P><LI>M=&#060;n&#062; moves to absolute line no. n</P></LI>

</UL><P>The command raises the failure flag if there is an attempt to move past the last line or before the first line of the file.</P>


</UL><H3><A NAME="Y">Y</H3>
<PRE>
Y&#091;&#091;=|-&#093;n&#093;|&#091;*&#091;-&#093;&#093; - move in column (Y axis) by &#091;n&#093; lines.
Y0 - Reset the column traversed by subsequent Y commands.
</PRE>

<P>Similar to the <A HREF="#M">M</A> command except that it up and down in a column of text.</P>

<P>If it passes through a line that is too short to maintain the columnar movement, the cursor is left at the end of the line but the original column number remains stored internally. If some subsequent invocation of Y passes through lines of sufficient length, the original columnar movement is restored.</P>

<P>The special case y0 will reset the internally-stored column number. It does not affect the cursor position but causes the *next* y command to redefine the column number.</P>


</UL><H3><A NAME="E">E</H3>
<PRE>
E&#091;-&#093;&#091;&#060;n&#062;&#093; - Erase n bytes to the right &#091; or left&#093; of the cursor.
</PRE>
<P>Erase next&#091;previous&#093; n&#091;1&#093; bytes. If n is finite and would cause the cursor to go out of bounds the failure flag is raised. With a positive arg, E deletes the bytes from the currently-selected character and characters to it's right. With a negative arg, it deletes bytes from characters to the left of the current chr.</P>

<P>The programmer must be aware that one byte is not necessarily a complete character - see <A HREF="#ABOUT UNICODE">about unicode</A>.</P>


</UL><H3><A NAME="P">P</H3>
<PRE>
P&#091;-&#093;&#091;&#060;n&#062;&#093; - print line(s).
</PRE>
<P>Prints (displays in the console area) the next&#091;/previous&#093; n&#091;1&#093; lines. If n is specified, and is greater than 1, or less than -1, then the current line is set to the last line printed. If the value of n would cause it to go outside the range of the current buffer then the failure flag is raised.</P>


</UL><H3><A NAME="W">W</H3>
<PRE>
W - redraw Window.
</PRE>
<P>Forces a redrawing of the Window - by default the window is only redrawn when it re-prompts for a new command string (at a breakpoint or normal command-entry prompt) - this command can be included in a complicated macro or command script to allow the user to review progress or for debugging.</P>


</UL><H3><A NAME="F">F</H3>
<PRE>
F&#091;-&#093;&#091;range&#093;&#091;&#060;delim&#062;&#060;string&#062;&#060;delim&#062;|'&#060;key&#062;&#093;&#091;-&#093;&#091;rpts&#093; - Find
</PRE>
<P>Search text for specified string. If found the substring is highlighted and becomes the selected substring. - see <A HREF="jot_ug.html#ABOUT THE CURRENT CHARACTER AND SUBSTRINGS">About the current character and substrings</A></P>

<P>The F command takes parameters which specify the search string, a range and repeat count.</P>

<P>By default JOT starts off in it's case insensitive mode, this can be modified by the '%S=case' command.</P>

<P>If there is no currently-selected no substring, the search starts at the current character. If there is a substring, the search starts one characters after (or one character before, in the case of F-) the start of the current substring.</P>

<P>For unsuccessful forwards-looking multi-line searches the current character is left at the start of the last searched line. For unsuccessful backwards-looking searches current character is left at the end of the last-searched line.</P>

<P>For unsuccessful single line searches (i.e. when the range parameter is set to 1) the current character pointer is left unchanged for both forwards and backwards-looking searches.</P>

<P>Parameters:</P>

<UL><P><LI>1 Direction, a '-' will cause it to search back towards the start e.g.</P></LI>

<UL><P>f-/abc/</P>

</UL><P><LI>2 Range specifies the max. no. of lines to search (defaults to unlimited). e.g. f3/abc/ - this will search the next three lines, including any of the current line to the right of the cursor.</P></LI>

<P><LI>3 The string can be a literal string delimited by any non-alphanumeric ASCII character that does not appear in the string e.g. f"abc", also, the ' character cannot be used - see <A HREF="#ABOUT COMMAND PARAMETERS">about command parameters</A>. N.B. unicode characters cannot be used as delimiters.</P></LI>

<P>The second delimiter may be omitted is there are no further commands or modifiers on the command line - e.g. f/monday</P>

<P>Alternatively, the '&#060;key&#062; form will search for a match to the current line of the nominated buffer e.g. f'@ - see <A HREF="#ABOUT COMMAND PARAMETERS">about command parameters</A>.</P>

<P>Finally, if no find string is specified, then it uses the last-used literal search string.</P>

</UL><P>e.g: in the following, the first command finds the next occurrence of the string 'fred', the next find locates the string indicated by the current record of the $ buffer and, finally, it locates the next instance of the string 'fred'.</P>

&#062; f/fred
&#062; f/'$
&#062; f
<UL><P><LI>The optional hyphen after the search string causes the current-character pointer to be left after the end of the substring. By default it is left at the first character of the substring.</P></LI>

&#062; f/fred/-
<P><LI>4 The final parameter is used to repeat the search. e.g. f/abc/23 will stop at the 23rd. occurrence of "abc".</P></LI>

</UL><P>See also <A HREF="#%F">%F</A> - regular-expression search and <A HREF="#%S">%S</A> to change case sensitivity.</P>


</UL><H3><A NAME="T">T</H3>
<PRE>
T - Trace
</PRE>
<P>This sets the trace vector to the value specified by the default trace vector. By default the trace vector is 0 (no tracing activity) and the default trace vector is set to Trace_Stack, Trace_Print, Trace_Break and Trace_AllCommands this means:</P>

<UL><P><LI>It will report the stack contents at each trace point,</P></LI>

<P><LI>it will print the current line of the current buffer at every trace point,</P></LI>

<P><LI>it will enter an execution breakpoint at every trace point and</P></LI>

<P><LI>the trace point will be every command.</P></LI>

</UL><P>Alternatively, the trace vector can be set explicitly with the <A HREF="#%S=TRACE">%s=trace</A> command. The default trace vector can be redefined with <A HREF="#%S=TRACEDEFAULT">%s=tracedefault</A>.</P>

<P>See also <A HREF="jot_ug.html#ABOUT JOT DEBUGGING">about jot debugging</A> and <A HREF="#THE JOT DEBUGGER">the jot debugger</A>.</P>


</UL><H3><A NAME="Q">Q</H3>
<PRE>
Q&#091;-&#093;&#091;&#060;delim&#062;&#060;string&#062;&#060;delim&#062;|'&#060;key&#062;&#093; -  Qualify
</PRE>
<P>Tests for existence of any of a specified set of ASCII characters in substring - n.b. This does not currently work for unicode characters.</P>

<P>The argument string can contain any ASCII characters but not unicode.</P>

<P>The character at &#091;or before&#093; the current character position is matched to the character set specified by the string parameter, if one of the specified set of characters matches then the command returns successfully, otherwise if reports a failure. The Q command is invariably case sensitive and has no effect on the text file image.</P>

<P>If, instead of the &#060;delim&#062;&#060;string&#062;&#060;delim&#062; syntax, the '&#060;key&#062; syntax is used, then the qualifying string is in the current line of the specified buffer.</P>

<P>The string may be a simple list of all allowable characters, or may specify a range of ASCII characters ordered by their ASCII codes, to match to the literal '-' character it should be the first or last in the string for example:- Q/0123456789/ Will match to any digit. Q/0-9/ Will do the same but saves typing. Q/0-9+-/ Will match to any digit or the '+' or '-' characters. Q/0-9A-Fa-f/ Will match to any Hex digit.</P>


</UL><H3><A NAME="V">V</H3>
<PRE>
V&#091;-&#093;&#091;string&#093; - Verify string.
</PRE>
<P>Verify - tests text at current character position for match with string.</P>

<P>If the given string matches the substring to the right of the cursor then the substring is highlighted and becomes the <A HREF="jot_ug.html#ABOUT THE CURRENT CHARACTER AND SUBSTRINGS">About the current character and substrings</A>. If not then the failure flag is raised. Correspondingly, V- verifies the text to the left of the cursor.</P>


</UL><H3><A NAME="C">C</H3>
<PRE>
C&#091;-&#093;&#091;n&#093; - Change case.
</PRE>
<P>Change case of next &#091;/previous&#093; n characters. If n is specified and would cause the cursor to go out of bounds the failure flag is raised.</P>

<P>Note that the C command has no affect on unicode characters.</P>


</UL><H3><A NAME="I">I</H3>
<PRE>
I&#091;-&#093;&#091;string&#093;&#091;n&#093; - Insert substring
</PRE>
<P>Inserts specified substring before current character.</P>

<P>The optional '-' parameter only affects the position of the substring end pointer on completion - normally the cursor is immediately after the end of the inserted substring I- causes it to be at the start.</P>


</UL><H3><A NAME="S">S</H3>
<PRE>
S&#091;-&#093;&#091;&#060;delim&#062;&#060;string&#062;&#060;delim&#062;|'&#060;key&#062;&#093; - Substitute
</PRE>
<P>Replace the currently-selected string with the given string.</P>

<P>If a substitute string is defined then this is replaces the current substring, if no substitute string is specified then the last used substitute string is used.</P>

<P>When the '&#060;key&#062; syntax is used, the substituted string is taken from the current line of the specified buffer.</P>

<P>This command normally only fails when the current buffer does not currently have a valid substring <A HREF="jot_ug.html#ABOUT THE CURRENT CHARACTER AND SUBSTRINGS">About the current character and substrings</A> (e.g. following a F, T V or a previous S command) - when it fails the failure flag is raised.</P>


</UL><H3><A NAME="B">B</H3>
<PRE>
B&#091;-&#093;&#091;n&#093; - Break line.
</PRE>
<P>Where n is an optional (defaults to 1) repeat count, on completion the character pointer is left at the beginning of the second line (i.e. it still points to the same character), except if a negative repeat count is entered</P>

<UL><P><LI>zeros are not allowed for break counts.</P></LI>

<P>A negative repeat count will break the line the same number of times but will leave the character pointer at the end of the first half line.</P>


</UL><H3><A NAME="G">G</H3>
<PRE>
G&#091;&#060;n&#062;&#093; - Get 
</PRE>
<P>Read a new line(s) of text or single character from the keyboard.</P>

<P>Use this to key in new text above the current line, the parameter sets the number of lines to be input or you may terminate with a control+C or a colon ':' at the beginning of an otherwise empty line.</P>

<P>By default it prompts with "&#062; " but you may define the prompt string using <A HREF="#%S=PROMPT">%s=prompt</A>.</P>

<P>If a linecount is specified and an early exit is forced, then the failure flag is raised.</P>

<P>See also the <A HREF="#%G">%G</A> command, which reads lines from the current script or macro and the <A HREF="#OG">OG</A> command, which reads single characters to the stack.</P>


</UL><H3><A NAME="J">J</H3>
<PRE>
J&#091;-&#093;&#091;n&#093; - Join
</PRE>
<P>Joins current line with next (or previous) line.</P>

<UL><P><LI>J Joins the current line with the next line</P></LI>

<P><LI>J- Joins the current line with the previous line</P></LI>

<P><LI>J&#060;n&#062; joins the next n+1 lines</P></LI>

<P><LI>J-&#060;n&#062; joins the previous n+1 lines</P></LI>

</UL><P>If join runs out of lines (because it's at the start/end of the buffer) then the failure flag is raised.</P>


</UL><H3><A NAME="K">K</H3>
<PRE>
K&#091;-&#093;&#091;n&#093; - Kill i.e. delete line(s).
</PRE>
<P>This completely removes lines and there is no way of getting them back. If n is specified and finite and it runs out of lines to kill, then the command fails. K0 deletes the current line and all subsequent lines, K-0 deletes the current line and all previous lines.</P>

<P>K- deletes the current line and leaves the cursor at the begining of the line above, similarly K-n deletes the current line and up to (n-1) lines above leaving the cursor at the begining of the line above the last deleted line. If the first line was deleted, then the cursor is left at the begining of the line following the original current line.</P>

<P>Note that there must always be at least one line in a buffer. To maintain this situation, an instruction to kill the last record in the buffer will only erase all the text leaving an empty record - it will also fail.</P>


</UL><H3><A NAME="N">N</H3>
<PRE>
N&#091;.&#093; Note
</PRE>
<P>Note = Note line &#091;and character&#093; number for later abstract.</P>

<P>This sets the start point of one or more lines of text to be moved by a later abstract <A HREF="#A">A</A> command. </P>

<P>Without the ( . ) modifier, complete lines are removed by the subsequent abstraction. </P>

<P>With the ( . ) modifier, all lines and characters are abstracted between the current character position when the N command was given to that at the time of the A command.</P>

<P>See also <A HREF="#A">A</A> and <A HREF="#H">H</A> commands.</P>


</UL><H3><A NAME="A">A</H3>
<PRE>
A&#060;key&#062;&#091;+|-|.&#093;&#091;*|&&#093; - Abstract
</PRE>
<P>Abstracts (moves) text from note point to current character (see <A HREF="#N">N</A>) into the nominated buffer.</P>

<P>If the whole-line abstraction flag is set (see <A HREF="#N">N</A> command), then only complete lines are moved.</P>

<P>The optional '+' qualifier places the abstracted text after the end of any preexisting text in the destination buffer, '-' similarly places it before the start '.' places at the current character in the destination buffer. If none of these qualifiers are specified then the buffer is cleared before the new text is abstracted. The current character pointer of the buffer is always left at the beginning of the of the last line of abstracted text.</P>

<P>The optional * qualifier replaces the abstracted text with an equivalent number of spaces, this feature is useful when editing tables and pictorial text.</P>

<P>The optional & qualifier copies the text without changing the original. This is essential if abstracting from a readonly buffer - see <A HREF="#%B=READONLY">%b=readonly</A>.</P>

<P>The two valid optional qualifiers must follow the buffer key but not in any particular order.</P>

<P>If the abstraction fails (typically because no note-point is set) then the failure flag is raised.</P>

<P>See also <A HREF="#H">H</A> and <A HREF="#N">N</A> commands.</P>


</UL><H4><A NAME="ABSTRACTION OPTIONS">Abstraction options</H4>
<P>Abstraction in jot is similar to ecce - by default, the n (note) and the a (abstract) commands abstract only complete lines.</P>

<P>By default jot abstracts complete lines - like ecce. By adding the . option to the note command it abstracts to the nearest character.</P>

<P>Cumulative abstraction - by default the destination buffer is first cleared of any preexisting text only the abstract appears in the buffer after abstraction.</P>

<UL><P><LI>The + qualifier adds the now text to the end of any preexisting text in the destination buffer.</P></LI>

<P><LI>The - qualifier prepends the abstracted text to the start of any preexisting text.</P></LI>

<P><LI>The . qualifier inserts the new text at the destination buffers current-character point.</P></LI>

</UL><P>Non-destructive abstraction. By default text is removed from the source buffer. For non-cumulative abstraction it's easy enough to restore the abstract it immediately after but this process sets an internal marker tag indicating that the buffer has been modified - this is not always helpful. The '&' qualifier will abstract without changing the source text or setting the marker tag.</P>


</UL><H3><A NAME="H">H</H3>
<PRE>
H&#060;key&#062;&#091;&#060;count&#062;&#093;&#091;*&#093; - copy Here
</PRE>
<P>Contents of specified buffer (the source buffer) is copied to current buffer (the destination buffer) either to the current character position or above the current line. There is a status flag in the source buffer that determines which.</P>

<P>If the source buffer was itself defined by abstraction part lines (using <A HREF="#N">N</A>.) then the buffer is inserted at the current character. If the source buffer was defined in any other way (abstraction with N, <A HREF="#%I">%I</A> or a <A HREF="#%Q">%Q</A> query) then the source text is inserted immediately above the current line.</P>

<P>The status flag is invisible except in the "wholeRecords" line of a <A HREF="#QUERY BUFFER">query buffer</A> report.</P>

<P>The effect of the optional count is to insert the text that many times.</P>

<P>The effect of the optional * qualifier is to overlay the original text with the new. This feature is intended for maintenance of column spacing in whitespace-delimited tables and line-drawings.</P>

<P>See also <A HREF="#N">N</A> and <A HREF="#A">A</A> commands.</P>


</UL><H3><A NAME="Z">Z</H3>
<PRE>
Z&#060;key&#062; - Zoom (change focus to nominated buffer)
</PRE>
<P>Changes the current buffer to the one identified by the buffer key.</P>

<P>The the key for the current buffer is displayed in the editor prompt following the line number, it is also be displayed in the window separator lines (see <A HREF="#%W">%w</A> command).</P>

<P>See also <A HREF="#OB">OB</A> and <A HREF="#OZ">OZ</A></P>


</UL><H3><A NAME="(">(</H3>
<PRE>
( - Block start
</PRE>
<P>The block of commands must be terminated by a ')', it may contain any number of valid jot commands, including sub blocks. See also <A HREF="#)">)</A> and <A HREF="#JOT COMMAND STRUCTURE">jot command structure</A>.</P>


</UL><H3><A NAME=")">)</H3>
<PRE>
)&#091;&#060;n&#062;&#093; - Block end.
</PRE>
<P>This terminates the current block, if a repeat count ( &#060;n&#062; ) is specified then the block is repeated that many times or until the block fails, if the repeat count is zero then the block only exits when something in the command sequence fails but, overall, a zero-repeat block never fails.</P>

<P>If repeat count finite or not given, then any failure in the command sequence is passed on upwards. See also <A HREF="#(">(</A> and <A HREF="#JOT COMMAND STRUCTURE">jot command structure</A>.</P>


</UL><H3><A NAME=",">,</H3>
<PRE>
(&#060;anyNumberOfCommands&#062;, &#060;failureHandler&#062;) - Failure handler.
</PRE>
<P>The commands following the comma are only executed when some earlier command has failed. When a command fails, control is transferred to the code following the comma - the failure handler. A single block can containing any number of failure handlers, each picking up the failure condition from the previous - this is effectively an if, else-if, else-if ... structure.</P>


</UL><H3><A NAME="\">\</H3>
&#060;cmd&#062;\ - Reverse status of command or block.
<P>If the previous command failed and raised the failure flag, then this resets it, correspondingly, if the previous command did not fail then the failure flag is raised.</P>

<P>Note, \ only applies to the command or block *immediately* before it.</P>

<P>If, for example, we want to insert abc in any case except when it already exists:</P>

<PRE>
(v/abc/\i/abc/,)
</PRE>
<P>This is also useful for inverting the status of blocks, e.g.:</P>

<PRE>
(f1/fred/\ f1/jim/ f1/bill/\)\
</PRE>
<P>The block will succeed if the current line contains either if the substrings "fred", "jim" or "bill".</P>


</UL><H3><A NAME="?">?</H3>
 <CODE>&lt;</CODE>P<CODE>></CODE>&#060;validCommand or block&#062;? - ignore status of command or block.<CODE>&lt;</CODE>/P<CODE>></CODE>

<P>This has the effect of lowering the failure flag irrespective of the outcome of the previous command.</P>

<P>Note, ? only applies to the command or block *immediately* before it. Thus in the sequence m99p? the ignore-failure command applies only to the p command - not m99.</P>

<P>You can also follow ? with \ to ensure that a command *always* fails - this is useful when a failure handler needs to exit a repeated block.</P>

<P>See also <A HREF="#\">\</A>, <A HREF="#JOT COMMAND STRUCTURE">Jot command structure</A> and <A HREF="#SUCCESS, FAILURE AND ERRORS">success, failure and errors</A>.</P>


</UL><H3><A NAME="STACK OPERATIONS">Stack Operations</H3>
<P>The editor maintains an evaluation stack used for numerical and logical operations.</P>

<P>A stack frame may contain one of three datatypes, an integer value, a floating-point quantity or a buffer. All buffers on the stack are tagged with the buffer key '~'), as values are retrieved, there is a simple check to ensure compatibility with the expected datatype, in the event of a mismatch, execution halts with an error message.</P>

<P>If a stack-based buffer is the current buffer, numeric values may be added to the stack without affecting the status of the buffer. You cannot, however, return to the buffer with a Z~ or OZ command (and, also the <A HREF="#HASHTABLE JUMP">hashtable jump</A> command) unless the buffer is at the top of the stack. This command sequence, for example, will fail:</P>

<PRE>
%q~=date; m(oidr)3 z.z~
</PRE>
<P>But this one's OK:</P>

<PRE>
%q~=date; m(oidr)3 z.(oo/%d:/r0)3z~
</PRE>
<P>The stack size is by default limited to 100 slots (see <A HREF="#-STACKSIZE">-stacksize</A>) any push operation will fail abruptly if there are already 100 on the stack. Similarly, any pop operation will fail if there are no values on the stack.</P>

<P>The arithmetic operations (O+, O-, O*, O/, O=. O&#060; and O&#062;) work for both integer or real (floating-point) quantities. If one item is integer and the other is real then the integer operand is first converted to real and the result, where applicable, is also real.</P>

<UL><P><LI><A HREF="#O+">O+</A> - Add.</P></LI>

<P><LI><A HREF="#O-">O-</A> - Subtract.</P></LI>

<P><LI><A HREF="#O*">O*</A> - Multiply.</P></LI>

<P><LI><A HREF="#O/">O/</A> - Divide.</P></LI>

<P><LI><A HREF="#O%">O%</A> - remainder</P></LI>

<P><LI><A HREF="#O~">O~</A> - increment - add 1 to item at top, fail if result=0.</P></LI>

<P><LI><A HREF="#O|">O|</A> - OR - performs bitwise OR of top two items in stack.</P></LI>

<P><LI><A HREF="#O&">O&</A> - AND - performs bitwise AND of top two items in stack.</P></LI>

<P><LI><A HREF="#O!">O!</A> - NOT - bitwise NOT.</P></LI>

<P><LI><A HREF="#O?">O?</A> - dump contents of stack - stack contents are not changed.</P></LI>

<P><LI><A HREF="#O#">O#</A> - duplicate top of stack.</P></LI>

<P><LI><A HREF="#O=">O=</A> - fail if top two items on stack not equal, top item is destroyed.</P></LI>

<P><LI><A HREF="#O&#060;">O&#060;</A> - test that item at top greater than next one down</P></LI>

<P><LI><A HREF="#O&#062;">O&#062;</A> - test that item at top less than next one down</P></LI>

<P><LI><A HREF="#OB">OB</A> - push pointer to current buffer onto stack.</P></LI>

<P><LI><A HREF="#OE">OE</A> - push Extent of current record/substring onto stack.</P></LI>

<P><LI><A HREF="#OF">OF</A> - push line no. of First line in window.</P></LI>

<P><LI><A HREF="#OC">OC</A> - push current chr. no. onto stack.</P></LI>

<P><LI><A HREF="#ON">ON</A> - push current line no. onto stack.</P></LI>

<P><LI><A HREF="#OP">OP</A> - push mouse cursor Position no. onto stack.</P></LI>

<P><LI><A HREF="#OU">OU</A> - set sUbstring length from stack.</P></LI>

<P><LI><A HREF="#OA">OA</A> - push rAndom number onto stack.</P></LI>

<P><LI><A HREF="#O.">O.</A> - set current line number to &#060;top of stack&#062;.</P></LI>

<P><LI><A HREF="#OL">OL</A>&#060;n&#062;&#091;.&#060;n&#062;&#093; - Literal integer (optionally fp) value is pushed onto stack.</P></LI>

<P><LI><A HREF="#OI">OI</A>&#091;C|D|O|X|F&#093; - formatted conversion from text - result to stack.</P></LI>

<P><LI><A HREF="#OG">OG</A> - formatted character input - prompts and reads one character to stack.</P></LI>

<P><LI><A HREF="#OO">OO</A> - formatted Output - pop value, using given string.</P></LI>

<P><LI><A HREF="#OV">OV</A> - Value - defines hashtable data item from stack.</P></LI>

<P><LI><A HREF="#OQ">OQ</A> - Query, query a hashtable value and push value onto stack.</P></LI>

<P><LI><A HREF="#OR">OR</A> - index Right (left if -ve) by no. of characters popped off stack.</P></LI>

<P><LI><A HREF="#OM">OM</A> - Move (backwards if -ve) no. of lines popped off stack.</P></LI>

<P><LI><A HREF="#OZ">OZ</A> - Zoom (change to buffer) key popped off stack.</P></LI>

<P><LI><A HREF="#OK">OK</A> - Kill - delete top of stack.</P></LI>

<P><LI><A HREF="#O@">O@</A> - reset stack and random number generator.</P></LI>

<P><LI><A HREF="#OS">OS</A> - Swap 1st and 2nd items of stack.</P></LI>

<P><LI><A HREF="#OW">OW</A> - scrolls Window view by no. lines set in top of stack.</P></LI>

<P><LI>See also <A HREF="#QUERY STACK">query stack</A></P></LI>


</UL><H4><A NAME="OL">OL</H4>
<PRE>
OL&#060;intVal&#062; - push an integer Literal onto stack.
</PRE>
<P>or</P>

<PRE>
OL&#060;floatingPointValue&#062; - push a floating-point Literal onto stack.
</PRE>
<P>The specified value is placed on the top of the stack. e.g:</P>

&#062; ol123
<P>This pushes the number 123 onto the top of the stack.</P>

<P>The literal can be modified by prefixing with x or o to specify the integer in Hex or Octal respectively. eg:</P>

&#062; ol1024
&#062; olx100
&#062; olo400

<P>Note that the usual C-language format 0xnnn or 0onnn are not supported here as these are syntactically indistinguishable from an OL0 followed by an X or another O command.</P>

<P>For floating-point (real) values the only permissible syntax is &#060;nnn&#062;.&#060;mmm&#062; eg:</P>

&#062; ol1234.56789
<P>The OL command is sometimes followed by <A HREF="#OV">OV</A>. This combination is used to set a data object to a literal value. See <A HREF="#ABOUT HASHTABLES">about hashtables</A> and <A HREF="#USING HASHTABLE DATA">using Hashtable data</A></P>


</UL><H4><A NAME="O&">O&</H4>
<PRE>
o& - bitwise AND
</PRE>
<P>The top two items in the stack must be integers. These are removed and the bitwise AND of the two values is added.</P>

</UL><H4><A NAME="O|">O|</H4>
<PRE>
o| - bitwise OR
</PRE>
<P>The top two items in the stack must be integers. These are removed and the bitwise OR of the two values is added.</P>

</UL><H4><A NAME="O!">O!</H4>
<PRE>
o! - bitwise NOT
</PRE>
<P>The item at the top of the stack must be an integer. It is replaced by the bitwise NOT of the original bit pattern - i.e. 0's are changed to 1's and 1's are changed to 0's.</P>

</UL><H4><A NAME="O?">O?</H4>
<PRE>
O? - List contents of stack.
</PRE>
<P>This is useful for debugging - dumps the entire contents of the stack to the console - see also <A HREF="#QUERY STACK">query stack</A>.</P>


</UL><H4><A NAME="OG">OG</H4>
<PRE>
OG - reads one character from console and pushes character onto stack.
</PRE>
<UL><P>This prompts using the prompt string defined by <A HREF="#%S=PROMPT">%s=prompt</A> and reads one character that is pushed onto the stack as a wide-format unicode character (see <A HREF="#ABOUT UNICODE">about unicode</A>).</P>

<P>If unicode-support is disabled (see <A HREF="#%B=UNICODE">%b=unicode</A>) then unicode characters arrive as a series of values in the range 128-255 requiring multiple OG calls. Jot does not offer any method of determining where one unicode character ends and the next begins when a series of unicode characters are entered in this way.</P>


</UL><H4><A NAME="OO">OO</H4>
<PRE>
OO&#060;delim&#062;&#060;formatString&#062;&#060;delim&#062; - Output using sprintf format string.
</PRE>
<P>Output the value at top of stack using the format string. </P>

<P>If the current buffer has a substring following a command that defines a substring (eg: F, S, I, OI or a previous OO command), then the substring is replaced by the sprintf output. This sequence will first insert 999 and then immediately change it to 123:</P>

&#062; ol123 ol999 oo/%d/ oo/%d/
<P>this will give both numbers - the r-r removes the substring marker without affecting the cursor position:</P>

&#062; ol123 ol999 oo/%d/ r-r oo/%d/
<P>When writing unicode characters, the %c format string *must* have the l (long-format) modifier to convert the wide-format unicode eg:</P>

&#062; ol65r0boo/%c simple ASCII character/r0
&#062; ol163r0boo/but the unicode %lc requires the l modifier with %%c/
<P>Note that the <A HREF="#OG">OG</A> command can add a unicode character too the stack.</P>

<P>For numeric values the use of this modifier is recommended but a simple %d seems to work on most systems for integers of not more then 32 bits eg - this generally seems to work;</P>

&#062; ol123456789r0boo/%d/
<P>but use %ld to avoid truncation:</P>

&#062; ol123456789123456789r0boo/%ld/
<P>On completion, the current character points to the end of the inserted substring.</P>

<P>Examples:</P>

&#062; ol12345 oo"The number you first thought of is %-10d"
&#062; %q~=buffer; f/pathName = /-bza oo/The pathname is %s/ok
&#062; off za oo/%8f/

</UL><H4><A NAME="OQ">OQ</H4>
<PRE>
OQ&#060;delim&#062;&#060;key&#062;&#060;delim&#062; - Value, push value from hashtable onto stack.
</PRE>
<P>The delimitedKey must match the key used to create a hashtable entry with the <A HREF="#HASHTABLE DATA">hashtable data</A> command. The OV operation pops the stack and copies the top frame value to the hash-table entry, deleting any previously-held value associated with that hashtable entry. A copy of the frame can later be returned to the top of stack with the <A HREF="#OQ">OQ</A> command.</P>

<P>In the event of an unmatched hashtable key or an empty stack, the OV command fails. Note that there is no typing in the <A HREF="#HASHTABLE DATA">hashtable data</A> command so OV just takes whatever datatype happens to be at the top of the stack and copies it to the data object.</P>

<P>If the top item on the stack is a buffer, then a complete copy of all the buffer records is made and associated with the data object, ignoring most of the other buffer attributes like PathName, header or Footer.</P>

<P>For example:</P>

&#062; %h=data fred;  %%Creates the entry associated with the keyword 'fred'
&#062; ol123
&#062; ov/fred/       %%Moves the top stack frame (integer 123) to the hashtable.
<PRE>
...
</PRE>
&#062; oq"fred"       %%Queries (restores) the stack frame 'fred'.
&#062; ol456
&#062; ov,fred,       %%Redefines  the value of the data object 'fred'.

</UL><H4><A NAME="OV">OV</H4>
<PRE>
OV&#060;delim&#062;&#060;key&#062;&#060;delim&#062; - Query - pops stack and sets value in hash-table.
</PRE>
<P>The key must match one used to create a data entry with the <A HREF="#HASHTABLE DATA">hashtable data</A> command with a value previously defined with the <A HREF="#OV">OV</A> command. The OQ command copies the contents of the hashtable data entry associated with the hashtable key to the top of stack.</P>

<P>In the event of an unmatched hashtable key or no value associated with the entry or, less likely, a full stack, the OQ command fails.</P>

<P>If the data object holds a buffer, then a complete copy of all the buffer records is made and placed on the top of the stack, ignoring the other attributes like PathName, header or Footer.</P>


</UL><H4><A NAME="O+">O+</H4>
<PRE>
O+ - Add
</PRE>
<P>Replace top two values with their sum.</P>

<P>If either of the two values is a real number then the result is real, if one is integer then it is first converted to real.</P>

<P>There is no checking for arithmetic overflows.</P>


</UL><H4><A NAME="O-">O-</H4>
<PRE>
O- - Subtract
</PRE>
<P>The value at the top of the stack is subtracted from the next value, the top two items are replaced by the result.</P>

<P>If either of the two values is a real number then the result is real, if one is integer then it is first converted to real.</P>

<P>There is no checking for arithmetic overflows.</P>


</UL><H4><A NAME="O*">O*</H4>
<PRE>
O* - Multiply
</PRE>
<P>Replace top two values with their product.</P>

<P>If either of the two values is a real number then the result is real, if one is integer then it is first converted to real.</P>

<P>There is no checking for arithmetic overflows.</P>


</UL><H4><A NAME="O/">O/</H4>
<PRE>
O/ - Divide
</PRE>
<P>The top item on the stack is the denominator, the next item is the numerator, both items are removed from the stack and the result of numerator/denominator is then added to the stack.</P>

<P>If either of the two values is a real number then the result is real, if one is integer then it is first converted to real.</P>

<P>There is no checking for arithmetic overflows but this command will fail if the denominator (the 1st. item in the stack) is 0.</P>


</UL><H4><A NAME="O%">O%</H4>
<PRE>
O% - remainder.
</PRE>
<P>The top item on the stack is the denominator, the next item is the numerator, both items are removed from the stack and the remainder of numerator/denominator is then added to the stack.</P>

<P>If either or both items are real, the reals are first converted to integer the result is always integer.</P>

<P>There is no checking for arithmetic overflows but this command will fail if the denominator (the 1st. item in the stack) is 0.</P>


</UL><H4><A NAME="O=">O=</H4>
<PRE>
O= Test for numerical equality
</PRE>
<P>The top two items must be either integer or real, they are compared and the top item is removed, if they are equal the command status is Success, otherwise it's Fail.</P>

<P>If either item is a real number it is converted to integer before the comparison. This conversion does not apply to the value left behind on the stack.</P>


</UL><H4><A NAME="O~">O~</H4>
<PRE>
O~ Increment value in top of stack.
</PRE>
<P>The item at the top of the stack must be an integer, for any other type the the operation fails. The modified value is checked and fails the failure flag is raised if the result is zero.</P>


</UL><H4><A NAME="O&#062;">O&#062;</H4>
<PRE>
O&#062; - Greater than.
</PRE>
<P>The top two items compared and the top item is removed, if the top item is greater than the next, then the command status is Success, otherwise it Fails.</P>

<P>If both of the operands are floating-point values, then a floating point comparison is used. Similarly, if both items are integer, an integer comparison is performed. If only one of the operands is floating point, then a floating-point comparison is performed, using the floating-point conversion of the integer value. This conversion does not affect the value left behind on the stack.</P>


</UL><H4><A NAME="O&#060;">O&#060;</H4>
<PRE>
O&#060; - Less than.
</PRE>
<P>The top two items compared and the top item is removed, if the top item is less than the next, then the command status is Success, otherwise it's Fail.</P>

<P>If both of the operands are floating-point values, then a floating point comparison is used. Similarly, if both items are integer, an integer comparison is performed. If only one of the operands is floating point, then a floating-point comparison is performed, using the floating-point conversion of the integer value. This conversion does not affect the value left behind on the stack.</P>


</UL><H4><A NAME="OB">OB</H4>
<PRE>
OB - save Buffer key
</PRE>
<P>The ASCII value of the current buffer identification key is placed on the stack (see also <A HREF="#OZ">OZ</A>).</P>


</UL><H4><A NAME="OE">OE</H4>
<PRE>
OE - push Extent of current substring or record.
</PRE>
<P>This command pushes the length, in characters, of the currently-selected substring onto the stack. Jot has two forms of substring yielding +ve and -ve results:</P>

<UL><P><LI>Positive, where the current character is the first character of the substring typically the result of a <A HREF="#F">F</A> command.</P></LI>

<P><LI>Negative, where the current character is immediately after the substring typically the result of the <A HREF="#S">S</A> command.</P></LI>

</UL><P>If unicode support is turned off off (see <A HREF="#%B=UNICODE">%b=unicode</A>) then it pushes the number of bytes in the currently-selected substring. If no substring is currently selected, it pushes the total length of the current record onto the top of the stack. The result is negative if the current-character pointer follows the selected substring (as would be the case after the <A HREF="#S">S</A> command, for example).</P>

<P>See also <A HREF="#OU">OU</A>, <A HREF="#ABOUT UNICODE">about unicode</A>, <A HREF="#%B=TABSTOPS">%b=tabstops</A>, <A HREF="#ABOUT TABULAR TEXT">about tabular text</A>, <A HREF="#QUERY INVIEW">query inview</A> and <A HREF="jot_coms.html#UC_BASIC.JOT">uc_basic.jot</A>.</P>

<P>The substring-length calculation disregards any leftoffset setting - it always assumes all characters are fully visible. See also <A HREF="#ABOUT LONG LINES">about long lines</A>.</P>


</UL><H4><A NAME="OF">OF</H4>
<PRE>
OF - push line no. of First line of current buffer in window.
</PRE>
<P>This command will search all currently displaying windows, from first (topmost) to last window (bottommost) until it finds one displaying the current buffer. It then calculates the line number of the topmost line displayed in the window. In most cases it's much simpler than that - usually there's only one window set up to display the current buffer - see <A HREF="#%W">%W</A> for details.</P>

<P>This information can be used to control the view e.g. it can be used to return to a previously displayed view - see also <A HREF="#OW">OW</A>.</P>

<P>Note that the line number returned is the line number at the time when the display was last updated. If your code contains anything that might change the display you should first refresh the display with the <A HREF="#W">W</A> command.</P>


</UL><H4><A NAME="OU">OU</H4>
<PRE>
OU - set sUbstring length from stack.
</PRE>
<P>The length of the currently-selected substring is set to the value currently at the top of the stack. A zero can be used to remove the substring setting in that buffer. </P>

<P>With unicode support turned on (see <A HREF="#%B=UNICODE">%b=unicode</A>) this value is interpreted as a character count, otherwise 's taken as a byte count.</P>

<P>A negative substring indicates that the current character is immediately after the selected substring (e.g. after a f/.../- os s/.../ command, doc. Otherwise the value is positive indicating that the current character is the first character of the substring (e.g. after a F/.../ or S-/../ command).</P>

<P>See also <A HREF="#OE">OE</A>.</P>


</UL><H4><A NAME="OZ">OZ</H4>
<PRE>
OZ - Zoom.
</PRE>
<P>The value at the top of the stack is removed and used to specify a buffer key, this is used to specify the new current buffer (see also <A HREF="#OB">OB</A>).</P>

<P>Unlike the <A HREF="#Z">Z</A> command, oz does not transliterate to uppercase and an error will result if there happens to be a lower-case acsii alpha character at the top of the stack.</P>


</UL><H4><A NAME="OP">OP</H4>
<PRE>
OP - push mouse Position onto stack.
</PRE>
<P>This places coordinates of the last-detected mouse-click onto the stack. Readback of mouse-click coordinates is enabled by the <A HREF="#%S=MOUSEMASK">%s=MouseMask</A> command.</P>

<P>On completion, the top of the stack holds the following:</P>

<UL><P><LI>buffer key on display in the window receiving the last mouse click</P></LI>

<P><LI>the line number and</P></LI>

<P><LI>the character number for the mouse-click point.</P></LI>

</UL><P>If the last-clicked mouse event has not been enabled (see <A HREF="#%S=MOUSEMASK">%s=MouseMask</A>) then OP places three zeros on the stack.</P>

<P>See also <A HREF="#ABOUT MOUSE EVENTS">About mouse events</A>, <A HREF="#%S=MOUSEMASK">%s=mousemask</A>, <A HREF="#%S=SETMOUSE">%s=setmouse</A> and <A HREF="#%B=ADDTAG">%b=addtag</A></P>


</UL><H4><A NAME="ON">ON</H4>
<PRE>
ON - save line Number
</PRE>
<P>The current line number is placed on the stack (see also <A HREF="#OM">OM</A>).</P>


</UL><H4><A NAME="OM">OM</H4>
<PRE>
OM - Move
</PRE>
<P>The value at the top of the stack is removed and used to specify a relative move forwards (+ve.) or backwards (-ve) by no. of lines.</P>

<P>If the move is out of bounds (i.e. before the start or after the end of the current buffer) then the cursor is left at the start of the first or last line as appropriate and the command fails.</P>

<P>n.b. With a zero at the top of the stack, OM just moves to the start of the current line (see also <A HREF="#ON">ON</A>).</P>


</UL><H4><A NAME="OA">OA</H4>
<PRE>
OA - rAndom
</PRE>
<P>A randomly-generated number is pushed onto the top of the stack. In reality, of course, this is a pseudo-random number. That means it runs to a predictable repeatable sequence depending on how the pseudorandom number generator is seeded (see <A HREF="#O@">O@</A>).</P>


</UL><H4><A NAME="O.">O.</H4>
<PRE>
O. - Set line number.
</PRE>
<P>The value at the top of the stack is removed and used to specify the line no. of current line from top of stack.</P>

<P>N.B. This has no effect on the cursor, it only changes the internally-maintained line number. This is displayed in the JOT prompt, and the line number in <A HREF="#M">M</A>+ operations and <A HREF="#ON">ON</A> etc.</P>


</UL><H4><A NAME="OC">OC</H4>
<PRE>
OC - save Chr no.
</PRE>
<P>Place current character no. (i.e. number of characters from beginning of line to the current cursor position) onto the stack (see also <A HREF="#OR">OR</A>).</P>

<P>If unicode support has been turned off (see <A HREF="#%B=UNICODE">%b=unicode</A>) then OC counts bytes not characters, including all bytes in any unicode characters.</P>


</UL><H4><A NAME="OR">OR</H4>
<PRE>
OR - shift Right by character count (byte count if unicode support is turned 
</PRE>
<P>off - see <A HREF="#UNICODE - THE GRUESOME DETAILS">Unicode - the gruesome details</A>) shifts left for negative values.</P>


<P>Item at top of stack is removed and used to shift the current character pointer. Cursor moves cursor right (+ve.) or left (-ve.) by no. bytes at top of stack.</P>

<P>If the move is out of bounds (before the start or after the end of the current line) then the operation fails and the cursor is left at the start/end of the line as appropriate (see also <A HREF="#OC">OC</A>).</P>


</UL><H4><A NAME="OI">OI</H4>
<PRE>
OI&#091;C|D|O|X|F&#093; - formatted Input conversion (of string at current character).
</PRE>
<P>OI&#060;chr&#062; uses the character (C, D, O, X or F) as a format specifier and uses it to extract a value from the string at the current character in the current buffer. The result is pushed onto the stack. Note that the interpretation of the format-selection character (C, D, O, X or F) is case insensitive - so c, d, o, x or f will do just as well.</P>

<P>Each of these variants converts characters beginning with the current character and proceeding to the right. The current character is left pointing to the character to the right of the last converted character and all the converted characters are highlighted as a substring. </P>

<P>In the event of there being no valid characters the current character is left unchanged, nothing is added to the stack and the command fails.</P>

<UL><P><LI>OIC converts one character immediately to the right of the current character to it's ASCII code - this one does not skip whitespace characters.</P></LI>

<P><LI>OID converts a string of numeric characters to decimal.</P></LI>

<P><LI>OIO converts value in an octal string and</P></LI>

<P><LI>OIX converts value in a hexadecimal string.</P></LI>

<P><LI>OIF converts real-number value in a string.</P></LI>

</UL><P>OID, OIO, OIX and OIF all skip past any leading whitespace before converting digits.</P>


</UL><H4><A NAME="OK">OK</H4>
<PRE>
OK - Kill top item on stack
</PRE>
<P>The item at the top of the stack is removed and it's value is lost. Note that the OK command will fail if the stack is empty or the item at the top of the stack is a buffer and this happens to be the current buffer or if it is marked as write-if-changed (see <A HREF="#%B=WRITEIFCHANGED">%b=writeifchanged</A>).</P>


</UL><H4><A NAME="O@">O@</H4>
<PRE>
O@ - Reset stack
</PRE>
<P>Reseeds the random number generator (see <A HREF="#OA">OA</A>) and then destroys all items currently in the stack. If the item at the top of the stack is an integer type then this is is used to reseed the generator, otherwise it's reseeded with 1.</P>

<P>The O@ command will work it's way down the stack, deleting entries, starting with the top item in the stack. If it encounters a buffer, it might fail at this point if this buffer is the current buffer.</P>


</UL><H4><A NAME="OS">OS</H4>
<PRE>
OS - Swap
</PRE>
<P>The items in the top and next-but-one slots in the stack swap places.</P>

<P>OS will fail if there are less than two items on the stack.</P>


</UL><H4><A NAME="O#">O#</H4>
<PRE>
O# - Duplicate
</PRE>
<P>The item at the top of the stack is copied and placed above the original item. </P>

<P>If the top item on the stack is a buffer, the O# operation does not copy the buffer records etc. it simply constructs another pointer to the same internal data. This is in contrast to <A HREF="#OV">OV</A> and <A HREF="#OQ">OQ</A> which do make new copies of buffer data.</P>

<P>O# will fail if the stack is already full.</P>


</UL><H4><A NAME="OW">OW</H4>
<P>The screen display is scrolled by the number of lines indicated by the top of stack - a positive value scrolls up the screen, negative scrolls down.</P>


</UL><H3><A NAME="PERCENT COMMANDS">Percent Commands</H3>
<P>See also <A HREF="#PERCENT-COMMAND SYNTAX">percent-command syntax</A></P>

<UL><P><LI><A HREF="#%%">%%</A> - Comment line.</P></LI>

<P><LI><A HREF="#%A">%A</A> - Exit without writing file.</P></LI>

<P><LI><A HREF="#%B">%B</A> - set Buffer attributes.</P></LI>

<P><LI><A HREF="#%C">%C</A> - Exit writing new file.</P></LI>

<P><LI><A HREF="#%D">%D</A> - Define a buffer from console.</P></LI>

<P><LI><A HREF="#%E">%E</A> - Execute following CLI command line.</P></LI>

<P><LI><A HREF="#%P">%P</A> - Pipe a message to interactive session.</P></LI>

<P><LI><A HREF="#%G">%G</A> - Get - Define a complete buffer from current command file.</P></LI>

<P><LI><A HREF="#%H">%H</A> - Hashtable maintenance.</P></LI>

<P><LI><A HREF="#%I">%I</A> - Secondary input file.</P></LI>

<P><LI><A HREF="#%L">%L</A> - set line Length and redraws all windows and slices.</P></LI>

<P><LI><A HREF="#%M">%M</A> - Message.</P></LI>

<P><LI><A HREF="#%O">%O</A> - Output current buffer as specified file.</P></LI>

<P><LI><A HREF="#%Q">%Q</A> - system Query.</P></LI>

<P><LI><A HREF="#%R">%R</A> - Run a command file.</P></LI>

<P><LI><A HREF="#%S">%S</A> - define System settings (case sensitivity, insert mode ...).</P></LI>

<P><LI><A HREF="#%U">%U</A> - Undo last substitution.</P></LI>

<P><LI><A HREF="#%W">%W</A> - Set up a screen window.</P></LI>

<P><LI><A HREF="#%X">%X</A> - eXit current macro with a user-defined error message.</P></LI>

<P><LI><A HREF="#%~">%~</A> - Insert or display control character.</P></LI>


</UL><H4><A NAME="%A">%A</H4>
<PRE>
%A&#091;&#091;&#060;status&#062;&#093;=&#060;message&#062;&#093; - Abandon = Exit without writing file.
</PRE>
<P>This exits the editor, no files are written out.</P>

<P>The message defaults to "Edit abandoned", it is written to stdout after closing the screen management system.</P>

<P>By default, the exit status code is set to 1, any value in the range 0 to 255 can be supplied in decimal.</P>

<P>If some buffer has been marked as <A HREF="#%B=WRITEIFCHANGED">%b=writeifchanged</A>, and the buffer has been changed, then the editor will refuse to exit until that buffer has been written. A suitable message appears if this happens - see <A HREF="jot_coms.html#FREEALL.JOT">freeall.jot</A>.</P>


</UL><H4><A NAME="%C">%C</H4>
<PRE>
%C&#091;=&#060;message&#062;&#093; - Close = Exit writing new file.
</PRE>
<P>The file spec. is initially determined by the arguments given to the editor image (see <A HREF="#-TO">-to</A>) and may be further redefined by the <A HREF="#%B=PATHNAME">%b=pathname</A> command. By default the file will have the same pathname as the original.</P>

<P>The command fails if there is an attempt to %C from any buffer other than the main buffer . - to write out some other buffer use <A HREF="#%O">%O</A>.</P>

<P>The message defaults to "Normal exit", it is written to stdout after closing the screen management system. For %C, the exit status is always set to 0.</P>

<P>If some buffer (other than the main buffer) has been marked as <A HREF="#%B=WRITEIFCHANGED">%b=writeifchanged</A>, and the buffer has been changed, then the editor will refuse to exit until that buffer has been written or the writeifchanged lock is removed - see <A HREF="jot_coms.html#FREEALL.JOT">freeall.jot</A>.</P>


</UL><H4><A NAME="%E">%E</H4>
<PRE>
%E=&#060;CliCommand&#062;  - executes a CLI command
%E&#060;key&#062;=&#091;|&#093;&#060;CliCommand&#062; - executes CLI command and catches the output.
%E&#060;key&#062;=&#091;&&#093;&#060;CliCommand&#062; - interactive CLI command.
</PRE>
<P>If a destination buffer is specified with the optional &#060;key&#062; qualifier, then the stdout stream of the child process is picked up and saved in the specified buffer. If no destination buffer is specified the child's stdout goes to the screen.</P>

<P>Since the single quote character ( ' ) is so important to shell commands, the usual '&#060;bufferKey&#062; syntax is not allowed for %e - see <A HREF="#PERCENT-COMMAND SYNTAX">percent-command syntax</A>.</P>

<P>The command is passed to the CLI, the return status is checked and used to set the failure flag.</P>

<P>If the CLI Command is prefixed with a pipe or vertical bar ( | ), then the contents of the current buffer is output to the stdin of the command. This feature allows users to use external co-processors for handling specific tasks - e.g. sorting, numerical processing.</P>

<P>If the CLI command is prefixed with an ampersand ( & ) and the subprocess is inherently interactive, communicating via it's std and stdout (eg: gdb or sh) then jot maintains an input and output pipe to the process. New commands and input can be supplied to the subprocess via the <A HREF="#%P">%P</A> command. For linux, the child process is killed when the destination buffer is destroyed or as the session exits. </P>

<P>For linux the parent session normally kills the child by sending it a SIGTERM but some processes my need to so some tidying up before they exit - such processes can be terminated by specifying an -exit=&#060;exitCommand&#062; qualifier to the <A HREF="#%P">%P</A> command then these commands are sent instead of the SIGTERM signal.</P>

<P>For windows, the user requires a special privilege to kill a process - even if it's a process they've created in the same session. If the session attempts to exit with active child processes it will hang while the system waits for the child to terminate. The solution is to either explicitly send the child the correct command for it to terminate itself or, use the -exit= qualifier to the <A HREF="#%P">%P</A> command.</P>

<P>The simple form of %E (no pipe) will return a success/failure result reflecting the cli command's exit status - any nonzero exit code is deemed to be a failure, zero is deemed to be success.</P>


</UL><H4><A NAME="%P">%P</H4>
<PRE>
%P&#091;&#060;key&#062;&#093;=&#060;command&#062;; - Pipe a command to remote session.
%P&#091;&#060;key&#062;&#093;= -exit=&#060;command&#062;; - Set a termination command for a remote session.
</PRE>
<P>The remote session must have been previously set up by the <A HREF="#%E">%E</A> command, with the & modifier to create a persistent interactive session. The message is sent to the remote process's stdin and it is also appended to the buffer text.</P>

<P>The message is automatically suffixed with a newline character ( \n ), if the remote process responds by sending characters to it's stdout then these are picked up and also appended to the buffer text. If there is some delay in the remote process response this is picked up asynchronously when the remote process responds ie. without blocking the editors normal command-driven activity.</P>

<P>The -exit= option is used to terminate the child process at some later time. This option only useful in windows or for certain linux process that do not respond well to the SIGTERM signal. In these cases it is necessary for a child process to terminate itself. The command string is saved and as the session terminates or the buffer is destroyed, the exit command is sent to the child process.</P>


</UL><H4><A NAME="%F">%F</H4>
<PRE>
%F&#091;&#060;key&#062;&#093;=&#091;&#060;REx&#062;&#093; - search forwards in buffer using regular expression.
%F-&#091;&#060;key&#062;&#093;=&#091;&#060;REx&#062;&#093; - search back in buffer using regular expression.
</PRE>
<P>When a match is found, the first record of the destination buffer is set to the complete matched substring. Subsequent records of the destination buffer are set to substrings matching parenthesized sub-expressions.</P>

<P>If the optional regular expression &#060;REx&#062; is not specified, then the last-specified REx is re-used.</P>

<P>The underlying system call only searches forwards hence, for backwards searches, when a matching line of text is found, the system call is repeated until there are no more valid matches. Hence reverse regex searches can be quite inefficient for cases where there are many possible matches on a line.</P>

<P>Briefly, it supports most of the usual regular-expression constructs but some of the more complex ones may be missing, for details look at the documentation of the regex library routine:</P>

<UL><P>http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html - Circumflex '^' and dollar sign '$', respectively, at the start or end of</P>

<P>the RE, will anchor the body of the RE to the start or end of the match string.</P>

<P><LI>Bracketed expressions - '&#091;' ... '&#093;', the expression inside a pair of matching square brackets - see below.</P></LI>

<P><LI>Sub-expression grouping, enclosing expressions in matching round braces '(' and ')', creates a result for each such subexpression. Each of these is assigned a separate record in the destination buffer and may be referred to by number in some later expression (see subexpression references, below).</P></LI>

<P><LI>Alternation within sub-expressions the vertical bar character '|' indicates an alternative subexpression. (&#060;subexpr1&#062;|&#060;subExpr2&#062; ... )</P></LI>

<P><LI>Subexpression references - \n (where n is a decimal) refers to the value extracted for that subexpression.</P></LI>

<P><LI>Numeric quantifiers - specifying that, for a match, the preceding subexpression should be reiterated a given number of times.</P></LI>

<P><LI>Range quantifiers, a comma-separated pair of decimal values in curly braces '&#123;'m, n'&#125;' where m specifies the minimum number of repeats, n the maximum.</P></LI>

</UL><P>Bracketed expressions - anything in matching square brackets &#091; ... &#093;</P>

<UL><P><LI>A set of equally acceptable characters, special characters must be escaped with a backslash.</P></LI>

<P><LI>A range of characters &#060;ch1&#062;-&#060;ch2&#062; in the ASCII/POSIX collating sequence.</P></LI>

<P><LI>A circumflex '^' - the negation character, matches to any character not in the expression e.g. &#091;^a-zA-Z&#093; matches to any non-alpha character.</P></LI>

<P><LI>Character-class expressions of the form &#091; ... &#091;:&#060;classexpr&#062;:&#093; ... &#093; the following character class expressions are allowed: alnum, cntrl, lower, space, alpha, digit, print, upper, blank, graph, punct, xdigit.</P></LI>


</UL><H4><A NAME="%M">%M</H4>
<PRE>
%M&#091;&#060;bufferKey&#062;&#093;=&#060;message&#062; - prints Message in console area.
</PRE>
<P>Prints the message in the console area and continues. If the optional bufferKey is given then the message is also copied as a new line at the end of the specified buffer. </P>

<P>The message may contain an indirect reference to any buffer or the stack - see <A HREF="#ABOUT COMMAND PARAMETERS">about command parameters</A> e.g:</P>

<PRE>
ob %q~=date; t2/, /b %m=This is the time '~; osozok
</PRE>

</UL><H4><A NAME="%X">%X</H4>
<PRE>
%X=&#060;message&#062; - eXit current command sequence, macro or script displaying the
</PRE>
<P>message in the console area.</P>

<P>Prints the message to the console area then abruptly exits of current command sequence. e.g:</P>

&#062; %x=File 'n is of the wrong type.

</UL><H4><A NAME="%S">%S</H4>
<PRE>
%S=&#060;attribute&#062; &#091;&#060;value&#062;&#093; - set the value of a System attribute.
</PRE>
<P>This group of commands control various system attributes affecting behaviour in any buffer.</P>

<P>Briefly, these are the valid attribute keys:</P>

<UL><P><LI><A HREF="#%S=CASE">%s=case</A> &#091;0|1|+1&#093; - Sets case sensitivity for F, and V commands.</P></LI>

<P><LI><A HREF="#%S=SYSTEM">%s=system</A> &#091;0|1&#093; - system mode on/off - preserves search & insert strings.</P></LI>

<P><LI><A HREF="#%S=COMMANDMODE">%s=commandmode</A> &#091;+&#093;&#091;&#060;bitMask&#062;&#093; - to select screen-edit mode.</P></LI>

<P><LI><A HREF="#%S=COMMANDCOUNTER">%s=commandcounter</A> - Sets the command-counter stop-point.</P></LI>

<P><LI><A HREF="#%S=TRACE">%s=trace</A> - set Trace, prefix with '+' to XOR with current value</P></LI>

<P><LI><A HREF="#%S=TRACEDEFAULT">%s=tracedefault</A> - set default trace bitmask see also <A HREF="#T">T</A> command.</P></LI>

<P><LI><A HREF="#%S=SETENV">%s=setenv</A> &#060;envName&#062; &#060;envValue&#062; - sets an environmental variable.</P></LI>

<P><LI><A HREF="#%S=VERBOSE">%s=verbose</A> - to change verbosity level.</P></LI>

<P><LI><A HREF="#%S=CONSOLE">%s=console</A> &#060;n&#062; - sets an upper limit on console-area expansion.</P></LI>

<P><LI><A HREF="#%S=COMMANDSTRING">%s=commandstring</A> - redefines console-input string.</P></LI>

<P><LI><A HREF="#%S=RECOVERYMODE">%s=recoverymode</A> - disables I/O used in journal-recovery procedure.</P></LI>

<P><LI><A HREF="#%S=COPY">%s=copy</A> - copies currently-selected text to the system paste buffer.</P></LI>

<P><LI><A HREF="#%S=PASTE">%s=paste</A> - imports text from the system paste buffer to the text.</P></LI>

<P><LI><A HREF="#%S=SETMOUSE">%s=setmouse</A> - Sets the mouse-event coords to the current cursor position.</P></LI>

<P><LI><A HREF="#%S=GUARDBAND">%s=guardband</A> - Makes a few lines above or below cursor visible.</P></LI>

<P><LI><A HREF="#%S=MOUSEMASK">%s=mousemask</A> - Enables mouse events.</P></LI>

<P><LI><A HREF="#%S=TAB">%s=tab</A> - defines the tab character in tabular text.</P></LI>

<P><LI><A HREF="#%S=PROMPT">%s=prompt</A> - defines the prompt string for <A HREF="#G">G</A> commands.</P></LI>

<P><LI><A HREF="#%S=ON_KEY">%s=on_key</A> - defines a command sequence to be run after every keyboard-initiated command.</P></LI>


</UL><H5><A NAME="%S=CASE">%S=case</H5>
<PRE>
%S=case &#091;0|1|+1&#093; - set case sensitivity attribute.
</PRE>
<P>This sets case sensitivity for the <A HREF="#F">F</A> and <A HREF="#V">V</A> commands - 1 makes them case sensitive, 0 makes them case-insensitive (e.g. f/Fred/ will match to fred, FRED or Fred equally well). If no valid value is given, it defaults to 0 (i.e. insensitive to case). The value +1 reverses the current setting.</P>


</UL><H5><A NAME="%S=SYSTEM">%S=system</H5>
<PRE>
%s=system &#091;0|1&#093;;
</PRE>
<UL><P>In system mode the usual behaviour of saving search and substitute/insert strings is suspended. This is used in functions which use the <A HREF="#F">F</A>, <A HREF="#S">S</A> and <A HREF="#I">I</A> commands and maintains the original state of these strings after the function has completed.</P>


</UL><H5><A NAME="%S=COMMANDMODE">%S=commandmode</H5>
<PRE>
%s=commandmode &#091;+&#093;&#091;&#060;hexBitMask&#062;&#093; - sets command-mode attribute.
</PRE>
<P>Bits are assigned as follows:</P>

<UL><P><LI>01 - Temporary, Insert mode reverts to command mode when any function or</P></LI>

<UL><P>cursor-control key is hit.</P>

</UL><P><LI>02 - InsertMode (until next %S=commandmode or a Ctrl+C interrupt).</P></LI>

<P><LI>04 - Overtype - when in insert mode overwrites preexisting text.</P></LI>

<P><LI>08 - EscapeAll - all keyboard input is taken as escape strings.</P></LI>

<P><LI>10 - EscapeCtrl - any control character (ASCII characters in the range 0 to 31)</P></LI>

<UL><P>will be treated as initiating an escape sequence.</P>

</UL></UL><P>Various useful combinations are available:</P>

<UL><P><LI>%s=commandmode 0; - the default setting, sane command mode - your typing appears in the console, it can supply a parameter to some jot function. To insert to the text use the <A HREF="jot_ug.html#INSERT">Insert</A> and <A HREF="jot_ug.html#ENTER">Enter</A> functions.</P></LI>

<P><LI>%s=commandmode 2; - normal insert mode - your typing appears on the screen at the current-character position indicated by the jot cursor.</P></LI>

<P><LI>%s=commandmode 6; - insert-overtype - similar to %s=commandmode 2; except that typed input overwrites any preexisting text.</P></LI>

<P><LI>%s=commandmode 8; - EscapeAll - all your typing is taken as escape sequences - similar to vi/vim command mode.</P></LI>

<P><LI>%s=commandmode 10; - EscapeCtrl - any control character (ASCII codes in the range 0 to 31) is treated as the start of an escape sequence.</P></LI>

<P><LI>%s=commandmode 12; As above but with insert mode - control characters initiate escape-sequences and non-control characters appear at the current-character position.</P></LI>

<P><LI>Other combinations may do something useful but there's no guarantees.</P></LI>


</UL><H5><A NAME="%S=COMMANDCOUNTER">%S=CommandCounter</H5>
<PRE>
%s=commandcounter 123456789; - sets the endpoint for the command counter.
</PRE>
<P>This command is only really useful for debugging and in the journal-recovery process. It specifies how many commands that should be allowed to execute normally before a trace event is triggered - see <A HREF="#THE JOT DEBUGGER">the jot debugger</A>.</P>

<P>As each command is processed a counter is incremented. This counter is normally set to 0 every time a new command line is read from the console. When the initial setting is defined with %s=SetCommandCounter it is instead set to run for the specified number of commands and then execution proceeds in whatever trace mode you have previously selected. Typically it will proceed in single-step mode.</P>

<P>In a normal session, execution can be continued under control of the debugger - see <A HREF="jot_ug.html#ABOUT JOT DEBUGGING">about jot debugging</A>. In a recovery session, the command counter is used to simulate a &#123;Ctrl+c&#125; interrupt at exactly the same point as one was received in the original session - see <A HREF="#ABOUT JOURNAL FILES">about journal files</A>.</P>

<P>For break point activation the command counter is designed to to be used in conjunction with the trace mask (see <A HREF="#THE JOT DEBUGGER">the jot debugger</A>, <A HREF="#%S=TRACE">%S=trace</A> and <A HREF="#%S=TRACEDEFAULT">%S=tracedefault</A>).</P>

<P>The trace mask determines the trace trigger and action. When this internal counter reaches zero, the trace action is enabled when nonzero, the counter is decremented.</P>

<P>Note that the counting only applies to the command sequence initiated by the *next* command line. For subsequent command lines, the counter is initialized to zero, as usual.</P>


</UL><H5><A NAME="%S=TRACE">%S=trace</H5>
<PRE>
%s=trace &#091;+-&#093;&#091;&#060;XXXX&#062;&#093; - Trace = Set &#091;modify&#093; trace mode, in hexadecimal.
</PRE>
<P>The optional + qualifier sets the specified bits, the optional - qualifier unsets the specified bits.</P>

<P>The screen window is only redrawn when the Trace_Break bit is set.</P>

<P>%S=trace sets a mask which controls the user-script debugging facility for the editor - see also <A HREF="#%S=TRACEDEFAULT">%S=tracedefault</A> and the <A HREF="#T">T</A> command.</P>

<P>The trace action may optionally be delayed by setting an internal counter - see <A HREF="#%S=COMMANDCOUNTER">%S=commandcounter</A>.</P>

<P>The trace mode bitmask has the following control bits which can be ORed together:</P>

<UL><P><LI>0001 Trace_AllCommands: Each new command is triggers a trace event.</P></LI>

<P><LI>0002 Trace_CommandLines: Each new command line triggers a trace event.</P></LI>

<P><LI>0004 Trace_Failures: Any failing command triggers a trace event.</P></LI>

<P><LI>0008 Trace_Interrupt: A &#123;Ctrl+C&#125; interrupt triggers a trace event.</P></LI>

<P><LI>0040 Trace_Recovery: Enables normal debugging in recovery mode.</P></LI>

<P><LI>0080 Trace_DumpSeq: Dumps compiled commands.</P></LI>

<P><LI>0800 Trace_Backtrace: Dumps a backtrace at each trace event.</P></LI>

<P><LI>1000 Trace_Stack: Dumps contents of the stack at each trace event.</P></LI>

<P><LI>2000 Trace_Print: Prints the current line of the current buffer.</P></LI>

<P><LI>4000 Trace_Source: Displays the command line at each trace event.</P></LI>

<P><LI>8000 Trace_Break: Break at selected trace point, halts and prompts for a debug command.</P></LI>

</UL><P>One group of bits (Trace_AllCommands, Trace_CommandLines, Trace_Failures, and Trace_Interrupt) define the trace points. The other group of bits (Trace_Backtrace, Trace_Stack, Trace_Print, Trace_Source and Trace_Break) determine the action to be taken at a trace point. The other one - Trace_Recovery is used in recovery scripts only - see <A HREF="#ABOUT JOURNAL FILES">about journal files</A>.</P>

<P>Trace_AllCommands and Trace_CommandLines perform the selected trace-point actions at every command or at the start of a new command line respectively. Trace_Failures performs the trace-point actions after a failing command.</P>

<P>Trace_Interrupt changes normal &#123;Ctrl+c&#125; behaviour - &#123;Ctrl+c&#125; normally exits everything and returns to the normal jot prompt. With Trace_Interrupt set it enters the interactive jot debugger - note that, by default, Trace_Int is not set up the <A HREF="#T">T</A> command, you have to set Trace_Interrupt in your <A HREF="#%S=TRACEDEFAULT">%s=tracedefault</A> setting and your %s=trace settings - see <A HREF="#THE JOT DEBUGGER">the jot debugger</A>.</P>

<P>The Trace_Stack bit directs a stack dump to the console, this will not be of much help unless the console area of the screen is reasonably large or there is not much on the stack.</P>

<P>The Trace_Print bit prints the current line of the current buffer just before execution of the command.</P>

<P>The Trace_Break bit triggers a break at the trace point, it prompts for a command with 'Debug Command&#062;' any valid JOT command string may be entered. If a hexadecimal value is entered with a leading zero, then this sets a new value for the trace mode - in particular 0 will exit trace mode. Just hitting the return key advances to the next break point. Note that the debugger does not attempt to restore the original context. Note also the debugger interface does not handle hotkeys.</P>

<P>The Trace_Recovery bit causes trace points to behave normally in recovery mode. By default, a trace break in recovery will read instructions from the recovery file, these are identical to those given while debugging the original session. With the Trace_Recovery bit set, debugger commands are read from the console, as normal, so you can debug the recovery script. Not though, if the original session had debugger interaction then what happens next is anyone's guess but the end result is unlikely to be an accurate reproduction of the original session state.</P>

<P>In order to enter the debugger while processing a recovery file, it is necessary to edit the recovery file inserting a suitable %s=trace or %s=tracedefault command in the script. A typical useful setting might be 0X8041:</P>

&#062; %s=tracedefault 8041;
<P>Setting the Trace_Backtrace bit causes a backtrace to be issued at each trace point - not particularly useful for Trace_AllCommands and Trace_CommandLines but can be most useful when combined with Trace_Failures. Even so, it is not a good idea to run the editor with Trace_Failures turned on - it's not unusual for simple keyboard-driven functions to generate several failures - all appropriately handled.</P>

<P>If a macro buffer is redefined and reused part-way through execution, the compiled code will execute normally but the original source is no longer available to the debugger for display. When this happens, the situation is detected and instead of echoing the original source, it displays a disassembly of the compiled code. For example:</P>

<PRE>
$ jot t.t -in="%w; %w 9; %w 0; %s=trace 4001; %da=zai/%ga/bi/mm-/bi/:/bi/ \\\'a/b2; 'a"
</PRE>
<P>In this -init sequence the buffer ( A ) is initially defined as a macro that redefines the same macro buffer with source-code tracing turned on.</P>

<P>If no trace action is specified then, appropriately, it does nothing at each trace point.</P>

<P>The <A HREF="#T">T</A> command simply sets the trace value to the current default value, initially set to B001 (Trace_Stack | Trace_Print | Trace_Break | Trace_AllCommands) but can be redefined using the '%s=tracedefault' command. Another useful setting is B002 - this displays the same at each stop but only stops at the start of each new command line.</P>

<P>See also <A HREF="#%S=TRACEDEFAULT">%s=tracedefault</A> and <A HREF="jot_ug.html#ABOUT JOT DEBUGGING">about jot debugging</A>.</P>


</UL><H5><A NAME="%S=TRACEDEFAULT">%s=tracedefault</H5>
<PRE>
%S=tracedefault &#091;+-&#093;&#091;&#060;hexValue&#062;&#093;
</PRE>
<P>This defines the value to be assigned to the trace vector by the <A HREF="#T">T</A> command. By default this is:</P>

<UL><P>Trace_Stack | Trace_Print | Trace_Break | Trace_AllCommands</P>

</UL><P>The optional + qualifier sets the specified bits, the optional - qualifier unsets the specified bits in the mask.</P>

<P>In contrast to %s=trace, which sets the trace mask with immediate effect, %s=tracedefault specifies a trace mask to be applied at the next break point (breakpoints are set by the <A HREF="#T">T</A>, by the <A HREF="#%S=COMMANDCOUNTER">%s=commandcounter</A> commands and bu Ctrl+C interrupts).</P>

<P>See also <A HREF="#%S=TRACE">%s=trace</A> and <A HREF="jot_ug.html#ABOUT JOT DEBUGGING">about jot debugging</A>.</P>


</UL><H5><A NAME="%S=SETENV">%s=setenv</H5>
<PRE>
%s=setenv &#060;envName&#062; &#060;envValue&#062;
</PRE>
<P>This sets an environmental variable in your session. It does not, of course, change the environment in your shell but only for your editor session and any child processes it might spawn.</P>


</UL><H5><A NAME="%S=VERBOSE">%s=verbose</H5>
<PRE>
%S=verbose &#060;x&#062; - sets the verbosity bit mask in hex.
</PRE>
<P>The verbosity bit mask currently has four recognized bits:</P>

<UL><P><LI>1 (Bit 0) NonSilent - when set, normal error messages are delivered.</P></LI>

<P><LI>2 (Bit 1&#125; PromptUser - when set, prompts user for command input.</P></LI>

<P><LI>4 (Bit 2) QuiteChatty - when set it reports a few more failures and briefly explains what is wrong, it is recommended to allow at least 5 lines in the console area for this.</P></LI>

<P><LI>8 (bit 3) PrintLine - causes the current line of the current buffer to be written to the console area, in addition to the other messages.</P></LI>

<P><LI>16 (bit 4) ReportCommandCount - also reports command counter - see <A HREF="#%S=COMMANDCOUNTER">%s=commandcounter</A> and <A HREF="jot_ug.html#ABOUT JOT DEBUGGING">about jot debugging</A>. When ReportCommandCount and QuiteChatty are both set, the failure reports are augmented with the current state of the command counter. Setting ReportCommandCount will also cause user-defined messages (see <A HREF="#%M">%M</A>) to be augmented with the command counter state. The command counter can be used to set a break point in some later run - see <A HREF="#%S=COMMANDCOUNTER">%s=commandcounter</A>).</P></LI>

<P><LI>32 (Bit 5) AnnoyingBleep - error messages are accompanied by a bleep.</P></LI>

<P><LI>64 (Bit 6) DebugMessages - enables whatever debugging messages may have been accidentally left in your version of jot.</P></LI>

</UL><P>These bits are combined to achieve a desired effect e.g.</P>

&#062; %s=verbose 3;   - (default state) for normal prompting and error reporting.
&#062; %s=verbose 23;  - for normal prompts and reporting with bleeping.
&#062; %s=verbose 1f;  - for normal prompts and comprehensive reporting.

</UL><H5><A NAME="%S=CONSOLE">%s=console</H5>
<PRE>
%s=console &#060;0&#062;|&#060;noOfLines&#062;;
</PRE>
<P>This sets an upper limit on the expansion of the console messages. By default messages are restricted to any spare terminal lines at the bottom of the display (see <A HREF="#ABOUT THE JOT CONSOLE AND DISPLAY WINDOWS">about the jot console and display windows</A>), setting this limit allows messages to encroach upwards into the window area of the terminal.</P>

<P>If set to 0 (the default state), then the console area is fixed at the number of lines left below the windows. The startup script sets the windows to leave a 2-line console area.</P>

<P>If the console expansion area is set to more than the number of lines below the windows, then the console area will expand upwards to a total size limit specified in the %s=console command. The Additional console lines are erased on the next editor action (a new command string, an escape sequence or just by hitting &#123;return&#125;.</P>


</UL><H5><A NAME="%S=GUARDBAND">%s=guardband</H5>
<PRE>
%S=guardband&#091; &#060;n&#062;&#093;
</PRE>
<P>Sets an n-line guardband. A band of n lines is maintained between the current line of text and the top or bottom of the display. The value may be 0 - this is also the default.</P>

<P>In the event of the total guardband exceeding the window size, the current line is centred.</P>

<P>With a 3-line guardband, for example, it always displays the 3 lines above and below the current record.</P>


</UL><H5><A NAME="%S=TAB">%s=tab</H5>
<PRE>
%s=tab &#091;&#060;chr&#062;&#093;
</PRE>
<P>This defines the character to be used as a cell separator for tabular text. It defaults to VT (vertical Tab). This can be set to, pretty-much, any normal ASCII character but not unicode characters.</P>


</UL><H5><A NAME="%S=COMMANDSTRING">%S=CommandString</H5>
<PRE>
%s=commandstring &#060;CommandString&#062;
</PRE>
<P>This inserts the specified command string back into the console command buffer. This makes it possible to modify the console input using ordinary editor commands and then execute the modified command sequence.</P>

<P>This is used for command-line editing (see <A HREF="jot_ug.html#ABOUT COMMAND EDITING">about command editing</A>) and systematic modification of keyboard input - take a look at <A HREF="jot_coms.html#UC_BASIC.JOT">uc_basic.jot</A> this uses %s=commandstring to substitute unicode escape sequences for UTF-8 byte sequences.</P>


</UL><H5><A NAME="%S=MOUSEMASK">%s=MouseMask</H5>
<PRE>
%s=mousemask&#091;=&#060;HexValue&#062;&#093;
</PRE>
<P>This enables the detection and handling of selected mouse events - e.g. left-button clicks etc. When enabled by %s=MouseMask, mouse events can be picked up and handled in the same way as as escape sequences. Also, mouse-click coordinates can be picked up by the <A HREF="#OP">OP</A> command.</P>

<P>By default, all mouse actions are disabled (the mouse mask is set to 0), if %s=mousemask is given with no value then all mouse events are picked up by the editor (and normal X mouse actions are disabled). If a hex value is given then that value is passed to the curses mousemask() function. For full details refer to curses.h and the mousemask (3NCURSES) man page.</P>

<P>The problem with enabling all mouse events is that it replaces the really useful X-windows selection actions - so only set the mouse mask when you really need to define mouse functions. The standard setup defines a few mouse-action functions.</P>

<P>The problem is not so acute for windows users since windows offers virtually no worthwhile mouse functions for console terminals.</P>

<P>In any case, normal service can be restored by resetting the mousemask to 0:</P>

&#062; %s=mousemask 0;
<P>See also <A HREF="#ABOUT MOUSE EVENTS">About mouse events</A>, <A HREF="#OP">OP</A> and <A HREF="#%B=ADDTAG">%b=addtag</A></P>


</UL><H5><A NAME="%S=RECOVERYMODE">%S=RecoveryMode</H5>
<PRE>
%s=recoverymode &#060;value&#062;
</PRE>
<P>Used when recovering a session from journal files. In order to prevent corruption of existing files %o operations are disabled and %I and %E operations read from the journal area - see <A HREF="#ABOUT JOURNAL FILES">about journal files</A></P>


</UL><H5><A NAME="%S=COPY">%S=copy</H5>
<PRE>
%s=copy
</PRE>
<P>Copies text into the system paste buffer. The start point is set by the 'N' (Note) command, the end point is set by the current character position at the time when the %s=copy command is invoked. As with the 'A' (Abstract) command, the start and end point must be in the same buffer and, if the end point is before the start point the start and end points are automatically reversed.</P>

<P>In windows, the system buffer used is the 'clipboard', in linux %s=copy and %s=paste both use the X paste buffer N.B. not the selections buffer.</P>

<P>In order to minimize the number of statically-linked libraries in the linux version, this command is not available in the linux executables supplied in the download - see <A HREF="#UNIX AND LINUX SETUP">Unix and linux setup</A>.</P>


</UL><H5><A NAME="%S=PASTE">%S=paste</H5>
<PRE>
%s=paste
</PRE>
<P>Copies the contents of the system paste buffer into the current buffer at the current-character position.</P>

<P>In order to minimize the number of statically-linked libraries in the linux version, this command is not available in the linux executables supplied in the download - see <A HREF="#UNIX AND LINUX SETUP">Unix and linux setup</A>.</P>


</UL><H5><A NAME="%S=PROMPT">%s=prompt</H5>
<PRE>
%s=prompt&#091; &#060;promptString&#062;&#093;; - set prompt string.
</PRE>
<P>Sets the prompt for the <A HREF="#G">G</A> command.</P>

<P>If the prompt string is not given, then the G-command prompt reverts to it's default ( &#062; ).</P>


</UL><H5><A NAME="%S=ON_KEY">%s=on_key</H5>
<PRE>
%s=on_key&#091; &#060;JotCommandSequence&#062;&#093;
</PRE>
<P>Defines a Jot command sequence to be performed after any normal interactive command.</P>

<P>Typically, the on_key sequence will be just be some housekeeping operation or an interface for some application that driven by changes in the text.</P>


</UL><H5><A NAME="%S=SETMOUSE">%s=setmouse</H5>
<PRE>
%s=setmouse
</PRE>
<P>Initializes the mouse position to the current character in the current buffer - see <A HREF="#OP">OP</A>, <A HREF="#QUERY TAGS">Query tags</A> and <A HREF="#QUERY WINDOW">query window</A>.</P>

<P>Useful for emulating mouse clicks for applications designed as mouse/touch-pad interfaces in non-mouse environments (see <A HREF="jot_coms.html#QR.JOT">qr.jot</A>) and for testing scripts using the OP command for the window query.</P>


</UL><H4><A NAME="%B">%B</H4>
<PRE>
%b=&#060;attributeName&#062;&#091; &#060;value&#062;&#093; - set some attribute of the current buffer.
</PRE>
<UL><P><LI><A HREF="#%B=UNRESTRICTED">%b=unrestricted</A> - sets the buffer write-access attribute.</P></LI>

<P><LI><A HREF="#%B=READONLY">%b=readonly</A> - sets the buffer write-access attribute.</P></LI>

<P><LI><A HREF="#%B=LEFTOFFSET">%b=leftoffset</A> &#060;n&#062; - sets the buffers left-offset attribute.</P></LI>

<P><LI><A HREF="#%B=TABSTOPS">%b=tabstops</A>&#091; &#060;n1&#062;&#091; &#060;n2&#062;&#091; &#060;n3&#062;&#091; ...&#093;&#093;&#093;&#093; - controls display of simple tabular text.</P></LI>

<P><LI><A HREF="#%B=TABCELLS">%b=tabcells</A>&#091; &#060;n1&#062;&#091; &#060;n2&#062;&#091; &#060;n3&#062;&#091; ...&#093;&#093;&#093;&#093; - controls display of tabular text.</P></LI>

<P><LI><A HREF="#%B=HEADER">%b=header</A> &#060;headerText&#062; - defines a static header line for display.</P></LI>

<P><LI><A HREF="#%B=FOOTER">%b=footer</A> &#060;footerText&#062; - defines text for window-separator line.</P></LI>

<P><LI><A HREF="#%B=UNICODE">%b=unicode</A> &#123;0|1&#125; - Disables|Enables unicode support in this buffer.</P></LI>

<P><LI><A HREF="#%B=PATHNAME">%b=pathname</A> &#060;pathName&#062; - (re)defines pathname.</P></LI>

<P><LI><A HREF="#%B=SAMEFLAG1">%b=sameflag1</A> - sets the user change-control flag.</P></LI>

<P><LI><A HREF="#%B=TAGTYPE">%b=tagtype</A> - defines a named metadata tag.</P></LI>

<P><LI><A HREF="#%B=ADDTAG">%b=addtag</A> - Adds a metadata tag to the text.</P></LI>

<P><LI><A HREF="#%B=REMOVE_TAG">%b=remove_tag</A> - Removes instances of a named tag</P></LI>

<P><LI><A HREF="#%B=SORT">%b=sort</A> - sorts text in buffer.</P></LI>

<P><LI><A HREF="#%B=TABSORT">%b=tabsort</A> - sorts tabular text in buffer.</P></LI>

<P><LI><A HREF="#%B=CODEPAGE">%b=codepage</A> - Sets code page for buffer (windows only).</P></LI>


</UL><H5><A NAME="%B=UNRESTRICTED">%B=unrestricted</H5>
<PRE>
%b=unrestricted - sets the buffer write-access attribute.
</PRE>
<P>This returns the readonly and writeifchanged status of the buffer (see <A HREF="#%B=READONLY">%b=readonly</A> and <A HREF="#%B=WRITEIFCHANGED">%b=writeifchanged</A>) to their default settings.</P>


</UL><H5><A NAME="%B=READONLY">%B=readonly</H5>
<PRE>
%b=readonly&#091; 0|1&#093; - sets the buffer write-access attribute.
</PRE>
<P>The default state for buffers is that they may be modified. If this command is applied with no value specified or is specified as 1 then the current buffer is set to a readonly state. It can be viewed but not altered, sections of text may be abstracted provided the & qualifier is given (see the <A HREF="#A">A</A> command).</P>

<P>See also the <A HREF="#%B=UNRESTRICTED">%B=unrestricted</A> command.</P>


</UL><H5><A NAME="%B=WRITEIFCHANGED">%b=writeifchanged</H5>
<PRE>
%b=writeifchanged&#091; 0|1&#093; - sets the buffer write-access attribute.
</PRE>
<P>The default state for buffers is that any changes are lost if the session is terminated without explicitly saving (see the <A HREF="#%O">%O</A> command). If this command is applied with no value or the value is specified as 1 then the buffer must be saved if some changes have been made.</P>

<P>In this state the buffer may be modified but if there is an attempt to overwrite or to exit the editor without first saving. Then a warning is issued and the editor session remains live. It is , of course, possible to reset this lock and exit normally to discard changes.</P>

<P>The motivation for this one is that jot encourages users to edit multiple files in one session - it's just a bit too easy to forget and exit without saving something important.</P>

<P>If, after you've checked the locked buffers, you still want to exit the session anyway, the <A HREF="jot_coms.html#EXIT.JOT">exit.jot</A> script might help.</P>

<P>See also the <A HREF="#%B=UNRESTRICTED">%B=unrestricted</A> command.</P>


</UL><H5><A NAME="%B=LEFTOFFSET">%b=leftoffset</H5>
<PRE>
%b=leftoffset &#060;n&#062; - sets the buffers left-offset attribute.
</PRE>
<P>Sets the text column to appear in the leftmost column of the window when displaying this buffer.</P>

<P>By default, the left offset is 0. This may be increased to display records longer than the width of the current window. See <A HREF="#ABOUT LONG LINES">about long lines</A>. If the given value is negative, this is silently ignored and the leftoffset is set to 0.</P>

<P>See also <A HREF="#ABOUT LONG LINES">about long lines</A> and <A HREF="#QUERY INVIEW">query inview</A> - this verifies that the current character is visible with the current leftoffset setting.</P>


</UL><H5><A NAME="%B=TABSTOPS">%b=tabstops</H5>
<PRE>
%b=tabstops&#091; &#060;n1&#062;&#091; &#060;n2&#062;&#091; &#060;n3&#062;&#091; ...&#093;&#093;&#093;&#093; - controls display of simple tabular text.
</PRE>
<P>By default, tabs and other control characters are rendered as a tilde '~' on the screen - see <A HREF="#ABOUT TABULAR TEXT">about tabular text</A>. If tabStops have been defined for a buffer containing tabular text then each tab is replaced by one or more blanks in the display. When correctly set up, the tabular text is neatly aligned with that of other records in the buffer.</P>

<P>Each entry in the %b=tabStops command is a number indicating the absolute column number to be assigned to the following text - hence tabStops should always be an ascending sequence of column numbers. If a tab is encountered that is already beyond (i.e. to the right of) it's assigned column then the tab character is simply rendered as a single blank.</P>

<P>Use %b=tabcells for buffers containing simple tabular text - indented source code, simple tables, formatted letter headings etc. For tables with wildly-varying cell lengths use <A HREF="#%B=TABCELLS">%b=tabcells</A> which will truncate overlong cells to maintain the columns.</P>

<P>The %b=tabstops command will delete any preexisting tabstops or tabcells settings, if no tabstops are given, then the buffer reverts to displaying tabs as tildes ( ~ ).</P>

<P>If the first tabstop is any negative number, then this is taken as a request for automatically-assigned tabstops - any other values in the command line are ignored. With automatically assigned tabstops the window manager analyses the position of all tab characters currently in view and assigns the smallest tabstops compatible with displaying tabular data in neat columns. Currently, the maximum number of of automatically-assigned tabstops is limited to 100.</P>

<P>The tabstops are displayed in the <A HREF="#QUERY BUFFER">query buffer</A> report.</P>


</UL><H5><A NAME="%B=TABCELLS">%b=tabcells</H5>
<P>Each tab-delimited item of text is said to be a cell. If the manually-defined tabcell is insufficient to display all of a cell, then the cell text is truncated and an exclamation point ( ! ) is added to the righthand end of the truncated text.</P>

<P>The %b=tabcells command will delete any preexisting tabstops or tabcells settings, if no tabcells are given, then the buffer reverts to displaying tabs as tildes ( ~ ).</P>

<P>In the event of there being a record with more then the number of predefined tabcells, then additional tabcells are assigned by adding the tab spacing to the previous tabcell entry.</P>

<P>If the first tabcell is any negative number, then this is taken as a request for automatically-assigned tabcells - any other values in the command line are ignored. With automatically assigned tabcells the window manager analyses the position of all tab characters currently in view and assigns the smallest tabcells compatible with displaying tabular data in neat columns. Currently, the maximum number of of automatically-assigned tabcells is limited to 100.</P>

<P>The tabcells are displayed in the <A HREF="#QUERY BUFFER">query buffer</A> report.</P>


</UL><H5><A NAME="%B=HEADER">%b=header</H5>
<PRE>
%b=header&#091; &#060;headerText&#062;&#093; - defines or removes a static header line.
</PRE>
<P>If the headerText string is given, this is displayed in reverse video at the top of any window displaying the current buffer. The header is static in the sense that it is fixed to the top line of the window and text scrolls past it. When you define a buffer string it occupies one of the lines requested in the <A HREF="#%W">%W</A> command, leaving you with one less line for viewing buffer images. If no headerText string is given then any previously defined header line is removed. By default, buffers have no header line.</P>

<P>If the buffer has TabStops set (see <A HREF="#%B=TABSTOPS">%b=tabstops</A>) then any tabs in the header text will be treated in the same way as those in the main body of the buffer. The upshot of this is that the text can contain column headings for buffers containing tabular entries (e.g. images of spreadsheets etc.).</P>


</UL><H5><A NAME="%B=FOOTER">%b=footer</H5>
<PRE>
%b=footer some text;
</PRE>
<P>By default, the reverse-video separator at the end of a window contains the current buffer's pathname (if defined) and the buffer key. This command replaces the pathname with some text of your own choosing.</P>

<P>As with long pathnames, the text may be truncated to fit.</P>


</UL><H5><A NAME="%B=UNICODE">%b=unicode</H5>
<PRE>
%b=unicode &#123;0|1&#125;
</PRE>
<P>This controls unicode support for the current buffer.</P>

<P>Any value other than 0 restores the default mode of operation - unicode characters are rendered normally.</P>

<P>The value 0 turns off unicode support, in this state each byte of UTF-8 is represented on the screen by a tilde ( ~ ).</P>

<P>Disabling unicode support affects the rendering of characters on the screen any non-ASCII or ASCII control characters bytes are displayed as a tilde ( ~ ) and also affects several commands:</P>

<UL><P><LI><A HREF="#R">R</A> - counts bytes not characters.</P></LI>

<P><LI><A HREF="#OR">OR</A> - counts bytes not characters.</P></LI>

<P><LI><A HREF="#OE">OE</A> - returns the byte count not character count.</P></LI>

<P><LI><A HREF="#OC">OC</A> - returns byte count not character count.</P></LI>

<P><LI><A HREF="#OU">OU</A> - expects to be given a byte count not a character count.</P></LI>


</UL><H5><A NAME="%B=PATHNAME">%b=pathname</H5>
<PRE>
%b=pathname &#060;pathName&#062; - (re)defines pathname.
</PRE>
<P>This sets the default pathname to be used when this buffer is later written to the filing system.</P>


</UL><H5><A NAME="%B=SAMEFLAG1">%b=sameflag1</H5>
<PRE>
%b=sameflag1 - sets the user change-control flag.
</PRE>
<P>Sets the user flag SameFlag1 - this remains true until there is some change to the buffer text. This flag can be tested if ever a macro needs to detect changes that have occurred since the flag was set.</P>


</UL><H5><A NAME="%B=TAGTYPE">%b=tagtype</H5>
<PRE>
%b=tagtype &#060;tagName&#062; colour &#060;foregroundColourNo&#062; &#060;backgroundColourNo&#062;
</PRE>
<P>Currently the only tag types allowed are colour tags but it is envisaged that this might be extended in the future.</P>

<P>This either defines a new colour pair or redefines one. Colour pairs are defined in terms of the foreground and background colour and are referenced by the pair number.</P>

<P>The tag name can then be used to tag text with colour using the <A HREF="#%B=ADDTAG">%b=addtag</A> command - see also <A HREF="#ABOUT TAGGED TEXT">about tagged text</A>.</P>

<P>Colours are identified by number in the range 0-to-7 - in linux these are:</P>

<UL><P><LI>0 Black</P></LI>

<P><LI>1 Red</P></LI>

<P><LI>2 Green</P></LI>

<P><LI>3 Yellow</P></LI>

<P><LI>4 Blue</P></LI>

<P><LI>5 Magenta</P></LI>

<P><LI>6 Cyan</P></LI>

<P><LI>7 White</P></LI>

</UL><P>in windows:</P>

<UL><P><LI>0 Black</P></LI>

<P><LI>1 Blue</P></LI>

<P><LI>2 Green</P></LI>

<P><LI>3 Cyan</P></LI>

<P><LI>4 Red</P></LI>

<P><LI>5 Magenta</P></LI>

<P><LI>6 Yellow</P></LI>

<P><LI>7 White</P></LI>

</UL><P>In windows, adding 8 gives a more intense colour.</P>

<P>e.g. To define a colour tag "fred" as yellow forground on a blue background in linux:</P>

<PRE>
%s=colourpair fred 3 4;
</PRE>
<P>in windows</P>

<PRE>
%s=colourpair fred 6 1;
</PRE>
<P>or, for a brighter yellow:</P>

<PRE>
%s=colourpair fred 14 1;
</PRE>

</UL><H5><A NAME="%B=ADDTAG">%b=addtag</H5>
<PRE>
%b=addtag &#123;&#060;tagName&#062;|-text=&#060;textString&#062;&#125;;
</PRE>
<UL><P><LI>In the %b=addtag &#060;TagName&#062; form:</P></LI>

<UL><P>The TagName must match a previously defined tag type (see <A HREF="#%B=TAGTYPE">%b=tagtype</A>) or the command fails.</P>

<P>Applies the named tag to the currently-selected substring in text. The named tag type and it's colour pairs must first be defined with the <A HREF="#%B=TAGTYPE">%b=tagtype</A> command - see also <A HREF="#ABOUT TAGGED TEXT">about tagged text</A>.</P>

<P>If, at "addtag" time, there is a selected substring, two tags are applied - one at the start of the currently-selected substring and one at it's end. If there is no selected substring then no end-tag is added the tagging continues through to the end of the line.</P>

</UL><P><LI>In the %b=addtag -text=&#060;textString&#062; form:</P></LI>

<UL><P>The text string, which may be of any length, is added to the tag descriptor. This string can be used for any purpose but is primarily intended for use as a hashtable key. The string is only visible in the <A HREF="#QUERY TAGS">query tags</A> report.</P>

</UL><P>Tags persist until removed with the removed with the <A HREF="#%B=REMOVE_TAG">%b=remove_tag</A> command or the text is deleted.</P>

<P>See also <A HREF="#ABOUT MOUSE EVENTS">About mouse events</A>, <A HREF="#%B=REMOVE_TAG">%b=remove_tag</A>, <A HREF="#%S=MOUSEMASK">%s=mousemask</A> and <A HREF="#OP">OP</A></P>


</UL><H5><A NAME="%B=REMOVE_TAG">%b=remove_tag</H5>
<PRE>
%b=remove_tag &#060;type&#062; &#060;name|key|text&#062;
</PRE>
<P>The current character must be at the start-point of the tag to be deleted.</P>

<P>This command uses the details given and the current-character position to uniquely identify one tag and then removes it from the internal record data structure. In the event of there being two or more identical tags matching the description, it randomly selects one of the matching tags and deletes it.</P>

<UL><P><LI>The tag type field must be one of colour, text or target.</P></LI>

<P><LI>the name field for a colour tag must match the colour-tag name, for a text-tag it must match the first whitespace-separate word of the tag text and, for a hash-table target, the name must match the hash-table key.</P></LI>

<P><LI>the current character and substring length select the start and end point of the tag.</P></LI>

</UL><P>The tags were originally created by the <A HREF="#%B=ADDTAG">%b=addtag</A>, <A HREF="#HASHTABLE NEW">hashtable new</A> and <A HREF="#HASHTABLE ADD">hashtable add</A> commands - see <A HREF="#ABOUT TAGGED TEXT">about tagged text</A>.</P>

<P>Where precise details of the tag is not known, use the <A HREF="#QUERY TAGS">query tags</A> to extract the necessary information from the internal data set.</P>

<P>In the event of there being no tag exactly matching the details given then the command fails without affecting any tags.</P>


</UL><H5><A NAME="%B=SORT">%B=sort</H5>
<PRE>
%b&#091;&#060;destBuf&#062;&#093;=sort &#091;&#060;sliceColumn1&#062;&#093;&#091; &#060;sliceColumn2&#062;&#091; &#060;sliceColumn3&#062; ...&#093;&#093;&#093;
</PRE>
<P>Performs an alphabetical sort of all records in the buffer, by default the records are sorted by the strings starting at the first character (column 0). For tabular text, other columns (slices) may be specified, to sort tab-separated tabular text use <A HREF="#%B=TABSORT">%B=tabsort</A></P>

<P>Each parameter is taken as a slice definition (i.e. a vertical slice down the tabulated text), the following forms are supported:</P>

<UL><P><LI>&#060;firstChrNo&#062;-&#060;lastChrNo&#062; - counting from the first character in each record (chr no. 0), this defines a slice of the buffer to be used in the sort comparison.</P></LI>

<P><LI>&#060;firstChrNo&#062;+&#060;width&#062; - defines the start character and width of the slice - minimum sensible width is 1.</P></LI>

</UL><P>The sort function (a version of quicksort) compares pairs of records, initially from slice slice1. If they are found to be identical, it tries a comparison from slice slice2, then slice3 etc... If no slices are specified it performs just one comparison on each complete record.</P>

<P>Note that left to the user to ensure that each record has at least the number of columns specified - otherwise results are unpredictable.</P>

<P>The sort function modifies the current buffer and writes a sort summary into the nominated destination buffer.</P>


</UL><H5><A NAME="%B=TABSORT">%B=TabSort</H5>
<PRE>
%b=tabsort &#060;tab1&#062;&#091; &#060;tab2&#062; &#091;&#060;tab3&#062; ...&#093;&#093;&#093; - sort buffer holding tabular text.
</PRE>
<P>Each tab entry is an integer in the range 0 to n-1 where n is the number of columns in the table.</P>

<P>Similar to the <A HREF="#%B=SORT">%b=sort</A> command, tabsort sorts records by values of unaligned tab-separated fields, the delimiter character defaults to an ascii VT ( 0xB ) character but can be redefined with the <A HREF="#%S=TAB">%s=tab</A> command.</P>

<P>Shorter fields always rank higher in a strcmp string comparison so some additional whitespace padding may be required.</P>


</UL><H5><A NAME="%B=CODEPAGE">%b=codepage</H5>
<PRE>
%b=codepage &#060;codepage&#062;
</PRE>
<P>This modifier is only available in the windows version. By default jot uses the 65001 (UTF-8).</P>

<P>This sets the codepage which is only relevant to unicode - see <A HREF="#ABOUT UNICODE">about unicode</A>, <A HREF="#PRACTICALITIES OF UNICODE ETC. AND JOT.">Practicalities of unicode etc. and jot.</A></P>


</UL><H4><A NAME="%Q">%Q</H4>
<PRE>
%Q&#091;&#060;bufferKey&#062;&#093;=&#060;query&#062;
</PRE>
<P>Query this command offers a few selected peepholes into selected internal editor states and the system environment.</P>

<P>In most cases the target buffer, indicated by &#060;bufferKey&#062;, is the buffer to receive the result. The exceptions are dir, file, SameFlag1 and the hashtable queries. In all cases the first line of output to the nominated buffer is the original %q command. Valid queries are:</P>

<P>%q~=... is a special case, the ~ buffer is created on the stack - see <A HREF="#ABOUT THE OPERAND STACK">about the operand stack</A>.</P>

<UL><P><LI><A HREF="#QUERY SYSTEM">query system</A> - Returns current system settings to specified buffer.</P></LI>

<P><LI><A HREF="#QUERY LINUX">query linux</A> fails if not running under linux.</P></LI>

<P><LI><A HREF="#QUERY WINDOWS">query windows</A> fails if not running under windows.</P></LI>

<P><LI><A HREF="#QUERY HASHTABLES">query hashtables</A> - Summary report on all hashtables.</P></LI>

<P><LI><A HREF="#QUERY WD">query wd</A> - Returns users current working directory to specified buffer.</P></LI>

<P><LI><A HREF="#QUERY WINDOW">query window</A> - Reports window allocation parameters to specified buffer.</P></LI>

<P><LI><A HREF="#QUERY BACKTRACE">query backtrace</A> reports command-script calls</P></LI>

<P><LI><A HREF="#QUERY DATE">query date</A> - Reports current data and time to specified buffer.</P></LI>

<P><LI><A HREF="#QUERY ENV">query env</A> - Reports value of specified environment variable to specified buffer.</P></LI>

<P><LI><A HREF="#QUERY STACK">Query stack</A> - Dumps stack contents to specified buffer.</P></LI>

<P><LI><A HREF="#QUERY TABSTOPS">Query tabstops</A> - Fails if no tabstops set in current buffer.</P></LI>

<P><LI><A HREF="#QUERY BUFFER">Query buffer</A> - Reports buffer status to specified buffer.</P></LI>

<P><LI><A HREF="#QUERY SAMESINCEIO">Query samesinceio</A> - Fails if current buffer has been changed since last read or written.</P></LI>

<P><LI><A HREF="#QUERY SAMESINCEINDEXED">Query samesinceindexed</A> - Fails if current buffer has been changed since last hash-table entry was added.</P></LI>

<P><LI><A HREF="#QUERY SAMEFLAG1">Query sameflag1</A> - Fails if current buffer has been changed since user flag 1 was last reset.</P></LI>

<P><LI><A HREF="#QUERY CASE">Query case</A> - Fails if case sensitivity is off.</P></LI>

<P><LI><A HREF="#QUERY INVIEW">Query inview</A> - Fails if current character of current buffer is out of view.</P></LI>

<P><LI><A HREF="#QUERY VERSION">Query version</A> - Reports jot version to buffer, if specified or else as a message to the console area.</P></LI>

<P><LI><A HREF="#QUERY DIR">Query dir</A> - Reports contents of to buffer if specified or fails if not a valid directory.</P></LI>

<P><LI><A HREF="#QUERY FILE">Query file</A> - Reports system file data to buffer if specified, fails if not a valid pathname.</P></LI>

<P><LI><A HREF="#QUERY KEYS">Query keys</A> - Writes a diagnostic dump of buffer hash-table keys to specified buffer.</P></LI>

<P><LI><A HREF="#QUERY TAGS">Query tags</A> - lists the tags (hash-table target points and colour tags) in current buffer.</P></LI>

<P><LI><A HREF="#QUERY HEAP">Query heap</A> - in linux sends heap-status to the nominated buffer.</P></LI>

<P><LI><A HREF="#QUERY HISTORY">Query history</A> - Dumps command history to specified buffer.</P></LI>

<P><LI><A HREF="#QUERY KEYS">Query keys</A> - Lists details of all hashtable entries..</P></LI>

<P><LI><A HREF="#QUERY KEY">Query key</A> &#060;string&#062; - Lists only hashtable entry specified by &#060;string&#062;.</P></LI>

<P><LI><A HREF="#QUERY VERIFY">Query verify</A> - Checks consistency of current buffer's internal data structures.</P></LI>


</UL><H4><A NAME="QUERY SYSTEM">Query system</H4>
<PRE>
%q&#060;key&#062;=system
</PRE>
<P>Reports current state of system settings to nominated buffer followed by a list of primary buffers i.e. not stack-based or data-object buffers.</P>

<PRE>
          Trace vector = &#060;hex value&#062; - of trace vector - (see `%S=trace`)
      Case sensitivity = &#060;hex value&#062; - case sensitivity vector - (see `%S=case`)
          Command mode = &#060;hex value&#062; - the command-mode vector (see `%S=commandMode`)
 Table-entry separator = &#060;hex value&#062; - the character used to separate  entries
</PRE>
<UL><P>in tabular text (see <A HREF="#%S=TAB">%S=tab</A>).</P>

<PRE>
   Hold screen on exit = &#123;On|Off&#125;    - Set by `-hold` CLI qualifier.
Buffers:
  buffer &#060;key1&#062;                   - First in list of defined buffers.
  buffer &#060;key2&#062;
  ...
Data-object buffers:
  data obj &#060;path&#062; 
  ...
</PRE>
</UL><P>The list of buffers contains all primary buffers that have been created thus-far in the session, including some with lower-case alpha keys (i, t and p) - these are set up and used internally and are not accessible to the user.</P>


</UL><H4><A NAME="QUERY LINUX">Query linux</H4>
<PRE>
%q=linux
</PRE>
<P>Used to test the underlying OS, this one fails for anything other than linux.</P>


</UL><H4><A NAME="QUERY WINDOWS">Query windows</H4>
<PRE>
%q=windows
</PRE>
<P>A simple test the underlying OS, this one fails for anything other than some flavour of NT-windows.</P>

<P>Note - this has nothing to do with the <A HREF="#QUERY WINDOW">query window</A> command, which generates a window-assignments report.</P>


</UL><H4><A NAME="QUERY HASHTABLES">Query hashtables</H4>
<PRE>
%q&#060;key&#062;=hashtables
</PRE>
<P>Searches all active buffers, for each of those with a hashtable. It generates a one-line list of all the buffers referenced by the hashtable - see <A HREF="#ABOUT HASHTABLES">about hashtables</A>.</P>


</UL><H4><A NAME="QUERY WD">Query wd</H4>
<PRE>
%q&#060;key&#062;=wd
</PRE>
<UL><P><LI>Returns the users current working directory.</P></LI>

</UL><H4><A NAME="QUERY WINDOW">Query window</H4>
<PRE>
%q&#060;key&#062;=window - reports window assignments.
</PRE>
<P>Lists screen size, details of all allocated windows and number of unallocated lines on the screen.</P>

<P>Then follows a screen dump - the current contents of the screen is copied to the end of the report. Note that the screen dump does not show any highlights, reverse video, colour tags or the cursor position.</P>

<P>Note - this has nothing to do with the <A HREF="#QUERY WINDOWS">query windows</A> command, which is a simple go-nogo test on your OS architecture.</P>


</UL><H4><A NAME="QUERY TIME">Query Time</H4>
<PRE>
%q=time - pushes seconds since beginning of unix epoch onto the stack.
</PRE>
<P>This uses the system clock to calculate how many seconds have elapsed since the begining of unix time (zero o'clock on the first of January 1970). See also <A HREF="#QUERY CPUTIME">query cputime</A>.</P>


</UL><H4><A NAME="QUERY CPUTIME">Query cputime</H4>
<PRE>
%q=cputime - pushes to stack, time elapsed since last query cputime.
</PRE>
<P>This uses the system clock to measure the time interval between calls. It calculates gives a floating-point value calculated from the system seconds and nanoseconds elapsed-time counters . Each time it's called it subtracts the previous values of these counters from their current values and converts the difference to a floating-point number, which is pushed onto the stack. It is envisaged that this may be useful for some future profiling tool. See also <A HREF="#QUERY TIME">query time</A>.</P>


</UL><H4><A NAME="QUERY DATE">Query date</H4>
<PRE>
%q&#060;key&#062;=date - reports date and time.
</PRE>
<P>Returns the current date and time in the form dd/mm/yy, hh:mm:ss</P>

</UL><H4><A NAME="QUERY ENV">Query env</H4>
<PRE>
%q&#060;key&#062;=env &#060;name&#062; - reports value of nominated env variable.
</PRE>
<P>Returns the current value of the specified variable in the users env.</P>

</UL><H4><A NAME="QUERY PID">Query pid</H4>
<PRE>
%q&#060;key&#062;=pid - Query the ID of the ediors process.
</PRE>
<P>This reports just the process-ID number of the editor process.</P>


</UL><H4><A NAME="QUERY STACK">Query stack</H4>
<PRE>
%q&#060;key&#062;=stack
</PRE>
<UL><P><LI>reports state of stack.</P></LI>

<P>Returns the current state of the stack in decimal hex and character format - see also <A HREF="#O?">O?</A>.</P>

</UL><H4><A NAME="QUERY TABSTOPS">Query tabstops</H4>
<PRE>
%q=tabstops
</PRE>
<P>This is a quick test to identify buffers which have been set up for tabular text. The command succeeds if tabstops are set in the current buffer, otherwise it fails.</P>


</UL><H4><A NAME="QUERY BACKTRACE">Query backtrace</H4>
<PRE>
%q&#060;key&#062;=backtrace
</PRE>
<P>Lists macros, functions and scripts in the active call stack - for debugging only. </P>

<P>When called from a normal interactive command line it, unsurprisingly, doesn't report very much. When called from a debugger break point prompt, it shows all the call frames that led to the breakpoint. It also dutifully reports the debugger as a frame in the call stack.</P>

<P>In addition to the various scripts, macros and function calls you may notice a few lower-case alpha macros you don't recognize:</P>

<UL><P>i - the initialization commands passed in via the CLI qualifier <A HREF="#-INIT">-init</A> c - the normal interactive command buffer. d - the debuggers own command buffer,</P>

</UL><P>See also <A HREF="jot_coms.html#BT.JOT">bt.jot</A></P>


</UL><H4><A NAME="QUERY BUFFER">Query buffer</H4>
<PRE>
%q&#060;key&#062;=buffer
</PRE>
<UL><P><LI>reports internal state of buffer.</P></LI>

<P>Returns the state of the current buffer in tabular form N.B. if the nominated buffer is the current buffer this command will fail and will return an empty report. e.g:</P>

&#062; %qa=buffer
<P>In buffer A it inserted the following text:</P>

<PRE>
buffer
                  key = .                    The key for the buffer.
             pathName = t.t                  The pathname of the file read into the buffer.
     currentDatestamp = 2011/10/04, 16:27:16 The file's datestamp at the time of the query.
          SameSinceIO = TRUE                 This flag is set true when the file was originally read and reset by  a change to any text in the buffer.
     SameSinceIndexed = FALSE                This flag is set true by adding some hashtable entries and reset by  a change to any text in the buffer.
    SameSinceCompiled = FALSE                This flag is set TRUE when a new hash-table entry is added.
            SameFlag1 = FALSE                This flag is set by the `%b=sameflag1` command and reset by a change to any text in the buffer.
            NoUnicode = FALSE                Unicode support is enabled (controlled by `%b=unicode` command)
           lineNumber = 1                    The normal line number of the record.
           CurrentChr = 0                    The current character position, in this case it is the leftmost character of the record.
      SubstringLength = 0                    The length of the currently-selected substring - in this case none is selected.
         wholeRecords = TRUE                 Indicates that, if inserted into text it will not break lines.
          predecessor = =                    When called as a macro, this indicates the parent macro.
             editLock = Unrestricted         Other options are WriteIfChanged and ReadOnly.
           LeftOffset = 0                    See `%b=leftoffset`
    CurrentRec length = 209                  Indicates the current character in the current record, counting from the leftmost ( 0 )
 CurrentRec protected = 0                    Indicates that the current record of the buffer is a hash-table target and has been protected.
     ProtectedRecords = 0                    Indicates that the buffer contains at least one protected record.
               Header = "A"~"B"~"C" ...      See `%b=header`
             FileType = ascii                Currently the only valid entries are ascii or binary.
                        No tag types         If the buffer had tag types defined then these would be listed here (see `About Tagged text`).
        HashTableMode = 0                    Valid modes are 0 (No hashtable), 1 (ProtectEntries), 
                                               2 (AdjustEntries), 3 (DeleteEntries) and 4 (DestroyHashtables)
                                               see `hashtable create` for details.
             TabStops = 17 41 62 89 172 ...  Indicates columns in tabular text - see `about tabular text`.
                 htab = FALSE                Indicates that there is no hash table associated with this buffer.
</PRE>

</UL><H4><A NAME="QUERY SAMESINCEIO">Query samesinceio</H4>
<PRE>
%q=samesinceio
</PRE>
<UL><P><LI>tests state of SameSinceIO flag in current buffer.</P></LI>

<P>Use this command to test for changes to the buffer since it was last read or written back to the filing system.</P>

<P>Command exits with failure if the buffer has been changed in any way compared to the version on the filing system, exits with success if unchanged. </P>

<P>Text buffers which are not images of files are always created with samesinceio set false.</P>


</UL><H4><A NAME="QUERY SAMESINCEINDEXED">Query samesinceindexed</H4>
<PRE>
%q=samesinceindexed
</PRE>
<UL><P><LI>tests state of buffers SameSinceIndexed flag.</P></LI>

<P>Use this command to test for changes to the the buffer since making the last hash table entry.</P>

<P>Command exits with failure if the buffer has been changed in any way since it was indexed with the <A HREF="#%H">%H</A> commands, exits with success if unchanged. Note that text buffers which have not been indexed are always created with samesinceindexed set false.</P>


</UL><H4><A NAME="QUERY SAMEFLAG1">Query sameflag1</H4>
<PRE>
%q=sameflag1
</PRE>
<UL><P><LI>tests state of buffers SameFlag1 flag.</P></LI>

<P>Use this command to test for changes to the buffer since the flag was set.</P>

<P>Command exits with failure if the buffer has been changed in any way since the SameFlag1 was set (see <A HREF="#%B=SAMEFLAG1">%b=sameflag1</A>), exits with success if unchanged. Note that text buffers are initially created with samesinceindexed set false.</P>


</UL><H4><A NAME="QUERY CASE">Query case</H4>
<PRE>
%q=case
</PRE>
<UL><P><LI> Success if case sensitivity is on.</P></LI>

<P>This simply sets the failure flag - it fails if case sensitivity is off.</P>


</UL><H4><A NAME="QUERY INVIEW">Query inview</H4>
<PRE>
%q=inview
</PRE>
<UL><P><LI>Success if current character is visible on the screen, adds other details to stack.</P></LI>

<P>Verifies that current character is visible with the current setting of leftoffset - see <A HREF="#%B=LEFTOFFSET">%b=leftoffset</A> and <A HREF="#ABOUT LONG LINES">about long lines</A>. This query works independently of the display management, the consequence of this is that it is not necessary to update the display (see the <A HREF="#W">W</A> command) before launching the query.</P>

<P>This query always pushes three values onto the stack:</P>

<UL><P><LI>perceived current character offset - i.e. if tabstops are set, it take these into account.</P></LI>

<P><LI>width of the screen and</P></LI>

<P><LI>the current buffer's leftoffset,</P></LI>

<P><LI>for a tabcells buffer (see <A HREF="#ABOUT TABULAR TEXT">about tabular text</A>) the query fails when the current character is in a truncated part of the cell text - even if it's cell is somewhere between the screen margins.</P></LI>

</UL><P>This command fails if the current character is outside the visible area. i.e if the current character is off to the right of the screen when leftoffset has been set too low or left of the left margin when the leftoffset has been set to high.</P>

<P>The values placed on the stack are designed to be a useful starting point for calculation of a revised leftoffset - for an example look at the definition of <A HREF="jot_ug.html#WORDLEFT">WordLeft</A> and <A HREF="jot_ug.html#WORDRIGHT">WordRight</A> in the standard startup script.</P>


</UL><H4><A NAME="QUERY COMMANDMODE">Query commandmode</H4>
<PRE>
%q=commandmode
</PRE>
<UL><P><LI>Success if editor is in command mode.</P></LI>

<P>This does not affect any buffers or the stack - it just returns a status result - Success indicates that the editor is indeed in command mode, fail indicates that it is in insert mode.</P>


</UL><H4><A NAME="QUERY VERSION">Query version</H4>
<PRE>
%q&#091;&#060;key&#062;&#093;=version
</PRE>
<UL><P><LI>reports editor version and, where appropriate, curses version.</P></LI>

<P>This delivers a brief informational message about the editor version build date and host system. If the buffer key is given this message goes to that buffer otherwise it goes to the console area of the screen. A typical report looks like this:</P>

<PRE>
version
jot for chrome v2.0, built 27/12/16 16:59:42 using crouton  ncurses 6.0.20150808
</PRE>
<P>The majority of the reply is defined by the compile-time string VERSION_STRING. This is typically defined with using the output of the uname command.</P>

<P>The final section is obtained by calling the curses function curses_version().</P>


</UL><H4><A NAME="QUERY DIR">Query dir</H4>
<PRE>
%q&#091;&#060;key&#062;&#093;=dir &#091;&#060;fmt1&#062; &#091;&#060;fmt2&#062; &#091; &#060;fmt3&#062; ... &#093;&#093;&#093;&#060;path&#062;
</PRE>
<UL><P><LI>reports contents of directory.</P></LI>

<P>If the specified pathname does not exits or does not point to a directory, then the command fails. If no destination buffer is specified then the dir query will only verify the path.</P>

<P>If the destination buffer is specified (i.e. if the optional buffer key is given) then the dir query lists the contents of the nominated directory to the nominated buffer. Note that the order is just as returned by the filing system - you will need to use <A HREF="#%B=SORT">%b=sort</A> to get them in order. This command will always check that the path exists and destination node really is a directory and will fail if this is not so. If no destination buffer is specified this query will only check that the given path exists and is a directory.</P>

<P>If any format specifiers are included then the relevant information is added to the file entries. The following format specifiers are currently supported:</P>

<UL><P><LI>-mtime - the file's modification time in the form yyyy/mm/dd-hh:mm:ss</P></LI>

<P><LI>-utime - the file's usage time in the form yyyy/mm/dd-hh:mm:ss</P></LI>

<P><LI>-ctime - the file's creation time in the form yyyy/mm/dd-hh:mm:ss</P></LI>

<P><LI>-uid - the uid of the file's owner (not available in Windows version),</P></LI>

<P><LI>-gid - the gid of the file's owner (not available in Windows version),</P></LI>

<P><LI>-size - the file size in bytes,</P></LI>

<P><LI>-mode - file permissions, in windows it only indicates Readonly or Writable,</P></LI>

<P><LI>-inode - the file's inode number (not available in Windows version),</P></LI>

</UL><P>In the report sent to the specified destination buffer, the optional data fields are separated from the file names by a tab (VT) character. To make this a bit easier on the eye run the <A HREF="jot_coms.html#AUTOTAB.JOT">autotab.jot</A> script.</P>


</UL><H4><A NAME="QUERY FILE">Query file</H4>
<PRE>
%q&#091;&#060;key&#062;&#093;=file &#091;&#060;pathName&#062;&#093;
</PRE>
<UL><P><LI>reports on state of file.</P></LI>

<P>The file query will always check that the pathName exists and will fail if this is not the case. If no destination buffer is specified, this check is all it does.</P>

<P>If no file name is specified then the pathName of the current buffer is used. If no pathname is specified and the destination buffer is the same as the current buffer then this command fails without completing the report.</P>

<P>When the destination buffer is specified, the file query lists various bits of system information about the specified file. Note that there is no stripping of additional whitespace following the delimiter blank after the file keyword.</P>

<P>The following report is written to the destination buffer:</P>

<PRE>
file &#060;pathName&#062;
                 Name = "&#060;pathName&#062;"
                inode = &#060;inodeNumber&#062;
                 Mode = &#060;modeInOctal&#062;
                  uid = &#060;userID&#062;
                  gid = &#060;groupID&#062;
                 size = &#060;fileSizeInBytes&#062;
 writable by this UID = &#060;yes|no&#062;
            directory = &#060;1_IfDirectory_0_IfNot&#062;
          Access time = &#060;fileAccessTime&#062;
          Modify time = &#060;fileModifyTime&#062;
        Creation time = &#060;fileCreationTime&#062;
</PRE>
<P>All datestamps are in the following format: YYYY/MM/DD, HH:MM:SS</P>


</UL><H4><A NAME="QUERY KEYS">Query keys</H4>
<PRE>
%q&#091;&#060;destinationBuffer&#062;&#093;=keys
</PRE>
<P>This dumps all the keys associated with the current buffer to a report in the nominated destination buffer it fails if there is no hash table associated with the current buffer. If no destination buffer is specified then it simply returns the status result. In addition to listing each key in full, it also the first 30 characters of the text associated with the key.</P>

<P>The keys are part of the internal hash-table data structure. While this query may be useful for diagnosis of problems with macros - it's primary purpose is the detection of errors in the editors internal hash-table-entry handling operations.</P>


</UL><H4><A NAME="QUERY KEY">Query key</H4>
<PRE>
%q&#091;&#060;destinationBuffer&#062;&#093;=key &#060;hTabKey&#062;;
</PRE>
<P>This reports on the specified hash-table entry the report is sent to the specified buffer. If the key has not been set up in that hash table then the command fails.</P>


</UL><H4><A NAME="QUERY TAGS">Query tags</H4>
<PRE>
%q&#060;destinationBuffer&#062;=tags&#091; -here&#093;
</PRE>
<P>In the internal data structure, each record has any number of tags associated with it. These tags are used to maintain hashtables, optional text colours and user-specified metadata in the form of text strings. This query lists the tags (hash-table target points, colour tags and text tags) in current buffer the report goes to a nominated destination buffer.</P>

<P>The optional qualifier -here will return only those tags active at the current character. Currently, this is the only mechanism for extraction of user-specified metadata from the record. One useful application for this is storage of hash-table keys associated with the text - especially when combined with a mouse-event handler. The <A HREF="jot_coms.html#LINKDOCS.JOT">linkdocs.jot</A> and <A HREF="jot_coms.html#BOOKINGS.JOT">bookings.jot</A> scripts are examples of this.</P>


</UL><H4><A NAME="QUERY HEAP">Query heap</H4>
<PRE>
%q=heap
</PRE>
<UL><P><LI>reports heap statistics.</P></LI>

<P>Reports raw data from the mallinfo routine (see the mallinfo man page).</P>


</UL><H4><A NAME="QUERY HISTORY">Query history</H4>
<PRE>
%q&#060;buf&#062;=history
</PRE>
<UL><P><LI>reports command history.</P></LI>

<P>Reports all entries in the history buffer in chronological order - the report is directed to the nominated buffer. The size of the history buffer is limited but can be changed with the <A HREF="#-HISTORY">-history</A> cli qualifier. This report is used in the command-edit screen - see <A HREF="jot_ug.html#ABOUT COMMAND EDITING">about command editing</A>.</P>

<P>N.B. The history maintained for the history query is entirety independent of the history file in the journal area - see <A HREF="#ABOUT JOURNAL FILES">about journal files</A>.</P>


</UL><H4><A NAME="QUERY VERIFY">Query verify</H4>
<PRE>
%q=verify
</PRE>
<UL><P><LI>Verify integrity of current buffer's internal data structures.</P></LI>

</UL><P>This command performs a few simple checks aimed at detection of errors in the internal record structures. The main test is to ensure that the string length of each record is never longer than the allocated string size. This situation should *never* occur, if it were to, the editor would crash before long as other internal data gets corrupted.</P>

<P>If the verbosity level is more than 1 (See <A HREF="#%S=VERBOSE">%S=verbose</A>) then the contents of the buffer are echoed to the console area.</P>


</UL><H3><A NAME="%H">%H</H3>
<P>The %H command is used for maintenance of hashtables - see <A HREF="#ABOUT HASHTABLES">about hashtables</A></P>

<PRE>
%H&#091;&#060;key&#062;&#093;=create &#060;n&#062;&#091; &#060;path&#062;&#093; &#123;-delete|-destroy|-protect|-adjust&#125;
</PRE>
<UL><P><LI>Creates a new hashtable. See <A HREF="#HASHTABLE CREATE">hashtable create</A></P></LI>

<PRE>
%H&#091;&#060;path&#062;&#093;=add &#060;hashTableKey&#062; - Create a hashtable entry.
</PRE>
<P>See <A HREF="#HASHTABLE ADD">hashtable add</A></P>

<PRE>
%H&#091;&#060;path&#062;&#093;=new &#060;hashTableKey&#062; - Create a new hashtable entry, fails if path 
</PRE>
<P>does not define a unique name. See <A HREF="#HASHTABLE NEW">hashtable new</A></P>

<PRE>
%H&#091;&#060;path&#062;&#093;=data &#060;hashTableKey&#062; - creates a hashtable object which can hold a 
</PRE>
<P>stack frame - see <A HREF="#HASHTABLE DATA">hashtable data</A>.</P>

<PRE>
%H&#091;&#060;path&#062;&#093;=setsect &#060;hashTableKey&#062; - creates a hashtable object for use in a 
</PRE>
<P>%i=&#060;pathName&#062; ... -section; command - see <A HREF="#HASHTABLE SETSECT">hashtable setsect</A></P>

<PRE>
%H&#091;&#060;path&#062;&#093;=setfsect &#060;hashTableKey&#062; - creates a hashtable object for use in a 
</PRE>
<P>%i= ... -fsection; command - see <A HREF="#HASHTABLE SETFSECT">hashtable setfsect</A></P>

<PRE>
%H&#091;&#060;path&#062;&#093;=delete &#060;hashTableKey&#062; - Removes specified hash-table entry.
</PRE>
<P>See <A HREF="#HASHTABLE DELETE">hashtable delete</A></P>

<PRE>
%H&#091;&#060;bufferKey&#062;&#093;=jump &#060;hashTableKey&#062;
</PRE>
<P><LI>Search for a match to path - see <A HREF="#HASHTABLE JUMP">hashtable jump</A>.</P></LI>

<PRE>
%H&#091;&#060;key&#062;&#093;=call &#060;hashTableKey&#062; -  Search for routine then run it.
</PRE>
<P>See <A HREF="#HASHTABLE CALL">hashtable call</A></P>

<PRE>
%H&#091;&#060;path&#062;&#093;=fix - resets line numbers for referencing hashtables.
</PRE>
<P>See <A HREF="#HASHTABLE FIX">hashtable fix</A></P>

<PRE>
%H&#091;&#060;path&#062;&#093;=destroy&#091; -all&#093; -  Destroys the hashtable.
</PRE>
<P>See <A HREF="#HASHTABLE DESTROY">hashtable destroy</A></P>

<PRE>
%H&#091;&#060;path&#062;&#093;=testkey &#091;&#060;string&#062;&#093; -  Verifies the hashtable entry exists.
</PRE>
<P>See <A HREF="#HASHTABLE TESTKEY">hashtable testkey</A></P>

<PRE>
%q&#091;&#060;destBufKey&#062;&#093;=keys - lists all keys in the hash table associated with
</PRE>
<UL><P>this buffer - see <A HREF="#QUERY KEYS">Query keys</A> for details it fails if there is no hashtable associated with the buffer.</P>

</UL><P><LI>%q&#091;&#060;destBufKey&#062;&#093;=key &#060;keyString&#062; - reports details of that key - if the key is not defied in the hashtable then the command fails.</P></LI>


</UL><H5><A NAME="HASHTABLE CREATE">Hashtable create</H5>
<PRE>
%H&#091;&#060;bufferKey&#062;&#093;=create &#060;size&#062;&#091; &#060;path&#062;&#093; &#091;-delete|-destroy|-protect|-adjust&#093; - Create a new hashtable.
</PRE>
<P>Create an empty hashtable in specified buffer, or the current buffer, if none specified. The size parameter specifies the size of the table. Take care to not underestimate the required size. The value can be specified on the command line or picked up from the top of the stack.</P>

<P>If the buffer already has a hashtable and the new size is sufficient, then this is destroyed and it's mode and entries are copied to the new hashtable, if the new size is insufficient then the command fails. As the hashtable is copied over, any zombies are removed (zombies are entries that have been deleted with the <A HREF="#HASHTABLE DELETE">hashtable delete</A> command). This behaviour is intended to allow purging and re-sizing while preserving existing entries.</P>

<P>If the size is set to 0 or any negative value then any preexisting hastable is destroyed and no new hashtable is created - the overall effect is identical to <A HREF="#HASHTABLE DESTROY">hashtable destroy</A>.</P>

<P>The hashtable contains pointers to various classes of object (see <A HREF="#ABOUT HASHTABLES">about hashtables</A>):</P>

<UL><P><LI>'target strings' in your text - allowing fast access to sections of text, </P></LI>

<P><LI>data objects (see <A HREF="#HASHTABLE DATA">hashtable data</A>), which can be copied to and from the stack and</P></LI>

<P><LI>file-section objects (see <A HREF="#%I">%I</A>)</P></LI>

</UL><P>There are several options regarding behaviour when the targeted strings are to be deleted (see <A HREF="#ABOUT HASHTABLES">about hashtables</A>). Essentially these are:</P>

<UL><P><LI>-adjust - When any target string is deleted the relevant entries targeting hashtables are silently redirected to some nearby point. This is the default mode of operation.</P></LI>

<P><LI>-delete - When any target string is changed the relevant hash-table entries are marked as deleted.</P></LI>

<P><LI>-destroy - When any target string is deleted the targeting hashtable is silently destroyed and all of it's target tags are removed. Any other changes in the vicinity of the hashtable target points cause the targets to be adjusted.</P></LI>

<P><LI>-protect - Any record containing a target string is protected from deletion Any other changes in the vicinity of the hashtable target points cause the targets to be adjusted.</P></LI>


</UL><H5><A NAME="HASHTABLE ADD">Hashtable add</H5>
<PRE>
%H&#091;&#060;bufferKey&#062;&#093;=add &#060;hashtableKey&#062; - adds a hashtable key.
</PRE>
<P>Adds a new jump entry (see <A HREF="#HASHTABLE JUMP">hashtable jump</A>) to the hash table for the specified or, current buffer, if none is specified. The hash table entry will store the exact location of the current character in the current buffer. In the event of a collision (i.e. the key already exists in the hashtable) the original value is silently replaced by the new value. See <A HREF="#ABOUT HASHTABLES">about hashtables</A>.</P>


</UL><H5><A NAME="HASHTABLE NEW">Hashtable new</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=new &#060;hashtableKey&#062; - adds a new hashtable key.
</PRE>
<P>Similar to add (above) except that, in the event of a collision, the original entry is unchanged and the command fails. See <A HREF="#ABOUT HASHTABLES">about hashtables</A>.</P>


</UL><H5><A NAME="HASHTABLE JUMP">Hashtable jump</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=jump &#060;hashtableKey&#062; - performs a hashtable lookup and jump.
</PRE>
<P>The hash table in the specified buffer (or the current buffer, if none specified) is searched. If the key exists then the focus is restored to the point at which the key was entered. If the key is not found, then the command fails - see <A HREF="#ABOUT HASHTABLES">about hashtables</A>.</P>


</UL><H5><A NAME="HASHTABLE DATA">Hashtable data</H5>
<PRE>
%h&#091;&#060;bufferKsy&#062;&#093;=data &#060;HashtableKey; - creates a hashtable entry for storage of generic data.
</PRE>
<P>This creates a hashtable entry which can be used for storage of a stack frame. The command creates a blank entry and does not affect the state of the stack. The data value can be refined with the <A HREF="#OV">OV</A> command and later retrieved using the <A HREF="#OQ">OQ</A> commands. </P>

<P>Note the absence of any typing with this command, any of the three valid stack datatypes (integer value, floating-point value or buffer) may be used with any data object and the datatype is allowed to change. In this example, the data object fred is first set to an integer, then a float and, finally, a buffer - it's all allowed.</P>

&#062; %h=create 100;
&#062; %h=data fred;
&#062;ol123456789 ov/fred/
&#062; ol123.456 ov/fred/
&#062; %d~=Hello world; ov/fred/

</UL><H5><A NAME="HASHTABLE SETSECT">Hashtable setsect</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=setsect &#060;hashtableKey&#062;; - creates a hashtable entry for use in %i;
</PRE>
<P>This takes the top two items on the stack and creates a hashtable entry for use by the -section=&#060;key&#062; qualifier of the <A HREF="#%I">%I</A> command. This is a rare example of a magic command in jot - it is designed for use by scripts reading index tables for large files and is only useful for this purpose. (see <A HREF="#ABOUT LARGE FILES">about large files</A>).</P>

<P>Another unusual feature of this command - although it uses two values at the top of the stack, it does not remove them. This feature is designed for scripts which calculate section byte counts by subtracting seek neighbouring seek points.</P>


</UL><H5><A NAME="HASHTABLE SETFSECT">Hashtable setfsect</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=setfsect &#060;hashtableKey&#062;; - creates a hashtable entry for use in %i;
</PRE>
<P>This takes the top three items on the stack and creates a hashtable entry for use by the -fsection=&#060;key&#062; qualifier of the <A HREF="#%I">%I</A> command. It is designed for use by scripts reading index tables for large numbers of files and is probably only useful for this purpose. (see <A HREF="#ABOUT LARGE COLLECTIONS OF FILES">about large collections of files</A>).</P>

<P>Another unusual feature of this command, similar to <A HREF="#HASHTABLE SETSECT">hashtable setsect</A>, although it uses three values at the top of the stack, it does not remove them. This feature is designed for the computational convenience of scripts calculating section byte counts by subtracting the previous-section seek point from the current-section seek point.</P>

<P>Note that consecutive setfsect calls referring to the same pathname will all share the same internally-held copy of the pathname. This behaviour is designed to minimize memory usage by the internal data structures. Fortunately most practical indexation methods will generate index file structured in this way.</P>


</UL><H5><A NAME="HASHTABLE DELETE">Hashtable delete</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=delete &#060;hashTableKey&#062;;
</PRE>
<P>This changes the state of the selected key to a sort of half-dead zombie state. Unfortunately it is not possible to delete keys from hashtables built using the gnu-library hashtables. So we do the next-best thing.</P>

<P>The hash key can be re-assigned - this, for example, will work:</P>

&#062; %h=add fred;
&#062; %h=delete fred;
&#062; %h=data fred;
<P>The zombies are removed if the hashtable is rebuilt - see <A HREF="#HASHTABLE CREATE">hashtable create</A>.</P>


</UL><H5><A NAME="HASHTABLE CALL">Hashtable call</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=call &#060;functionName&#062;
</PRE>
<P>The buffer indicated by the key must be a code repository ( see <A HREF="#CALLING SUBROUTINES BY NAME">calling subroutines by name</A> ). The <A HREF="jot_coms.html#STARTUP.JOT">startup.jot</A> script, for example, defines and creates hash-table entries for a number of routines in the ' buffer.</P>

<P>In the event of the named subroutine is not in the specified buffer, then the call fails silently.</P>

<P>Note that %h=call does not pass parameters into the routine. The way this is done with escape sequences is a little bit of code immediately before the call that copies parameters into the ( $ ) buffer - see <A HREF="#TRANSLATION OF KEYBOARD EVENTS TO ACTIONS">translation of keyboard events to actions</A></P>


</UL><H5><A NAME="HASHTABLE FIX">Hashtable fix</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=fix
</PRE>
<P>This corrects the linenumbers held in any hashtable it also resets the linenumber of the first line to 1 and returns to the first line.</P>

<P>If records are added or removed after the buffer has been indexed in a hashtable, the linenumbers held in the hashtable may be incorrect. This can result in errors when using these linenumbers to calculate offsets between indexed records. The fix operation assigns the new, correct, linenumbers in the referencing hashtables and resets the buffer so that any errors in the line numbering are resolved.</P>


</UL><H5><A NAME="HASHTABLE DESTROY">Hashtable destroy</H5>
<PRE>
%h&#091;&#060;bufferKey&#062;&#093;=destroy&#091; -all&#093;
</PRE>
<P>This removes the entire hashtable, destroying all entries. The optional -all qualifier will destroy all hash tables in all buffers - N.B. including any system hashtables like the code-repository functions set up in the ( ' ) buffer.</P>


</UL><H5><A NAME="HASHTABLE TESTKEY">Hashtable testkey</H5>
<PRE>
%H&#091;&#060;bufferKey&#062;&#093;=testkey &#091;&#060;string&#062;&#093;
</PRE>

<P>By default this tests the hashtable of the current buffer. The optional bufferKey specifies some other buffer's hashtable to be tested. </P>

<P>The %h=testkey command verifies the hashtable contains at least one key matching the given string. This is used to find out if a hashtable has been set up and, if a search string is given, that at least one key matches the string.</P>

<P>If the string parameter is not given, then this command checks that a hashtable exists.</P>

<P>This command does not write any report, it simply returns a Success or Fail status.</P>


</UL><H4><A NAME="%D">%D</H4>
<PRE>
%D&#060;key&#062;=&#060;string&#062; - Defines the specified buffer directly from the console.
</PRE>
<P>The first parameter is the buffer identifier key - a single character used to reference the buffer. Note that, unlike most other percent commands, any indirect references in the string are not resolved at %D time - see <A HREF="#PERCENT-COMMAND SYNTAX">percent-command syntax</A> for details. This anomalous behaviour is designed to facilitate the definition of macro commands.</P>

<P>One particularly important variant is %d~=...; - this creates a one-line buffer on the top of the stack and is often followed by the <A HREF="#OV">OV</A> command. This combination is used to set a data object to a string value. See <A HREF="#ABOUT HASHTABLES">about hashtables</A> and <A HREF="#USING HASHTABLE DATA">using Hashtable data</A></P>

<P>Whereas %D will define a single-line buffer (usually a macro) <A HREF="#%G">%G</A> is useful for defining any-number of lines.</P>


</UL><H4><A NAME="%G">%G</H4>
<PRE>
%G - Get = Reads in an buffer from current command stream or macro.
</PRE>
<P>This is similar to the <A HREF="#G">G</A> command, except that whereas G always takes input from the console, %G will take from whatever command input currently active</P>

<UL><P><LI>typically a script. Thus %G is a handy way for scripts to define multi-line macros.</P></LI>

<P>Whereas %G defines any number of records <A HREF="#%D">%D</A> is a convenient way of defining a single-line macro.</P>


</UL><H4><A NAME="%I">%I</H4>
<PRE>
%I&#091;&#060;bufferKey&#062;&#093;&#091;=&#060;pathName&#062;&#093;&#091; -seek=&#060;ByteNo&#062;&#093;&#091; -bytes|-block=&#060;bytes&#062;|-records=&#060;n&#062;&#093;|
</PRE>
<P>&#091; -section|-fsection&#093;&#091; -insert | -append&#093;&#091; -hold&#093;&#091; -binary&#091;=&#060;recordSize&#062;&#093;&#093;</P>

<UL><P><LI>Input (read) a secondary file.</P></LI>

</UL><P>This loads the file to buffer specified by the buffer identifier key. If no key is given, it reads to the current buffer.</P>

<P>The pathname defaults to the pathname of the currently-edited file. If the new filename is incompletely specified then the missing fields are filled in using the current-buffer's pathname. Note that this behaviour can cause difficulties. If the new file is in your pwd and the current file is in some other directory, you must prefix the name with the path "./". If the target file has no name extension and the current file does, you must change focus to a buffer with no pathname set.</P>

<P>Briefly %I has the following optional qualifiers several dedicated in some way to the loading of sections of large files - see <A HREF="#ABOUT LARGE FILES">about large files</A>:</P>

<UL><P><LI>-seek - specifies a byte-offset section start point,</P></LI>

<P><LI>-bytes - specifies a section length in bytes,</P></LI>

<P><LI>-section - loads a named section, previously defined in a hashtable,</P></LI>

<P><LI>-fsection - as -section but object also specifies pathname,</P></LI>

<P><LI>-append - adds the section to the end of an existing file image,</P></LI>

<P><LI>-insert - inserts the text at the current-character position,</P></LI>

<P><LI>-hold - holds the file-handle open for reading multiple sections,</P></LI>

<P><LI>-records - limits the number of records (lines) read from the file,</P></LI>

<P><LI>-binary - loads the (possibly binary) file in the form of a Hex dump</P></LI>

</UL><P>The -bytes qualifier gives it an end count which restricts the read to that many bytes. It can be combined freely with the -hold, the -seek and the -binary options. The -block qualifier is similar in that it specifies a limit on the number of bytes but, with -block, blocks of data are read into one record of the specified size. This feature is designed to speed up the movement of large blocks of data by bypassing all the normal record-building activity associated with normal reads. The -records=&#060;n&#062; qualifier sets an upper limit on the number of records to be read.</P>

<P>The -seek can be used for reading sections of file, provided you know where the desired section is and how big it is. It can be useful for reading the important bits from large files.</P>

<P>The -section qualifier sets the seek and limit from the top two items on the stack. This is designed to be used in conjunction with the <A HREF="#HASHTABLE SETSECT">hashtable setsect</A> command. Unlike the -fsection variant, -section assumes that the pathname is known and constant. It is therefore more suitable for situations where only one file is required - typically a very large file containing a great many sections.</P>

<P>The -hold qualifier causes the file handle associated with the buffer and to be left open, this is to facilitate reading of files in blocks. The actual file handle is associated with the buffer and therefore cannot be used to read into other buffers. This option is intended to be used in conjunction with the -section option, on very large files.</P>

<P>The -fsection qualifier is very similar to -section, except that the hashtable object it accepts is the form created by the <A HREF="#HASHTABLE SETFSECT">hashtable setfsect</A> command. These objects are created by the <A HREF="#HASHTABLE SETFSECT">hashtable setfsect</A> command. Like the setsect object, this contains a seek-offset byte count and a section-length bytecount but it also contains the pathname of the file to be read. This makes the -fsection variant suitable for situations where sections are distributed over a large number of files.</P>

<P>The -binary option reads the file and displays it in the form of a hex dump. The optional recordSize value specifies ow many Hex pairs to place in each line, defaults to 16 if not specified. To view ascii characters use the script <A HREF="jot_coms.html#HEX2ASCII.JOT">hex2ascii.jot</A>, this annotates each line of hex dump with the ascii translation.</P>

<P>The -insert qualifier causes the file image to be inserted into the current-character position of the buffer. By default the buffer is cleared and the new file completely defines the buffer text. The -append qualifier is similar except that the new records are delivered to the end of the current buffer without changing the current view.</P>

<P>If the buffer has already been reading a file with -hold, the new pathname is ignored and the old file handle is reused. To prevent this happening it is necessary to perform a read without the -hold qualifier - something like this should do the trick:</P>

&#062; %iz=/dev/null -append;

</UL><H4><A NAME="%L">%L</H4>
<PRE>
%L &#091;&#060;width&#062;x&#060;height&#062;&#093; - Sets the terminal line length and number of lines.
</PRE>
<P>This is a throwback to the days of VT200-series terminals, the DECCOLM function allowed 80/132 switches.</P>

<P>More typically, in an xterm environment the xterm size is changed by dragging the window boundaries. After this, %l can be used, without the terminal-size parameter, after changing the xterm dimensions. It reads back the new screen height and width henceforth these new values are used in internal calculations involving screen dimensions.</P>

<P>If a terminal size is specified, each of the given dimensions should be less that the than or equal to the corresponding dimensions of the actual terminal you are using - if not then %L fails and both are set to the actual screen size.</P>

<P>After a %L operation, all windows remain valid except any where the right or bottom margin exceeds the relevant new terminal dimension. If this should happen the %L sets the failure flag and the offending windows are tagged as Void. Use the <A HREF="jot_ug.html#WINDOWONE">WindowOne</A> function to re-assign the window.</P>

<P>This command also completely redraws all windows on the screen, hence it is useful if, for whatever reason, the screen happens to get messed up.</P>


</UL><H4><A NAME="%O">%O</H4>
<PRE>
%O&#091;&#060;pathName&#062;&#093;&#091; -append&#093;  - Output current buffer as specified file.
</PRE>
<P>The current buffer is written out using the given pathname.</P>

<P>The -append qualifier adds the contents of the buffer to the end of the file. Whether or not the -append qualifier is given, if the file does not exist, then a new one is created.</P>

<P>The pathName defaults to the pathname of the current buffer. If the new file name is incompletely specified then the missing fields are filled in using the current pathname.</P>


</UL><H4><A NAME="%R">%R</H4>
<PRE>
%R=&#091;pathname&#093;&#091; -asConsole&#093;&#091; &#060;Arg1&#062;&#091; &#060;Arg2&#062;&#091; ...&#093;&#093;&#093; - Run a command file.
</PRE>
<P>If no path is explicitly specified, then JOT first searches your PWD, if it's not found there, it searches the directory $&#123;JOT_HOME&#125;/coms - see <A HREF="#INSTALLATION">installation</A>.</P>

<P>Any parameters will be copied into the ( $ ) buffer to be picked up by your script.</P>

<P>The file contains editor commands, these are all executed in the same way as with console input, the default file name is startup.jot.</P>

<P>In the event of an un-trapped error (i.e. a command failed and no else clause applies), then execution of the script is normally terminated. The -asConsole qualifier changes this behaviour.</P>

<P>When the -asConsole qualifier is given, the behaviour is more like an interactive session:</P>

<UL><P><LI>Errors are reported normally then, instead of abandoning the script, the error is changed to an ordinary command failure so that processing resumes at the else block or the next line of the script.</P></LI>

<P><LI>The script may contain escape sequences - in practice the only ones that are likely to contain these are recovery scripts - see <A HREF="#ABOUT JOURNAL FILES">about journal files</A>.</P></LI>

<P><LI>While the script is active all console reads (e.g. commands and g command input) are from this script.</P></LI>

<P><LI>The principal purpose for -asConsole operation is to allow recovery scripts to behave as the original interactive session - see <A HREF="#ABOUT JOURNAL FILES">about journal Files</A>.</P></LI>

</UL><P>Command files may be nested to a depth of 20.</P>


</UL><H4><A NAME="%U">%U</H4>
<PRE>
%U - Undo = Undo last substitution.
</PRE>
<P>The current substring (irrespective of whether selected by <A HREF="#F">F</A>, <A HREF="#V">V</A>, <A HREF="#I">I</A> or <A HREF="#S">S</A>) is replaced by the last specified search string. Normally, of course, this would have been set as a result of a S (substitute) command, following a F (Find) command, hence the substitution is undone.</P>

<P>If the original find substring had a different case pattern to the replaced substring (i.e. the find was done in case-insensitive mode) then the undo will not reflect the original case pattern.</P>


</UL><H4><A NAME="%W">%W</H4>
<PRE>
%W&#091;&#060;key&#062;&#093;=&#091; -winno=&#060;n&#062;&#093;&#091; -key=&#060;NewKey&#062;&#093;&#091; -popup&#093;&#091; -delim&#093;
</PRE>
<UL><P>&#091; -height=&#060;height&#062;&#093;&#091; -width=&#060;width&#062;&#091;+&#060;guard&#062;&#093;&#093;&#093;&#093; &#091; -delete|-insert|-freeze=&#091;0|1&#093;&#093;</P>

</UL><H5><A NAME="HISTORICAL SYNTAX">Historical syntax</H5>
<PRE>
%w &#060;height&#062;&#091; &#060;key&#062;&#093;;
</PRE>
<P>The %W command controls the display which may be split into any number of windows, limited by the overall size of your terminal. Windows may be defined as a number of screen lines or may be vertical slices of &#060;height&#062; lines and &#060;width&#062; columns. Windows may be assigned to specific buffers or can be left unassigned - in which case they display the current buffer.</P>

<P>The window configuration can be modified by specifying a particular window deleting it or specifying a new &#060;width&#062;, &#060;height&#062; or &#060;windowKey&#062; of a specific window.</P>

<UL><P><LI>Set up next &#060;height&#062; lines as a screen window or</P></LI>

&#062; %W&#060;key&#062;= -width=&#060;width&#062;&#091;+&#060;guard&#062;&#093;
<P><LI>set up another vertical slice in the previously defined window or</P></LI>

&#062; %W&#060;key&#062;= -popup &#091; -width=&#060;width&#062;&#093;&#091; -height=&#060;height&#062;&#093;
<P><LI>defines a popup window (only appears when buffer contains text) or</P></LI>

&#062; %W;
<P><LI> with no arguments, all screen windows are cleared</P></LI>

&#062; %W &#060;height&#062;&#091; &#060;key&#062;&#093;;
</UL><P>This is a historical syntax, still supported but deprecated. If, when using the historical syntax, a -height=&#060;height&#062; qualifier is included, then the height specified here overrides the earlier specification. </P>

<P>New windows, or vertical slices of windows, are added in sequence by a series of %W commands, typically the first will be %W; - to clear all windows.</P>

<P>Note that the qualifiers must always follow whitespace - this is correct syntax:</P>

&#062; %wz= -height=11;
<P>this will fail:</P>

&#062; %wz=-height=11;
<UL><P><LI>&#060;height&#062; - Specifies the number of screen lines to allocate to the next window. These are allocated sequentially starting from the top line. New windows are added below any preexisting ones. Note that n specifies the total size of the window, if you later request a delimiter line (%w 0; ), this replaces the bottom line of your window and if you specify a header line to be associated with a buffer (see <A HREF="#%B=HEADER">%b=header</A>) then this replaces the top line of your window. eg:</P></LI>

&#062; %w 20;
<P>or, here we take the window size off the stack:</P>

&#062; %w '~;
<P><LI>The -delim option requests that the last line of the window be filled with a delimiter line. The window delimiter is in reverse video and, by default, set to the pathname and the buffer key - see <A HREF="#%B=FOOTER">%b=footer</A>.</P></LI>

<P>An obsolete method of requesting a delimiter line was %w=0; after the %w used to define the window - this is deprecated but still supported for the benefit of old scripts.</P>

<P><LI>The optional -width=&#060;width&#062; modifier specifies the width of a vertical slice of the window. When mixed with %W=&#060;height&#062; ... this becomes the leftmost slice in a new window of that height. When the window-height is set to 0, then a new slice of the specified width is added to earlier slices.</P></LI>

<P>By default, the left margin of the second and subsequent slices will abut the right margin of the predecessor slice. The +&#060;guard&#062; modifier (where &#060;guard&#062; is a small integer) will insert that many blank columns between the slice and it's predecessor slice.</P>

<P><LI>The optional &#060;key&#062; parameter specifies which buffer is to be associated with the screen window, if this is not given then the current buffer is displayed in the window - a floating window. </P></LI>

<P>In the event of there being more than one floating window, or, one floating window and the current window is attached to a static window, then the floating window is left displaying whatever buffer it is currently displaying or, at the start of day, it displays blank lines.</P>

<P><LI>When the optional -winno=&#060;windowNo&#062; modifier is given, rather than creating a new window, the command will modify the attributes of an existing window. The &#060;windowNo&#062; refers to the target window's position in the window list. This is the same as the order that the windows were originally created and appears at the head of the report generated by the <A HREF="#QUERY WINDOW">Query window</A> command.</P></LI>

<P>The -winno=&#060;windowNo&#062; qualifier can be combined with the following modifiers to modify the relevant attributes of the target window:</P>

<UL><P><LI>-height=&#060;height&#062; - to set the window height - for slices see below,</P></LI>

<P><LI>-width=&#060;width&#062; - to specify a new slice width,</P></LI>

<P><LI>-key=&#060;NewKey&#062; - to specify a new buffer association for the window.</P></LI>

<P><LI>-delete - deletes the selected window from the window list.</P></LI>

<P><LI>-insert - inserts the newly-specified window above the selected window.</P></LI>

<P><LI>-freeze=&#091;0|1&#093; - forces the window in/out of frozen mode - see below.</P></LI>

</UL><P>When it is required to change the height of an existing group of slices, this can be accomplished by changing only the height of the first (leftmost) slice in the group. Any attempt to change the height of other members of the group will fail.</P>

<P><LI>The -freeze=1 modifier forces the selected window to be frozen - even if there are no duplicate views in other windows. The -freeze option can be applied to any window and it will remain displaying whatever was displayed as the %w ... -freeze command was issued. Note that the -freeze modifier is ignored for popup windows. The -freeze=0 modifier unfreezes the window.</P></LI>

<P>Note that jot does not maintain a record of the state of frozen windows. It simply avoids updating them as the state of the underlying buffer changes. Any subsequent <A HREF="#%W">%W</A> or <A HREF="#%L">%L</A> command will clear the window and, should a <A HREF="#%E">%E</A> corrupt the display by scrolling into the frozen section of the display, then the %E output will replace the original view.</P>

<P><LI>When the -popup option is given, a buffer key must be given. Popup windows can be used to display information or to provide some sort of menu-driven interface. These are visible only when the associated buffer has a nonblank first line.</P></LI>

<P>Popups overwrite rectangular sections of the display, in order to ensure that the popup becomes visible the popup window should be defined after the definition of the underlying windows.</P>

<P>There is no limit to the number of popups but since each requires a dedicated buffer and it is quite easy to share them between a number of activities it is recommended practice to use as few as possible.</P>

<P>For -popup windows, the height and -width dimensions specify the maximum size that the window can be allowed to grow to - if unspecified the popup may grow to fill the entire terminal screen. The top-left character of the popup is normally aligned to the top left character position of the screen. If a negative width is specified then the top right character position of the popup is aligned to the top-right character position of the screen.</P>

<P>Note that, by default, the popup appears in the same colour pair and font as the surrounding text with no delimiter markers. It is left to the programmer to make suitable arrangements for the popup stand out from the surrounding text. Failure to do this will make the display very confusing.</P>

<P>See also <A HREF="#%S=GUARDBAND">%S=guardband</A>.</P>

<P>Examples:</P>

&#062; %w;              %%Clear away all preexisting windows.
&#062; %w 35; %w 0;     %%Add one window of 34 lines and a delimiter line.

</UL><H4><A NAME="%%">%%</H4>
<P>A JOT comment.</P>

<P>The command scanner ignores all text to the right of the %%.</P>


</UL><H4><A NAME="%~">%~</H4>
<PRE>
%~ - Insert/Evaluate Control Character
</PRE>
<P>All control characters (i.e. characters having an ASCII code of less than 0x20) are represented on the screen as a '~'. To evaluate such a character, the %~ command returns the ASCII code, in hex, for the character at the cursor position. This command has an optional hex-value parameter, if given then the command will instead insert a control character of the specified value, at the cursor position.</P>


</UL><H2><A NAME="JOT TECHNIQUES">JOT techniques</H2>
<P>This section attempts to reveal some insights into JOT usage.</P>


</UL><H3><A NAME="DO THAT AGAIN">Do that again</H3>
<P>Simply typing a number at the console will repeat the last command that many times. This is how the &#060;&#060;Again&#062;&#062; function works. Typically you will want to do this when you've typed in a short command string and want to interactively control how many times it gets repeated.</P>

<P>e.g. The following command removes any indentation from the current line and replaces it with two blanks:</P>

&#062; (v/ /e)0i/ /m
<P>To repeat the treatment on subsequent lines just keep on pumping the &#060;&#060;Again&#062;&#062; key.</P>


</UL><H3><A NAME="CASE BLOCKS">Case blocks</H3>
<P>A block can have any number of failure handlers, thus each case becomes the failure handler for the previous one e.g. (v/fred/..., v/jim/..., ...)</P>


</UL><H3><A NAME="MATCH TO ANY NUMBER OF EQUAL-PRIORITY CONDITIONS.">Match to any number of equal-priority conditions.</H3>
<P>A block without a failure handler will pass it's status up to the parent block, so if there are a list of conditions, any of which may be met we could write something like this:</P>

<UL><P>( ... (v/fred/\v/jim/\v/bill/\) abc, def )</P>

</UL><P>If the cursor is at the start of any of those names, then the command string abc is executed, otherwise it's command def.</P>


</UL><H3><A NAME="TABULATED TEXT">Tabulated text</H3>
<P>Several scripts are available for handling tabulated text. These apply to the entire buffer. To limit the scope of these scripts, abstract the section containing the tabular data into a temporary buffer and apply the scripts in there.</P>

<P>By default, the tab character is the ASCII HT (Horizontal Tab 0x0B), this can be redefined with the <A HREF="#%S=TAB">%s=tab</A> command.</P>

<P>The scripts are all based on the tab character indicating the alignment points.</P>

<UL><P><LI><A HREF="jot_coms.html#RETAB.JOT">retab.jot</A> &#060;string&#062; - inserts tabs based on text content.</P></LI>

<P><LI><A HREF="jot_coms.html#RETABHERE.JOT">retabhere.jot</A> - inserts tabs based on position.</P></LI>

<P><LI><A HREF="jot_coms.html#AUTOTAB.JOT">autotab.jot</A> - replaces the first instance of a tab with blanks so as to align the following text.</P></LI>

<P><LI><A HREF="jot_coms.html#AUTOTABDP.JOT">autotabdp.jot</A> - similar to autotab but aligns decimal points in column following the first tab.</P></LI>

<P><LI><A HREF="jot_coms.html#AUTOTABJUST.JOT">autotabjust.jot</A> - similar to autotab but aligns the following tabs - the effect is to right-justify the column.</P></LI>


</UL><H2><A NAME="COMMAND-LINE QUALIFIERS">Command-Line qualifiers</H2>
<P>The following command-line qualifiers are allowed, the keywords are case insensitive, the upper-case alphas indicate the minimum requirement - briefly:</P>

<UL><P><LI><A HREF="#-">-</A> - stream-in mode - edit the stdin stream (only required by windows version).</P></LI>

<P><LI><A HREF="#-HOLD">-HOld</A> - holds screen on exit.</P></LI>

<P><LI><A HREF="#-HELP">-Help</A> - displays a brief help page.</P></LI>

<P><LI><A HREF="#-HISTORY">-History</A>=&#060;n&#062; - specifies size of internal history buffer.</P></LI>

<P><LI><A HREF="#-INIT">-Init</A>=&#060;jotCommands&#062; - some initialization commands, run after startup.</P></LI>

<P><LI><A HREF="#-JOURNAL">-Journal</A> - create a journal file for recovery from crashes.</P></LI>

<P><LI><A HREF="#-NEW">-New</A> - The specified primary file does not exist.</P></LI>

<P><LI><A HREF="#-OBEY">-Obey</A> - stdin stream is commands.</P></LI>

<P><LI><A HREF="#-QUIET">-Quiet</A> - suppresses most messages.</P></LI>

<P><LI><A HREF="#-STARTUP">-STartup</A> &#060;pathName&#062; - specifies a nonstandard startup script.</P></LI>

<P><LI><A HREF="#-SCREENSIZE">-SCreensize</A>=&#060;width&#062;x&#060;height&#062; - specifies screen size.</P></LI>

<P><LI><A HREF="#-STACKSIZE">-STACksize</A>=&#060;n&#062; - specifies operand-stack size.</P></LI>

<P><LI><A HREF="#-TO">-To</A>=&#060;pathName&#062; - specifies the new default filename</P></LI>

<P><LI><A HREF="#-TTY">-Tty</A> - run in a simple teletype mode.</P></LI>

<P><LI><A HREF="#-LOCALE">-Locale</A>=&#060;locale&#062; - Set the locale appropriately (unix version only).</P></LI>

<P><LI><A HREF="#-CODEPAGE">-Codepage</A>=&#060;codepage&#062; - sets codepage (windows version only)</P></LI>


</UL><H3><A NAME="-">-</H3>
<PRE>
$ &#060;cmd&#062; | jot - ...
</PRE>
<P>The shell command &#060;cmd&#062; generates a text stream which is picked up by jot and loaded into the primary buffer ( . ) - this is only necessary in the windows version.</P>


</UL><H3><A NAME="-NEW">-New</H3>
<PRE>
$ jot -new &#060;pathName&#062; ...
</PRE>
<P>Either the file does not exist or, if it does it will be ignored. The editor starts with an empty buffer but with with the specified pathname and the file will be created by a <A HREF="#%O">%o</A> or <A HREF="#%C">%c</A> command.</P>


</UL><H3><A NAME="-TO">-To</H3>
<PRE>
$ jot &#060;origPathName -to=&#060;toPathName&#062; ...
</PRE>
<P>Sets the <A HREF="#%O">%o</A> and <A HREF="#%C">%c</A> destination file name.</P>


</UL><H3><A NAME="-STARTUP">-STartup</H3>
<PRE>
$ jot &#060;pathName&#062; -startup=&#091;&#060;startupPathName&#062;&#093; ...
</PRE>
<P>A pathName to a special startup sequence. If specified, this takes precedence over the other possible startup-file locations - see <A HREF="jot_coms.html#STARTUP.JOT">startup.jot</A>. </P>

<P>If -startup is specified with no pathName argument then no startup is run.</P>


</UL><H3><A NAME="-INIT">-Init</H3>
<PRE>
$ jot &#060;pathName&#062; -init=&#060;jotCommandString&#062; ...
</PRE>
<P>The jotCommandString commands are processed after running the normal startup sequence - this can be used to initialize the editor in some special way or for stream editing. This qualifier is also useful when jot is being driven by a shell script.</P>


</UL><H3><A NAME="-TTY">-Tty</H3>
<PRE>
$ jot &#060;pathName&#062; -tty ...
</PRE>
<P>Teletype mode, for use in environments where the normal screen-control operations won't work or, when jot is driven by a script.</P>

<P>With -tty any window setup in the startup file has no effect, on completion of each command line, the current line is displayed, the position of the current character is indicated by a carat ( ^ ) in the following line and the current substring by a string of tildes ( ~ ).</P>


</UL><H3><A NAME="-CODEPAGE">-Codepage</H3>
<PRE>
$ jot &#060;pathName&#062; -codepage &#060;value&#062; ...
</PRE>
<P>This qualifier is available only in the windows version, in linux the -locale qualifier performs a similar function. This qualifier sets codepage to specified value, by default codepage is set to 65001 - UTF8 - see <A HREF="#PRACTICALITIES OF UNICODE ETC. AND JOT.">Practicalities of unicode etc. and jot.</A></P>


</UL><H3><A NAME="-LOCALE">-Locale</H3>
<PRE>
$ jot &#060;pathName&#062; -locale=&#060;locale&#062; ...
</PRE>
<P>This qualifier is available only in the linux version, in windows the <A HREF="#-CODEPAGE">-Codepage</A> qualifier performs a similar function.</P>

<P>This sets the default locale for all buffers. Locale currently only affects the rendering of unicode characters. e.g:</P>

<PRE>
$jot $&#123;JOT_RESOURCES&#125;/t.t -locale=en_US.utf-8
</PRE>
<P>For linux the default locale is inherited from the shell env XTERM_LOCALE.</P>


</UL><H3><A NAME="-OBEY">-Obey</H3>
<PRE>
$ jot pathName -obey &#060;&#060; EndOfCommands ...
cmd1
cmd2
cmd3
EndOfCommands
</PRE>
<P>By default, when jot detects that stdin is not a keyboard, it is assumed to be a text stream to be picked up and processed in the primary buffer. In this case, however, it's a series of commands. The -obey qualifier identifies these as such</P>

<P>To push short sequences of in from the command line, the -init=&#060;...&#062; method is generally preferable.</P>

<P>Note that the last command in the -obey sequence *must* be %c or %a to terminate the editor session.</P>

<P>This option is really only useful in shell scripts in order to make the jot commands visible and accessible in the same context as the shell commands it interacts with. For an example look at Test 8 in $&#123;JOT_HOME&#125;/test.sh.</P>


</UL><H3><A NAME="-JOURNAL">-Journal</H3>
<PRE>
$ jot ... -journal ...
</PRE>
<P>This specifies a directory to hold the journal files. The journal files are used to recover your work following a crash. See <A HREF="#ABOUT JOURNAL FILES">About Journal Files</A> and <A HREF="jot_coms.html#RECOVER.JOT">recover.jot</A> for details.</P>


</UL><H3><A NAME="-QUIET">-Quiet</H3>
<PRE>
$ jot ... -quiet ...
</PRE>
<P>Suppresses all prompts and messages except for <A HREF="#P">P</A> commands. In -tty mode it also suppresses any indication of substrings and the current character.</P>


</UL><H3><A NAME="-SCREENSIZE">-SCreensize</H3>
<PRE>
$ jot ... -screensize=&#060;width&#062;x&#060;height&#062; ...
</PRE>
<P>Sets the screen size - only useful for non-curses environments where the editor can't determine the screen size for itself. The width is denominated in characters, height in lines.</P>


</UL><H3><A NAME="-STACKSIZE">-STACksize</H3>
<PRE>
$ jot ... -stacksize=&#060;n&#062; ...
</PRE>
<P>Sets the size of the operand stack to n. By default it is 100, if you need more then there's probably something gone badly wrong with your scripts.</P>


</UL><H3><A NAME="-HOLD">-HOld</H3>
<PRE>
$ jot ... -hold ...
</PRE>
<P>On exit, this holds the curses screen until any keyboard character is detected. This allows you see any messages generated by a script before the session finally terminates as you hit any key.</P>

<P>In windows, the windows console is not restored on exit so -hold just slows down your exit.</P>


</UL><H3><A NAME="-HISTORY">-History</H3>
<PRE>
$ jot ... -History=&#060;n&#062; ...
</PRE>
<P>Sets the size of the internal command-history buffer, by default it's set to to 20 lines. The first element of the history array is the current command, which must always exist. Hence you must specify a value in of 1 or more for this.</P>

<P>This buffer holds the last few typed-in commands. You cannot, at present, edit history directly but you can only view the contents of the history buffer with the %q&#060;buf&#062;=history command - see <A HREF="#QUERY HISTORY">query history</A>.</P>

<P>N.B. The size of this history buffer has no effect on the operation of the journal history - see <A HREF="#ABOUT JOURNAL FILES">about journal files</A>.</P>


</UL><H3><A NAME="-HELP">-Help</H3>
<PRE>
$ jot -help
</PRE>
<P>Displays a brief description of the jot CLI qualifiers and exits.</P>


</UL><H2><A NAME="INSTALLATION">Installation</H2>
<P>Start by downloading either jot_v&#060;version&#062;.tz or jot_v&#060;version&#062;.zip, whichever you fancy - both archives contain exactly the same files.</P>

<P>Before you can run the editor a certain amount of system-dependent setup may be necessary - see either <A HREF="#UNIX AND LINUX SETUP">unix and linux setup</A> or <A HREF="#MS-WINDOWS SETUP">ms-windows setup</A>.</P>

<P>These envs are referenced by either the main editor programme or the scripts:</P>

<UL><P><LI>JOT_HOME - points to the installation tree root</P></LI>

<P><LI>JOT_JOURNAL - if set then all sessions create a journal.</P></LI>

<P><LI>JOT_RESOURCES - used by some scripts (e.g. <A HREF="jot_coms.html#DIC.JOT">dic.jot</A>) to locate resources such as dictionaries, the startup script uses it to find a help-file tree. If this file exists $&#123;JOT_RESOURCES&#125;/help/help.hlp, then this is taken to be the root help entry.</P></LI>

</UL><P>Of these, the only essential one, for a working installation, is JOT_HOME, it uses this to locate the coms subdirectory (where it picks up scripts, including the all-important startup scripts). When JOT_RESOURCES is not defined, the startup script defaults it to $&#123;JOT_HOME&#125;/resources - the resources directory from the archive contains test, demonstration and training samples.</P>

<P>Typically jot will be started from the command line from an xterm (or a windows console) with a pathName argument, the editor takes over the screen and displays an image of the specified file. It also reads a setup script, by default $&#123;JOT_HOME&#125;/coms/startup.jot, this defines functions and the mapping of keyboard events to functions. To do this the JOT_HOME env must point to the correct point in the installation tree.</P>

<P>Also, if you have a shared jot installation then you may prefer to maintain your own $&#123;JOT_RESOURCES&#125; files. This is a collection of bits and pieces used by some jot scripts.</P>

<PRE>
JOT_HOME should point here --&#062;   v&#060;version&#062;                                  
                                     |                                    
                  ---------------------------------------------                  
                 |      |      |                  |            |                  
                bin    coms   releasenote.txt    resources    source                     
                 |      |                         |            |
                ...    ...                       ...          ...   
</PRE>
<P>In addition to files in the jot archives you may feel the need for one or more of the following:</P>

<UL><P><LI>Websters dictionary, useful for authors, available as a plain-text Ebook from the Gutenberg project - gutenberg.org</P></LI>

<P><LI>Roget's thesaurus, another must-have for authors, again it's available as an Ebook from Gutenberg.</P></LI>

<P><LI>aspell - a GNU spelling checker. This one was chosen because it has a command-driven interface, most of the others will only work via their GUI.</P></LI>

<P><LI>xls2csv - this can be downloaded from the sourceforge libxls project. It is used to convert Microsoft XL spreadsheets to plain text. For <A HREF="jot_coms.html#GET.JOT">get.jot</A> xls2csv is used in preference to tika as it allows individual sheets to be selected.</P></LI>

<P><LI>Apache Tika - this is a very useful format conversion utility. In particular it is used by <A HREF="jot_coms.html#GET.JOT">get.jot</A> to convert the following formats to plain text: MS-word, PDF and MS-XL - although xls2csv is the preferred converter for XL as this allows sheet selection. Tika requires a java installation.</P></LI>

<P><LI>iconv - a gnu unicode converter (see the GNU libiconv project), used by get.jot to convert the various other unicode formats to UTF-8 for display in jot.</P></LI>

<P><LI>Windows users will probably find life much easier with the UnixUtils toolset. Even if thy do not personally have any use for basic unix utilities like ls etc, many jot scripts are written assuming them to be available.</P></LI>

<P><LI>xsel - this little utility provides an interface to X-windows selections. This is used by <A HREF="jot_coms.html#COPY.JOT">copy.jot</A> and <A HREF="jot_coms.html#PASTE.JOT">paste.jot</A> to access the X-windows selection buffer.</P></LI>

<P>Although not always available by default, xsel is available as a download from your linux disto provider.</P>

<P>Windows users need not fret about xsel, windows does not support selections so you will have to use cut and paste instead.</P>

<P><LI>cabextract, used by get.jot to unpack these microsoft archives, it's available by default with most linux distributions.</P></LI>


</UL><H3><A NAME="UNIX AND LINUX SETUP">Unix and linux setup</H3>
<P>Wherever you decide to unpack the archive, JOT_HOME should be set to point at the v&#060;version&#062; directory. You will also need to set search path. In linux/bourne-shell:</P>

<PRE>
$ export JOT_HOME=/&#060;path&#062;/v&#060;version&#062;
$ export PATH=$&#123;JOT_HOME&#125;/bin/&#060;arch&#062;/;$&#123;PATH&#125;
</PRE>
<P>In order to minimize the number of statically-linked libraries in the linux version, the <A HREF="#%S=COPY">%s=copy</A> and <A HREF="#%S=PASTE">%s=paste</A>commands are not available with the linux executables supplied in the download. This deficiency can be corrected by recompiling with X11 enabled and, if necessary, installation of the X11 libs and header files.</P>

<P>If you have to recompile the jot executable, these commands should work, there may be a few _devl and sharable libraries to be installed:</P>

<PRE>
$ versionString="jot &#060;version&#062;, built `\date +%d/%m/%y\ %H:%M:%S` `\uname -nspr`  "
$ cc -D LINUX -g -Wall $&#123;JOT_HOME&#125;/source/jot.c -D_FILE_OFFSET_BITS=64 -D VERSION_STRING="\"$&#123;versionString&#125;\"" \
</PRE>
<UL><P>-lncursesw -lX11 -lXt -o $&#123;JOT_HOME&#125;/bin/&#060;arch&#062;/jot</P>

<PRE>
$ gcc -g source/jot.c -D VERSION_STRING="$&#123;versionString&#125;" -lncursesw -o bin/&#060;arch&#062;/jot
</PRE>
</UL><P>The linux executables supplied in the tarball were statically linked to the curses library, with cut and paste disabled by the noX11 flag, using a command similar to this:</P>

<PRE>
$ gcc -DLINUX -DnoX11 $debug -g -Wall source/jot.c \
</PRE>
<UL><P>-D_FILE_OFFSET_BITS=64 -D VERSION_STRING="\"$&#123;versionString&#125;\"" \ -Xlinker -dn -lncursesw -lncurses -Xlinker -dy -lgcc_s -o ed/bin/jot</P>

</UL><P>See also <A HREF="#X-WINDOWS SETUP">X-windows setup</A>.</P>

<P>To use the <A HREF="jot_coms.html#DOC.JOT">doc.jot</A> spelling check, you will need aspell on your search path.</P>


</UL><H4><A NAME="THINGS THAT MIGHT GO WRONG">Things that might go wrong</H4>
<UL><P><LI>bash: jot: command not found</P></LI>

<UL><P>Check your search path like this:</P>

<PRE>
$ echo $PATH
</PRE>
<P>You should see the path to the bin subdir in the colon-separated list it returns - if not check the following:</P>

<UL><P><LI>did you remember to start a new bash after setting up your .bashrc?</P></LI>

<P><LI>is the spelling and case pattern correct.</P></LI>

</UL><P>If the path is correct then check the binary is giving you execute permission:</P>

<PRE>
$ ls -l &#060;binPath&#062;/jot
</PRE>
<P>you should see something like this "-rwxr-xr-x" if you don't see the x characters then make it executable - like this:</P>

<PRE>
$ chmod ugo+x &#060;binPath&#062;/jot
</PRE>
</UL><P><LI>/lib64/libc.so.6: version 'GLIBC_2.17' not found </P></LI>

<UL><P>This is probably because you are using an old linux distribution. Try installing a newer glibc - either glibc.x86_64 or glibc.i686 for older 32-bit machines. Another approach would be to try recompiling the source, you will need various libraries including some _dev libs and a gcc - see the previous section for details of the gcc command.</P>

</UL><P><LI>Error opening terminal: &#060;termName&#062;.</P></LI>

<UL><P>Check your TERM env:</P>

<PRE>
$ echo $TERM
</PRE>
<P>Most distributions default it to "xterm" if it's something different, then try setting it to xterm like this:</P>

<PRE>
$ export TERM=xterm
</PRE>
<P>If that works out, and you have no reason to want it to be different, put that export line into ~/.bashrc so you don't have to keep on setting it in every new shell.</P>

<P>If, however, your TERM is set to xterm, then you've got a problem. Check your terminfos:</P>

<PRE>
$ ls -l /usr/share/terminfo/x/xterm*
</PRE>
<P>There will probably be several flavours of xterm to chose from - pick a likely looking one and export that one.</P>


</UL></UL><H4><A NAME="X-WINDOWS SETUP">X-windows setup</H4>
<P>The mapping of keyboard function keys is dependent on various elements of operating system and it's setup. This is done in several stages, ultimately, JOT picks up text characters, control codes and VT100-like escape sequences.</P>

<P>Jot is implemented using functions from the curses library - these provide a consistent mapping of most function keys to control codes which jot can map to your selected actions at setup time.</P>

<P>In addition to function keys and other keys supported by curses, jot will recognize vt220-like escape sequences generated in response to numeric-keypad actions. The mapping of these is not consistent and different installations may give different results. Use xev and xmodmap to define these mappings. See also <A HREF="jot_ug.html#KEYBOARD FUNCTIONS DEFINED AT STARTUP">Keyboard functions defined at startup</A></P>

<P>The jot setup assumes unique keycodes from the numeric keyboard, unfortunately, in the linux-curses environment, the numeric keypad keystrokes are indistinguishable from their twins in other sections of the keyboard. The windows version does not use curses and does not suffer from this problem. The solution for linux users, wanting to use their bean-counters keypad, is to redefine the numeric keyboard keys with xmodmap. e.g:</P>

<PRE>
$ xmodmap $&#123;JOT_RESOURCES&#125;/my_xmodmap
</PRE>
<P>This version of my_xmodmap works for PC keyboards:</P>

<PRE>
!! Make the numeric keypad keys unique.
keycode  63 = KP_Multiply
keycode  82 = KP_Subtract
keycode  86 = KP_Add
keycode  91 = KP_Decimal
keycode 108 = KP_Enter
keycode  79 = KP_7
keycode  80 = KP_8
keycode  81 = KP_9
keycode  83 = KP_4
keycode  84 = KP_5
keycode  85 = KP_6
keycode  87 = KP_1
keycode  88 = KP_2
keycode  89 = KP_3
keycode  90 = KP_0
</PRE>

</UL><H3><A NAME="MS-WINDOWS SETUP">MS-Windows setup</H3>
<P>Wherever you unpack the archive, JOT_HOME should be set to point at the v&#060;version&#062; directory. You will also need to set search path. System registry entries are the recommended method but, hey, life is short maybe this will be good enough for now:</P>

<PRE>
$ setx JOT_HOME=C:\&#060;unpackPath&#062;\v&#060;version&#062;\
$ set PATH=C:\&#060;unpackPath&#062;\v&#060;version&#062;n.m\bin\win32;%PATH%
</PRE>
<P>In windowsland it is most unlikely you will need to recompile, which is just as well since compiling just about anything in windowsland is going to be painful. If you have a working cl installation and libgcc and libgw32c gnu libraries (try sourceforge) then something like this might work:</P>

<PRE>
$ cl /c /DVC /D__value=_value /Zi /D_DEBUG /DVERSION_STRING="jot for WindowsNT v&#060;version&#062;" %JOT_HOME%\jot.c /Fojot.obj
$ link /debug /out:%JOT_HOME%/bin/jot.exe jot.obj ^
</PRE>
<UL><P>&#060;MSDKsPath&#062;\v7.1\Lib\*.Lib ^ &#060;gnuLibPath&#062;\libgw32c-0.4\lib\libgw32c.a ^ &#060;gnuLibPath&#062;\libgcc\lib\libgcc.lib</P>


</UL>
