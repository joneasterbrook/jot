                                Jot Evaluation
                                --------------

1 Text-editor evaluation and comparison
---------------------------------------
  This note compares jot to several popular text editors. See also
    https://en.wikipedia.org/wiki/Editor_war
  and
    https://en.wikipedia.org/wiki/Comparison_of_text_editors
  
  On my linux installation (a Fedora 27) the vi command launches a vim:
$ vi --version
VIM - Vi IMproved 8.0 (2016 Sep 12, compiled Oct  6 2017 15:20:00)
...
  
  The editors included in this comparison were:
    - jot v2.3.1
    - vim 8.0
    - gvim v8.0.1573
    - emacs 25.3.1
    - nano 2.8.7

1.1 Methodology
---------------
  The performance assessments were done on an otherwise idle  quad-core  Intel
  64-bit linux box the only other user processes running were top and vmstat:
$ uname -a
Linux localhost.localdomain 4.13.9-300.fc27.x86_64 #1 SMP Mon Oct 23 13:41:58 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
  
  For editors that allow commands to be entered via  the  CLI  (jot,  vim  and
  gvim) this method was used as it avoids including the time taken  to  fumble
  with the mouse and keyboard.
  
  emacs has a non-interactive mode - not really quite the  same  thing  as  an
  interactive editor that allows initialization commands from the command line
  and we're trying to compare like with like. Anyway, most tests  include  two
  results for emacs - one for a non-interactive lisp script  and  another  for
  normal interactive mode. In some cases the lisp-script version  was  several
  orders of magnitude faster - far more than could be  explained  away  by  my
  slow typing or the requirement to update the screen. The lisp-script version
  gives the impression of being an entirely different editor.
  
  The vim installation  came  out  of  the  box  with  my  linux  (Fedora  27)
  masquerading as vi, the gvim and  emacs  were  the  default  downloads  from
  Fedora, nano was also out of the box.
  
  In general, for quick-running tests (anything under  about  2  minutes)  the
  test was repeated and the quoted results are for the best of three. The only
  exceptions were the image-activation tests. For these, in order to clear the
  cache and swap files, the computer was restarted and each editor  was  fired
  up only once. In the case of emacs, the system was restarted for each case.
  
  Any test run that dragged on for more than 30 minutes was killed.
  
  I used GNU time 1.7 - this has the option to collect other performance  data
  - although this additional data was not as significant as  the  elapsed-time
  result, it gives some insight into what was going  on  for  under-performing
  tests.
  
  Both jot and nano are, by default case insensitive  whereas  vim,  gvim  and
  emacs are case sensitive. Case sensitive searches are simpler and one  would
  expect them to run a little faster. All jot runs include a command  to  make
  searches case sensitive.
  
  The values in the `text density` section were obtained from the RSS field of
  the time reports in the `Loading a  big  file`  section.  The  numbers  were
  verified using /usr/bin/pmap which gave roughly the same results.
  
  In all cases the session was abandoned without writing back  to  the  filing
  system.

1.2 Image size
--------------
  The image sizes refer to the  executable-image  size  for  the  most  recent
  linux-64 versions. This just looks at the size of the  main  image,  in  the
  case of emacs, after following links, then ls -l.
    - jot     521216
      The stripped version with dynamically-linked ncurses is 191512
    - vim    1102216
    - gvim   3320904
    - emacs 16913736
    - nano    239944
    
  Of course image size depends on how the image is linked. All are dynamically
  linked to /usr/lib64 libraries, interestingly, while jot, gvim and nano link
  to the gnu ncurses lib, vim and emacs seem to make their  own  arrangements.
  Yet, strangely, gvim uses ncurses and it's a much bigger image than vim.

1.3 Image activation time
-------------------------
  The elapsed time is not particularly reliable in the case of emacs and nano,
  since these do not seem to offer any options to enter editor  commands  from
  the command line. For nano and emacs the session was  quickly  closed  using
  interactive commands.
  
    - jot 
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot t.t -in="%a"
	  0:00.14 elapsed, 0.01 user, 0.00 system, 10% CPU, (3 major + 347 minor) faults, 1520 io, 3892 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi t.t -c:q
	  0:00.05 elapsed, 0.00 user, 0.00 system, 5% CPU, (8 major + 206 minor) faults, 2160 io, 4064 rss
  
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim t.t -v -c:q
	  0:00.29 elapsed, 0.02 user, 0.01 system, 14% CPU, (26 major + 1411 minor) faults, 7488 io, 18556 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs -nw t.t
  - {Ctrl+x}{Ctrl+c}
	  0:02.96 elapsed, 0.09 user, 0.04 system, 4% CPU, (216 major + 4175 minor) faults, 69840 io, 50212 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "t.t")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	  0:02.01 elapsed, 0.09 user, 0.04 system, 6% CPU, (211 major + 3049 minor) faults, 67808 io, 48396 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano t.t
	  0:00.51 elapsed, 0.02 user, 0.00 system, 5% CPU, (2 major + 715 minor) faults, 9328 io, 9220 rss

1.4 Loading a big file
----------------------
  A sample file was created by jot using these commands:
$ rm big_file.txt
$ jot /dev/null -in="%eq=ls -RF /usr/lib64; %r=ls2list; \
  ol1000000000 m-0((%i.='q -binary 64; i'qbr0b %o=big_file.txt -append;, ) %q$=file big_file.txt; f/ size = /-oid o> zqm)0"
  
  It turns out that the actual file size was 1000679059. It contained 75300980
  instances of the string "00" and 20422442 instances of the string "99".
  
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in=%a
	0:03.47 elapsed, 2.01 user, 1.05 system, 88% CPU, (8 major + 638535 minor) faults, 98216 io, 2556520 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c:q
	0:07.44 elapsed, 3.87 user, 0.81 system, 62% CPU, 23 faults, 795248 io, 1251080 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c:q
	0:04.13 elapsed, 3.43 user, 0.62 system, 98% CPU, 0 faults, 680 io, 1265032 rss
   
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
  - y - Yes I really do want to read a big file.
  - {Ctrl+x}{Ctrl+c}
	0:05.19 elapsed, 3.55 user, 0.53 system, 78% CPU, (2 major + 276771 minor) faults, 104 io, 1149140 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_file.txt")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	0:03.73 elapsed, 3.23 user, 0.49 system, 99% CPU, (0 major + 272060 minor) faults, 0 io, 1123744 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
   {Ctrl+x}  - to exit.
	0:37.28 elapsed, 36.16 user, 0.90 system, 99% CPU, 5 faults, 9880 io, 2459268 rss

1.5 Loading a different big file
--------------------------------
  The  file   used   here   was   downloaded   from   the   Federal   Election
  Commission   -   â€‹https://www.fec.gov/files/bulk-downloads/2018/indiv18.zip)
  It's a big (about 4.3Gb) tabular database  organized  as  about  22  million
  lines of 20 columns separated by vertical bars ( | ).
  
  - jot 
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot itcont.txt -in=%a;
  3:21.39 elapsed, 7.11 user, 9.46 system, 8% CPU, (69 major + 1484465 minor) faults, 8373136 io, 3482732 rss
  
  - vi
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi itcont.txt  -c:q
  1:31.11 elapsed, 17.21 user, 7.03 system, 26% CPU, (24 major + 501048 minor) faults, 8368824 io, 2007368 rss
    
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs itcont.txt
  13:27.35 elapsed, 53.08 user, 28.72 system, 10% CPU, (369813 major + 6757217 minor) faults, 31983928 io, 3532996 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "itcont.txt")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
  5:24.25 elapsed, 19.67 user, 17.98 system, 11% CPU, (245186 major + 3795275 minor) faults, 24057320 io, 3540768 rss  
  
  -nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano itcont.txt
  11:37.87 elapsed, 161.20 user, 27.00 system, 26% CPU, (522701 major + 5100756 minor) faults, 41607872 io, 3535936 rss
  

1.6 Text density
----------------
  See `methodology` notes.
  
  - jot -   2556520 2.556520
  
  - vim -   1251080 1.251080
  
  - gvim -  1265032 1.265032
   
  - emacs - 1149140 1.149140  (interactive)
  
  - emacs - 1123744 1.123744 (.el-lisp script)
  
  - nano -  2459268 2.459268

1.7 Loading a big file and searching forwards
---------------------------------------------
  The big_file.txt is loaded again and this time each editor is set to  search
  the entire file for a nonexistent string.
  
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="%s=case 1; f/zzz/? %a"
	0:09.27 elapsed, 6.35 user, 1.21 system, 81% CPU, (10 major + 638534 minor) faults, 740488 io, 2556728 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c/zzz/ +:q
	0:18.72 elapsed, 14.49 user, 1.29 system, 84% CPU, 19 faults, 820568 io, 1251312 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c/zzz/ +:q
	0:09.31 elapsed, 8.59 user, 0.70 system, 99% CPU, (0 major + 313416 minor) faults, 0 io, 1265224 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
  - y - Yes I really do want to read a big file.
  - {Ctrl+s}zzz{Return}
  - {Ctrl+x}{Ctrl+c}
	0:12.98 elapsed, 10.48 user, 0.53 system, 84% CPU, (0 major + 277001 minor) faults, 16 io, 1150076 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_file.txt")
(search-forwards "zzz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	0:03.71 elapsed, 3.20 user, 0.49 system, 99% CPU, (0 major + 272229 minor) faults, 0 io, 1124272 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
  - {Ctrl+w}zzz
  - {Ctrl+x}
	2:18.92 elapsed, 135.42 user, 0.93 system, 98% CPU, 0 faults, 159784 io, 2459172 rss

1.8 Loading a big file and doing a global search and replace - 1
----------------------------------------------------------------
  In this case the replacement string is the same length as the  original.  My
  big_file.txt had 96860652 instances if the search string "00".
  
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="%s=case 1; (f/00/s/zz/)0 %a"
	0:22.67 elapsed, 20.38 user, 1.14 system, 94% CPU, (7 major + 638536 minor) faults, 462272 io, 2556464 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c:%s/00/zz/g +:q!
	0:54.96 elapsed, 34.97 user, 3.83 system, 70% CPU, 4606 faults, 957048 io, 3552576 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c:%s/00/zz/g +:q!
	1:19.04 elapsed, 39.14 user, 3.79 system, 54% CPU, 5426 faults, 2421776 io, 3583744 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
  - y - Yes I really want to open a big file.
  - {Alt+x}replace-string{Return}00{Return}zz{Return}
  - {Ctrl+x}{Ctrl+c}
  - n - I don't want the file image writing out.
  - yes{Return} - I still don't want the file image writing and I still want to get out of emacs.
	17:06.93 elapsed, 1002.50 user, 1.98 system, 97% CPU, (2 major + 816832 minor) faults, 480 io, 1181416 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_file.txt")
(replace-string "00" "zz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	15:14.29 elapsed, 910.98 user, 0.79 system, 99% CPU, (0 major + 283041 minor) faults, 56 io, 1143092 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
  - {Ctrl+\}00{Return}zz{Return}a{Return}
  - After about 10 minutes it crashed my linux session.

1.9 Loading a big file and doing a global search and replace - 2
----------------------------------------------------------------
  In this case the replacement string is the longer than the original. This is
  an important difference since our editors must somehow shuffle the text  and
  allocate more memory for the extended lines.
  
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="%s=case 1; (f/00/s/abcdefghi/)0 %a"
	0:34.34 elapsed, 30.26 user, 1.77 system, 93% CPU, (31 major + 943014 minor) faults, 384776 io, 3559384 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c:%s/00/abcdefghi/g +:q!
	12:36.20 elapsed, 78.23 user, 13.76 system, 12% CPU, (46370 major + 1311186 minor) faults, 6721408 io, 3531524 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c:%s/00/abcdefghi/g +:q!
	17:49.37 elapsed, 607.37 user, 16.02 system, 58% CPU, (66980 major + 1694965 minor) faults, 8311200 io, 3542908 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
  - y - Yes I really want to open a big file.
  - {Alt+x}replace-string{Return}00{Return}zz{Return}
  - {Ctrl+x}{Ctrl+c}
  - n - I don't want the file image writing out.
  - yes{Return} - I still don't want the file image writing and I still want to get out of emacs.
	17:06.93 elapsed, 1002.50 user, 1.98 system, 97% CPU, (2 major + 816832 minor) faults, 480 io, 1181416 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_file.txt")
(replace-string "00" "abcdefghi")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	20:55.74 elapsed, 1165.36 user, 2.45 system, 92% CPU, (396 major + 814215 minor) faults, 2255032 io, 1185052 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt  
  - {Ctrl+\}00{Return}abcdefghi{Return}a{Return}
  - As before, after a few minutes it crashed my linux session.

1.10 Loading a big file and doing a global regex-search and replace
------------------------------------------------------------------
  
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="(%f=[^a-zA-Z0-9]00[^a-zA-Z0-9];s/ zz /)0 %a;"
	14:01.91 elapsed, 834.67 user, 1.59 system, 99% CPU, (2 major + 695160 minor) faults, 1353128 io, 2783112 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c":%s/[^a-zA-Z0-9]00[^a-zA-Z0-9]/ zz /g" +:q!
	2:35.86 elapsed, 110.08 user, 34.62 system, 92% CPU, (2742 major + 932154 minor) faults, 146392 io, 3551876 rss
   
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c":%s/[^a-zA-Z0-9]00[^a-zA-Z0-9]/ zz /g" +:q!
	2:41.29 elapsed, 119.19 user, 18.48 system, 85% CPU, (2176 major + 969954 minor) faults, 2273216 io, 3569676 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
  - y - Yes I really want to open a big file.
  - {Alt+x}replace-string{Return}00{Return}zz{Return}
  - {Ctrl+x}{Ctrl+c}
  - n - I don't want the file image writing out.
  - yes{Return} - I still don't want the file image writing and I still want to get out of emacs.
	17:06.93 elapsed, 1002.50 user, 1.98 system, 97% CPU, (2 major + 816832 minor) faults, 480 io, 1181416 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_file.txt")
(replace-regexp "[^a-zA-Z0-9]00[^a-zA-Z0-9]" " zz ")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	10:13.22 elapsed, 610.94 user, 0.60 system, 99% CPU, (1 major + 282484 minor) faults, 280 io, 1140232 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt  
  nano was excluded from this test.

1.11 Loading a file and moving right to the end
----------------------------------------------
  The only reason for doing this is to obtain an accurate measurement  of  the
  reverse-search time.
  
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="m0 %a"
	0:06.55 elapsed, 3.04 user, 1.34 system, 67% CPU, (3 major + 695168 minor) faults, 628648 io, 2782912 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c:G +:q!
	0:08.26 elapsed, 4.16 user, 0.89 system, 61% CPU, (8 major + 312040 minor) faults, 1083528 io, 1251204 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim -v big_file.txt -c:G +:q!
	0:04.08 elapsed, 3.44 user, 0.60 system, 99% CPU, (0 major + 313412 minor) faults, 8 io, 1265332 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
  - y - Yes I really do want to read a big file.
  - {Esc >}
  - {Ctrl+x}{Ctrl+c}
	0:29.68 elapsed, 20.23 user, 0.54 system, 70% CPU, (0 major + 276972 minor) faults, 0 io, 1149696 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_file.txt")
(goto-char (point-max))
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	0:03.72 elapsed, 3.19 user, 0.49 system, 99% CPU, (0 major + 272082 minor) faults, 0 io, 1124112 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
   {Ctrl+_}{Ctrl+v}{Ctrl+x}
	0:33.93 elapsed, 33.05 user, 0.83 system, 99% CPU, (0 major + 563730 minor) faults, 0 io, 2261060 rss

1.12 Loading a file, moving right to the end then searching back
---------------------------------------------------------------
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="%s=case 1; m0 f-/zzz/? %a"
	0:07.17 elapsed, 6.15 user, 0.99 system, 99% CPU, (0 major + 638540 minor) faults, 0 io, 2556580 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt -c:G +?zzz? +:q!
	0:12.28 elapsed, 8.50 user, 0.98 system, 77% CPU, (21 major + 312038 minor) faults, 752872 io, 1251380 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v -c:G +?zzz? +:q!
	0:10.61 elapsed, 8.15 user, 0.72 system, 83% CPU, (128 major + 313414 minor) faults, 29304 io, 1264924 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
  - y - Yes I really do want to read a big file.
  - {Esc >}
  - {Ctrl+r}zzz
  - {Ctrl+x}{Ctrl+c}
	0:29.68 elapsed, 20.23 user, 0.54 system, 70% CPU, (0 major + 276972 minor) faults, 0 io, 1149696 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_file.txt")
(goto-char (point-max))
(search-backward "zzz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	0:04.97 elapsed, 4.46 user, 0.49 system, 99% CPU, (0 major + 272229 minor) faults, 0 io, 1124180 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
  - {Ctrl+_}{Ctrl+v}
  - {Alt+b}
  - {F6}zzz{Return}
  - {Ctrl+x}
	2:26.64 elapsed, 135.73 user, 0.93 system, 93% CPU, (5 major + 613280 minor) faults, 147232 io, 2459312 rss

1.13 Loading, cutting and pasting and pasting all of a big file
---------------------------------------------------------------
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_file.txt -in="n.m0aaha %a;"
	0:35.42 elapsed, 6.35 user, 3.44 system, 27% CPU, (43 major + 1276767 minor) faults, 1960328 io, 3578088 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_file.txt
    - v - enter visual-selection mode.
    - G{Return} - goto end of file
    - d - cut all the highlighted text.
    - P - paste it all back again.
    - :q!
	1:57.08 elapsed, 14.33 user, 5.97 system, 17% CPU, (94996 major + 1804828 minor) faults, 6984168 io, 3578132 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_file.txt -v
    - v - enter visual-selection mode.
    - G{Return} - goto end of file
    - d - cut all the highlighted text.
    - P - paste it all back again.
    - :q!
	8:42.73 elapsed, 19.09 user, 16.60 system, 6% CPU, (248435 major + 3119208 minor) faults, 12886392 io, 3553940 rss
   
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_file.txt
  - y - Yes I really do want to read a big file.
  - {Ctrl+@} - to set a mark.
  - {Esc >} - goto end
  - {Ctrl+w} - Cut
  - (Ctrl+y} - Paste it back again.
  - {Ctrl+x}{Ctrl+c}
  - n -  no I don't want to write the file
  - yes{Return} - let me out.
	2:07.87 elapsed, 16.30 user, 6.12 system, 17% CPU, (33165 major + 1471901 minor) faults, 4204560 io, 3556208 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_file.txt")
(kill-region 1 (point-max))
(yank)
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	0:09.22 elapsed, 3.39 user, 1.07 system, 48% CPU, (144 major + 497113 minor) faults, 980416 io, 2021192 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_file.txt
   - {Ctrl+^} - to set a mark.
   - {Alt+/} - move to end
   - {Ctrl+Shift+k} - to cut
   - {Ctrl+Shift+u} - to paste
   - {Ctrl+x}  - to exit.
  Crashed the linux session after about 5 minutes.

1.14 Loading a file with very long lines - a fat file
-----------------------------------------------------
  A file of just over 100MB was created with these command:
$ rm fat_file.txt
$ jot /dev/null -in="%eq=ls -RF /usr/lib64; %r=ls2list; \
  ol100000000 m-0((%i.='q -binary 64; (m-0(jm)0m-)0 r-0i'qbr0b %o=fat_file.txt -append;, ) %q$=file fat_file.txt; f/ size = /-oid o> zqm)0"
  
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot fat_file.txt -in=%a
	0:00.32 elapsed, 0.26 user, 0.06 system, 99% CPU, (0 major + 33337 minor) faults, 0 io, 131980 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi fat_file.txt -c:q
	0:04.54 elapsed, 3.07 user, 1.41 system, 98% CPU, (8 major + 1405333 minor) faults, 2160 io, 116448 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim fat_file.txt -v -c:q
	0:04.66 elapsed, 3.17 user, 1.46 system, 99% CPU, (0 major + 1410216 minor) faults, 0 io, 143440 rss
   
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs fat_file.txt
  - y - Yes I really do want to read a big file.
  - {Ctrl+x}{Ctrl+c}
	0:03.10 elapsed, 0.36 user, 0.09 system, 14% CPU, (265 major + 27970 minor) faults, 75000 io, 147784 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "fat_file.txt")
(search-forwards "zzz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	0:00.41 elapsed, 0.35 user, 0.06 system, 99% CPU, (0 major + 28152 minor) faults, 0 io, 148308 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano fat_file.txt
  - {Ctrl+x}  - to exit.
	0:04.43 elapsed, 4.21 user, 0.08 system, 97% CPU, (1 major + 51042 minor) faults, 8856 io, 186912 rss

1.15 Loading a fat file and searching
------------------------------------
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot fat_file.txt -in="%s=case 1; f/zzz/? %a;"
	0:00.67 elapsed, 0.59 user, 0.07 system, 99% CPU, (0 major + 33007 minor) faults, 0 io, 131864 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi fat_file.txt -c/zzz/ +:q
	0:11.55 elapsed, 6.76 user, 4.75 system, 99% CPU, (0 major + 4755463 minor) faults, 0 io, 219552 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim fat_file.txt -v -c/zzz/ +:q
	0:11.80 elapsed, 6.99 user, 4.76 system, 99% CPU, (0 major + 4781384 minor) faults, 0 io, 232112 rss
   
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs fat_file.txt
  - y - Yes I really do want to read a big file.
  - {Ctrl+s}zzz{Return}
  - {Ctrl+x}{Ctrl+c}
	0:06.58 elapsed, 1.29 user, 0.09 system, 21% CPU, (0 major + 32913 minor) faults, 0 io, 174632 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "fat_file.txt")
(search-forwards "zzz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	0:00.40 elapsed, 0.35 user, 0.05 system, 99% CPU, (0 major + 28144 minor) faults, 0 io, 148224 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano fat_file.txt
  - {Ctrl+w}zzz
  - {Ctrl+x}  - to exit.
	0:21.73 elapsed, 16.65 user, 0.10 system, 77% CPU, (0 major + 51012 minor) faults, 0 io, 186892 rss

1.16 Loading a fat file and and doing a global search and replace - 1
---------------------------------------------------------------------
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot fat_file.txt -in="%s=case 1; (f/00/s/zz/)0 %a"
	0:02.28 elapsed, 2.20 user, 0.07 system, 99% CPU, (0 major + 33010 minor) faults, 0 io, 131984 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi fat_file.txt -c:%s/00/zz/g +:q!
Killed at  30:56.24 elapsed, 1836.23 user, 1.51 system, 99% CPU, (0 major + 1427388 minor) faults, 0 io, 158044 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim fat_file.txt -v -c:%s/00/zz/g +:q!
Killed at   30:28.54 elapsed, 1807.12 user, 1.75 system, 98% CPU, (26 major + 1416782 minor) faults, 8008 io, 170140 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs fat_file.txt
  - y - Yes I really want to open a big file.
  - {Alt+x}replace-string{Return}00{Return}zz{Return}
Killed at   34:30.12 elapsed, 2016.00 user, 0.64 system, 97% CPU, (4 major + 86817 minor) faults, 199328 io, 204116 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "fat_file.txt")
(replace-string "00" "zz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	1:32.63 elapsed, 92.22 user, 0.09 system, 99% CPU, (0 major + 33939 minor) faults, 0 io, 167012 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano fat_file.txt
  - {Ctrl+\}00{Return}zz{Return}a{Return}
  - {Ctrl+x}
Crashed at 7:32.92 elapsed, 403.85 user, 2.40 system, 89% CPU, (149 major + 1840211 minor) faults, 37648 io, 3579632 rss

1.17 Loading a fat file and and doing a global search and replace - 2
---------------------------------------------------------------------
  This time the substitute string is a bit longer than the  original  but,  to
  make it a  bit  easier  for  our  editors,  they're  searching  for  a  less
  commonly-occurring string "99" instead of "00" as before.
  
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot fat_file.txt -in="%s=case 1; (f/99/s/abcdefghi/)0 %a"
	1:29.93 elapsed, 89.09 user, 0.10 system, 99% CPU, (0 major + 53370 minor) faults, 0 io, 152272 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi fat_file.txt -c:%s/99/abcdefghi/g +:q!
	2:16.07 elapsed, 129.89 user, 4.91 system, 99% CPU, (0 major + 4827378 minor) faults, 0 io, 457824 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim fat_file.txt -v -c:%s/99/abcdefghi/g +:q!
	2:17.18 elapsed, 131.03 user, 4.89 system, 99% CPU, (0 major + 4853298 minor) faults, 0 io, 470248 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs fat_file.txt
  - y - Yes I really want to open a big file.
  - {Alt+x}replace-string{Return}99{Return}zz{Return}
  - {Ctrl+x}{Ctrl+c}
  - n - I don't want the file image writing out.
  - yes{Return} - I still don't want the file image writing and I still want to get out of emacs.
	0:59.38 elapsed, 12.12 user, 0.27 system, 20% CPU, (113 major + 80831 minor) faults, 31176 io, 188152 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "fat_file.txt")
(replace-string "99" "abcdefghi")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	0:07.65 elapsed, 7.11 user, 0.49 system, 99% CPU, (0 major + 276715 minor) faults, 32 io, 1139720 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano fat_file.txt
  - {Ctrl+\}99{Return}abcdefghi{Return}a{Return}
  - {Ctrl+x}
	6:56.64 elapsed, 396.59 user, 2.41 system, 95% CPU, (715 major + 1841675 minor) faults, 377632 io, 3588260 rss

1.18 Loading a big fat file - big_fat_file.txt
----------------------------------------------
  A file of just over 1GB was created with these commands:
$ rm big_fat_file.txt
$ jot /dev/null -in="%eq=ls -RF /usr/lib64; %r=ls2list; \
  ol1000000000 m-0((%i.='q -binary 64; (m-0(jm)0m-)0 r-0i'qbr0b %o=big_fat_file.txt -append;, ) %q$=file big_fat_file.txt; f/ size = /-oid o> zqm)0"
  
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_fat_file.txt -in=%a
	0:01.16 elapsed, 0.55 user, 0.59 system, 99% CPU, (0 major + 271742 minor) faults, 0 io, 1020488 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_fat_file.txt -c:q
	0:19.97 elapsed, 16.87 user, 3.00 system, 99% CPU, (0 major + 2575870 minor) faults, 0 io, 1008944 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_fat_file.txt -v -c:q
	0:20.20 elapsed, 17.04 user, 3.06 system, 99% CPU, (0 major + 2581583 minor) faults, 0 io, 1039776 rss
   
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_fat_file.txt
  - y - Yes I really do want to read a big file.
  - {Ctrl+x}{Ctrl+c}
	0:05.18 elapsed, 3.16 user, 0.50 system, 70% CPU, (0 major + 254962 minor) faults, 0 io, 1059484 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_fat_file.txt")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	0:03.24 elapsed, 2.78 user, 0.44 system, 99% CPU, (0 major + 250083 minor) faults, 0 io, 1036432 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_fat_file.txt
  - {Ctrl+x}  - to exit.
	0:33.70 elapsed, 32.99 user, 0.46 system, 99% CPU, (3 major + 259449 minor) faults, 10352 io, 1020272 rss

1.19 Loading a big fat file and searching
-----------------------------------------
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_fat_file.txt -in="%s=case 1; f/zzz/? %a;"
	0:04.56 elapsed, 3.93 user, 0.61 system, 99% CPU, (0 major + 271744 minor) faults, 0 io, 1020440 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_fat_file.txt -c/zzz/ +:q
	0:25.80 elapsed, 22.77 user, 2.91 system, 99% CPU, (0 major + 2575873 minor) faults, 8 io, 1008952 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_fat_file.txt -v -c/zzz/ +:q
	0:25.86 elapsed, 22.69 user, 3.06 system, 99% CPU, (0 major + 2581579 minor) faults, 0 io, 1039444 rss
   
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_fat_file.txt
  - y - Yes I really want to open a big file.
  - {Ctrl+s}zzz{Return}
  - {Ctrl+x}{Ctrl+c}
	0:12.58 elapsed, 10.26 user, 0.47 system, 85% CPU, (0 major + 254895 minor) faults, 0 io, 1062112 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_fat_file.txt
  - y - Yes I really do want to read a big file.
  - {Ctrl+s}zzz{Return}
  - {Ctrl+x}{Ctrl+c}
	0:11.01 elapsed, 9.07 user, 0.49 system, 86% CPU, (0 major + 254816 minor) faults, 0 io, 1060732 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_fat_file.txt")
(search-forwards "zzz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	0:03.25 elapsed, 2.80 user, 0.44 system, 99% CPU, (0 major + 250268 minor) faults, 0 io, 1036408 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_fat_file.txt
  - {Ctrl+w}zzz
  - {Ctrl+x}  - to exit.
	2:07.22 elapsed, 125.34 user, 0.48 system, 98% CPU, (0 major + 259416 minor) faults, 0 io, 1020316 rss

1.20 Loading a big fat file and and doing a global search and replace - 1
-------------------------------------------------------------------------
  None of the editors performed particularly well  at  this  test  -  to  make
  things easier for them the search string was changed from "00" to  the  less
  commonly-occurring "99"
  
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_fat_file.txt -in="%s=case 1; (f/99/s/zz/)0 %a"
	0:04.87 elapsed, 4.21 user, 0.65 system, 99% CPU, (0 major + 271743 minor) faults, 0 io, 1020448 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_fat_file.txt -c:%s/99/zz/g +:q!
	5:21.72 elapsed, 315.29 user, 3.45 system, 99% CPU, (0 major + 2868852 minor) faults, 0 io, 1980576 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_fat_file.txt -v -c:%s/99/zz/g +:q!
	5:22.95 elapsed, 313.89 user, 3.78 system, 98% CPU, (27 major + 2869893 minor) faults, 1971856 io, 1992508 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_fat_file.txt
  - y - Yes I really want to open a big file.
  - {Alt+x}replace-string{Return}99{Return}zz{Return}
  - {Ctrl+x}{Ctrl+c}
  - n - No I don't want the file writing out.
  - yes{Return} - I still don't want the file image writing and I still want to get out.
	2:17.23 elapsed, 118.42 user, 1.55 system, 87% CPU, (0 major + 504104 minor) faults, 0 io, 1083284 rss
 
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_fat_file.txt")
(replace-string "99" "zz")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
	0:09.79 elapsed, 6.20 user, 0.50 system, 68% CPU, (339 major + 254609 minor) faults, 86936 io, 1052068 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_fat_file.txt
  - {Ctrl+\}99{Return}zz{Return}a{Return}
  - {Ctrl+x}
  This seems to have crashed at 13:43.55 elapsed, 596.73 user, 210.35 system, 98% CPU, (4 major + 194487152 minor) faults, 1966208 io, 1051672 rss

1.21 Loading a big fat file and and doing a global search and replace - 2
-------------------------------------------------------------------------
  This time the substitute string is a bit longer than the original.
  
  - jot
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" jot big_fat_file.txt -in="%s=case 1; (f/99/s/abcdefghi/)0 %a"
	13:19.73 elapsed, 586.50 user, 206.95 system, 99% CPU, (0 major + 194487229 minor) faults, 0 io, 1051324 rss
  
  - vim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" vi big_fat_file.txt -c:%s/99/abcdefghi/g +:q!
	6:07.71 elapsed, 343.47 user, 20.50 system, 98% CPU, (8 major + 18713246 minor) faults, 2440 io, 2004156 rss
  
  - gvim
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" gvim big_fat_file.txt -v -c:%s/99/abcdefghi/g +:q!
	6:08.00 elapsed, 343.71 user, 20.07 system, 98% CPU, (26 major + 18714702 minor) faults, 7472 io, 2017948 rss
  
  - emacs (interactive)
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs big_fat_file.txt
  - y - Yes I really want to open a big file.
  - {Alt+x}replace-string{Return}99{Return}abcdefghi{Return}
Gave up - out of memory  2:24.20 elapsed, 123.52 user, 1.83 system, 86% CPU, (1 major + 752843 minor) faults, 168 io, 1102836 rss
  
  - emacs (.el-lisp script)
$ cat - > x.el << end-of-lisp
(insert-file-contents "big_fat_file.txt")
(replace-string "99" "abcdefghi")
end-of-lisp
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" emacs --script x.el
Gave up, out of memory at   1:04.16 elapsed, 15.53 user, 5.05 system, 32% CPU, (1020 major + 2732208 minor) faults, 103768 io, 3551296 rss
  
  - nano
$ /usr/bin/time -f "  %E elapsed, %U user, %S system, %P CPU, (%F major + %R minor) faults, %I io, %M rss" nano big_fat_file.txt
  - {Ctrl+\}99{Return}abcdefghi{Return}a{Return}
  - {Ctrl+x}
  Crashed after 5:40.93

1.22 Analysis of performance comparison.
----------------------------------------
  - `Image size` No-one, well no-one that's anyone, er.  well  hardly  anyone,
    frets about the size of executables in this day and age but,  if  it  were
    important, then jot would win hands down. All the other images  have  been
    stripped (symbolic  debugging  data  removed)  so,  in  the  interests  of
    comparing like with like, the size of a stripped jot  with  links  to  the
    sharable ncurses libraries has been  included.  A  non-stripped  jot  with
    shared curses was used in the performance comparisons.
    
  - `Image  activation  time`  While  there  was   some   variation   in   the
    image-activation times, the  biggest  surprise  was  nano  -  one  of  the
    smallest executables but much slower than vim  and  gvim.  Even,  so  this
    makes no real difference to the price of eggs.  The  biggest  non-surprise
    was that emacs took considerably longer than all the others put together.
    
  - `Loading a big file` To asses  the  reading  speed  which,  for  practical
    purposes includes the time taken to build the internal image structure,  a
    fairly large  file  (about  1Gb)  was  used.  Most  of  our  editors  were
    reasonably quick,  although  nano  is  just  starting  to  look  like  the
    two-ounce weakling of the group.
    
  - `Text density` This shows that the vims and emacs  have  compact  internal
    data structures. This, in turn, suggests, that for any given system,  they
    should capable of swallowing much bigger files. The actual  capacity,  for
    any given system, depends on system tuning. Meanwhile jot  and  nano  have
    about half the data density and we'd expect them to  reach  system-defined
    limits with files roughly half the size of the vims and emacs. On  my  PC,
    vim and emacs can (eventually) load a 5GB file and jot and nano can not.
    
    Jot's internal record structure facilitates  jot  tags,  hashtable  jumps,
    sorting and various other useful features including support for files  too
    big for vim to swallow. Yet the fact remains - vim can load 10GB files and
    jot can not.
    
  - `Loading a big file and searching forwards`  Now  we  start  to  do
    something with our file image, search it for something, in  this  case,  we
    see a continuation of the trend established in the previous batch of tasks
    - namely that nano struggles with big files. The rest of  our  interactive
    editors all performed reasonably well, the non-interactive emacs being the
    star performer.
    
  - `Loading a big file and doing a global search and replace - 1` While  both
    vim and emacs each have a built-in function for doing  global  search  and
    replace. It would seem reasonable to expect these to  outperform  the  jot
    interpretive  approach  -  which  essentially  consists  of   find-string,
    replace-string and repeat to exhaustion. So how surprising was it that jot
    came an easy first in this task - by a country mile, in the case of emacs.
    Poor old nano, unfortunately, fell by the wayside.
    
  - `Loading a big file and doing a global search and  replace  -  2`  In  the
    previous task, the substituted string was the same length  as  the  search
    string. This is not always the case, when the text shrinks or grows,  text
    may have  to  be  shifted,  depending  on  the  internal  data  structure.
    Furthermore, allowing the text to grow implies that more  memory  must  be
    allocated and efficiently deployed. The next task is designed to sort  the
    men from the boys. This time vim, gvim and  emacs  were  all  more-or-less
    comparable with jot an order of magnitude faster and, oh dear! nano...
    
  - `Loading a big file and doing a  global  regex-search  and  replace`  This
    shows that jot's regular-expression engine is far less speedy than  vim's.
    The non-interactive emacs managed to finish well ahead of the  interactive
    version both emacs times being comparable to jot's.
    
  - `Loading a file, moving right to the end then searching back` It could  be
    that backwards-searching performs differently to forwards searching - thes
    results should be compared to the earlier section `Loading a big file  and
    searching forwards`. Interestingly, emacs was much slower in reverse,  the
    other editors were pretty much the same in either direction.
    
  - `Loading a file with very long lines - a fat file` Long lines can  present
    special difficulties for  editors.  All  of  our  editors  swallowed  this
    moderately large file (100MB) in good time.
    
  - `Loading a fat file and searching` -  All  of  the  editors  did  this  in
    reasonably good time although, some, less-so than others.
    
  - `Loading a fat file and and doing a global search and  replace  -  1`  for
    this task, our editors were instructed to change all instances of "00"  to
    "zz". Only jot and the lisp-script emacs managed to complete this task  in
    under 30 minutes, vim and gvim fell over as did the usual suspect: nano.
    
  - `Loading a fat file and and doing a global search and replace - 2` In this
    test we set our editors the task of change every instance  of  the  string
    "99" to "abcdefghi". Since there are  quite  a  lot  less  of  these,  the
    editors might find this slightly easier. Most editors have to work  harder
    when the new string is a different size to the original,  especially  when
    it's longer. The editors all  completed  this  in  reasonable  time,  once
    again, nano was far behind the main pack.
    
  - `Loading a big fat file - big_fat_file.txt`  All  editors  swallowed  this
    file in reasonable time, although nano was significantly slower  than  the
    rest.
    
  - `Loading a big fat file and searching` Jot was a bit faster than vim, gvim
    and the interactive emacs session, nano was much slower.
    
  - `Loading a big fat file and and doing a global search and replace - 1` Jot
    was quite a lot faster, nano crashed but vim, gvim  and  interactive-emacs
    all got there in the end.
    
  - `Loading a big fat file and and doing a global search and replace - 2`
  
  
    Now  performing  substitutions  on  very  long  lines  can  present
    difficulties for text editors that rely in text shuffling as  line-lengths
    change - jot is one such.
  
    For this  relatively  small  file  (only
    about 100MB) jot won hands down, but the tables  were  turned  later  when
    they had to do the same thing but with a much bigger file.

2 Command structure
-------------------
  - Number of primitives - jot  62  basic  primitives,  133  counting  the  71
    options for %S, %B, %Q and
      %H commands.
      
    - emacs - hard to  say,  probably  all  primitive  functions  in  whatever
      version of lisp it happens to be using.
      
    - vim - It looks as though vim just has functions.
  
  - basic number of user functions (ie. default no. of functions).
    - jot 117
    
    - emacs - 483 (number of functions found in emacs info pages)
    
    - vim 59 (for vimscript language, counted in
        http://www.adp-gmbh.ch/vim/scripting/built_in_functions.html)
  
  - Basic number of defined keystrokes/hotkeys/escape sequences
    - jot 160
    
    - emacs 634 (number of keystrokes mentioned in emacs info pages,  some  of
      these are duplicates containing metasyntax from the info text)
      
    - vim 631 listed in http://vimdoc.sourceforge.net/htmldoc/quickref.html#quickref
      

3 More
------
  - Line wrapping:
    - jot: only supports truncated view
    - emacs defaults to line-wrapping, can be turned off to give  a  truncated
      view with M-x toggle-truncate-lines
  
  - Split windows:
    - jot: horizontal splits are easy, vertical splits impossible.
    - emacs: both horizontal and vertical splits possible.
    
  - Annoying features: They've all got some, trouble is, it's  easier  to  see
    these in other people's efforts.
    
    - jot:
      - I guess many will find  the  complicated  Ctrl,  Shift  and/or  Alt  +
        Function/cursor key combinations more than a little tiresome. This  is
        probably more of a problem for touch typists  than  for  hunt-and-peck
        typists such as myself.
    
    - emacs:
      - emacs - that stupid "Oh golly! that's a big file" query  for  file  of
        1Mb or more and anyway what's so special about 1Mb files in  this  day
        and age? Similarly, there,s not just one but two annoying popups  when
        trying to abandon a session.
      - Oh, and on the subject of stupid questions, the use of blue highlights
        makes these almost invisible on my (reverse video) xterms.
        
    - vim:
      - It's a minefield of special cases, special modes and special  features
        and the what where and when of how they apply is not always  uniformly
        intuitive. Not to mention the funny little historical quirks that were
        in some old-testament version of vi.  While  some  might  be  prepared
        dedicate their professional lives to mastering it all, the rest of  us
        have coding to be done. Interestingly, the  jot  command  language  is
        based on ecce which predates even the dawn of unix.
  
  
