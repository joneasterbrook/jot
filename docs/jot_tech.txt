
1 JOT Technical Guide
---------------------
  This guide is rather more technical in nature. It goes into some details  of
  the design and  internals  of  the  editor,  it's  command  structure,  it's
  primitive commands and installation. For a general user guide  take  a  look
  at `jot user  guide`,  `jot  walkthrough`  and  `jot  quick  reference`.  In
  particular, there is a special startup script `qr.jot` which is designed  to
  be used thusly:
$ jot -st=qr

1.1 About jot commands
----------------------
  There are two clearly identifiable groups  of  jot  commands  -  those  text
  manipulation and those for interfacing with the  operating  system  and  for
  internal housekeeping.
  
  The basic text manipulation commands are all single  characters,  e.g.  `F`-
  find, `S` - substitute, `I` - insert, `M`  -  move  (up/down),  `R`  -  move
  right. There is also an important group of  commands  to  do  with  creating
  programme structures e.g. `(` - block start, `)`  -  block  end  and  `,`  -
  introduces a logical else clause. Most commands set  a  success/fail  status
  flag - a fail will result in an interruption in the programme flow within  a
  block. 
  
  The housekeeping commands can be for probing and  setting  system  state  or
  calling system services. These are generally prefixed with a percent (  %  )
  character e.g:
    - `%I` - input - reads a file from the filing system,
    - `%O` - output - writes a file to the filing system,
    - `%Q` - query - returns reports or values reflecting the  internal  state
      of the editor,
    - `%S` - System settings and services - these affect all buffers.
    - `%B` - Buffer settings and services -  these  affect  only  the  current
      buffer.

1.2 About command parameters
----------------------------
  Numeric parameters are generally specified in decimal e.g:
> m123
  
  String  parameters  may  use  any  non-alphanumeric  ASCII  character  as  a
  delimiter provided the delimiter does not occur in  the  string.  Note  that
  most (see `Q`) of these commands will accept ISO-8859-x or UTF-8  characters
  in the parameter string but only ASCII characters may be used as delimiters.
   
  If there is no further text on the command line then the string may be  left
  unterminated. These examples all find the next instance of the string £1234:
> f/£1234/
> f/£1234
> f@£1234@
> f"£1234"
  
  Most commands that accept a string parameter will also accept a reference to
  a buffer by replacing the string and delimiters with '<key> in  the  command
  line (e.g. F'@ ) in this case the string used is the entire current line  of
  the secondary buffer. The input parameters to many of the  percent  commands
  (mainly those which take pathNames) may also be defined indirectly  in  this
  way (e.g. %ia='$; %qb=file '$ ) but the destination  buffer  cannot  be  the
  same as the pathName buffer. Where this type of indirection is  used,  there
  is an upper limit of 1024 on the allowable length of parameter strings.
  
  The indirect reference can be to a buffer on the operand stack  (see  `about
  the operand stack`). 
  
  In this example, the value of env FRED is used to define a search string:
> %q~=env FRED; mz. f'~
 
  Most references to numerical items on the stack cause  the  to  item  to  be
  removed, references to buffers on the stack remove the link  to  the  buffer
  and, if no other links exist,  the  buffer  object  is  destroyed.  In  this
  example, the top item on the stack contains a numerical value  used  to  set
  the size of a hashtable:
> %h=create '~;
  
  In jot's direct insert mode (see `command-mode vs. insert mode`), you cannot
  enter  commands  (but  you  can  temporarily  exit  to  command-mode  -  see
  `TempInsertMode`). You can only type text straight onto the screen  or  fire
  off the editor functions attached to hot-keys and control keys. If an editor
  function requires an parameter it will prompt you for it. Type it  into  the
  console area and hit {Return}. See `%s=commandmode` for details about  jot's
  type-into screen mode.

1.3 About parameters to macros and jot scripts
----------------------------------------------
  The `%R` command picks up any parameters from the command  line  and  copies
  them to the $ buffer where they can be examined by the script.
  
  The `cli.jot` script, for example, take an ordinary CLI command executes  it
  and returns the result in the @ buffer. For example:
> %r=cli ls -l;
  On completion the @ buffer contains a directory listing  of  your  PWD.  The
  <<`Do`>> function is just a wrapper for the %R command.
  
  The native jot language does not define how parameters find their  way  from
  the keyboard via the console area to macros  or  functions  (see  `hashtable
  call`). For the most important of these Macro1 to Macro9 the startup  script
  (See `about startup scripts`) arranges for parameters to be copied into  the
  ( $ ) buffer.
  
  It's a similar story for  the  more  complex  functions  held  in  the  code
  repository (see `calling functions by name`)  The  `FindSequence`  function,
  for example, takes a list of words from the command line - these are  picked
  up from console area and  copied  to  the  $  buffer  and  the  FindSequence
  function picks them up from there.
  
  When in insert mode (see `Command-mode vs. insert mode`) the startup  script
  arranges for the correct prompt to appear -  see  `translation  of  keyboard
  events to actions`

1.4 About text buffers
----------------------
  In jot, a text buffer is an internal data structure containing an  image  of
  some text. Each buffer is identified by a single-character buffer  key.  The
  following buffers are accessible but some are used by command file  scripts.
  Buffers may contain a file image, fragments of text or jot command strings -
  otherwise known as macro commands.
   
    - ( . ) is the primary buffer, this contains an image of the file you gave
      on the shell command line.
     
    - ( A ) to ( Z ) available without restriction, note that these  are  case
      insensitive i.e. a and A are the same buffer.
     
    - ( 0 ) to ( 9 ) user-defined functions attached to Numeric keypad keys  0
      to 9 ({Esc 0} to{Esc 9} for those lacking a numeric keypad) but, if  you
      don't want to use these as macros, they  are  available  for  any  other
      purpose.
      
    - ( $ ) used to pass parameters to function keys, scripts and macros.
     
    - ( ^ ) set up by startup script - defines function-key mapping.
    
    - ( ' ) Set up by startup script - hosts  the  code  repository  and  it's
      hashtable. It's hashtable is also used to hold bits  of  global  data  -
      like the jump addresses for `ViewSave` and `ViewRestore`.
      
    - ( : ) Set up by the startup script, is the help repository - see  `about
      help files`.
    
    - ( $ ! " # % & ( ) * + - . / ; < = > ? @ [ \ ] _ ) are all available  but
      may be used by scripts or functions hence they can only be relied on for
      temporary storage.
      
    - The ( ! $ % ; @ ) buffers are used by the standard setup script, so they
      may contain something after the startup has run - but may  be  redefined
      without causing problems.
        - ( $ ) is used to pass parameters into many startup-defined functions
          and by %R for all jot scripts.
        - buffer ( @ ) is used as temporary storage  by  many  startup-defined
          functions,  in  particular  it  holds   the   search   strings   for
          FindSequence and FindSequencePrev and some similar functions.
    
    - The buffers ( ^ ) and ( ' ) are defined by  the  standard  setup  script
      (see above), changing these may cause things to not work properly.
      
    - The ( : ) buffer is used as the jot help repository - if you don't  need
      jot help then feel free to redefine it.
    
    - The ( ; ) buffer is used to display help pages but it can  be  used  for
      temporary storage, the syntax gets a bit  messy  when  used  in  percent
      commands since the semicolon is used to terminate percent commands.
      
    - The ( ? )  buffer  is  defined  by  many  scripts  to  give  brief  help
      information on the script.
      
  See `A`, `H` and `about command parameters`.

1.5 Translation of keyboard events to actions
---------------------------------------------
  Like most modern editors jot attaches editor functions to  various  function
  keys, escape sequences and and various combinations of the Shift,  Ctrl  and
  Alt keys with function and other keys. The key-to-function translation table
  is held in the text buffer ( ^ )  defined  at  startup  time  -  see  `about
  startup scripts`.
  
  As a function key is pressed, signals trickle through various layers of  the
  OS (maybe xkb followed by terminfo) until they reach the editor in the  form
  of a keycode or an escape sequence.
    - Simple ASCII characters are a keycode byte indicating the ASCII code,
    - unicode characters appear as a series of bytes  indicating  their  UTF-8
      sequence,
    - simple function keys and mid-keypad keys appear as a single-byte keycode
      as defined in ncurses.h and
    - keys modified by Ctrl, Shift and/or Alt, use this scheme:
        - {F1-12}                  yields key_f1-key_f12,
        - {Shift F1-12}            yields key_f13-key_f24,
        - {Ctrl F1-12}             yields key_f25-key_f36,
        - {Ctrl+Shift F1-12}       yields key_f37-key_f48,
        - {Alt F1-12}              yields key_f49-key_f60,
        - {Shift+Alt F1-3}         yields key_f61-key_f63,
        - {UpArrow}, {DownArrow}, {LeftArrow}, {RightArrow}, {Insert}, {Home},
          {Delete}, {End}, {PageUp} and {PageDown} Keycodes  for  all  of  the
          above are defined in ncurses.h
    - The following keys, however, usually generate unique key sequences  (but
      even uniqueness is not guaranteed) determined by your OS  configuration.
      Furthermore some  may  be  hardwired  as  system  shortcuts  (especially
      {Ctrl+Alt+F1-12}) and some combinations of {Up/DownArrow}.
        - {Shift+Alt F3-12}
        - {Ctrl+Alt F1-12}
        - {Ctrl+Shift+Alt F1-12}
        - {<AnyModifier>+<AnyMid-keypadKey>}
      The point to note about linux system-defined escape  sequences  is  that
      they are liable to change from one distribution  to  another.  It's  not
      even guaranteed that these will yield any usable key  code  at  all  and
      sometimes they have been known to  collide  with  other  keycodes/escape
      sequences from the same system. See `define_keymap.jot` for  details  of
      how  to  redefine  the  jot   key   mapping   for   your   system.   The
      `curses_keys_<subVersion>.jot` in the jot distribution was set up  using
      a Fedora-27 with TERM set to xterm.
  
  After a key event is received,  jot  will  attempt  to  match  the  received
  keycode with codes in the ^ buffer (see `startup.jot`). Some keys  return  a
  simple numerical  value,  others  return  an  escape  sequence  -  an  {Esc}
  character followed by a few ordinary  printable  characters.  Alternatively,
  the user may type in {Esc} followed by two or more characters -  essentially
  another form of escape sequence.
  
  Where a parameter is required, e.g. for the <<Do>> function the script  name
  parameter is represented in the function definition by a  pair  of  adjacent
  hash characters. For in a  typical  linux  installation  this  key  will  be
  defined by this entry in the ^ buffer:
X010A   %r=##"Command file pathName> ";
  X010A is the key code associated with the F2 key for some curses versions.
  
  In command mode, the name of the script is typed in *before*  hitting  {F2},
  thus the function key doubles up as a delimiter for  the  parameter  string,
  saving you the bother of hitting {Return}.
  
  In insert mode, however, it is necessary to prompt for the pathname and  the
  prompt is, of course, the string following the double hash.  If  the  prompt
  string is omitted then no prompt is issued.
  
  The startup script builds the key translation table in buffer ( ^  )  -  see
  `startup.jot`.
  
  In the normal startup script, for example, we find this  definition  of  the
  <<Remove>> function (this removes the currently-selected substring):
<<Remove>>(s/ /e-)
  
  Then, further along in the startup.jot script we see this:
<<Remove>>            {Shift+F5}
  This says that the <<Remove>> function should be activated by  pressing  the
  F5 function key while the Shift key is held down.
  
  In the curses_keys_xterm script we find this line:
X0119                        -- {Shift+F5}
  In the WindowsNT_keys script we find this line - functionally similar but  a
  different keycode.
X374                         -- {Shift+F5}
  these give the specific key code for {Shift+F5}.  Finally,  looking  in  the
  key-translation buffer ( ^ ) of a linux session we should see this:
X0119   (s/ /e-)
  The sequence of events is thus:
    - You select a substring,
    - you press {Shift+F5},
    - the system detects this event and generates a binary the code determined
      by terminfo to be 0x119,
    - jot translates the code 0x119 to the escape sequence {Esc 0 1 1 9},
    - jot matches the internally-generated escape sequence and finds  the  jot
      command sequence (s/ /e-) by searching the ( ^ ) buffer,
    - jot then executes that little bit of code and, finally,
    - you see the substring disappear from the screen

1.6 About startup scripts
-------------------------
  As we hit keys, various layers of hardware and the operating system  perform
  a translation from electrical impulses in the keyboard to keycodes that  can
  be understood by whatever software is reading them - in this case jot.
  
  For windows the situation appears to be  that  all  flavours  of  NT-windows
  running on any machine connected to  any  compatible  keyboard  will  always
  yield the same keycodes.
  
  For linux, the recent history of unix intrudes, as  video  terminals  became
  popular a great many firms entered the  market  with  competing  and,  well,
  incompatible devices which all had to be connected to unix servers. This was
  the necessity that gave birth to the invention of termcaps. Later there  was
  terminfo - an improved version of termcaps.
  
  With termcaps/info it became possible for many users,  all  connected  to  a
  unix server using a variety of terminals and for the system  to  communicate
  reliably with all of them. But only if each  has  properly  announced  which
  terminal type they have by setting their $TERM env.
  
  However ... most linux installations run on PCs with only one  keyboard  and
  only one monitor but the unix distros have provided a plethora  of  terminal
  types and many distros set up the default TERM to xterm. But no! ... not all
  distros  provide  a  complete  description  of  the   capabilities   of   an
  IBM-compatible keyboard and worse yet, not all agree on what keycodes result
  from various combinations of function and control keys.
  
  This is resolved in the  startup  script  (See  `startup.jot`),  which  runs
  different keycode-setup  scripts  according  to  your  curses  version  (see
  `WindowsNT_keys.jot` and `curses_keys_<subVersion>.jot`).
  
  The mapping of function key events to  editor  functions  is  determined  in
  various layers of OS and, in particular your terminfo file and, finally,  by
  the editor startup file. See also `X-windows setup`
  
  The approximate sequence of events, in the `startup.jot` file is:
    - The appropriate curses_keys_<TermName>.jot script is run - this  defines
      the mapping of keycodes (either numerical keycodes or escape  sequences)
      to the names printed on the keycaps. This table is set up in the (  @  )
      buffer.
    - The startup script then defines functions in the code repository  buffer
      ( ' ).
    - The startup script then defines the mapping of functions to key names in
      buffer ( ! ).
    - If you have specified a function and keymap  modification  script  using
      the -keyfuncs=<pathName> qualifier then  that  script  is  run  at  this
      point.
    - The startup script merges the keycodes map, the functions  map  and  the
      functions to create the key translation table in buffer ( ^ ) - this  is
      used to map hotkeys function keys and escape sequences  to  actual  code
      and function calls.

1.7 About jot streams
---------------------
  Jot is normally used to edit text files held on the filing system but it can
  pick up text from the stdin stream (see `-`) and it can direct text  to  the
  stdout stream when `-tty` is set.
  
  In normal usage, the `P` command prints line in the console area.  When  the
  editor is stared in stream-out mode the printed lines are  sent  to  stdout,
  where they can be directed to a  file  or  piped  to  another  process.  The
  stream-out operation  is  detected  automatically  when  stdout  is  set  to
  anything except your  xterm  (or  windows  console).  e.g  (this  matches  a
  specific class of error message with the function name):
$ jot message.log -quiet -tty -init="t(f/warning: unused variable/onf-/in function/n.r2f1/:/aa&ono-omhapm)0 %a" | cat
  This would also cause it to enter stream-out mode:
$ jot message.log -q -tty -in="t(f/warning: unused variable/onf-/in function/n.r2f1/:/aa&ono-omhapm)0 %a" > errors.lis
  
  It is also possible to output to stdout in normal window manager mode -  the
  `%A` command has an option to output a selected buffer to stdout instead  of
  the usual exit message.
  
  Note the use of the -tty and -quiet qualifiers in these two examples -  -tty
  this prevents xterm escape sequences appearing in stdout, -quiet  suppresses
  many normal messages that would otherwise appear in the output stream.
  
  In stream-out mode the records selected by the `P` command is sent off  down
  stdout where it can be piped  off  to  some  other  process.  This  mode  of
  operation  is  used  in  the  99  bottles  of   beer   demonstration.   (see
  `http://99-bottles-of-beer.net`)
  
  99 bottles of beer is a simple drinking song:
  
	99 bottles of beer on the wall, 99 bottles of beer.
	Take one down and pass it around, 98 bottles of beer on the wall.
	   ...   
	2 bottles of beer on the wall, 2 bottles of beer.
	Take one down and pass it around, 1 bottle of beer on the wall.
	  
	1 bottle of beer on the wall, 1 bottle of beer.
	Take one down and pass it around, no more bottles of beer on the wall.
	  
	No more bottles of beer on the wall, no more bottles of beer.
	Go to the store and buy some more, 99 bottles of beer on the wall.
  
  The object of the exercise is to write some code in your favourite  language
  to generate the lyrics correctly - this is one way of doing it in jot:
  
$ jot -tty -in=\
"ol99 (o#boo/%d bottles of beer on the wall,/r0o#oo/ %d bottles of beer./b"\
"ol1o- ol-1o=\ o#oo/Take one down and pass it around, %d bottles of beer on the wall./b)0 ok"\
"(f-/1 bottles/-e-)3 m0i/Go to the store and buy some more, 99 bottles of beer on the wall./bm-0p0%a;"

1.8 About help files
---------------------
  The help files are structured in a similar fashion to occam folded files.
  
  The top help file normally contains only file folds. If,  for  example,  the
  JOT_RESOURCES env is set  to  /home/my_home/resources,  there  should  be  a
  top-level helpfile help.hlp in the help subdirectory:
    /home/my_home/resources/help/help.hlp
  Inside that file we might find this line:
    [unix]unix - Notes on a few unix commands.
  When When a user queries this help entry (by moving the cursor to  somewhere
  in the line and hitting F1) the [unix]unix element is transformed  into  the
  path:
    /home/my_home/resources/help/unix/unix.hlp
    
  Within the child help files are folded sections like this:
> {{{ Section name
>   Section text.
>   ...
> }}}
  
  These help sections are nestable.
  
  The help files can be typed in manually, but it is easy to make mistakes  in
  the fold  nesting.  It  is  recommended  that  help  files  be  prepared  as
  plain-text documents with the section hierarchy defined  by  section  header
  levels (i.e. the section levels indicated by  the  section  numbers)  -  see
  `text document preparation`.
  
  There are some text-processing scripts to help with this:
    - `doc2fold.jot` - Creates a help file from a text document.
    - `fold2doc.jot` - reverse of doc2fold - only use  this  when  the  source
      text is not available.
    - `updatehelp.jot` - pushes simple modifications to a help  fold  back  to
      the helpfile.

1.9 About long lines
---------------------
  The maximum length line that can be displayed properly  is  limited  by  the
  display window. When the editor has to display a longer line  the  behaviour
  is as follows:
   
    - If current character and all of any selected substring are in within the
      terminal width then the line, the current character  and  the  substring
      are displayed normally. Any text to the right of the window right margin
      is silently ignored.
       
    - If the current character or some part of the selected substring is at or
      beyond the terminal width then the line is displayed in the console area
      of the screen.
       
    - If a LeftOffset is set for the buffer  (see  `%b=leftoffset`)  then  the
      left margin of the display is aligned to somewhere right  of  the  first
      character. If the current  character  or  some  part  of  the  currently
      selected substring falls outside the defined screen  area  then,  again,
      the relevant section of the record is displayed in the console area.
      
    - When a script or macro has to ensure that the current  character  is  in
      view use %q=inview; - see `Query inView`.
      
    - The <<CellLeft>> and <<CellRight>> actions  (normally  {Shift+LeftArrow}
      and {Shift+RightArrow} respectively), will check  for  visibility  using
      %q=inview and will adjust leftoffset accordingly.
      
    - The     <<ViewLeft>>     and     <<ViewRight>>     actions     (normally
      {Ctrl+Shift+LeftArrow} and {Ctrl+Shift+RightArrow} respectively), can be
      used to manually adjust leftoffset.

1.10 About the jot console and display windows
----------------------------------------------
  In jot documentation, a window  is  a  viewing  area  of  the  terminal.  By
  default, the startup script creates a single window which displays  whatever
  happens to be the current buffer. The area at the bottom of  the  screen  is
  the console area, used to display system messages etc. and prompts for  your
  typed-in commands. In the event of a long line with  the  current  character
  being off to the right of the screen then the console area is used to repeat
  an appropriate section of the line.
  
  The standard startup script (see `about  startup  scripts`)  will  use  your
  screen dimensions to calculate the size of a single window that will leave a
  one-line console area at the bottom of the  screen.  It  also  sets  up  the
  screen, using the `%L` command. it also uses  the  `%s=console`  command  so
  that various message can temporarialy encroach into the  window  area.  When
  this happens, the window will be restored to it's  full  size  on  the  next
  command - or by hitting {return}. If the temporary  display  overwrites  the
  current line in the display window then the current line is repeated in  the
  console area.
  
  When the console area is set up with two or more lines, lines of text scroll
  up the console up to the bottom line of the last window. If the  console  is
  set up with one line but allowing it to temporarialy encroach  upwards  into
  the windows area (see `%s=console`  for  details),  then  the  console  will
  borrow lines up to the specified limit.
  
  For debugging scripts, especially when  using  `the  jot  debugger`,  it  is
  useful to set up windows for a fairly large console window. For normal usage
  a one-line console area is useful since this maximizes the text view.
  
  The  size  of  a  window  can  be  adjusted  with  the  `WindowStretch`  and
  `WindowShrink` functions. The view can be adjusted left, right  up  or  down
  with the functions - see `ViewUp`, `ViewDown`,  `ViewLeft`  and  `ViewRight`
  respectively.
  
  It is possible to split the viewing area between more than one  window  with
  one or more windows dedicated to displaying specified  buffers.  The  screen
  may be split either vertically or horizontally  -  see  `about  multi-window
  working`   and   `WindowOne`,   `WindowHorizSplit`   and   `WindowVertSplit`
  functions.

1.11 About Tabular text
-----------------------
  Jot supports text two types of text containing tabs - normally the ascii  VT
  character, here referred to as tab. The first form uses tabs simply to align
  text into predefined columns, the  second  form  aligns  tab-delimited  text
  cells. Cells often contain numerical data, so the  text  is  right-justified
  and over-long strings are truncated to maintain the tabular structure.
  
  See  `%b=tabstops`,  `%b=tabcells`  and  `%b=tabsort`.  It  also   generates
  tab-separated tables (see `Query dir`).
  
  When viewing tabular data it is often useful to have a header  line  showing
  the meaning of each column - the window headers provided by `%b=header` will
  follow tabstops set in the text body eg:
$ jot ${JOT_RESOURCES}/consumertrends2012q3cvmnsa_tcm77-292466.tsv \
    -in="m+13 %b=header '.; %b=tabcells -1; wol12ow"
  
  The header is also useful for wide blank-separated tables eg:
$ pmap -XX <anyValidPid> | jot -in="m %b=header '.;"
  
  In addition to `%b=tabstops` and `%b=tabcells`, there are two  more  options
  for representing tabular text. 
    - By default, jot will treat tabs as it does any other control  characters
      and will represent them with tildes ( ~ ) -  not  a  especially  helpful
      option for most uses - but it is sometimes useful to see where they are.
    - The following scripts will reformat documents, guided by temporary tabs:
      `autotab.jot`     `autotabdp.jot`     `autotabjust.jot`      `retab.jot`
      `retabhere.jot`
  
  If the width of the table execeeds that of your  window,  you  can  set  the
  leftoffset - see `about long lines` and `%b=leftoffset` this  is  all  taken
  care of by the <<`WordRight`>> and <<`WordLeft`>> functions.
  
  A good example is the output of the linux dumpkeys command  -  the  keycodes
  section consists of 256 entries per line with  20  or  more  characters  per
  entry, to view these with a header showing the modifier values try this:
$ sudo dumpkeys -f | jot -in="(f/ /s/\t/(v//e)0)0m-0 %b=tabstops -1; \
  ol0z\$m-0k0(i/\t/)3 (o#oo/\t%2X/r0o~ol256o<)0 z.%b=header '$;"
  
  You may then navigate the table using `WordLeft`, `WordRight`, `WordUp`  and
  `WordDown`  -  {Shift+LeftArrow},  {Shift+RightArrow},  {Shift+UpArrow}  and
  {Shift+DownArrow} respectively.
  
  As with linear text, if the current character ends up  outside  the  visible
  area of the screen (i.e. left of the buffers leftoffset setting, or right of
  the right margin), the relevant section is repeated  in  the  console  area.
  Also, if any part of the cell is out of the viewing area or the tabstops are
  set to narrow to properly display a cell, the cell  text  is  truncated  and
  displayed prefixed with a pling ( ! ) character. The section of text is also
  repeated in the console area - see `about long lines`.
  
  While the %b=tabstops command affects only the way tables are represented on
  the screen in the current edit  session,  There  are  scripts  available  to
  permanently change the text file  -  see  `autotab.jot`,  `autotabjust.jot`,
  `autotabdp.jot` and `retab.jot`.

1.12 Of Mice and Menus
----------------------
  Jot offers a Text-based User Interface (TUI) which can  support  mouse-click
  and menu-driven applications. Although the plain-text menus might look quite
  crude and clonky by modern standards but that doesn't make them less  useful
  than their slick counterparts. Take a look at the coding of  `menu.jot`  and
  `linkdocs.jot` for examples of how this might be done.
  
  - Firstly, to enable mouse events, the  mousemask  must  be  set  up  -  see
    `%s=mousemask`.
    
  - It  is  usual  to  highlight  clickable  target  points  with  an   easily
    identifiable visible marker, in jot this requires  the  application  of  a
    colour tag (see `%b=addtag`). If  popup  menus  are  being  used  this  is
    essential in order to avoid confusion as the popup overwrites normal text.
  
  - Mouse-clicks trigger the delivery of an escape sequence in much  the  same
    way as a function key - these are picked up and are  normally  set  up  to
    call a mouse-event handler function - see `translation of keyboard  events
    to actions`.
  
  - The mouse-event handler must first identify the buffer,  column  and  line
    number ( X and Y) where the mouse cursor was pointing at the time  of  the
    mouse event. This information is provided by th `OP` command.
  
  - Having determined the mouse-event coordinates, we now have to identify the
    correct action associated with the identified mouse event  and  the  event
    location. A  text  tag  is  assigned  to  the  clickable  region  and  the
    mouse-event  handler  checks  the  event  point  for  text  tags   -   see
    `%b=addtag`. Following a mouse event, the event-point text can be  checked
    for text tags using the `query tags` using the -here qualifier  to  select
    the correct text region.
    
    For menus, there will be a wide range of follow-on actions, then  the  tag
    is effectively a callback selector -  see  `menu.jot`  for  examples.  For
    hypertext applications  the  tag  simply  gives  the  link  destination  -
    possibly in the form of a hashtable key - see `linkdocs.jot`.

1.12.1 About Mouse Events
-------------------------
  By default, any mouse activity (movements, clicks, drags etc.)  are  ignored
  since in X the default mouse functions (selections) are  reasonably  useful.
  If however, some application needs to handle  mouse  events,  these  can  be
  enabled. An example of a script that does this would be `linkdocs.jot`.
  
  Jot is normally driven by keyboard events with mouse-button events disabled.
  When mouse events are enabled, these are treated  as  keyboard  events  with
  special mouse event codes prefixed with 'M@. In linux,  it  is  possible  to
  select mouse events in the `%s=mousemask` command, in  windows  this  either
  enables or disables all mouse events.
  
  The normal startup sequence defines four functions
M0040   <<CopyFromMouse>>    -- {Button2Up}
M0080   <<NoteFromMouse>>    -- {Button2Down}
M0200   <<FocusToMouse>>     -- {Button2DoubleClick}
M4000   <<InsertHereMouse>>  -- {Button3Click}
  these are intended to be demonstrators rather than useful functions - enable
  them for use with the mousemask command:
> %s=mousemask 42A0
  
  To integrate these in a useful way - e.g. for mouse clicks to perform useful
  processing some metadata is often required - e.g. to perform a jump to  some
  place in another buffer on a mouse click we might  need  a  hash-table  key.
  This key can be associated with a launch point by adding a text tag  in  the
  launch point with the`%b=addtag` command using the -text=<string> modifier.
  
  See also `OP`, `%s=mousemask`, `%s=setmouse` and `%b=addtag`

1.12.2 About Menus
------------------
  Menus are normally but not exclusively driven by  mouse  events  -  normally
  clicks. Menu items are normally highlighted by choosing a  different  colour
  pair for them - see `%b=tagtype` and `%b=addtag`.
  
  For menus each menu item  will  require  a  different  callback  -  this  is
  normally determined by tagging menu items with a text tag (see  `%b=addtag`)
  that identifies the callback. Alternatively, the click-event  handler  might
  simply pick up the visible text  from  the  menu  buffer  and  identify  the
  follow-on action from that.
  
  Popup menus can be set up using popup windows - see the -popup option of the
  `%W` command.

1.13 About unicode
------------------
  Back in the days of teletypewriters and paper tape it was all so  easy.  The
  American Standard Code for Information Interchange (ASCII)  would  represent
  every character you could ever want with just  7  bits  -  so  long  as  you
  weren't  a   mathematician,   an   engineer   or   anyone   working   in   a
  non-english-speaking part of the world.
  
  Mapping the 7-bit ASCII code to 8-track paper tape code left one  extra  bit
  which was sometimes used for checking  -  early  modems,  electro-mechanical
  tape punches and readers were not especially reliable. Since that time,  the
  8-bit unit (one byte) has become the industry-standard unit for organization
  of computer memory. 
  
  Modern computer hardware is much less error prone and, where  error-checking
  schemes are employed, nowadays they are  usually  cyclic-redundancy  systems
  that can detect and correct multiple errors. Also modern modern transmission
  protocols include error detection and correction. So the 8-th.  bit  is  not
  required as a check for storage or transcription errors.
  
  Unicode (or Universal Character Set - UCS) - an  industry-standard  encoding
  scheme for most characters in  the  alphabets  of  most  written  languages,
  including many symbols used in mathematics and  engineering.  The  range  of
  characters is  so  vast  that,  in  practice,  it  is  necessary  to  encode
  characters as  sequences  of  one-byte  tokens.  Some  tokens  indicate  the
  existence of yet more tokens to come, in UTF-8, UTF-16 and UTF-7. In  common
  with many mail  and  unix  systems  jot  uses  UTF-8  to  represent  unicode
  characters. 
  
  It's important to note that whereas UCS is basically a vast  character  set,
  UTF-8, UTF-16, UTF-7 ... are  coding  schemes  designed  for  efficient(ish)
  transmission, storage and handling of characters belonging to  that  set  by
  encoding them as sequences of bytes in the range 128-255.
   
  UTF-8 is a back-compatible expansion of the usual  8-bit,  non-parity  ASCII
  character set utilizing the, now redundant, 8th. bit and two or  more  bytes
  to yield an encoding space for many thousands  of  unique  character  codes.
  These can be used to represent all  of  the  unicode  characters.  Both  the
  windows and linux versions of jot support UTF-8 encoding.
  
  UCS-2 is an early attempt at  a  unicode  encoding  scheme  -  unfortunately
  whereas UCS-2 can address a character space of 64K characters (at most,  and
  in practice far less) the full chinese character set has in  excess  of  70K
  characters. This resulted in UTF-16 and UTF-32, UTF-32 abandons all pretence
  of packing efficiency and just gives each character 32 bits (a full word  in
  most modern computers). UTF-16, like UTF-8 is a variable-length scheme which
  can encode all of the current unicode characters.
  
  While UCS-2 and UTF-16, may not be actually obsolete they were never  really
  much good. Consequently jot offers only very limited support for UCS-2, it's
  slightly more intelligent younger  sibling  UTF-16  or  it's  obese  brother
  UTF-32. 
  
  Jot makes  no  attempt  to  make  sense  of  any  of  these  encodings.  The
  recommended solution for UCS-2, UTF-16 and UCF-32 is to convert  them  using
  iconv (linux) or a similar windows file-format converter. The  filing-system
  explorer `get.jot` automatically uses iconv to read these formats  as  UTF-8
  but to be consistent with the jot policy of not making  unrequested  changes
  to files, the pathname is changed in the editor session.
  
  Various earlier schemes, designed for users working in their own  languages,
  allows an additional character space (theoretically  up  to  a  further  128
  characters) by setting the parity bit. This scheme, enshrined  in  microsoft
  code pages, became popular because it  allowed  several  sets  of  non-roman
  alphabets with the minimum of fuss and still preserves the ancient principle
  of one byte  equals  one  character  -  very  important  for  developers  of
  text-handling tools. This is fine for those, like most of us, who never have
  to write in more than one non-roman alphabet in any one document. There  are
  now various ISO-8859-x standards covering these character sets.

1.13.1 Practicalities of unicode etc. and jot
---------------------------------------------
  The linux version of jot of jot can read  and  manipulate  files  containing
  mixed UTF-8 and ISO-8859-x character encodings.  For  correct  rendering  of
  ISO-8859-x you must have your locale set correctly - see `-locale`. Any text
  entered will be encoded in UTF-8. Also, some care is required in the  choice
  of terminal - a recent version of xterm is a usually a good bet.
  
  With appropriate unicode support jot should, in theory, be  usable  for  any
  left-to-right written language. Support for right-to-left languages (Hebrew,
  Arabic etc.) may be possible later.
  
  The windows version can properly display files containing  either  UTF-8  or
  those containing ISO-8859-x - but  not  both  in  the  same  document.  This
  version  requires  the  correct  code-page  setting  for  the  file  -   see
  `%b=codepage` and `-Codepage`, by default  it's  set  to  codepage  65001  -
  that's UTF-8 to you and me. Again, any  text  entered  will  be  encoded  in
  UTF-8.
  
  The linux version can only read and display UTF-8 but, if it is required  to
  view or modify a UTF-n file there is a little script `iconv.jot`  which,  as
  it's name suggests, uses the unix utility iconv to  transform  the  file  to
  something that can be read, it will also write the  file  in  it's  original
  format.
  
  In general, jot represents unicode as strings of UTF-8 bytes. The exceptions
  to this are:
    - the OIC flavour of the `OI` command and
    - the `Q` command.
  
  To enter  UTF-8  characters  into  the  command  line  use  the  jot  script
  uc_basic.jot - this recognizes sequences of keystrokes and converts them  to
  the relevant UTF-8 byte sequence. To generate the euro symbol  (  €  ),  for
  example:
> {Esc u = E}
  In command mode, `uc_basic.jot` translates  this  sequence  on  the  command
  line, so start off by loading the basic unicode:
> uc_basic{F2}
  Then, for example, to search for the the string "cost €123.456", type:
> cost {Esc u = E}123.456F8
  The uc_basic.jot script added the u=E escape string to your key translations
  list and it substituted the UTF-8 encoding for € in the command line.
  
  Many IBM-compatible keyboards supplied in non-english-speaking parts of  the
  world, have non-roman characters. Assuming your system is set up  correctly,
  in linux, these keystrokes are converted to the correct  UTF-8  sequence  by
  the OS. If, for whatever reason, your linux  locale  (or  Windows  codepage)
  does not match your keyboard, you can specify a different  locale  with  the
  `-locale` (or `-Codepage`) qualifier. If you have some ISO-8859-x encoded in
  a different locale, you can change the locale of a buffer with the `-locale`
  CLI modifier.
  
  To suppress conversion of unicode, turn off unicode support for that  buffer
  with the `%b=unicode` [0|1] command. Turning unicode support off (%b=unicode
  0;) displays each non-ASCII byte as a tilde ( ~ ), unicode  support  can  be
  restored with %B=unicode 1;

1.13.2 Unicode - the gruesome details
-------------------------------------
  Currently, the following unicode character encoding schemes are supported by jot:
    - UTF-8
    - UTF-16 (both Big and little-endien flavours)
    - UTF-32 (both Big and little-endien flavours)
    
  Files may be read in any supported unicode encoding scheme  and,  typically,
  will be written out in their original encoding scheme.
  
  It detects the encoding scheme by checking for  a  valid  Byte-Order  Marker
  (BOM) - this is a few bytes written at the very begining of the file.  UTF-8
  files may optionally have a BOM, jot  detects  this  but  takes  no  further
  action apart from removing the BOM from the  file  image,  if  the  file  is
  rewritten, jot will reinsert the UTF-8 BOM. Here is a list of BOMs  jot  can
  detect:
	    BOM bytes      	 Unicode encoding scheme
~    EF BB BF       	 UTF_8                  
~    FF FE          	 UTF_16, little-endian  
~    FE FF          	 UTF_16, big-endian     
~    00 00 FE FF    	 UTF_32, big-endian     
~    FF FE 00 00    	 UTF_32, little-endian  
  
  While the file is internally represented  in  UTF-8,  jot  maintains  a  tag
  indicating the original encoding scheme so that  it  can  rewrite  the  file
  correctly. This tag appears in the `query buffer` report in  the  UCEncoding
  line. If it is desired to rewrite the file in one  of  the  other  supported
  unicode encodings, this tag may be changed with the `%b=encoding` command.
  
  For example, the UTF-8 encoding for the euro sign ( € ) is E2, 82, AC -  jot
  will recognize these characters as UTF-8 and store them in  the  same  form.
  When jot displays these characters they must be  converted  from  the  UTF-8
  internal representation to C-language "wide characters" coding for the  euro
  symbol for display on the screen. It's left to  your  terminal  emulator  to
  correctly interpret the UTF-8 string to present the  correct  image  on  the
  screen.
  
  Note that the `R` and `OR` commands will  normally  traverse  the  specified
  number of characters irrespective of  how  many  bytes  have  been  used  to
  represent each character. Similarly the  `E`  command  normally  erases  the
  specified number of  characters  irrespective  of  their  byte  count.  This
  behaviour is modified by the `%b=unicode` command, which can be used to turn
  off all unicode support - with unicode disabled, R, OR and E commands  count
  bytes not characters. Erasing bytes belonging to  UTF-8  characters  is  not
  recommended - there is no guarantee that the line will display properly when
  unicode-support is turned back on.

1.13.3 Editing Binaries
-----------------------
  Binary files (i.e. any non  text  file)  are  generally  made  that  way  to
  minimize their size and improve performance - the most  important  class  of
  binary files are executables and libraries. We would need be very  desperate
  to want to start hacking those. Also, many have some sort of file  integrity
  checking - so your modified file may get rejected anyway.
  
  However, there are occasions when it might be  useful  examine  these  files
  and, provided we understand their internal  structure,  it  is  possible  to
  glean some useful insights by going through hex dumps of binaries.
  
  In a *very* few instances there might even be something to  be  said  for  a
  facility to write a hacked dump file back in a  binary  form.  Jot  has  the
  -binary qualifier to the `%O` command which  does  exactly  this.  Typically
  proceed as follows:
    - Read the binary into a jot buffer using `%I` with the -binary qualifier,
      this presents your file as a hexadecimal dump.
    - Change the hex dump,
    - Write back using `%O` -binary
    
  Something for you to try (unzip seems to check only the total length of  the
  zipfile) This operation only changes the name from 'test' to 'ZZZ':
$ jot -init="%i= -binary ${JOT_RESOURCES}/test_get/test_get.zip; \
    %b=unicode 0; %r=hex2ascii; f/test.zip/f-/74 65/(e3i/5A /)4 \
    %o= -binary /tmp/test.zip;"
$ unzip -l ${JOT_RESOURCES}/test_get/test_get.zip
  - It contains another zip file - confusingly also test.zip
$ unzip -l /tmp/test.zip
  - The archive file name was changed to ZZZ.zip

1.14 About Journal Files
------------------------
  Jot's journal files are designed to recreate a session in the  event  of  an
  abnormal exit. The journal file, along with a cache  of  files  and  queries
  read by the original session, can be used to retrace all your activity in  a
  recovery session so that you end up with an editing environment identical to
  that before the abnormal exit. In the future, journal  files  might  provide
  the basis for some sort of undo function - although it would be rather  slow
  by modern standards.
  
  By default no journal is maintained - the editor is not particularly  crashy
  and modern computers and power grids are generally reasonably reliable.  The
  endurance of battery-powered devices is also quite  good  these  days.  From
  time to time however we are reminded that certain  can't-happen  events  are
  in fact infrequent events and it's pretty distressing to see hours  of  work
  wiped out like that.
  
  When the CLI qualifier `-journal` is set, jot maintains a history  file  and
  snapshots of all the files it reads - these files are  normally  deleted  as
  the next session starts. Following a crash the journal files remain and  the
  original session is re-created by reading in snapshots of the original files
  and re-running the interactive commands.
  
  An empty lock file is also created in the journal directory, this is deleted
  when a jot session exits normally (via  `%C`  or  `%A`).  If,  however,  the
  previous session did not exit normally  (or  maybe  it's  still  running  in
  background?), the presence of LOCK will the prevent the usual destruction of
  the old sessions history files. The editor will inform you  of  the  correct
  pathname and leave you to take appropriate action.
  
  The process for a session editing myfile.txt is described below.
   
    - 1 Start the editor with journal files enabled:
$ jot myfile.txt -journal[ -init=<initializationSequence>] [ -<any other valid args>]
      As usual, the args may appear in any  order.  In  your  current  working
      directory (cwd) jot creates a  new  subdirectory  <fileName>.jnl  -  for
      this to happen, you clearly need write access to your cwd. At  the  star
      of the session that directory will contain three files:
        - LOCK - an empty file used to detect an abnormal termination of  your
          session (see below).
        - <fileName>_<timeStamp> - a copy of your original file.
        - history.txt - this is continuously updated with your keystrokes  and
          mouse activity as the session progresses.
      More files may be added as the session continues, these are:
        - copies of files read during the session,
        - copies of reports generated by jot query commands (these are  listed
          at `%Q`).
 
    - 2 After crashing or exiting, restart the editor  but  run  the  recovery
      script recover.jot - any  other  args  will  be  ignored,  the  recovery
      process will restart with the original -init sequence etc.
$ jot myfile.txt -st=recover
      Where the original session read a file or launched a system  query,  the
      recovery session will read the backup copy from the journal directory.
  
    - 3 If there are problems, then edit the command script recover_now.jot in
      your current directory and re-run the recovery using that:
$ jot myfile.txt -startup -init="%r= -asconsole ./recover_now.jot"
  
  The history file contains the replacement pathnames (in the <name>.jnl area)
  and other bits of information from the original session like adjustments  to
  terminal size and results of system-query reports. These raw data are munged
  into a personalized recovery script by the `recover.jot` script.
  
  If some mismatch is found, the session  is  terminated  immediately  with  a
  message explaining what went wrong.
  
  See `about not losing your work`, `%S=RecoveryMode`  and  `recover.jot`  for
  full details of the journal/recovery process.

1.15 About Tagged Text
---------------------
  Tags are used  to  mark  sections  of  text  with  some  special  attribute.
  Typically, this will be display colour but tags are also used internally  to
  identify and to protect hash-table target  points  or  to  add  metadata  to
  points in the text. The metadata is in the form of a text string, this is an
  essential ingredient in jot mouse and menu-driven interfaces where  the  tag
  metadata is used to identify a mouse-event callback.
  
  Those familiar with vim and Emacs tags (of the sort generated  by  exuberant
  ctags), should note that jot tags are nothing to do with that.  In  jotspeak
  these are index files - see `about index files`.
  
  Each colour tag indicates a colour pair (i.e. a foreground and a  background
  colour) to be associated with the tag see `%b=tagtype`. The tags  are  added
  to text with the `%b=addtag` command.
  
  The colours associated with the tags are defined in the `%b=tagtype` command
  - this associates a colour pair with  a  user-supplied  name  which  can  be
  referenced by  the  `%b=addtag`  command.  The  names  must  not  exceed  12
  characters.
  
  The `%b=addtag` command adds a tag into the internal record data -  the  tag
  identifies the start and end points of the tagged substring.
  
  The tag definitions are associated with the buffer and are displayed by  the
  `query buffer` query. The tags are associated with records and can be listed
  using the `query tags` query.
  
  For windows there is no limit on the number of named tags you can  define  -
  although there seems little point in going beyond the 256 unique colour pair
  combinations that are possible with windows.
  
  For linux, there are only  64  possible  colour-pair  combinations  and  the
  curses system allows only 63 user-defined colour pairs.  The  63-colour-pair
  limit is a system limit - the total number of colour pairs  in  all  buffers
  cannot exceed this.
  
  This is what happens if the text is changed  on  a  line  containing  tagged
  text:
    - If a change (insertion, deletion or substitution) is  made  after  (i.e.
      right-of) the tagged text there is no effect on the tagging.
    - If the change happens before (i.e. left-of) the  tagged  text  any  tags
      then the tags are shifted left or right as appropriate.
    - If text is inserted deleted or substituted in a  tagged  substring,  the
      extent (n. of characters) of the tag remains unaffected but text covered
      is changed.
    - If the record is broken mid tag (e.g. by a B  or  A  command)  then  the
      extent of the tag is reduced to match the new record length in the first
      of the two new lines, no trace of the broken tab appears in  the  second
      new line.
    - If a new colour tag starts inside the scope of some outer colour tag the
      display effect is not guaranteed but, with the current  version  of  the
      editor, the inner tag is invisible even if it's end point is  after  the
      end of the first tag.

1.16 About the Operand Stack
----------------------------
  The operand stack allows  simple  arithmetic  operations  and  tests  to  be
  performed on objects (typically integer  quantities)  held  in  a  push-down
  stack. It can also hold real numbers and temporary buffers  created  by  the
  system query commands. The full range of operations is described  in  `Stack
  Operations`.
  
  The underlying C-language type for integer values is  long  long,  for  real
  values it's double.
  
  For the benefit  of  those  not  familiar  with  the  notion  of  stacks  in
  computing. Stacks are analogous  to  those  spring-loaded  plate  stacks  so
  beloved of institutional caterers. As clean plates are delivered, the  stack
  gets pushed down, as plates are taken off the next one pops up.  Note  that,
  when plates are added individually, the last one on is the first one  off  -
  this is a key property  of  computer  stacks  -  sometimes  known  as  LIFOs
  (Last-In First-Out).
  
  And so it is, with our operand stack, new values are 'pushed' onto the stack
  and later 'popped' off for processing. Each item on the jot stack is wrapped
  up in a little data structure called a stack frame, which play the  part  of
  plates in the above description. Many common arithmetic  operations  require
  two operands, for these, the top two operands are removed and the result  is
  pushed onto the stack.
  
  A stack frame can be detached from the stack, assigned  a  name  and  loaded
  into a hash table (see `about hashtables`),  from  there  it  can  later  be
  referenced by the same name and restored to the stack.
  
  Essentially the stack objects can interact with the text and the system  the
  following ways (see `Stack operations` for the full list):
    - Integer or real numbers picked up from the text (e.g. with `oi`),
    - Integers or real-number literals from the command line (see `OL`),
    - Integers generated by the random-number generator (see `OA`),
    - Integers describing the current focus  point  (i.e.  buffer  i.e.,  line
      number `ON` and character number`OC`),
    - Integers, Reals or Buffers held by hashtable data  objects  (see  `Using
      hashtable data`)
    - A temporary buffer created for as a destination buffer for  any  command
      that directs it's output to a buffer eg: %q~=date;.
    - Arithmetic and logical operations can be performed on  numerical  values
      (see `O+`, for example.
    - Values and strings can be written to the buffer text (see `OO`).
    - Numerical values can be extracted by indirect references - eg: %w '~;  -
      sets the window size to an integer picked up from the stack. If the  top
      stack frame is a buffer, then the current character of that buffer  must
      be pointing to one or more digits for conversion to  an  integer  -  see
      also `About command parameters`.
      
  If performing a straightforward text abstraction  (e.g.  `A`~)  or  maybe  a
  query to stack with %q~=... (see `%Q`), a new buffer  stack  frame  will  be
  created at the top of the stack. If, however, you  are  doing  a  cumulative
  abstraction (i.e. a~+,a~- or a~. - see `A`) then the item at the top of  the
  stack must be a buffer stack frame.
      
  Jot supports the usual arithmetic and logical operations and can use  values
  in the stack to control programme flow or values can be written to the text.
  Addition, for example, pops the top two values and  pushes  their  sum  back
  onto the stack (see `O+`).
  
  All arithmetic and comparison operations will  work  with  integer  or  real
  values, for mixed operations integers are first converted to reals  and  the
  results of such arithmetic is always real. Any attempt to perform arithmetic
  on a buffer-type will fail.

1.17 About Hashtables
---------------------
  Each buffer can have an associated hashtable. Hashtables are  referenced  by
  keyword - the keyword can be any unique string and each hashtable entry  may
  point to one of the following classes of data object:
    - A pointer to some point in the text - a JumpObj,
    - a stack-frame image - a DataObj,
    - a file section (a seek offset and a byte count) - a SetsectObj, 
    - a file  section  (a  pathName,  seek  offset  and  a  byte  count)  -  a
      SetfsectObj,
    - a (stack) data object DataObj - interchangeable with the stack  and  may
      be an integer or real value or a sub-buffer,
    - a deleted object - a ZombieObj.
  Any number of these five types of entry may coexist in the  same  hashtable.
  Note also, the buffer-type data entries may each support child hashtables.
  
  The JumpObj is essentially an index which allows fast references to  indexed
  text. Hashtables are a useful alternative to searching with the `F`  command
  when the buffer is extremely large or when a macro makes many references  to
  moderately large buffer making the searching a significant proportion  of  a
  macros execution time (see `hashtable jump`)
  
  The DataObj is a stack-frame (see `about the operand stack`) that  has  been
  detached from the top of the stack and can be copied back to  the  stack  as
  required, this works for any stack-frame type -  integer,  float  or  buffer
  (see `hashtable data`, `OV` and `OQ` commands). Data objects can be  swapped
  between the stack and the hashtables, note that the data-object buffers  can
  also have hashtables, leading to the possibility of unlimited hierarchies of
  hashtables.
  
  For data objects assigned to one of the main buffers, the syntax  is  pretty
  simple - to extract the value of an object  named  "fred"  hanging  off  the
  current buffer it would be:
> ov/fred/
  
  But to access an object named 'fred' hanging  off  data-object-buffer  named
  'jim', which is itself hanging off another data-object-buffer named  'brian'
  hanging off the primary buffer ( . )  -  we  might  just  plod  through  the
  hierarchy - first making the parent buffer current then  descending  to  the
  child ... etc.:
> z.oq/brian/z~ oq/jim/z~ oq/fred/
  
  That's pretty painful - so there is a path-specification syntax designed for
  delving into buffer hierarchies without having to constantly change focus:
    [<bufferKey>=][<PathElement1>[|<pathElement2>[| ... ]]]
  This is how we might use this syntax to access  the  object  "fred"  in  the
  hierarchy described above:
> oq/.=brian|jim|fred/
  
  While this syntax simplifies usage, and  makes  for  tidy  encapsulation  of
  objects, it still requires three relatively expensive  hashtable  operations
  to locate the data.  Note  that  that,  although  some  path  depth  may  be
  desirable - possibly essential for some  recursive  functions,  it  can  get
  expensive and programmers are urged to keep their data  structures  as  flat
  as possible.
  
  The code repository hashtable is useful for creating data structures as  the
  hashtable is created at startup  time  and  this  buffer  should  never  get
  deleted. When using the code-repository hashtable, the ( ' ) character  must
  be escaped in the pathname part of %H operations - e.g:
> %h=create \'=fred;
  
  The SetsectObj is intended for the handling of very large files, it  defines
  the byte-offset and  byte-count  of  sections  of  files  -  see  `hashtable
  setsect`, `hashtable setfsect` and the -section=<hastableKey> section of the
  `%I` command.
  
  The SetfsectObj is similar to SetsectObj except  that  it  also  includes  a
  pathname and is intended for support of collections of files  -  see  `about
  large collections of files`
  
  Typically what happens is the text is first scanned to identify  the  target
  points, and create hashtable entries. When queried, the editor  picks  up  a
  reference to the original target point an restores the editor focus to  that
  at the time when the entry was created.
  
  The ZombiObj exists because the gnu hashtables do  not  support  removal  of
  entries. When a `hashtable delete` request is made, the hashtable  entry  is
  left in place but the object it points to becomes a zombie.
  
  When a buffer object is duplicated on the stack (see `O#`) it is said to  be
  cloned. The original and the clone are identical and point have pointers  to
  the same underlying data structure.
  
  Note that stack-based buffer that has already been used to define  one  data
  object cannot be used to define another. This restriction is, hopefully, not
  very onerous since the same data can be accessed via the first data  object.
  The restriction comes about because, put simply, an object can only have one
  parent tree. In practice, as the hash-table trees are deleted, a data object
  shared between two different trees would acquire an undefined status.
  
  When a hashtable is destroyed by `hashtable destroy` or it's  parent  buffer
  is cleared (eg by the `A`, `%D`, `%Q`, `%I`, ... commands), then all of it's
  it's objects and any descendants are also destroyed. There may be clones  of
  destroyed buffers on the stack or the current buffer may be  a  clone  of  a
  buffer previously dangling off a destroyed hashtable. These remain effective
  and usable - but their hashtable path is removed as their parent buffers  no
  longer exist.
  
  For more details on hashtables, take a look at `Using Hashtables`.

1.18 About project files
------------------------
  Jot can be used to maintain a  stand-alone  file  or,  for  big  complicated
  projects, a suite of files  including  source,  documentation  and  whatever
  other text files that might constitute a code-development project.
  
  Project files should be placed in a dedicated  directory  (the  project-file
  directory) with a  startup  file  containing  all  project-specific  startup
  commands. The actual project files are usually ignored by the  editor,  they
  may be  used  for  storing  informal  project-specific  notes,  to-do-lists,
  checklists etc.
  
  An example project directory, startup file and project files are to be found
  at ${JOT_RESOURCES}/ide/... this directory was set up as an example for  the
  `ide.jot` script. It has the following subdirectories:
    - hello - a work directory for the hello project,
    - ed - a work directory for testing a development version of jot.
    - tree - a work directory containing a a simple suite of source files  for
      demonstration and testing of ide.jot and
    - projects - the project-file directory, this contains the following:
      - ide_hello - the project file for the hello.c project using ide.jot
      - ide_jot - the project file for jot development using ide.jot
      - ide_tree - the project file for the simple tree project using ide.jot
      - jot - the non-ide project file for jot development and
      - startup.jot - contains project-specific jot commands for all  projects
        in this project directory.
        
  Th example projects in  ${JOT_RESOURCES}/ide/projects  are  structured  such
  that the work directory sits alongside the projects directory,  in  practice
  the work area can be anywhere convenient to you.
        
  To initiate a project session, first cd to the projects directory then start
  the  editor  with  the  appropriate  project  file.  The  projects-directory
  startup.jot will set up the session using commands specified for your chosen
  project file. Note that  the  contents  of  the  project  file  are  usually
  ignored, you can use the project file for informal  notes,  tests,  examples
  checklists and to-do lists.

1.19 About index files
----------------------
  Index files contain pointers to specific points in one or  more  text  files
  and are used to facilitate rapid and convenient context changes.
  
  Jot supports two types of index files - the native jot format which is  used
  to drive the `%I` command with a seek and section-size specification and the
  vim-style tags file generated by the ctags unix command.
  
  The native-jot index files are optimised for navigating *very* large  files,
  where it would be impossible, or very inconvenient, to load and  search  the
  whole file - see `about large files`. The native-jot  index  form  has  also
  been adapted for use with large collections of files eg the source-file tree
  for a complicated programming project -  see  `about  large  collections  of
  files`.
  
  Jot also supports the  vim-style  tags  files,  these  can  be  conveniently
  generated by generated by ctags.
  
  The native-jot indexes supported  by  the  jot  scripts  `big_file.jot`  and
  `multi_file.jot` are significantly faster for very large  files  since  they
  use a filing-system seek to access the files and only read the  sections  of
  interest. The downside is  that  writing  modified  versions  of  the  files
  requires special care. Writing is supported by  big_file.jot,  the  modified
  file will usually require re-indexing as the seek points will have changed.
  
  In contrast, vim-style tags files read the entire file to a buffer making it
  easy to write an updated version but, because it needs to search the  entire
  file for each new section heading, it can be slow if there are any very  big
  files in the tree - this is most unlikely for normal source-code trees.

1.20 About Large Files
----------------------
  A working definition of a very large file is one big enough  to  exceed  the
  capacity of a text editor as supported by our system. That definition  takes
  into account various system configuration  and  tuning  considerations  like
  memory size swap size disc bandwidth cache size and all that sort of stuff.
  
  The main problem with *very* large text files is not changing them but  just
  viewing them. Although These files are generally both generated and read  by
  machine they are presented in a text form because people  need  to  work  on
  them when something goes wrong.
  
  These files are frequently used as intermediaries in CAD design flows  using
  design systems from rival vendors. Many are based on spice  netlists  and  a
  spice netlist of just a section of a modern chip is  never  going  to  be  a
  small file.
  
  So the way jot approaches  this  problem  is  to  acknowledge  that  nobody,
  pondering the problem of "what went wrong" or "why am I  seeing  that  error
  report" or "why that timing violation" is ever going to want to look at  all
  xxxGb of a file - only the bits that an investigation leads to. So we need a
  method that lets us pull in the relevant  bits  of  information.  There  are
  several qualifiers to the %I command that allow us to pull in selected parts
  of a big file and make it viewable - even  if  not  editable.  In  any  case
  modifying these files wouldn't do us much good  -  we'd  be  corrupting  the
  design flow.
  
  The `%I` command has a number of features designed to facilitate the reading
  big files. In %I, the -hold, -bytes and -block qualifiers  can  be  used  to
  read large files  by  the  spoonful  (or,  indeed,  by  the  bucketful)  for
  filtering or generating an index, as  in  the  `big_file.jot`  script.  This
  script  gives  a  more-or-less  normal  editing  environment  for  specified
  sections of large files.

1.21 About Large Collections of Files
-------------------------------------
  Many modern editors offer methods of  maintaining  source-code  trees  using
  some sort of index file. In vim and Emacs thes index files are  called  tags
  files but in jotland, in order to avoid unnecessary complexity, index  files
  are referred to as index files. Also as it happens, in  jotspeak,  the  term
  "tags" refers to little bits of metadata that can be attached to text -  see
  `about tagged text`.
  
  When working on some big complicated project, involving lots of source files
  or maybe, after downloading some source-code, one of the first  things  many
  of us like to do is to browse the source code to get some  idea  of  how  it
  works. 
  
  Unfortunately, the more complicated systems consist of  a  large  number  of
  source files and, without some  prior  knowledge  of  how  the  sources  are
  structured, it can  be  difficult  to  see  what's  going  on.  The  scripts
  `multi_file.jot` and `ctags.jot` are designed to help with this problem.
  
  These scripts each support  a  separate  index-file  format,  multi_file.jot
  supports one based on an extension of the form used  for  large  files  (see
  `about large files`) and ctags.jot supports vim-style tags files  which  can
  be conveniently generated by Exuberant Ctags.

2 Jot Programming
-----------------
 
2.1 Success, Failure and Errors
-------------------------------
  Most commands set a success/failure flag. Failures are quite normal in JOT -
  many commands are used simply to locate structures in  the  text  and  these
  failures are normally handled in the command sequence. One may, for  example
  want to test if the cursor is at the end of a record, then we might use  the
  move right (`R`) command and check it's status - a failure can  only  happen
  when the cursor is at the end of a line.
  
  Errors are more serious (typically a syntax error in your coding or  an  I/O
  operation that failed), these result in an immediate exit from  the  command
  sequence with a message in the console area. By default,  errors  will  stop
  execution of the current command sequence with a message  indicating  what's
  gone wrong - these can be suppressed using `%s=verbose` or `-quiet`.
  
  There is a message associated with failures too but these are suppressed  by
  default. If a command sequence  ends  with  the  error  flag  set  then  the
  termination message "{Command-sequence failed.}" is  issued  with  a  simple
  diagnostic indicating which command failed.
  
  If a command fails and no command is found to handle the failure,  then  the
  block or macro fails, if the failing command was not in  a  block  or  macro
  then a message like this appears at the console:
> {Command-sequence failed.}...<failingcommand>...
  
  See `%s=verbose` for details on controlling the level of error reporting.
  
  Failing commands are handled as follows:
   
     - If the next command is the ignore-failures command `?`, the failure  is
       ignored and processing continues.
        
     - If  a  failure  handler  exists  (see  the  `,`  command),   then   the
       failure-handler code is executed
       
     - If there is no failure handler, then the current block exits (see  `Jot
       command structure` and `(` `)` ).
        
       If the block was an infinite loop i.e. '( ... )0' then the  loop  exits
       without passing on the failure, all other types of blocks fail.
       
     - The \ (`reverse status command`) reverses the status of  the  preceding
       command you can also reverse the status of a command that's already had
       it's status reset by the  `?`  command  -  in  this  case  the  command
       *always* fails - which can sometimes be useful.

2.2 Jot command structure
-------------------------
  Jot allows users to construct macro-commands  which  can  apply  tests  make
  decisions and return results - they can also, of course, alter your text.
  
  Most commands are capable of failure, by looking at the status returned by a
  command we can often deduce something useful about the  text  we're  working
  on. If, for example, the `r` command fails it can only mean that the  cursor
  is already at the end of a line, if `f`/<string>/ fails then it  means  that
  string does not exist. When writing a macro-command these failures  are  not
  so much disasters as potentially useful results.
  
  Jot  commands  are  organized  into  blocks  bounded  by   round   brackets.
  Optionally, the sequence of commands within a block may be broken by commas,
  the sequence following the comma take control if a  failure  occurs  in  the
  sequence before the comma -  giving  us  an  if-else  structure.  Since  the
  else-sequence might fail successive commas can be deployed giving us  an  if
  ... elseif ... elseif ... structure. Ultimately, if the last sequence in the
  block fails then the *entire* block returns a failure. Blocks may be  nested
  to any number of levels.
  
  Jot blocks, like most jot commands, can be given a repeat count. As with jot
  commands this may be infinite the repeat count for a block must be a decimal
  literal immediately after the end brace. As with other jot commands  for  an
  infinitely repeating block, set the repeat count to zero. In the event of an
  unhandled failure occurring in a repeated block, the block exits immediately
  even if it has not gone through all it's iterations. In these  circumstances
  a   block   with   a   finite   repeat   count   returns   a   failure,   an
  infinitely-repeating block always returns success.
  
  A sequence of commands can be enclosed within parenthesis (see `(`  and  `)`
  ), this has the following effects:
   
    - The block can be used to define the  extent  of  `success,  failure  and
      errors` - in the phrase (r, m) ... , for example, if the r command fails
      (because we're at the end of a line), then it moves to the next line.
      
    - The block can repeat commands for a predefined number  of  iterations  -
      for example, the phrase (mi/#/)10 will insert a # at the  start  of  the
      next 10 lines. If a command in this type of block should fail, then  the
      loop exits early and the block sets the failure flag.
      
    - The block can be repeated to exhaustion - i.e. until something  fails  -
      for example l0(q/A-Z/c, r)0 will  change  the  case  of  all  upper-case
      characters on the line. In this case, a failing command will also  cause
      the block to exit, but the failure flag is reset.
      
    - The block's status can be handled like the status of any other command:
     
      - ( ... )? and ( ...  )123?  -  resets  the  failure  flag  following  a
        failure.
       
      - ( ... )\ and ( ... 123)\ reverse the status on exit.
      
      - ( ... )?\ and ( ... )123?\ - these blocks will always fail.
       
      - ( abc ) def , ghi - if the '( abc )' block fails then commands ghi are
        executed, otherwise it takes commands def.
        
    Here's a few examples:
      - ( ... , )0 - this block will loop indefinitely.
      - ( ... ,) and ( ... )? - these two have an identical effect,

2.2.1 Finite Repeat Block Example
---------------------------------
  (f/fred/s/bill/)23 - is  a  finite  repeat  block,  it  seeks  the  next  23
  occurrences of fred and substitutes bill. If there are less then 23 freds in
  the text then the F command fails and so to  does  the  complete  block.  If
  there are more than 23 then, on completion, there will still be some  fred's
  left.

2.2.2 Conditional Repeat Block Example
--------------------------------------
  (f/fred/s/william/)0 - is a conditional repetitive block, the thing keeps on
  finding freds and substituting williams until all  freds  have  been  found,
  then the `F` command fails, the block exits but in this case the block exits
  successfully.

2.2.3 Status Checking Example
-----------------------------
  (f1/fred/s/bill/, f1/jim/s/dave/) - If the current line has a fred at or  to
  the right of the current character, it will get changed to bill. If there is
  no fred then the failed f1 command leaves the  current  character  unchanged
  and searches the line for jim, if found then it gets changed to dave.

2.3 About macros
----------------
  Any buffer can hold sequence of commands, the commands in the buffer can  be
  executed as a macro command. Macro commands can  call  other  macros  -  but
  recursive macro calls (where a macro, or one of it's children, calls itself)
  are not allowed. The command to run a macro is a single quote ( ' ) followed
  by the buffer key.
  
  To run a macro place the macro-buffer key it in a command string prefixed by
  a single quotemark ( ' ) e.g:
> %d3=f/my_string/
  this macro is run as follows:
> '3 

2.4 Calling functions by name
-----------------------------
  Jot offers a primitive form of subroutine support, Sequences of commands may
  be entered in a buffer  and  then  referenced  using  the  `hashtable  call`
  command.
  
  Code  can  be  designed  to  operate  only  on  the   stack   resulting   in
  procedure-like behaviour. There  is  no  formally-defined  parameter-passing
  mechanism - programmers may use the stack or global buffers. But, it  should
  be noted, that there is no protection of stack objects - programmers must be
  very careful to maintain strict discipline in their stack operations.  Also,
  the only way back to the calling macro is to reach the  end  of  the  called
  sequence - there is no return command.
  
  The code repository set up by `startup.jot` is in the '  buffer.  The  first
  line of the code is, by convention, assumed to be the routine  name  and  is
  ignored by the %h=call command. 
  
  Where there are many routines defined by  the  normal  startup  script  (see
  `startup.jot`) saved in a buffer, there is no explicit mark denoting the end
  of each. Instead, the first line of the next  routine  is  used  as  an  end
  marker. The %h=call behaviour detects the end of a routine by  checking  for
  the existence of tags  on  each  record.  Any  tag  is  assumed  to  be  the
  hash-table target for the next routine in the repository. This  very  simple
  approach breaks if, for any reason, other tags have been added - so  do  not
  apply the `jot.jot` to the code repository.

2.5 About metasyntax
---------------------
  The following metasyntax has been used in this user guide:
    - a '$' in the first column represents a CLI prompt, the following text is
      something for you to type in response to whatever prompt your CLI uses.
      
    - a '>' in the first column represents a jot prompt, the following  string
      is something you type to the editor.
      
    - A key name in curly  brackets  indicates  that  this  is  a  button,  or
      sequence of buttons to press e.g:
> fred{F8}        - type the word 'fred' then hit the F8 function key
> fred{Shift+F8}  - type 'fred' then hold the Shift key and hit F8
> fred{Ctrl+F8}   - type 'fred' then hold the Control key and hit F8
> fred{Alt+F8}    - type 'fred' then hold the Alt key and hit F8
> 7 12{Esc b x} - type 7 a blank then 12 then hit the Escape key followed by
      the letter b followed by the letter x.
    
    - Anything else in angle brackets is intended to represent some  class  of
      command or command argument. e.g. <failingCommand> denotes some  command
      that failed, <n> any number, <alphaString> - any number of  alphabetical
      characters.
      
    - Something in double angle brackets  (e.g.  <<this>>)  represents  a  jot
      function defined in the startup file - normally you will  be  given  the
      key bindings to type in. You will see these mentioned in the user  guide
      ${JOT_HOME}/docs/jot_ug.html    and    in    the     startup     scripts
      ${JOT_HOME}/coms/startup.jot and ${JOT_HOME}/coms/curses_keys_<TERM>.jot
      
    - Something  in  square  brackets  is  optional  [   -bells][   -whistles]
      indicating that it's valid to give -bells and/or -whistles  or  neither.
      In some cases they are nested - e.g.: [ -bells[ -whistles]]  -  in  this
      case valid usage would be give -bells, -bells and -whistles or neither.
    
    - A list of things, separated by vertical bars ( | ) are valid options, in
      some cases you must give at least on of them  -  the  accompanying  text
      should clarify this.

2.6 Percent-command syntax
--------------------------
  Typical syntax of a percent command (for details see `percent commands`):
%da=f/example/;
  The first character after '%' is the command character,  'd'  in  this  case
  defines a buffer. As with many percent commands, the  next  character  is  a
  buffer key. The text following the '=' is often  a  simple  string  argument
  for the command.
     - for %A the character is not a buffer key but the exit status.
     - For %B the buffer key identifies the buffer affected by the command.
     - %C, %L, %O, %S, %U, %X do not accept any buffer key.
     - For %D, %E, %F, %G, %I,  %M,  %Q  the  key  identifies  the  buffer  to
       receive output from the command. 
     - For %H the key identifies the buffer hashtable to be affected.
     
  Some  of  these  have  sub-commands  and  qualifiers,  these  are  all  case
  insensitive e.g:
> %q=dir -size -atime <pathName>
> %o -append [<pathName>]
  These may be abbreviated, the minimum abbreviated  length  is  indicated  by
  capitalization in the detailed descriptions.
> %q=di -s -a <pathName>
> %o -a [<pathName>]
  
  For most of these commands, all or part of the  text  following  the  equals
  sign ( = ) may contain an indirect reference to the  current  line  of  some
  other buffer e.g:
%d$=dir /home
%q~=dir '$
  or, more usefully:
%q$=env JOT_HOME; m
%q~=dir '$
 
  Historically, these commands occupied a complete command line on  their  own
  with no terminating character. This made it difficult to incorporate percent
  commands in command sequences, so now they may be terminated by a  semicolon
  ( ; ) and other commands may follow, in the same line. The  only  exceptions
  are comments - where all text to the right of the %% is ignored.
  
  Many of these commands accept string arguments and there  are  some  special
  syntax rules for these:
    - Strings are composed of a list  of  any  number  of  ampersand-separated
      substrings,
    - Substrings  are  defined  as-is  apart  from   the   following   special
      characters, all of which are escaped with a backslash ( \ ) character
        - Backslash ( \ ) escapes any special character.
        - Ampersand ( & ) the substring separator character.
        - Semicolon ( ; ) - terminates the percent command.
        - Quote ( ' ) - if first character of the substring,  this  introduces
          an indirect reference to another buffer,  stack  item  or  hashtable
          item any text following the buffer reference is ignored.  Any  quote
          appearing later in the substring passes unaffected.
        - Carat ( ^ ) - if first character of  the  substring,  this  converts
          the following character to a control character  any  text  following
          the buffer reference is ignored. Any carat appearing  later  in  the
          substring passes unaffected.
    - substrings  may  refer  to  other  root   buffers   by   prefixing   the
      single-character buffer key with  a  quote  (  '  )  but  the  referring
      substrings may not contain any literal strings,
    - substrings may refer to an item at the top of the stack with '~,  again,
      this substring may not contain any  literal  text.
    - substrings may refer to a  floating  buffer  with  a  pathname  but  the
      referring substrings may not contain any literal strings
    - References to a buffer, a floating buffer or a stack are substituted  as
      follows: 
      - Integer values are converted to strings by substituting a "%D" format,
      - real values are converted to strings using engineering format and
      - buffers by substituting the current record of the buffer.
    - If required, the substring may continue  for  any  number  of  lines  by
      placing an ampersand at the end of incomplete lines.
    - The maximum allowable length for a string argument is currently  set  at
      1024 characters.
      
  Note that the behaviour of `%A` is an anomalous in this respect. Whereas  an
  indirect reference a buffer will be substitued  with  the  current  line  of
  that buffer, for %A it writes the entire buffer. This is to  facilitate  the
  writing of longer messages on exit.
      
  Note that quotemarks ( " ) have no special significance in  jot.  These  may
  be used freely in messages, search and insert strings without escaping.
  
  This syntax allows the  construction  of  strings  comprising  both  literal
  strings, and simple and floating buffer references.
  
  For cases where the same string passes by  the  command  scanner  more  than
  once, additional backslashes may be added, the command  scanner  strips  one
  from each series of backslashes at each pass.
  
  Some examples follow - the %M command echos the string back to  the  console
  area:
> %m=abc;
abc
> %m=abc\;def;
abc;def
> %m=abc\&def;
abc&def
> %da=1234567890; %m=abc&'a&def;
abc1234567890def
> %h.=create 10; %h.=data fred; %d~=def; ov/.=fred/ %m=abc&'.=fred&ghi;
abcdefghi
> %dq=abc&^Xdef&ghi; zqp
abc~def

2.7 Using Hashtables
--------------------
  Hashtables offer a good way of  rapidly  accessing  data  objects  scattered
  around in an unstructured mass. Although initially introduced to the  editor
  as a way of finding predetermined points in a large file image  (see  `Using
  Hashtables to Locate Text`), their range has been expanded  to  calling  jot
  functions (see `calling functions by name`), fast access of large files (see
  `about large files`), accessing large collections of moderately-sized  files
  (see `about large collections  of  files`)  and  storage  and  retrieval  of
  generic data (see `using hashtable data`).
  
  All %h commands can refer to hashtables belonging to other buffers e.g.  the
  command "%hz=jump fred;'" will search for an entry "fred" in  the  hashtable
  associated with buffer z, whereas "%h=jump fred;" will search the  hashtable
  in the current buffer. 

2.7.1 Using Hashtables to Locate Text
-------------------------------------
  The `hashtable newjump` and `hashtable addjump` commands  provide  a  method
  of indexing and rapidly returning to sections on the text image.
  
  Internally, this works by storing internal memory addresses of text  targets
  in the hashtable. The hashtable entry points to a  record  descriptor  which
  remains constant even if text has been added or removed in the buffer and  a
  target-point tag is inserted in the record metadata.
  
  The target is the selected substring at the time when the  hash-table  entry
  was first created. Now future changes to the  text  may  change  the  record
  containing the target but the target  substring  must  match  the  hashtable
  entry. In this context there are two important classes of change to consider
  - changes which only move the target to a new location and changes that
  delete the target string.
  
  The `hashtable jump` command returns to same focus point as when  the  entry
  was created with the `hashtable newjump` and `hashtable  addjump`  commands.
  It also maintains the original line number - this might now be  wrong  since
  changes to the target buffer may have altered the actual line number  -  but
  the linenumber entry in the hashtable is out of date. If this is  a  problem
  then use the  `hashtable  fix`  command  to  update  line  numbers  held  in
  hashtables.
  
  When the context switch happens, the line number in the target buffer is set
  to the line number at the time when the entry was created. This may  now  be
  incorrect if records have been  added  or  deleted  between  the  hash-table
  target points.
  
  The editor automatically adjusts hashtable entries when changes  have  moved
  the target. It offers several options for situations when the target  string
  has been deleted.
  
  The simplest method is to  make  the  target  buffer  readonly  (the  buffer
  containing the  target  string  -  see  `%b=readonly`).  Making  the  buffer
  ReadOnly is a simple and totally effective but it is quite restrictive.
  
  Another option is to automatically destroy the hashtable when target records
  are deleted - this is appropriate when the usage  implies  that  any  change
  requires a hashtable rebuild - see `hashtable create`.
  
  Another option is to protect records  containing  the  target  strings  from
  deletion - see `hashtable create`.
  
  Another option is for the hashtable target points to be adjusted to point to
  the next available point in the text - see adjust in `hashtable create`.
  
  Finally, the default option,  is  to  just  remove  the  hash-table  entries
  pointing to deleted targets, this is the default behaviour - see  delete  in
  `hashtable create`.
  
  For examples of %h=jump - look at ${JOT_HOME}/coms/qr.jot (see `qr.jot`).

2.7.2 Using Hashtable data
--------------------------
  The primary focus for arithmetic and logical operations is  the  stack  (see
  `about the operand stack`) - values and strings can be placed on the  stack,
  manipulated and either written to some buffer or used to  control  programme
  flow. The `hashtable data` command is essentially the declaration of a  data
  object. The value of this object can be copied to and from the  top  of  the
  stack.
  
  Once defined by the hashtable data command, a value can  be  assigned  using
  the `OV` command which pops the stack and  copies  the  value  to  the  data
  object.
  
  Note that the hashtable data command does not require the specification of a
  data type - the type of data (an integer value, a real value or a string) is
  defined at the time when a value is assigned. In  fact  it  is  possible  to
  change the type of a data object any number of times.
  
  The value can be retrieved using the `OQ` command, essentially  the  reverse
  of OV, the value is copied to a new stack frame and pushed onto the stack.

2.8 The jot debugger
--------------------
  The editor has various features designed for  the  monitoring  of  execution
  flow and the location and analysis of bugs. There  are  various  methods  of
  probing the internal state of the editor and various methods  for  selecting
  break points. It supports a simple single-step debugger with various options
  for controlling the step range and the amount of  information  displayed  at
  each step - see `About jot debugging`. The break point can be defined in the
  following ways:
    - Explicitly by inserting the `T` command in the code what this does is to
      set the trace vector (see `%s=trace` and `%s=tracedefault`),
    - by setting the command counter - see `%s=commandcounter` or
    - by selecting one of a set of predefined event classes - see `%s=trace`.
    - Tracing of blocks, macros etc. can be skipped using  the  `%s=traceskip`
      command - see also `DebuggerQuit`.
    
  The T command is easily inserted into the source code of any  script,  macro
  or command line. Where this is not selective enough, the T  command  can  be
  made conditional e.g.: ... (v/fred/t, ) ... will only trigger the trap  when
  the text at the current character matches the string "fred".
  
  Frequently if is useful to skip over a block, macro or function call  or  an
  entire script. This can be accomplished using  the  `DebuggerQuit`  function
  ({Esc+Q}) - which uses the `%s=traceskip` command. Typically  this  will  be
  used when single-stepping through some code and we want to step-over, say, a
  macro call - see `Using %s=commandcounter in debugging`.
  
  See `%s=trace` for details on how to set the trace vector - essentially, the
  trace vector controls when a trace-point occurs (every  command,  every  new
  line etc.) and what trace activity is to be triggered  at  these  points  (a
  Breakpoint, display the source line, display of  current  line,  stack-dump,
  backtrace etc.)
  
  Another potentially-useful debugging tool is the `%s=on_int` command. When a
  function enters an endless loop a {Ctrl+C} interrupt  is  the  only  way  of
  exiting it - but, by default it leaves no  clue  what  was  going  on.  This
  allows the specification of some commands to be executed before execution is
  terminated. Typically, this might be a backtrace or a trace point.

2.9 Using %s=commandcounter in debugging
----------------------------------------
  The command counter method is useful when a  data-sensitive  failure  occurs
  deep into many re-iterations of programme loops or when a script or function
  fails  under  mysterious  circumstances.  In  order  to  use   this   method
  successfully it is first necessary to identify the command count just before
  the point of failure. Having done that, it's possible to set a debugger trap
  at some point just before the failure using the `%s=commandcounter`  command
  and re-spin your script or function.
  
  Before setting the trap it is necessary  to  find  how  many  commands  were
  processed leading up to the failure but note that  the  command  counter  is
  reset at the start of a session and then after every interactive  operation.
  Here are some useful ways of obtaining the the command counter:
  
  - System error reports always include the state of the command counter.  The
    following messages in particular:
      - "-init sequence failed."
      - "Command-sequence failed."
      - "Last command failed."
      - "Attempt to modify a readonly buffer"
      - "Incorrect stack-frame type, expecting integer frame, found frame type"
      - ...
    The command counter is wrapped up in braces immediately after the  message
    e.g: for the message
      {-init sequence failed. (3097) (line 1 of buffer i)} ...
    the command counter was 3097.
    
    Note  that  most  of  the  other  messages  do  not  include  the  command
    counter - to request it with these set bit 10 of the verbosity mask -  see
    below.
  
  - When the terminating message is not one of those, try setting  bit  10  of
    the verbosity mask  (see  `%s=verbose`)  will  show  the  command  counter
    alongside every message. The problem with this is that, normally, ordinary
    failures do  not  generate  message  -  so  you  might  have  to  set  the
    Verbose_QuiteChatty bit in the verbosity mask (see `%s=verbose`) and stand
    by for a possible flood of messages. e.g:
> %s=verbose 13;    %% Displays the command counter in all messages.
> %s=verbose 17;    %% As above but displays all possible messages.
    
  - The `query system` command will show the counter but, unfortunately typing
    in this command will reset the counter - so  we  need  to  plan  ahead  by
    putting this command as a failure handler - e.g:
> %r=failing_script;, %q?=status;
    The state of the command counter appears in the `query system` report.
    
  - Adding the CLI qualifier -hold will cause the current state of the command
    counter to be displayed in the exit message. This is a useful option  when
    the failure occurs in the  -init  command  string  (see  `debugging  -init
    sequences`). e.g:
$ jot ... -in="failing_script.jot;" -hold
  Then make a note of the command counter (say 123456)  and  set  the  counter
  a few steps lower for the re-spin:
$jot ... -in="%s=cc 123450; %r=failing_script.jot;"
  (%s=cc is a valid abbreviation for `%s=commandcounter`).
  
  See the walkthrough exercise at `setting command-counter breakpoints`

2.10 Jot for experienced ecce users
------------------------------------
  The first, most obvious difference between jot and ecce is  that  jot  is  a
  screen editor - it maintains a window as an accurate reflection of the  what
  the file image is currently looking like.
  
  The next significant  difference  is  that,  whereas  ecce  would  only  use
  printing characters for controlling the editor, jot also  utilizes  function
  keys and, where available, the numeric and mid keypads.
  
  Internally, the structure is  quite  different,  ecce  used  the  buffer-gap
  structure which made good use of simple memory schemes available  in  1960's
  minicomputers. In contrast jot uses  a  less  efficient  but  more  flexible
  record-descriptor structure better suited to  modern  approaches  to  memory
  management.
  
  Comparing the command set of ecce with jot, we  see  a  few  old  favourites
  have been culled (D, T, U have been abolished or reassigned  new  meanings).
  However, for the percent commands, the cull is more like a total bloodbath
  - only %A, %C, %I and %O remain in anything like their original forms.
    - `A` - can now abstract to the nearest character (see `N`), and  has  new
      '+', '-', '.' and '&' qualifiers.
    - `B`, `C` - identical.
    - D Abolished.
    - `E`, `F`, `G` - pretty much unchanged.
    - `H` - has new '*' qualifier.
    - `I`, `J`, `K` and `M` - unchanged.
    - L - abolished - use `R`- instead.
    - `N` has new '.' qualifier for abstraction to nearest character.
    - `M` - has new '*' qualifier (move window).
    - O - Reassigned - now prefix for `stack Operations`.
    - `P`, `Q`, `R` and `S` - unchanged.
    - `T` Reassigned as Trace point, traverse replaced by f/<string>/- .
    - U - abolished.
    - `V` - unchanged.
    - `X` - was macro-X call, now eXits or repeats selected block.
    - `Y` - was macro Y call, now Y command (move in column).
    - `Z` - was macro Z call, now zoom (i.e. change current buffer).
    - `%A` - Now accepts exit status and exit message.
    - `%C` - essentially unchanged.
    - `%D` - Reassigned, now defines a one-line macro/text buffer.
    - `%F` - Reassigned - now search with options.
    - `%G` - Reassigned - now defines (Gets) multi-line macro/buffer.
    - `%H` - New Command - for hashtable maintenance.
    - `%I` - unchanged except for new options.
    - `%L` - Reassigned - (case sensitivity set by %S)  now  defines  terminal
      line length and no. of lines.
    - `%M` - Reassigned prints message to console area.
    - %N - Abolished.
    - `%O` - Still writes file image to filing system but with new options.
    - `%Q` - Reassigned - now system Query.
    - `%R` - Reassigned - now Run a command script (file).
    - `%S` - Replaced by `Z` command, %S now System interaction.
    - %T - Abolished.
    - `%U` - Reassigned - (now use %S to set case  sensitivity)  now  reverses
      last substitution.
    - `%W` - Reassigned - now assigns buffers to windows.
    - `%X` - Reassigned - now prints specified message in the console area and
      eXits.
    - %Z - Abolished.

3 JOT primitive commands
------------------------
  This section describe the primitive  (i.e.  basic  built-in)  commands.  For
  details of jot functions and key sequences see `JOT User Guide`.
  
  JOT has the following primitive commands, meta-commands and modifiers,  most
  are capable of failing in some way, failures normally result in the  raising
  of the failure flag (see `success, failure and  errors`),  this  can  affect
  execution flow:
    - `A` - Abstract (remove or copy) all Text From Note Point (see `N`).
    - `B` - Break Line At Current Character
    - `C` - Change Case
    - `E` - Erase bytes [defaults to 1]
    - `F` - Find Substring
    - `G` - Get (read) Some Lines From Terminal
    - `H` - Here (copy Text Buffer Here)
    - `I` - Insert Substring
    - `J` - Join This Line With Next/previous Line(s)
    - `K` - Kill (delete) record(s)
    - `M` - Move To A New Line
    - `N` - Note This Point In Text For A Later Abstract Operation
    - O - `Stack Operations`
    - `P` - Print Line(s)
    - `Q` - Qualify (tests next chr. for membership of string)
    - `R` - Move Cursor Right
    - `S` - Substitute current substring for given string
    - `T` - enter (Trace) debug (single-step) mode
    - `V` - Verify (tests immediate for match with substring)
    - `X` - eXit or re-iterate current (or selected parent) block.
    - `Y` - Move Cursor In Y Axis
    - `Z` - Zoom to Another Buffer
    - `(` - Block start
    - `)` - Block end
    - `,` - Else clause
    - \ - `Reverse status command`
    - `?` - Ignore status of previous command
    - % - Mainly housekeeping - see `percent commands`

3.1 R
-----
R[n] - shift Right by n characters (bytes if unicode support is turned 
  off - see `Unicode - the gruesome details`).
   
  Move character pointer n[1] places to the right, it  fails  and  raises  the
  failure flag if there is an attempt to go past the  end  of  the  line.  For
  non-unicode characters one byte is equivalent to one character. For  unicode
  characters, if unicode support has been turned  off  (see  the  `%b=unicode`
  command) the current-character pointer may be left pointing to a mid-unicode
  byte. See also `OR` command and `about unicode`.

3.2 M
-----
M[[=|-]n]|[*[-]] - Move to start of specified line.
    - M moves forwards by one line.
    - M<n> Moves forwards by n lines.
    - M* Moves forwards sufficient lines to view next page on screen.
    - M- moves back by 1 line.
    - M-<n> moves back by n lines.
    - M*- (or M-*) Moves back  sufficient  lines  to  view  previous  page  on
      screen.
    - M0 moves to last line of file.
    - M-0 move to first line of file.
    - M=<n> moves to absolute line no. n
     
  The command raises the failure flag if there is an attempt to move past  the
  last line or before the first line of the file.

3.3 X
-----
X[-][n] - eXit or re-iterate current, or selected parent block.
  
  - X[<n>] exits the selected block.
  - X-[<n>] - returns control to the beginning of the selected block.
  - X0 is a special case, it exits the innermost macro,  function  or  script,
    effectively a return.
    
  The X command with  a  +ve  argument  causes  the  selected  block  to  exit
  immediately, with a negative argument it causes to selected block to  repeat
  from the start. The numerical value specifies which of the enclosing  blocks
  to exit or repeat. A value of 1 (or -1) specifies the current block,  2  (or
  -2) it's enclosing block ... etc.
  
  The X command does not affect the current value of the block-repeat counter.
  
  In this context a block means any code-sequence enclosed by round braces and
  the current macro or function call. The range of the X command is limited to
  the current macro-command or function. Other than returning a  status  value
  the X command cannot affect blocks in the calling code sequence.
  
  On exit the status is usually set to success, a  backslash  (  \  )  can  be
  appended to change the status to failure.

3.4 Y
-----
Y[[=|-]n]|[*[-]] - move in column (Y axis) by [n] lines.
Y0 - Reset the column traversed by subsequent Y commands.

  Similar to the `M` command except that it up and down in a column of text.
  
  If it passes through a line that is  too  short  to  maintain  the  columnar
  movement, the cursor is left at the end of the line but the original  column
  number remains stored internally. If some subsequent invocation of Y  passes
  through lines of  sufficient  length,  the  original  columnar  movement  is
  restored.
  
  The special case y0 will reset the internally-stored column number. It  does
  not affect the cursor position but causes the *next* y command  to  redefine
  the column number.

3.5 E
-----
E[-][<n>] - Erase n bytes to the right [ or left] of the cursor.
   
  Erase next[previous] n[1] bytes. If n is finite and would cause  the  cursor
  to go out of bounds the failure flag is  raised.  With  a  positive  arg,  E
  deletes the bytes from the currently-selected character  and  characters  to
  it's right. With a negative arg, it deletes bytes  from  characters  to  the
  left of the current chr.
  
  The programmer must be aware that one byte is  not  necessarily  a  complete
  character - see `about unicode`.

3.6 P
-----
P[-][<n>] - print line(s).
   
  Prints (displays in the console area) the next[/previous] n[1] lines.  If  n
  is specified, and is greater than 1, or less than -1, then the current  line
  is set to the last line printed. If the value of n  would  cause  it  to  go
  outside the range of the current buffer then the failure flag is raised.

3.7 F
-----
F[-][range][<delim><string><delim>|'<key>][-][rpts] - Find
   
  Search text for specified string. If found the substring is highlighted  and
  becomes the selected substring. -  see  `About  the  current  character  and
  substrings`
  
  The F command takes parameters which specify the search string, a range  and
  repeat count.
  
  By default JOT starts off  in  it's  case  insensitive  mode,  this  can  be
  modified by the '%S=case' command.
  
  If there is no currently-selected no substring, the  search  starts  at  the
  current character. If there is a substring, the search starts one characters
  after (or one character before, in the case of F-) the start of the  current
  substring.
  
  For unsuccessful forwards-looking multi-line searches the current  character
  is  left  at  the  start  of  the  last  searched  line.  For   unsuccessful
  backwards-looking searches current character is  left  at  the  end  of  the
  last-searched line.
  
  For unsuccessful single line searches (i.e. when the range parameter is  set
  to 1) the current character pointer is left unchanged for both forwards  and
  backwards-looking searches.
   
  Parameters:
  
    - 1 Direction, a '-' will cause it to search back towards the start e.g.
        f-/abc/
  
    - 2 Range  specifies  the  max.  no.  of  lines  to  search  (defaults  to
      unlimited). e.g. f3/abc/ -  this  will  search  the  next  three  lines,
      including any of the current line to the right of the cursor.
  
    - 3 The string can be a literal string delimited by  any  non-alphanumeric
      ASCII character that does not appear in the string  e.g.  f"abc",  also,
      the ' character cannot be used - see `about  command  parameters`.  N.B.
      unicode characters cannot be used as delimiters.
      
      The second delimiter may be omitted is there are no further commands  or
      modifiers on the command line - e.g. f/monday
      
      Alternatively, the '<key> form will search for a match  to  the  current
      line of the nominated buffer e.g. f'@ - see `about command parameters`.
      
      Finally, if no find string is specified,  then  it  uses  the  last-used
      literal search string.
      
   e.g: in the following, the first command finds the next occurrence  of  the
   string 'fred', the next find locates the string indicated  by  the  current
   record of the $ buffer and, finally, it locates the next  instance  of  the
   string 'fred'.
> f/fred
> f/'$
> f
      
    - The optional hyphen after the search string causes the current-character
      pointer to be left after the end of the substring. By default it is left
      at the first character of the substring.
> f/fred/-
  
    - 4 The final parameter is used to repeat the search. e.g.  f/abc/23  will
      stop at the 23rd. occurrence of "abc".
      
  See also `%F` - search with options and `%S` to change case sensitivity.

3.8 T
------
T - Trace
  
  This sets the trace vector to the  value  specified  by  the  default  trace
  vector. By default the trace vector is  0  (no  tracing  activity)  and  the
  default trace vector is set to  Trace_Stack,  Trace_Print,  Trace_Break  and
  Trace_AllCommands this means:
    - It will report the stack contents at each trace point,
    - it will print the current line of the  current  buffer  at  every  trace
      point,
    - it will enter an execution breakpoint at every trace point and
    - the trace point will be every command.
  
  Alternatively, the trace vector can be set explicitly  with  the  `%s=trace`
  command. The default trace vector can be redefined with `%s=tracedefault`.
  
  See also `about jot debugging` and `the jot debugger`.

3.9 Q
------
Q[-][<delim><string><delim>|'<key>] -  Qualify
  Tests for existence of any of a specified set of characters in substring.
  
  The argument string can contain any ASCII and unicode characters but, for  a
  range of character codes (see below), ASCII and unicode should not be  mixed
  in the same range.
   
  The character at [or before] the current character position referred to here
  as the "match character") is compared to the character set specified by  the
  string parameter, if one of the specified set of characters matches then the
  command returns successfully, otherwise if reports a failure. The Q  command
  is invariably case sensitive and has no effect on the text file image.
  
  If, instead of the <delim><string><delim> syntax, the '<key> syntax is used,
  then the qualifying string is in the current line of the specified buffer.
  
  The string may be a simple list of all allowable characters, or may  specify
  a range of ASCII characters ordered by their ASCII codes, to  match  to  the
  literal '-' character it should be the first  or  last  in  the  string  for
  example:- Q/0123456789/ Will match to any digit. Q/0-9/ Will do the same but
  saves typing. Q/0-9+-/ Will match to any digit or the '+' or '-' characters.
  Q/0-9A-Fa-f/ Will match to any Hex digit.
  
  If the character set includes  unicode  and  the  match  character  is  also
  unicode, then the character and the string are both converted to native  UTF
  and the comparison is done in UTF. This is one of the  few  instances  where
  jot operates on full-width unicode - see `practicalities of unicode etc. and
  jot`.

3.10 V
-----
V[-][string] - Verify string.
   
  Verify - tests text at current character position for match with string.
  
  If the given string matches the substring to the right of  the  cursor  then
  the substring is highlighted and becomes the `About  the  current  character
  and substrings`. If not then the failure flag is raised. Correspondingly, V-
  verifies the text to the left of the cursor.

3.11 C
------
C[-][n] - Change case.
   
  Change case of next [previous] n characters. If n  is  specified  and  would
  cause the cursor to go out of bounds the failure flag is raised.
  
  Note that the C command has no affect on unicode characters.

3.12 I
------
I[-][string][n] - Insert substring
  Inserts specified substring before current character.
    
  The optional '-' parameter only affects the position of  the  substring  end
  pointer on completion - normally the cursor is immediately after the end  of
  the inserted substring I- causes it to be at the start.

3.13 S
------
S[-][<delim><string><delim>|'<key>] - Substitute
  Replace the currently-selected string with the given string.
   
  If a substitute  string  is  defined  then  this  is  replaces  the  current
  substring,  if  no  substitute  string  is  specified  then  the  last  used
  substitute string is used.
  
  When the '<key> syntax is used, the substituted string  is  taken  from  the
  current line of the specified buffer.
  
  This command normally only fails when the current buffer does not  currently
  have a valid substring `About the current character  and  substrings`  (e.g.
  following a F, T V or a previous S command) - when it fails the failure flag
  is raised.

3.14 B
------
B[-][n] - Break line.
   
  Where n is an optional (defaults to  1)  repeat  count,  on  completion  the
  character pointer is left at the beginning of the second line (i.e. it still
  points to the same character), except if a negative repeat count is entered
  - zeros are not allowed for break counts.
  
  A negative repeat count will break the line the same  number  of  times  but
  will leave the character pointer at the end of the first half line.

3.15 G
------
G[<n>] - Get 
  Read a new line(s) of text or single character from the keyboard.
   
  Use this to key in new text above the current line, the parameter  sets  the
  number of lines to be input or you may terminate with a control+C or a colon
  ':' at the beginning of an otherwise empty line.
  
  By default it prompts with "> " but you may define the prompt  string  using
  `%s=prompt`.
  
  If a linecount is specified and an early exit is forced,  then  the  failure
  flag is raised.
  
  See also the `%G` command, which reads lines  from  the  current  script  or
  macro and the `OG` command, which reads single characters to the stack.

3.16 J
------
J[-][n] - Join
  Joins current line with next (or previous) line.
    
    - J Joins the current line with the next line
    - J- Joins the current line with the previous line
    - J<n> joins the next n+1 lines
    - J-<n> joins the previous n+1 lines
    
  If join runs out of lines (because it's at the start/end of the buffer) then
  the failure flag is raised.

3.17 K
------
K[-][n] - Kill i.e. delete line(s).
   
  This completely removes lines and there is no way of getting them back. If n
  is specified and finite and it runs out of lines to kill, then  the  command
  fails. K0 deletes the current line and all subsequent lines, K-0 deletes the
  current line and all previous lines.
  
  K- deletes the current line and leaves the cursor at  the  begining  of  the
  line above, similarly K-n deletes the current line and  up  to  (n-1)  lines
  above leaving the cursor at the begining of the line above the last  deleted
  line. If the first line was deleted, then the cursor is left at the begining
  of the line following the original current line.
  
  Note that there must always be at least one line in a  buffer.  To  maintain
  this situation, an instruction to kill the last record in  the  buffer  will
  only erase all the text leaving an empty record - it will also fail.

3.18 N
------
N[.] Note
  Note = Note line [and character] number for later abstract.
  
  This sets the start point of one or more lines of text  to  be  moved  by  a
  later abstract `A` command. 
  
  Without the ( . ) modifier, complete lines are  removed  by  the  subsequent
  abstraction. 
  
  With the ( . ) modifier, all lines and characters are abstracted between the
  current character position when the N command was given to that at the  time
  of the A command.
  
  See also `A` and `H` commands.

3.19 A
------
A<key>[+|-|.][&] - Abstract
  Abstracts (moves) text from note point to current character (see  `N`)  into
  the nominated buffer.
   
  If the whole-line abstraction flag is  set  (see  `N`  command),  then  only
  complete lines are moved.
  
  The optional '+' qualifier places the abstracted text after the end  of  any
  preexisting text in the destination buffer, '-' similarly places  it  before
  the start '.' places at the current character in the destination buffer.  If
  none of these qualifiers are specified then the buffer is cleared before the
  new text is abstracted. The current  character  pointer  of  the  buffer  is
  always left at the beginning of the of the last line of abstracted text.
  
  The optional & qualifier copies the text without changing the original. This
  is essential if abstracting from a readonly buffer - see `%b=readonly`.
  
  The two valid optional qualifiers must follow the buffer key but not in  any
  particular order.
  
  If the abstraction fails (typically because no note-point is set)  then  the
  failure flag is raised.
  
  See also `H` and `N` commands.

3.19.1 Abstraction options
--------------------------
  Abstraction in jot is similar to ecce - by default, the n (note) and  the  a
  (abstract) commands abstract only complete lines.
  
  By default jot abstracts complete lines - like ecce. By adding the .  option
  to the note command it abstracts to the nearest character.
  
  Cumulative abstraction - by default the destination buffer is first  cleared
  of any preexisting text only  the  abstract  appears  in  the  buffer  after
  abstraction.
    - The + qualifier adds the now text to the end of any preexisting text  in
      the destination buffer.
    - The - qualifier prepends  the  abstracted  text  to  the  start  of  any
      preexisting text.
    - The .  qualifier  inserts  the  new  text  at  the  destination  buffers
      current-character point.
   
  Non-destructive abstraction. By default text  is  removed  from  the  source
  buffer. For non-cumulative abstraction  it's  easy  enough  to  restore  the
  abstract it immediately after but this process sets an internal  marker  tag
  indicating that the buffer has been modified - this is not  always  helpful.
  The '&' qualifier will abstract without changing the source text or  setting
  the marker tag.

3.20 H
------
H<key>[<count>] - copy Here
  Contents of specified buffer (the source buffer) is copied to current buffer
  (the destination buffer) either to the current character position  or  above
  the current line.  There  is  a  status  flag  in  the  source  buffer  that
  determines which.
  
  If the source buffer was itself defined by abstraction part lines (using  N.
  - see `N`) then the buffer is inserted at  the  current  character.  If  the
  source buffer was defined in any other way (e.g: abstraction with  N,  `%D`,
  `%G`, `%I` or a `%Q` query) then the source  text  is  inserted  immediately
  above the current line.
  
  The abstraction-status flag is invisible except in the  "wholeRecords"  line
  of a `query buffer` report.
  
  The effect of the optional count is to insert the text that many times.
  
  See also `N` and `A` commands.

3.21 Z
------
Z<key> - Zoom (change focus to nominated buffer)
  
  Changes the current buffer to the one identified by the buffer key.
  
  The the key for the  current  buffer  is  displayed  in  the  editor  prompt
  following the line number, it is also be displayed in the  window  separator
  lines (see `%w` command).
  
  See also `OB` and `OZ`

3.22 (
------
( - Block start
   
  The block of commands must be terminated by a ')', it may contain any number
  of valid jot commands, including sub blocks. See also `)` and  `jot  command
  structure`.

3.23 )
------
)[<n>] - Block end.
   
  This terminates the current block, if a repeat count ( <n>  )  is  specified
  then the block is repeated that many times or until the block fails, if  the
  repeat count is zero then the block only exits when something in the command
  sequence fails but, overall, a zero-repeat block never fails.
  
  If repeat count finite or  not  given,  then  any  failure  in  the  command
  sequence is passed on upwards. See also `(` and `jot command structure`.

3.24 ,
------
(<anyNumberOfCommands>, <failureHandler>) - Failure handler.
   
  The commands following the comma are only executed when some earlier command
  has failed. When a  command  fails,  control  is  transferred  to  the  code
  following the comma - the failure handler. A single block can containing any
  number of failure handlers, each picking up the failure condition  from  the
  previous - this is effectively an if, else-if, else-if ... structure.

3.25 Reverse status command
---------------------------
<cmd>\ - Reverse status of command or block.
   
  If the previous command failed and raised the failure flag, then this resets
  it, correspondingly, if the previous command did not fail then  the  failure
  flag is raised.
  
  Note, \ only applies to the command or block *immediately* before it.
  
  If, for example, we want to insert abc in any case except  when  it  already
  exists:
(v/abc/\i/abc/,)
  
  This is also useful for inverting the status of blocks, e.g.:
(f1/fred/\ f1/jim/ f1/bill/\)\
  The block will succeed if the current line contains either if the substrings
  "fred", "jim" or "bill".

3.26 ?
------
 <validCommand or block>? - ignore status of command or block.
   
  This has the effect of lowering the failure flag irrespective of the outcome
  of the previous command.
  
  Note, ? only applies to the command or block *immediately* before  it.  Thus
  in the sequence m99p? the ignore-failure  command  applies  only  to  the  p
  command - not m99.
  
  You can also follow ? with \ to ensure that a command *always* fails -  this
  is useful when a failure handler needs to exit a repeated block.
  
  See also \ (`Reverse status command`), `Jot command structure` and `success,
  failure and errors`.

3.27 Stack Operations
---------------------
  The editor maintains an evaluation stack  used  for  numerical  and  logical
  operations.
  
  A stack frame may contain one  of  three  datatypes,  an  integer  value,  a
  floating-point quantity or a buffer. All buffers on  the  stack  are  tagged
  with the buffer key '~'), as values are retrieved, there is a  simple  check
  to ensure compatibility with the  expected  datatype,  in  the  event  of  a
  mismatch, execution halts with an error message.
  
  If a stack-based buffer is the current buffer, numeric values may  be  added
  to the stack without  affecting  the  status  of  the  buffer.  You  cannot,
  however, return to the buffer with  a  Z~  or  OZ  command  (and,  also  the
  `hashtable jump` command) unless the buffer is at the top of the stack. This
  command sequence, for example, will fail:
%q~=date; m(oidr)3 z.z~
  But this one's OK:
%q~=date; m(oidr)3 z.(oo/%d:/r0)3z~
  
  The stack size is by default limited to 100  slots  (see  `-stacksize`)  any
  push operation will fail abruptly if there are already  100  on  the  stack.
  Similarly, any pop operation will fail if there are no values on the stack.
  
  The arithmetic operations (O+, O-, O*, O/, O=. O<  and  O>)  work  for  both
  integer or real (floating-point) quantities. If one item is integer and  the
  other is real then the integer operand is first converted to  real  and  the
  result, where applicable, is also real.
   
    - `O+` - Add.
    - `O-` - Subtract.
    - `O*` - Multiply.
    - `O/` - Divide.
    - `O%` - remainder
    - `O~` - increment - add 1 to item at top, fail if result=0.
     
    - `O|` - OR - performs bitwise OR of top two items in stack.
    - `O&` - AND - performs bitwise AND of top two items in stack.
    - `O!` - NOT - bitwise NOT.
     
    - `O?` - dump contents of stack - stack contents are not changed.
    - `O#` - duplicate top of stack.
    - `O=` - fail if top two items on stack not equal, top item is destroyed.
    - `O<` - test that item at top greater than next one down
    - `O>` - test that item at top less than next one down
    - `O0` - test that item at top is 0.
    - `O1` - test that item at top is 1.
     
    - `OB` - push pointer to current buffer onto stack.
    - `OX` - push eXtent of current record/substring onto stack.
    - `OF` - push line no. of First line in window.
    - `OC` - push current chr. no. onto stack.
    - `ON` - push current line no. onto stack.
    - `OP` - push mouse cursor Position no. onto stack.
    - `OU` - set sUbstring length from stack.
    - `OA` - push rAndom number onto stack.
    - `O.` - set current line number to <top of stack>.
    - `OL`<n>[.<n>]|[x<xxx>] - Literal integer|[real]|[hex] value is pushed onto stack.
    - `OI`[C|D|O|X|F] - Input (formatted conversion of text) to stack.
    - `OG` - character input - prompts and reads one character from keyboard.
    - `OO` - formatted Output - pop value, using given string.
    - `OV` - Value - defines hashtable data item from stack.
    - `OQ` - Query, query a hashtable value and push value onto stack.
     
    - `OR` - index Right (left if -ve) by no. of characters popped off stack.
    - `OE` - Erase no. of characters specified by top of stack.
    - `OM` - Move (backwards if -ve) no. of lines popped off stack.
    - `OZ` - Zoom (change to buffer) key popped off stack.
     
    - `OK` - Kill - delete top of stack.
    - `O@` - reset stack and random number generator.
    - `OS` - Swap 1st and 2nd items of stack.
     
    - `OW` - scrolls Window view by no. lines set in top of stack.
    
    - See also `query stack`
    
    - A few other %Q queries also push values onto  the  stack  -  see  `query
      Time`, `query cputime`, `query pid` and `query inview`.

3.27.1 OL
---------
OL<intVal> - push an integer Literal onto stack.
  or
OL<floatingPointValue> - push a floating-point Literal onto stack.
 
  The specified value is placed on the top of the stack. e.g:
> ol123
  This pushes the number 123 onto the top of the stack.
  
  The literal can be modified by prefixing with x or o to specify the  integer
  in Hex or Octal respectively. eg:
> ol1024
> olx100
> olo400

  Note that the usual C-language format 0xnnn or 0onnn are not supported  here
  as these are syntactically indistinguishable from an OL0 followed by an X or
  another O command.
  
  For floating-point (real) values the only permissible syntax is  <nnn>.<mmm>
  eg:
> ol1234.56789
  
  The OL command is sometimes followed by `OV`. This combination  is  used  to
  set a data object to a literal value.  See  `about  hashtables`  and  `using
  Hashtable data`

3.27.2 O&
---------
o& - bitwise AND
  
  The top two items in the stack must be integers. These are removed  and  the
  bitwise AND of the two values is added.
   
3.27.3 O|
---------
o| - bitwise OR
  
  The top two items in the stack must be integers. These are removed  and  the
  bitwise OR of the two values is added.
   
3.27.4 O!
---------
o! - bitwise NOT
  
  The item at the top of the stack must be an integer. It is replaced  by  the
  bitwise NOT of the original bit pattern - i.e. 0's are changed  to  1's  and
  1's are changed to 0's.
   
3.27.5 O?
---------
O? - List contents of stack.
  
  This is useful for debugging - dumps the entire contents of the stack to the
  console - see also `query stack`.

3.27.6 OG
---------
OG - reads one character from console and pushes character onto stack.
  
   This prompts using the prompt string defined by `%s=prompt` and  reads  one
   character that is pushed onto the stack as a wide-format unicode  character
   (see `about unicode`).
   
   If unicode-support is disabled (see `%b=unicode`) then  unicode  characters
   arrive as a series of values in the range  128-255  requiring  multiple  OG
   calls. Jot does not offer any  method  of  determining  where  one  unicode
   character ends and the next begins when a series of unicode characters  are
   entered in this way.

3.27.7 OO
---------
OO<delim><formatString><delim> - Output using sprintf format string.
  
  Output the value at top of stack using the format string. 
  
  If the current buffer has a substring following a  command  that  defines  a
  substring (eg: F, S, I, OI or a previous OO command), then the substring  is
  replaced by the sprintf output. This sequence will first insert 999 and then
  immediately change it to 123:
> ol123 ol999 oo/%d/ oo/%d/
  this will give both numbers - the r-r removes the substring  marker  without
  affecting the cursor position:
> ol123 ol999 oo/%d/ r-r oo/%d/
  
  When writing unicode characters, the %c format  string  *must*  have  the  l
  (long-format) modifier to convert the wide-format unicode eg:
> ol65r0boo/%c simple ASCII character/r0
> ol163r0boo/but the unicode %lc requires the l modifier with %%c/
  Note that the `OG` command can add a unicode character too the stack.
  
  For numeric values the use of this modifier is recommended but a  simple  %d
  seems to work on most systems for integers of not more then  32  bits  eg  -
  this generally seems to work;
> ol123456789r0boo/%d/
  but use %ld to avoid truncation:
> ol123456789123456789r0boo/%ld/
  
  On completion, the current character points  to  the  end  of  the  inserted
  substring.
  
  Examples:
> ol12345 oo"The number you first thought of is %-10d"
> %q~=buffer; f/pathName = /-bza oo/The pathname is %s/ok
> off za oo/%8f/
> oo/%lc/ - used to print a long-format unicode character.

3.27.8 OQ
---------
OQ<delim><key><delim> - Value, push value from hashtable onto stack.
  
  The delimitedKey must match the key used to create a  hashtable  entry  with
  the `hashtable data` command. The OV operation pops the stack and copies the
  top frame value to the hash-table entry, deleting any previously-held  value
  associated with that hashtable entry. A copy  of  the  frame  can  later  be
  returned to the top of stack with the `OQ` command.
  
  In the event of an unmatched hashtable key or an empty stack, the OV command
  fails. Note that there is no typing in the `hashtable data`  command  so  OV
  just takes whatever datatype happens to be at  the  top  of  the  stack  and
  copies it to the data object.
  
  If the top item on the stack is a buffer, then a complete copy  of  all  the
  buffer records is made and associated with the data object, ignoring most of
  the other buffer attributes like PathName, header or Footer.
  
  For example:
> %h=data fred;  %%Creates the entry associated with the keyword 'fred'
> ol123
> ov/fred/       %%Moves the top stack frame (integer 123) to the hashtable.
...
> oq"fred"       %%Queries (restores) the stack frame 'fred'.
> ol456
> ov,fred,       %%Redefines  the value of the data object 'fred'.

3.27.9 OV
---------
OV<delim><key><delim> - Query - pops stack and sets value in hash-table.
  
  The key must match one used to create a data entry with the `hashtable data`
  command. The OV command copies the contents  of  the  hashtable  data  entry
  associated with the hashtable key to the top of stack.
  
  In the event of an unmatched hashtable key or no value associated  with  the
  entry or, less likely, a full stack, the OQ command fails.
  
  If the data object holds a buffer, then a complete copy of  all  the  buffer
  records is made and placed on the top  of  the  stack,  ignoring  the  other
  attributes like PathName, header or Footer.

3.27.10 O+
---------
O+ - Add
  
  Replace top two values with their sum.
  
  If either of the two values is a real number then the result is real, if one
  is integer then it is first converted to real.
  
  There is no checking for arithmetic overflows.

3.27.11 O-
---------
O- - Subtract
  
  The value at the top of the stack is subtracted from the next value, the top
  two items are replaced by the result.
  
  If either of the two values is a real number then the result is real, if one
  is integer then it is first converted to real.
  
  There is no checking for arithmetic overflows.

3.27.12 O*
---------
O* - Multiply
   
  Replace top two values with their product.
  
  If either of the two values is a real number then the result is real, if one
  is integer then it is first converted to real.
  
  There is no checking for arithmetic overflows.

3.27.13 O/
---------
O/ - Divide
  
  The top item on  the  stack  is  the  denominator,  the  next  item  is  the
  numerator, both  items  are  removed  from  the  stack  and  the  result  of
  numerator/denominator is then added to the stack.
  
  If either of the two values is a real number then the result is real, if one
  is integer then it is first converted to real.
  
  There is no checking for arithmetic overflows but this command will fail  if
  the denominator (the 1st. item in the stack) is 0.

3.27.14 O%
----------
O% - remainder.
  
  The top item on  the  stack  is  the  denominator,  the  next  item  is  the
  numerator, both items are removed  from  the  stack  and  the  remainder  of
  numerator/denominator is then added to the stack.
  
  If either or both items are real, the reals are first converted  to  integer
  the result is always integer.
   
  There is no checking for arithmetic overflows but this command will fail  if
  the denominator (the 1st. item in the stack) is 0.

3.27.15 O=
----------
O= Test for numerical equality
  
  The top two items must be either integer or real, they are compared and  the
  top item is removed, if they  are  equal  the  command  status  is  Success,
  otherwise it's Fail.
  
  If either item is a real number  it  is  converted  to  integer  before  the
  comparison. This conversion does not apply to the value left behind  on  the
  stack.

3.27.16 O0
----------
O0 Test for value zero
  
  The top item must be either integer or real, a real value  is  converted  to
  integer. The value is compared to 0 and the top item is removed,  if  it  is
  zero the command status is Success, otherwise it's Fail.
  
  If the top item is a buffer,  the  command  fails  and  the  stack  is  left
  unchanged.

3.27.17 O1
----------
O1 Test for value one
  
  The top item must be either integer or real, a real value  is  converted  to
  integer. The value is compared to 1 and the top item  is  removed,  if  it's
  value is one the command status is Success, otherwise it's Fail.
  
  If the top item is a buffer,  the  command  fails  and  the  stack  is  left
  unchanged.

3.27.18 O~
----------
O~ Increment value in top of stack.
   
  The item at the top of the stack must be an integer, for any other type  the
  the operation fails. If the modified value has gone  to  zero,  the  failure
  flag is raised.

3.27.19 O>
----------
O> - Greater than.
  
  The top two items compared and the top item is removed, if the top  item  is
  greater than the next, then the command  status  is  Success,  otherwise  it
  Fails.
  
  If both of the operands are floating-point values,  then  a  floating  point
  comparison is used.  Similarly,  if  both  items  are  integer,  an  integer
  comparison is performed. If only one of the operands is floating point, then
  a  floating-point  comparison  is  performed,   using   the   floating-point
  conversion of the integer value. This conversion does not affect  the  value
  left behind on the stack.

3.27.20 O<
----------
O< - Less than.
  
  The top two items compared and the top item is removed, if the top  item  is
  less than the next, then the command status is Success, otherwise it's Fail.
  
  If both of the operands are floating-point values,  then  a  floating  point
  comparison is used.  Similarly,  if  both  items  are  integer,  an  integer
  comparison is performed. If only one of the operands is floating point, then
  a  floating-point  comparison  is  performed,   using   the   floating-point
  conversion of the integer value. This conversion does not affect  the  value
  left behind on the stack.

3.27.21 OB
----------
OB - save Buffer key
  
  The ASCII value of the current buffer identification key is  placed  on  the
  stack (see also `OZ`).

3.27.22 OX
----------
OX - push eXtent of current substring or record.
  
  This command pushes the length, in  characters,  of  the  currently-selected
  substring onto the stack. If no substring is currently selected,  it  pushes
  the total length of the current record onto the top of the stack. 
  
  The result is negative if the current-character pointer follows the selected
  substring (as would be the case after the `S` command, for example). Jot has
  two forms of substring yielding +ve and -ve results:
    - Positive, where the current character is  the  first  character  of  the
      substring typically the result of a `F` command.
    - Negative, where the current character is immediately after the substring
      typically the result of the `S` command.
  
  If unicode support is turned off off (see `%b=unicode`) then it  pushes  the
  number of bytes in the currently-selected substring. 
  
  See also `OU`, `about unicode`, `%b=tabstops`, `about tabular text`,  `query
  inview` and `uc_basic.jot`.
  
  The substring-length calculation disregards  any  leftoffset  setting  -  it
  always assumes all characters  are  fully  visible.  See  also  `about  long
  lines`.

3.27.23 OF
----------
OF - push line no. of First line of current buffer in window.
  
  This command will  search  all  currently  displaying  windows,  from  first
  (left/topmost)  to  last  window  (right/bottommost)  until  it  finds   one
  displaying the current buffer. It then calculates the  line  number  of  the
  topmost line displayed in the window. In most cases it's much  simpler  than
  that - usually there's only one window set up to display the current  buffer
  but see `%W` for details.
  
  This information can be used to control the view e.g.  it  can  be  used  to
  return to a previously displayed view - see also `OW`.
  
  Note that the line number returned is the line number at the time  when  the
  display was last updated. If your code contains anything that  might  change
  the display you should first refresh the display with  the  -refresh  option
  to the `%W` command.

3.27.24 OU
----------
OU - set sUbstring length from stack.
  
  The length of the currently-selected substring is set to the value currently
  at the top of the stack. A zero can be used to remove the substring  setting
  in that buffer. 
  
  With unicode support turned on (see `%b=unicode`) this value is  interpreted
  as a character count, otherwise 's taken as a byte count.
  
  A negative substring indicates that the  current  character  is  immediately
  after the selected substring (e.g. after a f/.../- os s/.../  command,  doc.
  Otherwise the value is positive indicating that the current character is the
  first character of the substring (e.g. after a F/.../ or S-/../ command).
  
  See also `OX`.

3.27.25 OZ
----------
OZ - Zoom.
  
  The value at the top of the stack is removed and used to  specify  a  buffer
  key, this is used to specify the new current buffer (see also `OB`).
  
  Unlike the `Z` command, oz does not transliterate to uppercase and an  error
  will result if there happens to be a lower-case acsii alpha character at the
  top of the stack.

3.27.26 OP
----------
OP - push mouse Position onto stack.
  
  This places coordinates of the last-detected  mouse-click  onto  the  stack.
  Readback  of  mouse-click  coordinates  is  enabled  by  the  `%s=MouseMask`
  command.
  
  On completion, the top of the stack holds the following:
    - buffer key on display in the window receiving the last mouse click
    - the line number and
    - the character number for the mouse-click point.
    
  If the last-clicked mouse event has not been  enabled  (see  `%s=MouseMask`)
  then OP places three zeros on the stack.
  
  See also `About mouse events`, `%s=mousemask`, `%s=setmouse` and `%b=addtag`

3.27.27 ON
----------
ON - save line Number
  
  The current line number is placed on the stack (see also `OM`).

3.27.28 OE
----------
OE - Erase no. of characters specified by stack.
  
  The number of characters to be erased is popped off the  stack,  a  negative
  value indicates leftwards erasure, positive values indicate  rightwards.  If
  there are insufficient characters then the command fails  leaving  the  text
  unchanged.

3.27.29 OM
----------
OM - Move
  
  The value at the top of the stack is removed and used to specify a  relative
  move forwards (+ve.) or backwards (-ve) by no. of lines.
  
  If the move is out of bounds (i.e. before the start or after the end of  the
  current buffer) then the cursor is left at the start of the  first  or  last
  line as appropriate and the command fails.
  
  n.b. With a zero at the top of the stack, OM just moves to the start of  the
  current line (see also `ON`).

3.27.30 OA
----------
OA - rAndom
  
  A randomly-generated number is pushed onto the top of the stack. In reality,
  of course, this  is  a  pseudo-random  number.  That  means  it  runs  to  a
  predictable repeatable sequence depending on  how  the  pseudorandom  number
  generator is seeded (see `O@`).

3.27.31 O.
----------
O. - Set line number.
  
  The value at the top of the stack is removed and used to  specify  the  line
  no. of current line from top of stack.
  
  N.B.  This  has  no  effect   on   the   cursor,   it   only   changes   the
  internally-maintained line number. This is displayed in the JOT prompt,  and
  the line number in `M`+ operations and `ON` etc.

3.27.32 OC
----------
OC - save Chr no.
  
  Place current character no. (i.e. number of  characters  from  beginning  of
  line to the current cursor position) onto the stack (see also `OR`).
  
  If unicode support has been turned off (see  `%b=unicode`)  then  OC  counts
  bytes not characters, including all bytes in any unicode characters.

3.27.33 OR
----------
OR - shift Right by character count (byte count if unicode support is turned 
  off - see `Unicode - the gruesome details`) shifts left for negative values.

  
  Item at top of stack is removed and used  to  shift  the  current  character
  pointer. Cursor moves cursor right (+ve.) or left (-ve.) by no. bytes at top
  of stack.
   
  If the move is out of bounds (before the start  or  after  the  end  of  the
  current line) then the operation  fails  and  the  cursor  is  left  at  the
  start/end of the line as appropriate (see also `OC`).

3.27.34 OI
----------
OI[C|D|O|X|F] - formatted Input conversion (of string at current character).
  
  OI<chr> takes the character (C, D, O, X or F) as a format specifier and uses
  it to extract a value from the string starting at the current  character  in
  the current buffer. For the numerical conversions (OID, OIO, OIX  and  OIF),
  this string may be prefixed with whitespace. The result is pushed  onto  the
  stack. As usual, the interpretation of the format-selection character (C, D,
  O, X or F) is case insensitive.
  
  Each of these  variants  converts  characters  beginning  with  the  current
  character and proceeding  to  the  right.  The  current  character  is  left
  pointing to the character to the right of the last converted  character  and
  all the converted characters are highlighted as a substring. 
  
  In the event of there being no valid characters  the  current  character  is
  left unchanged, nothing is added to the stack and the command fails.
    - OIC converts one character immediately  to  the  right  of  the  current
      character to  it's  unicode  code  (in  the  range  1-to-127  for  ASCII
      characters and 256-to-... for unicode characters -  this  one  does  not
      skip whitespace characters.
    - OID converts a string of numeric characters to decimal.
    - OIO converts value in an octal string and
    - OIX converts value in a hexadecimal string.
    - OIF converts real-number value in a string.
  OID, OIO, OIX and OIF all skip past any leading whitespace before converting
  digits.

3.27.35 OK
----------
OK - Kill top item on stack
  
  The item at the top of the stack is removed and,  if  it's  a  scalar  or  a
  locally-defined buffer, it's value is lost. If it's a pointer to  hash-table
  buffer (see `OQ`) the pointer  is  deleted  but  the  underlying  buffer  is
  preserved. 
  
  Note that the OK command will fail if the stack is empty or the item at  the
  top of the stack is a buffer and this happens to be the current buffer or if
  it  is  marked  as  write-if-changed  and  needs  to  be  written  out  (see
  `%b=writeifchanged`).

3.27.36 O@
----------
O@ - Reset stack
  
  Reseeds the random number generator (see `OA`) and then destroys  all  items
  currently in the stack. If the item at the top of the stack  is  an  integer
  type then this is is used to reseed the generator, otherwise  it's  reseeded
  with 1.
  
  The O@ command will work it's way down the stack, deleting entries, starting
  with the top item in the stack. If it encounters a buffer, it might fail  at
  this point if this buffer is the current buffer.

3.27.37 OS
----------
OS - Swap
  
  The items in the top and next-but-one slots in the stack swap places.
  
  OS will fail if there are less than two items on the stack.

3.27.38 O#
----------
O# - Duplicate
  
  The item at the top of the stack is copied and  placed  above  the  original
  item. 
  
  If the top item on the stack is a buffer, the O# operation does not copy the
  buffer records etc.  it  simply  constructs  another  pointer  to  the  same
  internal data. This is in contrast to `OV` and `OQ` which do make new copies
  of buffer data.
  
  O# will fail if the stack is already full.

3.27.39 OW
----------
  The screen display is scrolled by the number of lines indicated by  the  top
  of stack - a positive value scrolls up the screen, negative scrolls down.

3.28 Percent Commands
---------------------
  See also `percent-command syntax`
    - `%%` - Comment line.
    - `%A` - Exit without writing file.
    - `%B` - set Buffer attributes.
    - `%C` - Exit writing new file.
    - `%D` - Define a buffer from console.
    - `%E` - Execute following CLI command line.
    - `%F` - Find, with options.
    - `%P` - Pipe a message to interactive session.
    - `%G` - Get - Define a complete buffer from current command file.
    - `%H` - Hashtable maintenance.
    - `%I` - read a secondary Input file.
    - `%L` - set line Length and redraws all windows and slices.
    - `%M` - Message.
    - `%O` - Output current buffer as specified file.
    - `%Q` - system Query.
    - `%R` - Run a command file.
    - `%S` - define System settings (case sensitivity, insert mode ...).
    - `%U` - Undo last substitution.
    - `%W` - Set up a screen window.
    - `%X` - eXit current macro with a user-defined error message.
    - `%~` - Insert or display control character.

3.28.1 %A
---------
%A[[<status>]=<message>] - Abandon = Exit without writing file.
  
  This exits the editor, no files are written out.
  
  The message defaults to "Edit abandoned", it  is  written  to  stdout  after
  closing the screen management system.
  
  By default, the exit status code is set to 1, any value in the  range  0  to
  255 can be supplied in decimal.
  
  If a message is specified, this replaces the usual "Edit abandoned" message.
  There is a restriction on this, the length of  the  message  must  exceed  1
  character.
  
  If some buffer has been marked as `%b=writeifchanged`, and  the  buffer  has
  been changed, then the editor will refuse to exit until that buffer has been
  written. A suitable message appears if this happens - see `freeall.jot`.
  
  If the exit message begins with a reference to  another  buffer,  then  this
  buffer is written to stdout after closing down the display.  This  behaviour
  is important when it is required to write more than  the  usual  single-line
  message on exit - see `about jot  streams`.  Note  that  this  behaviour  is
  anomalous - that syntax normally copies just the current line of the  buffer
  (see `percent-command syntax`) whereas for %A it takes the entire buffer.

3.28.2 %C
---------
%C[=<message>] - Close = Exit writing new file.
  
  The file spec. is initially determined by the arguments given to the  editor
  image (see `-to`) and may be further redefined by the `%b=pathname` command.
  By default the file will have the same pathname as the original.
  
  The command fails if there is an attempt to %C from any  buffer  other  than
  the main buffer . - to write out some other buffer use `%O`.
   
  The message defaults to "Normal exit", it is written to stdout after closing
  the screen management system. For %C, the exit status is always set to 0.
  
  If  some  buffer  (other  than  the  main  buffer)  has   been   marked   as
  `%b=writeifchanged`, and the buffer has been changed, then the  editor  will
  refuse to exit until that buffer has been written or the writeifchanged lock
  is removed - see `freeall.jot`.

3.28.3 %E
---------
%E=<CliCommand>  - executes a CLI command
%E<key>=[ -pipe]<CliCommand> - executes CLI command and catches the output in the specified buffer.
%E<key>=[ -exit=<exitCommand>][ -interactive]<CliCommand> - interactive CLI command (see also `%P`).
  
  If a destination buffer is specified with the optional <key> qualifier, then
  the stdout stream of the child  process  is  picked  up  and  saved  in  the
  specified buffer. If no destination buffer is specified the  child's  stdout
  goes to the screen.
  
  The command is passed to the CLI, the return status is checked and  used  to
  set the failure flag.
  
  The simple form of  %E  (no  pipe)  will  return  a  success/failure  result
  reflecting the cli command's exit status - any nonzero exit code  is  deemed
  to be a failure, zero is deemed to be success.
  
  If the -pipe option is given, then the contents of  the  current  buffer  is
  output to the stdin of  the  command.  This  feature  allows  users  to  use
  external co-processors for handling specific tasks.
  
  If the subprocess is inherently interactive, communicating via it's std  and
  stdout the CLI command may be prefixed with the -interactive qualifier  (eg:
  gdb or sh) then jot can maintain an input and output pipe  to  the  process.
  New commands and input can be  supplied  to  the  subprocess  via  the  `%P`
  command. For linux, the child process is killed when the destination  buffer
  is destroyed or as the session exits. 
  
  The -exit=<exitCommand> option is used to terminate  the  child  process  at
  some later time. This option most useful in windows  or  for  certain  linux
  process that do not respond well to the SIGTERM signal. In  these  cases  it
  is necessary for a child process to terminate itself. The command string  is
  saved and as the session terminates or the buffer  is  destroyed,  the  exit
  command is sent to the child process.
  
  For windows, the user requires a special privilege to kill a process -  even
  if it's a process they've created  in  the  same  session.  If  the  session
  attempts to exit with active child processes it will hang while  the  system
  waits for the child to terminate. The solution is to either explicitly  send
  the child the correct command for it to terminate itself or, use the  -exit=
  qualifier to the `%P` command.
  
  Note that, at present, the -interactive option may  not  be  used  when  the
  session is maintaining a journal (see `-journal`).

3.28.4 %P
---------
%P[<key>]=[ --Waitfor=<commandSeq>][ -Nocr]
  [ -Timeout=<timeout_s>][ <message>]; - Pipe message to a remote session.
  
  The remote session must have been previously set up  by  the  `%E`  command,
  with the -interactive modifier to create a persistent  interactive  session.
  The message is sent to the remote process's stdin and it  is  also  appended
  to the buffer text. Note that the destination buffer (identified  by  <key>)
  must be the same as that in the corresponding %E command.
  
  Jot can support any number of simultaneous %E-%P sub  processes  running  in
  parallel, provided they are all focused on different buffers.
  
  The message would normally be a command recognized by the child process.  If
  a reply is expected via the child's stdout channel, this will  be  delivered
  to the nominated buffer.
  
  There is usually some delay in the  remote  process  response.  When  driven
  interactively, this delay may be small enough to go unnoticed  and,  in  any
  case, the target buffer is updated asynchronously  without  blocking  normal
  console activity. When %P is being driven by a jot function or  a  macro  it
  will usually be necessary to include a -timeout and a -waitfor  sequence  to
  synchronize further jot responses.
  
  Note that, with the the linux  version,  the  responses  usually  include  a
  windows-style carriage-return character ( \r ) this is because jot  sets  up
  a pseudo terminal ( pty ) and the child  process  sends  these  just  as  it
  would if interfacing with a real terminal. 
  
  Commands are sent to the child process and are normally terminated  by  "\n"
  - this translates to the ASCII characters  {CR}  {LF}  -  the  -nocr  option
  suppresses this behaviour.
  
  The -waitfor command sequence is a special version of the  -onreply  command
  sequence. If the -waitfor  command  sequence  fails  it  blocks  normal  jot
  console reads until a later reply causes the -waitfor  command  sequence  to
  return a success status.
  
  The -timeout qualifier sets a timeout, in seconds from the time the  command
  %P was run, if the waitfor condition has not been satisfied by  the  end  of
  the timeout period then the %P command  exits  with  failure  status.  If  a
  timeout was set with no -waitfor commands then the %P command  fails  if  no
  text is received within the timeout period.

3.28.5 %F
---------
%F[<key>]=[ -REx <RegularExpression>]
  [ -back][ -Reverse]
  [ -STARTLine=<n>][ -STARTChr=<n>][ -ENDLine=<n>][ -ENDChr=<n>]
  [ -SEtaperture][ -Aperture][ -REStart]
  [ -SUbstitute=<subsString>]
  [ -ALl][ -FIrst][ -ANy][ -Tab=<chr>] 
  <string>|<string1><tab><string2><tab>...;
  
  The %F command  offers  an  apparently  bizarre  selection  of  options  and
  features - it can limit the scope of a search to a defined  section  of  the
  buffer (the aperture), it can search for a list  of  substrings  either  all
  together or one at a time and it can also  do  regular  expressions  and  go
  backwards and forwards. It can be used to verify that one of a selection  of
  strings immediately adjacent to the current  character.  It  can  perform  a
  global or aperture-restricted search and  replace.  
  
  In fact, many of the features were  designed  to  facilitate  efficient  the
  implementation of `the proximity search functions` while still  offering  an
  efficient method of analyzing text.
  
  Like the `F` command, case sensitivity of %F is determined by the  `%s=case`
  command.
  
  The search string may be either  a  simple  string  or  a  list  of  strings
  separated by  table-entry-separator  characters.  The  table-entry-separator
  character defaults to an ASCII TAB character but may have been redefined  by
  the `%s=tab` command or by the %F -tab qualifier.
  
  - If -rex is given, the string is taken to be a  regular  expression  -  see
    `regular  expressions`.  For  regular  expressions  the  must  not  be   a
    tab-separated list. The buffer identified by key, if  specified,  receives
    the output from the regular-expression. When -rex is  not  given  the  key
    parameter is silently ignored.
  
  - if -back is given, it searches backwards towards the start of the  buffer,
    backwards regular expression searches are supported. 
  
  - if -reverse is given then,  in  the  event  of  a  successful  match,  the
    substring  marker  is  reversed  (i.e.  the  current  character  is   left
    immediately after the found substring - by default it is left at the first
    character of the substring.
    
  - The  -startline,  -startchr,  -endline  and  -endchr  parameters  together
    define a search aperture - a section of the buffer to  be  searched.  When
    the start and end points are  defined  with  these  parameters  the  -back
    qualifier is silently ignored.
    
    The start line and start character  define  the  starting  point  for  the
    search. These default to the current character position for both  forwards
    and backwards searches. If a startline is given,  but  no  startchr,  then
    the starting point for the search is the  first  character  of  the  given
    line for forward searches or the last character, for backwards searches.
    
    For forwards searches, the end point defaults to the end of the last  line
    in the buffer.  Correspondingly,  the  default  end  point  for  backwards
    searches is the start of the first line in the buffer. When an endline  is
    given, but no end character, the end character defaults to the end of  the
    given line for forwards searches and the  start  of  the  given  line  for
    backwards searches.
    
    It often happens that we want to do repeated search operations within  the
    same  aperture.  Thus  jot  provides  the   -setaperture   and   -aperture
    qualifiers: 
    
  - The -setaperture qualifier saves any elements of a search aperture defined
    by -start/endline/byte parameters. The  -setaperture  is  purely  a  setup
    command, when given no search is performed.
    
  - The -aperture  qualifier  uses  a  search  aperture  defined  by  previous
    -setaperture invocations. This causes the entire aperture to  be  searched
    unless the -restart qualifier is also given.
    
  - The -restart qualifier has no  effect  unless  it  is  combined  with  the
    -aperture qualifier.  It  causes  the  search  to  begin  at  the  current
    character position rather than the aperture start point.
    
  - If either -all, -first or -any is given, then the search string  is  taken
    to be a tab-separated list of substrings - see below. If more than one  of
    these is given only the last one  is  effective.  With  these  the  string
    argument is a list  of  search  strings  each  separated  by  the  current
    table-separator character (an ASCII TAB by default - see `%s=tab`) or  the
    character specified by the -tab=<chr> qualifier.
    
  - The -any qualifier searches each record in the range for each substring in
    the list until it finds a match, it then exits successfully.
    
  - The -all qualifier repeatedly searches each line in the aperture, for  all
    of the substrings in the list.  It  is  only  successful  if  all  of  the
    substrings are in the search area. On successful completion it leaves  the
    current character and substring indicating the first matching substring.
    
  - The -first qualifier, like the -any qualifier, does not require all of the
    substrings to match to succeed. Whereas -any stops at the  first  matching
    substring, -first will continue and report the first match in the line.
    
  - The -substitute=<subsString> qualifier causes all  instances  of  matching
    substrings, within the defined range, to be replaced  by  subString.  When
    -substitute is given the -reverse, -all, -first and  -any  qualifiers  are
    silently ignored and  all  instances  of  all  the  search  string(s)  are
    replaced  by  the  subString  (%F  still  accepts  tab-separated  list  of
    strings). The effect of -back is  undefined  but  the  substitution  might
    work. On completion, the current-character pointer is set to the start  of
    the buffer. 
    
    This  option  is  optimized  to   improve   the   efficiency   of   global
    substitutions in very long lines, where there may be a very  large  number
    of substitutions to be performed in a line. For  all  other  situations  a
    simple find and substitute loop is recommended.
  
  When used without the -rex qualifier the searches are similar in  nature  to
  those performed by the `F` command - but with a lot of options not available
  with the syntax of the F command.  Note  also,  the  destination  buffer  is
  ignored for non-rex searches.
  
  If  the  optional  regular  string  <string>  is  not  specified,  then  the
  last-specified %F string is re-used.

3.28.5.1 Regular Expressions
----------------------------
  The underlying system call  only  searches  forwards  hence,  for  backwards
  searches, when a matching line of text is found, the system call is repeated
  until there are no more valid matches. Hence reverse regex searches  can  be
  quite inefficient for cases where there are many possible matches on a line.
  
  When a match is found, the first record of the destination buffer is set  to
  the complete matched substring. Subsequent records of the destination buffer
  are set to substrings matching parenthesized sub-expressions.
  
  Briefly, %F supports most of the usual regular-expression  constructs  using
  the GNU regex library functions. Some  of  the  more  complex  ones  may  be
  missing, for details look at the documentation of the regex library routine:
    http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html   -
    
    - Circumflex '^' and dollar sign '$', respectively, at the start or end of
      the RE, will anchor the body of the RE to the start or end of the  match
      string.
      
    - Bracketed expressions - '[' ... ']', the expression  inside  a  pair  of
      matching square brackets - see below.
      
    - Sub-expression grouping, enclosing expressions in matching round  braces
      '(' and ')', creates a result for each such subexpression. Each of these
      is assigned a separate record in  the  destination  buffer  and  may  be
      referred to by  number  in  some  later  expression  (see  subexpression
      references, below).
      
    - Alternation  within  sub-expressions  the  vertical  bar  character  '|'
      indicates an alternative subexpression. (<subexpr1>|<subExpr2> ... )
      
    - Subexpression references - \n (where n is a decimal) refers to the value
      extracted for that subexpression.
      
    - Numeric quantifiers -  specifying  that,  for  a  match,  the  preceding
      subexpression should be reiterated a given number of times.
      
    - Range quantifiers, a comma-separated pair of  decimal  values  in  curly
      braces '{'m, n'}' where m specifies the minimum number of repeats, n the
      maximum.
    
  Bracketed expressions - anything in matching square brackets [ ... ]
    - A set of equally  acceptable  characters,  special  characters  must  be
      escaped with a backslash.
    - A range of characters <ch1>-<ch2> in the ASCII/POSIX collating sequence.
    - A circumflex '^' - the negation character, matches to any character  not
      in the expression e.g. [^a-zA-Z] matches to any non-alpha character.
    - Character-class expressions of the form [ ... [:<classexpr>:] ... ]  the
      following character class expressions are allowed: alnum, cntrl,  lower,
      space, alpha, digit, print, upper, blank, graph, punct, xdigit.

3.28.6 %M
---------
%M[<bufferKey>]=<message> - prints Message in console area.
  
  Prints the message in the  console  area  and  continues.  If  the  optional
  bufferKey is given then the  message  is  also  appended  to  the  specified
  buffer. 
  
  The message may contain an indirect reference to any buffer or the  stack  -
  see `about command parameters` e.g:
ob %q~=date; t2/, /b %m=This is the time '~; osozok

3.28.7 %X
---------
%X=<message> - eXit current command sequence, macro or script displaying the
  message in the console area.
  
  Prints the message to the console area then immediately exits all  commands,
  macros functions and scripts.
> %x=File 'n is of the wrong type.;

3.28.8 %S
---------
%S=<attribute> [<value>] - set the value of a System attribute.
   
  This group of commands control various system attributes affecting behaviour
  in any buffer.
  
  Briefly, these are the valid attribute keys:
    - `%s=CAse` [0|1|+1] - Sets case sensitivity for F, and V commands.
    - `%s=System` [0|1] - system mode on/off - preserves search & insert strings.
    - `%s=COMMANDMode` [+][<bitMask>] - to select screen-edit mode.
    - %s=CM - A recognized abbreviation of `%s=COMMANDMode` 
    - `%s=COMMANDCounter` - Sets the command-counter stop-point.
    - %s=CC - A recognized abbreviation of `%s=COMMANDCounter` 
    - `%s=COMMANDString` - redefines console-input string.
    - %s=CS A recognized abbreviation of `%s=COMMANDString`
    - `%s=ON_Int` - Introduces a {Ctrl+C} handler.
    - `%s=TRace` - set Trace, prefix with '+' to XOR with current value
    - `%s=TRACEDefault` - set default trace bitmask see also `T` command.
    - `%s=TRACESkip` [<n>] - suppresses tracing until block depth reaches specified level.
    - `%s=SETEnv` <envName> <envValue> - sets an environmental variable.
    - `%s=Verbose` - to change verbosity level.
    - `%s=CONsole` <n> - sets an upper limit on console-area expansion.
    - `%s=Recoverymode` - disables I/O used in journal-recovery procedure.
    - `%s=SETMouse` - Sets the mouse-event coords to the current cursor position.
    - `%s=Guardband` - Makes a few lines above or below cursor visible.
    - `%s=Mousemask` - Enables mouse events.
    - `%s=TAb` - defines the tab character in tabular text.
    - `%s=Prompt` - defines the prompt string for `G` commands.
    - `%s=ON_Key` - defines a command sequence to be run after every keyboard-initiated command.
    - `%s=SLeep` - suspends activity for period specified in milliseconds.

3.28.8.1 %S=case
----------------
%S=case [0|1|+1] - set case sensitivity attribute.
   
  This sets case sensitivity for the `F` and `V` commands - 1 makes them  case
  sensitive, 0 makes them case-insensitive (e.g. f/Fred/ will match  to  fred,
  FRED or Fred equally well). If no valid value is given,  it  defaults  to  0
  (i.e. insensitive to case). The value +1 reverses the current setting.

3.28.8.2 %S=system
------------------
%s=system [0|1];
  
   In system mode the usual behaviour of saving search  and  substitute/insert
   strings is suspended. This is used in functions which use the `F`, `S`  and
   `I` commands and maintains the original state of these  strings  after  the
   function has completed.

3.28.8.3 %S=commandmode
-----------------------
%s=commandmode [+][<hexBitMask>] - sets command-mode attribute.
   
  See `command-mode vs. insert mode`. The optional ( + )  indicates  that  the
  specified bits of the existing command-mode be toggled.
  
  Bits are assigned as follows (Hexadecimal):
          - 01 - Temporary  Insert  mode  reverts  to  command  mode  when any 
                 function or cursor-control key is hit.
          - 02 - Insert mode (until next %S=commandmode or a Ctrl+C interrupt).
          - 04 - Overtype - when in insert mode overwrites preexisting text.
          - 08 - EscapeAll - all keyboard input  is  taken  as  initiating  an
            escape sequence.
          - 10 - Pass_Ctrl_C  -  If  a  {Ctrl+c}  is  received,  it  does  not
            interrupt - but is passed on like any other character.
                 
        Various useful combinations are available:
          - %s=commandmode 0; - the default setting, sane command mode -  your
            typing appears in the console, it can supply a parameter  to  some
            jot function. To insert to the text use the `Insert`  and  `Enter`
            functions.
          - %s=commandmode 2; - normal insert mode - your  typing  appears  on
            the screen at the current-character position indicated by the  jot
            cursor.
          - %s=commandmode 6; - insert-overtype - similar to %s=commandmode 2;
            except that typed input overwrites any preexisting text.
          - %s=commandmode 8; - EscapeAll - all your typing is taken as escape
            sequences - similar to vi/vim command mode.
          - %s=commandmode 10; - EscapeCtrl -  any  control  character  (ASCII
            codes in the range 0 to 31) is treated as the start of  an  escape
            sequence.
          - %s=commandmode 12;  As  above  but  with  insert  mode  -  control
            characters initiate escape-sequences  and  non-control  characters
            appear at the current-character position.
          - Other  combinations  may  do  something  useful  but  there's   no
            guarantees.
          
        Note that command mode is set to 0 for  normal  command-driven  editor
        operation. See also `InsertMode` and `TempInsertMode` 

3.28.8.4 %S=Commandcounter
--------------------------
> %s=commandcounter 123456789; - a trace point is triggered after the 
                                 specified command count.
> %s=cc 123456789;             - Functionally identical abbreviation.
  
  This command is useful for debugging. It is intended to return to the  point
  of failure following a catastrophic failure inside a complicated  script  or
  function call. 
  
  It works by taking the number of commands that should be allowed to  execute
  normally before a trace event is triggered - see `the jot debugger`. When  a
  script, macro or function fails, there are ways  of  finding  out  how  many
  primitive commands had been executed normally before the failure -  this  is
  used to calculate the command-count limit.
  
  This raises the question "how am I supposed to know the command  count  when
  something interesting is about to happen?" Well "something  interesting"  is
  generally an unexplained early exit from deep down in a complicated  set  of
  code blocks and functions. Assuming the error is repeatable we  can  extract
  the command-counter value at the point of failure.
$ jot ... -in="%s=verbose 13; ... "
  When it fails we see a message like this:
    "{-init sequence failed. (1995529) ... """
  The number in brackets is the command counter at the point  of  failure.  We
  can re-spin the thing but set the command counter to trigger a  trace  point
  just before the failure:
$ jot ... -in="%s=commandcounter 1995520; ... "
  So it should enter the trace loop about 9 steps before it fails.
  
  In normal execution of functions, a counter is incremented as each primitive
  command is processed. This counter is normally set to 0  every  time  a  new
  command line is read from the console. When the initial setting  is  defined
  with %s=CommandCounter it is instead set to run for the specified number  of
  commands and then  execution  proceeds  in  whatever  trace  mode  you  have
  selected. The  trace  mask  (see  `%S=tracedefault`)  determines  the  trace
  trigger and action.
  
  Note that the counting only applies to the command sequence initiated by the
  *next*  command  line.  For  subsequent  command  lines,  the   counter   is
  reset to zero.
  
  In recovery mode (see `about Journal Files`), the behaviour is  modified  to
  exit from the debugger, when the original session used the  debugger  -  see
  `the jot debugger`. 

3.28.8.5 %S=trace
-----------------
%s=trace [+-][<XXXX>] - Trace = Set [modify] trace mode, in hexadecimal.
   
  The optional + qualifier sets the specified bits, the optional  -  qualifier
  unsets the specified bits.
  
  The screen window is only redrawn when the Trace_Break bit is set.
  
  %S=trace sets a mask which controls the user-script debugging  facility  for
  the editor - see also `%S=tracedefault` and the `T` command.
  
  The trace action may optionally be delayed by setting an internal counter  -
  see `%S=commandcounter`.
  
  The trace mode bitmask has the following control  bits  which  can  be  ORed
  together:
    - 0001 Trace_AllCommands:  Each new command is triggers a trace event.
    - 0002 Trace_CommandLines: Each new command line triggers a trace event.
    - 0004 Trace_Functions:    Trace at beginning of each new function call
    - 0008 Trace_SubSequence:  Start of else clauses etc.
    - 0010 Trace_Failures:     Any failing command triggers a trace event.
    - 0020 Trace_FailNoElse:   Any failing command with no local else sequence.
    - 0040 Trace_FailMacros:   Trace on exit from any failing block, macro or function.
    - 0080 Trace_Interrupt:    Trace on A {Ctrl+C} interrupt.
    - 0100 Trace_Recovery:     Enables normal debugging in recovery mode.
    - 0400 Trace_DumpSeq:      Dumps compiled commands.
    - 0800 Trace_Backtrace:    Dumps a backtrace at each trace event.
    - 1000 Trace_Stack:        Dumps contents of the stack at each trace event.
    - 2000 Trace_Print:        Prints the current line of the current buffer.
    - 4000 Trace_Source:       Displays the command line at each trace event.
    - 8000 Trace_Break:        Breakpoint at selected trace point.
     
  One group of bits (Trace_AllCommands, Trace_CommandLines, Trace_SubSequence,
  Trace_Failures, and Trace_Interrupt) define  the  trace  points.  The  other
  group of bits (Trace_Backtrace, Trace_Stack, Trace_Print,  Trace_Source  and
  Trace_Break) determine the action to be taken at a trace  point.  The  other
  one - Trace_Recovery is used in recovery scripts only - see below and `about
  journal files`.
  
  Trace_AllCommands,  Trace_CommandLines  and  Trace_SubSequence  perform  the
  selected trace-point actions at every command or  at  the  start  of  a  new
  command line respectively. Trace_Failures performs the  trace-point  actions
  after a failing command.
  
  Trace_Interrupt changes normal {Ctrl+c} behaviour - {Ctrl+c} normally  drops
  everything and returns to the normal jot prompt. With Trace_Interrupt set it
  enters the interactive jot debugger - note that, by  default,  Trace_Int  is
  not set up by the `T` command, you  have  to  set  Trace_Interrupt  in  your
  `%s=tracedefault`  setting  and  your  %s=trace  settings  -  see  `the  jot
  debugger` and `Trapping on {Ctrl+c}`.
  
  The Trace_Stack bit directs a stack dump to the console, this will not be of
  much help unless the console area of the screen is reasonably large or there
  is not much on the stack.
  
  The Trace_Print bit prints the current  line  of  the  current  buffer  just
  before execution of the command.
  
  The Trace_Break bit triggers a break at the trace point, it  prompts  for  a
  command with 'Debug Command>' any valid JOT command string may  be  entered.
  If a hexadecimal value is entered with a leading zero, then this sets a  new
  value for the trace mode - in  particular  0  will  exit  trace  mode.  Just
  hitting the return key advances to the  next  break  point.  Note  that  the
  debugger does not attempt to restore the original  context.  Note  also  the
  debugger interface does not handle hotkeys.
  
  The Trace_Recovery bit causes trace points to behave  normally  in  recovery
  mode. In recovery mode, the default behaviour is to read  instructions  from
  the recovery file rather than the console. Setting  this  bit  allow  normal
  interactive debugging of the recovery script - when unset the debugger picks
  up copies of debugger commands from the original session.
  
  In order to enter the debugger while  processing  a  recovery  file,  it  is
  necessary to edit  the  recovery  file  inserting  a  suitable  %s=trace  or
  %s=tracedefault command in the script. A typical  useful  setting  might  be
  F901 - see also `recovery notes`.
  
  Setting the Trace_Backtrace bit causes a backtrace  to  be  issued  at  each
  trace  point  -  not   particularly   useful   for   Trace_AllCommands   and
  Trace_CommandLines   but   can   be   most   useful   when   combined   with
  Trace_Failures. Even so, it is not a  good  idea  to  run  the  editor  with
  Trace_Failures turned on -  it's  not  unusual  for  simple  keyboard-driven
  functions to generate several failures - all appropriately handled  but  you
  still end up with gazillions of uninteresting messages.
  
  If a macro buffer is redefined and reused part-way  through  execution,  the
  compiled code will execute normally but the original  source  is  no  longer
  available to the debugger for display. When this happens, the  situation  is
  detected  and  instead  of  echoing  the  original  source,  it  displays  a
  disassembly of the compiled code. For example:
$ jot ${JOT_RESOURCES}/t.t -in="%w=clear; %w=new -height=9 -delim; %s=trace 4001; %da=zai/%ga/bi/mm-/bi/:/bi/ \\\'a/b2; 'a"
  In this -init sequence the buffer ( A ) is  initially  defined  as  a  macro
  that redefines the same macro buffer with source-code tracing turned on.  As
  you can see, the disassembly listings are quite  a  bit  more  difficult  to
  follow.
  
  If no trace action is specified then, appropriately, it does nothing at each
  trace point.
  
  The `T` command simply sets the trace value to the  current  default  value,
  initially  set  to  B001  (Trace_Stack  |  Trace_Print   |   Trace_Break   |
  Trace_AllCommands) but can be redefined using the '%s=tracedefault' command.
  Another useful setting is B002 - this displays the same  at  each  stop  but
  only stops at the start of each new command line.
  
  See also `%s=tracedefault` and `about jot debugging`.

3.28.8.6 %s=tracedefault
------------------------
%S=tracedefault [+-][<hexValue>]
  
  This defines the value to be  assigned  to  the  trace  vector  by  the  `T`
  command. By default this is:
     Trace_Stack | Trace_Print | Trace_Break | Trace_AllCommands
     
  The optional + qualifier sets the specified bits, the optional  -  qualifier
  unsets the specified bits in the mask.
  
  In contrast to %s=trace, which sets the trace mask  with  immediate  effect,
  %s=tracedefault specifies a trace mask to be applied at the next break point
  (breakpoints are set by the `T`, by the `%s=commandcounter` commands and  bu
  Ctrl+C interrupts).
     
  See also `%s=trace` and `about jot debugging`.

3.28.8.7 %s=traceskip
---------------------
%s=traceskip [<RelativeLevel>];
  
  Suppresses all tracing functions until call level (of block, macro,  function
  or script)  returns to the specified level, relative to current call level.
  
  Each time a new block, macro, function or script is entered, the call  level
  is incremented correspondingly, the call level is also decremented  on  exit
  from these programming structures. 
  
  To skip past one of these structures and resume tracing as it exits, specify
  a RelativeLevel of zero (the default). To skip  tracing  until  the  current
  block/macro exits specify a RelativeLevel of 1, etc. It is also possible  to
  set negative RelativeLevels - in this case tracing resumes inside  the  next
  structure.
  
  The function `DebuggerQuit` is implemented using %s=traceskip.

3.28.8.8 %s=setenv
------------------
%s=setenv <envName> <envValue>
   
  This sets an environmental variable in your session. It does not, of course,
  change the environment in your shell but only for your  editor  session  and
  any child processes it might spawn.

3.28.8.9 %s=verbose
-------------------
%S=verbose <x> - sets the verbosity bit mask in hex.
  
  The verbosity bit mask currently has the following recognized bits:
  
  Note that the CLI qualifier `-quiet` works by  setting  the  verbosity  mask
  but before any of the  normal  startup  messages  ensuring  quiet  operation
  right from the start.
   
    - 1 (Bit 0) Verbose_NonSilent  -  when  set,  normal  error  messages  are
      delivered.
    
    - 2 (Bit 1} Verbose_Prompt - when set, prompts user for command input.
     
    - 4 (Bit 2) Verbose_QuiteChatty - when set it reports a few more  failures
      and briefly explains what is wrong, it is recommended to allow at  least
      5 lines in the console area for this.
      
    - 8 (bit 3) Verbose_PrintLine - causes the current  line  of  the  current
      buffer to be written to the console  area,  in  addition  to  the  other
      messages.
      
    - 16 (bit 4) Verbose_ReportCounter - also reports command  counter  -  see
      `%s=commandcounter` and `about  jot  debugging`.  Messages  and  failure
      reports are augmented with the current state of the command counter, the
      command count is also added to the exit message (see `%C` and `%A`). 
      
      Setting ReportCommandCount will also cause  user-defined  messages  (see
      `%M`) to be augmented  with  the  command  counter  state.  The  command
      counter can be used to set a  break  point  in  some  later  run  -  see
      `%s=commandcounter` and `the jot debugger`).
     
    - 32 (Bit 5) Verbose_AnnoyingBleep - error messages are accompanied  by  a
      bleep.
    
    - 64 (Bit 6) Verbose_DebugMessages - enables whatever  debugging  messages
      may have been accidentally left in your version of jot.
    
  These bits are combined to achieve a desired effect e.g.
> %s=verbose 3;   - (default state) for normal prompting and error reporting.
> %s=verbose 23;  - for normal prompts and reporting with bleeping.
> %s=verbose 1f;  - for normal prompts and comprehensive reporting.

3.28.8.10 %s=console
-------------------
%s=console <0>|<noOfLines>;
  
  This sets an upper limit on  the  expansion  of  the  console  messages.  By
  default messages are restricted to any spare terminal lines at the bottom of
  the display (see `About the jot console and display windows`), setting  this
  limit allows messages to encroach  upwards  into  the  window  area  of  the
  terminal.
  
  If set to 0 (the default state), then the  console  area  is  fixed  at  the
  number of lines left below the windows. The startup script sets the  windows
  to leave a 2-line console area.
  
  If the console expansion area is set to more than the number of lines  below
  the windows, then the console area will expand upwards to a total size limit
  specified in the %s=console command. The Additional console lines are erased
  on the next editor action (a new command string, an escape sequence or  just
  by hitting {return}.

3.28.8.11 %s=guardband
----------------------
%S=guardband[ <n>]
  Sets an n-line guardband. A band  of  n  lines  is  maintained  between  the
  current line of text and the top or bottom of the display. The value may  be
  0 - this is also the default.
  
  In the event of the total guardband exceeding the window size,  the  current
  line is held at the centre of the window.
   
  With a 3-line guardband, for example, it always displays the 3  lines  above
  and below the current record.

3.28.8.12 %s=tab
----------------
%s=tab [<chr>]
  This defines the character to be  used  as  a  cell  separator  for  tabular
  text.It is also used as the default  search-string  separator  in  the  `%F`
  command. It defaults to VT (vertical Tab). This can be set to,  pretty-much,
  any normal ASCII character but not unicode characters.

3.28.8.13 %S=CommandString
-----------------------------
%s=commandstring <CommandString>
  This inserts the specified command string  back  into  the  console  command
  buffer. This makes it possible to modify the console  input  using  ordinary
  editor commands and then execute the modified command sequence.
  
  This is used for command-line editing  (see  `about  command  editing`)  and
  systematic modification of keyboard input - take a  look  at  `uc_basic.jot`
  this uses %s=commandstring to substitute unicode escape sequences for  UTF-8
  byte sequences.

3.28.8.14 %s=MouseMask
----------------------
%s=mousemask[ <HexValue>]
  
  This enables the detection and handling of  selected  mouse  events  -  e.g.
  left-button clicks etc. When enabled by %s=MouseMask, mouse  events  can  be
  picked up and handled  in  the  same  way  as  as  escape  sequences.  Also,
  mouse-click coordinates can be picked up by the `OP` command.
  
  By default, all mouse actions are disabled (the mouse mask is set to 0),  if
  %s=mousemask is given with no value then all mouse events are picked  up  by
  the editor (and normal X mouse actions are disabled).  If  a  hex  value  is
  given then that value is passed to the curses mousemask() function. For full
  details refer to curses.h and the mousemask (3NCURSES) man page.
  
  The problem with enabling all mouse events is that it  replaces  the  really
  useful X-windows selection actions - so only set the  mouse  mask  when  you
  really need to define mouse functions. The  standard  setup  defines  a  few
  mouse-action functions.
  
  The problem is not so acute for windows users since windows offers virtually
  no worthwhile mouse functions for console terminals.
  
  In any case, normal service can be restored by resetting the mousemask to 0:
> %s=mousemask 0;
  
  See also `About mouse events`, `OP` and `%b=addtag`

3.28.8.15 %S=RecoveryMode
-------------------------
%s=recoverymode <value>
  
  Used when recovering a session from  journal  files.  In  order  to  prevent
  corruption of existing files %O  operations  are  disabled  and  %I  and  %E
  operations read from the journal area - see `about journal files`

3.28.8.16 %S=copy
-----------------
%s=copy
    
  Copies text into the system paste buffer. The start point is set by the  'N'
  (Note) command, the end point is set by the current  character  position  at
  the time when the %s=copy command is invoked. As  with  the  'A'  (Abstract)
  command, the start and end point must be in the same buffer and, if the  end
  point is before the start point the start and end points  are  automatically
  reversed.
  
  In windows, the system buffer used is the 'clipboard', in linux %s=copy  and
  %s=paste both use the X paste buffer N.B. not the selections buffer.
  
  In order to minimize the number of statically-linked libraries in the  linux
  version, this command is not available in the linux executables supplied  in
  the download - see `Unix and linux setup`.

3.28.8.17 %S=paste
------------------
%s=paste
  
  Copies the contents of the system paste buffer into the  current  buffer  at
  the current-character position.
  
  In order to minimize the number of statically-linked libraries in the  linux
  version, this command is not available in the linux executables supplied  in
  the download - see `Unix and linux setup`.

3.28.8.18 %s=prompt
-------------------
%s=prompt[ <promptString>]; - set prompt string.
  
  Sets the prompt for the `G` command.
  
  If the prompt string is not given, then the G-command prompt reverts to it's
  default "> ".

3.28.8.19 %s=on_key
-------------------
%s=ON_Key[ -after][ <JotCommandSequence>]
  
  Defines  a  Jot  command  sequence  to  be  performed  before   any   normal
  interactive command. The -after qualifier says to run the command after  the
  users command. You may define commands to be run both before and  after  the
  user command sequence - but you will need two %s=On_Key commands  to  define
  them.
  
  The `WindowWithLineNumbers` function provides a good example of the  use  of
  this command.

3.28.8.20 %s=on_int
----------------------
%s=ON_Int <jotCommandSequence>;
  This defines a command sequence to be  obeyed  in  response  to  a  {Ctrl+C}
  interrupt before it commences to  unwind  the  call  stack.  It  could,  for
  example, be set up to backtrace. This could be useful in  the  diagnosis  of
  some errors.
> %s=on_int %q=backtrace;

3.28.8.21 %s=setmouse
---------------------
%s=setmouse
  
  Initializes the mouse position to  the  current  character  in  the  current
  buffer - see `OP`, `Query tags` and `query window`.
  
  Useful  for  emulating   mouse   clicks   for   applications   designed   as
  mouse/touch-pad interfaces in non-mouse environments (see `qr.jot`) and  for
  testing scripts using the OP command for the window query.

3.28.8.22 %s=sleep
------------------
%s=sleep <n>;
  
  Suspends activity for a period of n milliseconds.

3.28.9 %B
---------
%b=<attributeName>[ <value>] - set some attribute of the current buffer.
  - `%b=UNRestricted` - resets the buffer write-access attribute.
  - `%b=WRiteifchanged` - editor will not exit until buffer is written.
  - `%b=REadonly` - sets the buffer write-access attribute.
  - `%b=LEftoffset` <n> - sets the buffers left-offset attribute.
  - `%b=TABStops`[ <n1>[ <n2>[ <n3>[ ...]]]]  -  controls  display  of  simple
    tabular text.
  - `%b=TABCells`[ <n1>[ <n2>[ <n3>[ ...]]]] -  controls  display  of  tabular
    text.
  - `%b=HEader` <headerText> - defines a static header line for display.
  - `%b=FOoter` <footerText> - defines text for window-separator line.
  - `%b=UNIcode` {0|1} - Disables|Enables unicode support in this buffer.
  - `%b=ENcoding` {"Plain" | "UTF_8" | "UTF_16LE"} - sets unicode encoding scheme.
  - `%b=PAthname` <pathName> - (re)defines pathname.
  - `%b=SAmeflag1` - sets the user change-control flag.
  - `%b=TAGtype` - defines a named metadata tag.
  - `%b=ADdtag` - Adds a metadata tag to the text.
  - `%b=REmove_tag` - Removes instances of a named tag
  - `%b=SOrt` - sorts text in buffer.
  - `%b=TAbsort` - sorts tabular text in buffer.
  - `%b=COdepage` - Sets code page for buffer (windows only).

3.28.9.1 %B=unrestricted
------------------------
%b=UNRestricted - sets the buffer write-access attribute.
   
  This returns the readonly and  writeifchanged  status  of  the  buffer  (see
  `%b=readonly` and `%b=writeifchanged`) to their default settings.

3.28.9.2 %B=readonly
--------------------
%b=REadonly[ 0|1] - sets the buffer write-access attribute.
  
  The default state for buffers is that they may be modified. If this  command
  is applied with no value specified or is specified as  1  then  the  current
  buffer is set to a readonly  state.  It  can  be  viewed  but  not  altered,
  sections of text may be abstracted provided the & qualifier  is  given  (see
  the `A` command).
  
  See also the `%B=unrestricted` command.

3.28.9.3 %b=writeifchanged
--------------------------
%b=WRiteifchanged[ 0|1] - sets the buffer write-access attribute.
 
  The default state for buffers is: any changes are lost  if  the  session  is
  terminated without explicitly saving (see the `%O` command). In other  words
  you lose some of your work. If this command is applied with no value or  the
  value is specified as 1 and  the  buffer  has  been  modified,  the  session
  cannot be terminated normally (by `%C` or `%A`) until the  buffer  has  been
  be saved. If  you  set  writeifchanged  and  then  decide  to  discard  your
  changes, you can unset this flag with `%b=unrestricted`.
  
  In this state the buffer may be modified but  if  there  is  an  attempt  to
  overwrite or to exit the editor without first  saving.  Then  a  warning  is
  issued and the editor session remains live. It is , of course,  possible  to
  reset this lock and exit normally to discard changes.
  
  The motivation for this one is that jot encourages users  to  edit  multiple
  files in one session - it's just a bit too easy to forget and  exit  without
  saving something important.
  
  If, after you've checked the locked buffers, you  still  want  to  exit  the
  session anyway, the `exit.jot` script might help.
  
  See also the `%B=unrestricted` command.

3.28.9.4 %b=leftoffset
----------------------
%b=LEftoffset <n> - sets the buffers left-offset attribute.
   
  Sets the text column to appear in the leftmost column  of  the  window  when
  displaying this buffer.
  
  By default, the left offset is 0. This may be increased to  display  records
  longer than the width of the current window. See `about long lines`. If  the
  given value is negative, this is silently ignored and the leftoffset is  set
  to 0.
  
  See also `about long lines` and `query inview`  -  this  verifies  that  the
  current character is visible with the current leftoffset setting.

3.28.9.5 %b=tabstops
--------------------
%b=TABStops[ <n1>[ <n2>[ <n3>[ ...]]]] - controls display of simple tabular text.
   
  By default, tabs and other control characters are rendered as a tilde '~' on
  the screen - see `about tabular text`. If tabStops have been defined  for  a
  buffer containing tabular text then each tab is  replaced  by  one  or  more
  blanks in the display. When correctly set up, the  tabular  text  is  neatly
  aligned with that of other records in the buffer.
  
  Each entry in the %b=tabStops command is a number  indicating  the  absolute
  column number to be assigned to the following text - hence  tabStops  should
  always be an ascending sequence of column numbers. If a tab  is  encountered
  that is already beyond (i.e. to the right of) it's assigned column then  the
  tab character is simply rendered as a single blank.
  
  Use %b=tabcells for buffers containing simple tabular text - indented source
  code,  simple  tables,  formatted  letter  headings  etc.  For  tables  with
  wildly-varying cell lengths use `%b=tabcells` which will  truncate  overlong
  cells to maintain the columns.
  
  The %b=tabstops command will delete any  preexisting  tabstops  or  tabcells
  settings, if no tabstops are given, then the buffer  reverts  to  displaying
  tabs as tildes ( ~ ).
  
  If the first tabstop is any negative number, then this is taken as a request
  for automatically-assigned tabstops - any other values in the  command  line
  are  ignored.  With  automatically  assigned  tabstops  the  window  manager
  analyses the position of all tab characters currently in  view  and  assigns
  the smallest tabstops  compatible  with  displaying  tabular  data  in  neat
  columns. Currently, the maximum number of of automatically-assigned tabstops
  is limited to 100.
  
  The tabstops are displayed in the `query buffer` report.

3.28.9.6 %b=tabcells
--------------------
  Each  tab-delimited  item  of  text  is  said  to  be   a   cell.   If   the
  manually-defined tabcell is insufficient to display all of a cell, then  the
  cell text is truncated and an exclamation point  (  !  )  is  added  to  the
  righthand end of the truncated text.
  
  The %b=tabcells command will delete any  preexisting  tabstops  or  tabcells
  settings, if no tabcells are given, then the buffer  reverts  to  displaying
  tabs as tildes ( ~ ).
  
  In the event of there being a record with more then the number of predefined
  tabcells, then additional tabcells are assigned by adding the tab spacing to
  the previous tabcell entry.
  
  If the first tabcell is any negative number, then this is taken as a request
  for automatically-assigned tabcells - any other values in the  command  line
  are  ignored.  With  automatically  assigned  tabcells  the  window  manager
  analyses the position of all tab characters currently in  view  and  assigns
  the smallest tabcells  compatible  with  displaying  tabular  data  in  neat
  columns. Currently, the maximum number of of automatically-assigned tabcells
  is limited to 100.
  
  The tabcells are displayed in the `query buffer` report.

3.28.9.7 %b=header
------------------
%b=HEader[ <headerText>] - defines or removes a static header line.
  
  If the headerText string is given, this is displayed in reverse video at the
  top of any window displaying the current buffer. The header is static in the
  sense that it is fixed to the top line of the window and text  scrolls  past
  it. When you define a buffer string it occupies one of the  lines  requested
  in the `%W` command, leaving you with  one  less  line  for  viewing  buffer
  images. If no headerText string is given then any previously defined  header
  line is removed. By default, buffers have no header line.
  
  If the buffer has TabStops set (see `%b=tabstops`)  then  any  tabs  in  the
  header text will be treated in the same way as those in the main body of the
  buffer. The upshot of this is that the text can contain column headings  for
  buffers containing tabular entries (e.g. images of spreadsheets etc.).

3.28.9.8 %b=footer
------------------
%b=FOoter some text;
  
  By default, the reverse-video separator at the end of a window contains  the
  current buffer's pathname (if defined) and  the  buffer  key.  This  command
  replaces the pathname with some text of your own choosing.
  
  As with long pathnames, the text may be truncated to fit.

3.28.9.9 %b=unicode
-------------------
%b=UNicode {0|1}
  This controls unicode support for the current buffer.
  
  Any value other than 0 restores the default  mode  of  operation  -  unicode
  characters are rendered normally.
  
  The value 0 turns off unicode support, in this state each byte of  UTF-8  is
  represented on the screen by a tilde ( ~ ).
  
  Disabling unicode support affects the rendering of characters on the  screen
  any non-ASCII or ASCII control characters bytes are displayed as a tilde and
  also affects several commands:
    - `R` - counts bytes not characters.
    - `OR` - counts bytes not characters.
    - `OX` - returns the byte count not character count.
    - `OC` - returns byte count not character count.
    - `OU` - expects to be given a byte count not a character count.
    
  The editor should always navigate and display the UTF-8 correctly but  UTF-8
  is a variable-length encoding scheme. Now jot maintains  a  pointer  to  the
  first byte of the current character, if that pointer should end up  pointing
  to some other byte the character  will  not  be  displayed  correctly.  This
  situation should not occur normally but it can happen when switching back to
  unicode support with %b=unicode.

3.28.9.10 %b=pathname
---------------------
%b=PAthname <pathName> - (re)defines pathname.
   
  This sets the default pathname to be used when this buffer is later  written
  to the filing system.

3.28.9.11 %b=sameflag1
----------------------
%b=SAmeflag1 - sets the user change-control flag.
   
  Sets the user flag SameFlag1 - this remains true until there is some  change
  to the buffer text. This flag can be tested if ever a macro needs to  detect
  changes that have occurred  since  the  flag  was  set  -  see  also  `Query
  sameflag1`.

3.28.9.12 %b=tagtype
--------------------
%b=TAGtype -Colour=<foregroundColourNo>:<backgroundColourNo> <tagName>
  or, according to upbringing:
%b=TAGtype -Color=<foregroundColourNo>:<backgroundColourNo> <tagName>
  
  Currently the only tag types allowed are colour tags  but  it  is  envisaged
  that this might be extended in the future.
  
  This either defines a new colour pair or redefines  one.  Colour  pairs  are
  defined in terms of the foreground and background colour and are  referenced
  by the pair number.
  
  The tag name can then be used to tag text with colour using the  `%b=addtag`
  command - see also `about tagged text`.
  
  Colours are identified by number in the range 0-to-7 - in linux these are:
    - 0 Black
    - 1 Red
    - 2 Green
    - 3 Yellow
    - 4 Blue
    - 5 Magenta
    - 6 Cyan
    - 7 White
    
  in windows:
    - 0 Black
    - 1 Blue
    - 2 Green
    - 3 Cyan
    - 4 Red
    - 5 Magenta
    - 6 Yellow
    - 7 White
  In windows, adding 8 gives a more intense colour.
  
  e.g. To define a colour tag "fred" as yellow forground on a blue  background
  in linux:
%s=colourpair fred 3 4;
  in windows
%s=colourpair fred 6 1;
  or, for a brighter yellow:
%s=colourpair fred 14 1;

3.28.9.13 %b=addtag
-------------------
  There are two valid forms:
%b=ADdtag -text=<textString>;
%b=ADdtag <tagName>;
  
  - In the %b=addtag <TagName> form:
      The TagName must match a previously defined tag type (see  `%b=tagtype`)
      or the command fails.
      
      Applies the named tag to the currently-selected substring in  text.  The
      named tag type and it's colour pairs must  first  be  defined  with  the
      `%b=tagtype` command - see also `about tagged text`.
      
      If, at "addtag" time, there  is  a  selected  substring,  two  tags  are
      applied - one at the start of the currently-selected substring  and  one
      at it's end. If there is no selected substring then no end-tag is  added
      the tagging continues through to the end of the line.
  
  - In the %b=addtag -text=<textString> form:
      The text string, which may be  of  any  length,  is  added  to  the  tag
      descriptor. This string can be used for any  purpose  but  is  primarily
      intended for use as a hashtable key. The string is only visible  in  the
      `query tags` report.
      
    Tags persist until removed  with  the  removed  with  the  `%b=remove_tag`
    command or the text is deleted.
    
    See also `About mouse events`, `%b=remove_tag`, `%s=mousemask` and `OP`

3.28.9.14 %b=remove_tag
-----------------------
  There are three valid forms, in each case :
%b=REmove_tag -TArget <keyName>
  The current character must match  the  tag  point,  this  form  removes  the
  destination tag for `hashtable JUMP` operations.
%b=remove_tag -Colour <colourTagName>
  The currently-selected substring must match the extent  of  the  tag  to  be
  removed, this form removes the selected instance of the colour type.
%b=remove_tag -TExt <textString>
  The currently-selected substring must match the extent  of  the  tag  to  be
  removed, this removes the selected text tag matching the text string.
  
  The current character must be at the start-point of the tag to be deleted.
  
  This command uses the details given and the  current-character  position  to
  uniquely identify one tag and then removes it from the internal record  data
  structure. In the event of there being two or more identical  tags  matching
  the description, it randomly selects one of the matching  tags  and  deletes
  only that one.
  
    - The tag type field must be one of colour, text or target.
    - the name field for a colour tag must match the colour-tag  name,  for  a
      text-tag it must match the first whitespace-separate  word  of  the  tag
      text and, for a hash-table target, the name must  match  the  hash-table
      key.
    - the current character and substring length  select  the  start  and  end
      point of the tag.
  
  The tags were originally created by  the  `%b=addtag`,  `hashtable  newjump`
  and `hashtable addjump` commands - see `about tagged text`.
  
  Where precise details of the tag is not  known,  use  the  `query  tags`  to
  extract the necessary information from the internal data set.
  
  In the event of there being no tag exactly matching the details  given  then
  the command fails without affecting any tags.

3.28.9.15 %B=sort
-----------------
%b[<destBuf>]=SOrt [<sliceColumn1>][ <sliceColumn2>[ <sliceColumn3> ...]]]
  Performs an alphabetical sort of all records in the buffer, by  default  the
  records are sorted by the strings starting at the  first  character  (column
  0). For tabular text, other columns  (slices)  may  be  specified,  to  sort
  tab-separated tabular text use `%B=tabsort`
   
  Each parameter is taken as a slice definition (i.e. a  vertical  slice  down
  the tabulated text), the following forms are supported:
    - <firstChrNo>-<lastChrNo> - counting from the  first  character  in  each
      record (chr no. 0), this defines a slice of the buffer to be used in the
      sort comparison.
    - <firstChrNo>+<width> - defines the start  character  and  width  of  the
      slice - minimum sensible width is 1.
  
  The sort function (a  version  of  quicksort)  compares  pairs  of  records,
  initially from slice slice1. If they are found to be identical, it  tries  a
  comparison from slice slice2, then slice3 etc... If no slices are  specified
  it performs just one comparison on each complete record.
  
  Note that left to the user to ensure that  each  record  has  at  least  the
  number of columns specified - otherwise results are unpredictable.
  
  The sort function modifies the current buffer and writes a sort summary into
  the nominated destination buffer.
  
  See also `sort.jot`, this script offers a few options for tweaking the  sort
  order.

3.28.9.16 %B=tabsort
--------------------
%b=TAbsort <tab1>[ <tab2> [<tab3> ...]]] - sort buffer holding tabular text.
  
  Each tab entry is an integer in the range 0 to n-1 where n is the number  of
  columns in the table (counting from 0).
   
  Similar to the  `%b=sort`  command,  tabsort  sorts  records  by  values  of
  unaligned tab-separated fields,  the  delimiter  character  defaults  to  an
  ascii VT ( 0xB  )  character  but  can  be  redefined  to  any  valid  ASCII
  character with the `%s=tab` command.
  
  Shorter fields always rank higher in a  strcmp  string  comparison  so  some
  additional whitespace padding may be required.

3.28.9.17 %b=encoding
---------------------
%b=encoding <UTF-encodeing> - set output UTF encoding scheme for this buffer.
  
  This sets the UTF encoding scheme to be used if ever the buffer  is  written
  out to a file. By default the encoding matches that of the original file, if
  it's a new file then the default is UTF-8/ASCII.
  
  When reading a file to a jot buffer, it  is  not  necessary  to  define  the
  encoding scheme - jot recognizes the BOM tag (see `Unicode  -  the  gruesome
  details`). Intenally, jot uses UTF-8 so other formats are converted as  they
  are read in the reverse conversion is normally applied when they are written
  back.
  
  Supported encoding schemes:
    - UTF_8 (or plain old ASCII).
    - UTF_16BE
    - UTF_16LE
    - UTF_32BE
    - UTF_32LE

3.28.9.18 %b=codepage
---------------------
%b=COdepage <codepage>
   
  This modifier is only available in the windows version. By default jot  uses
  the 65001 (UTF-8).
  
  This sets the codepage which is  only  relevant  to  unicode  -  see  `about
  unicode`, `Practicalities of unicode etc. and jot`

3.28.10 %q
----------
%Q[<bufferKey>]=<query>
   
  The various flavours of the query command offers a  few  selected  peepholes
  into selected internal editor states and the system environment.
  
  Some of these send a wordy report to a specified target  buffer,  some  only
  return a success/failure status, others place values on the stack. Some will
  (e.g. backtrace and version) will generate a report in  a  specified  buffer
  or, if no destination buffer is specified, send the report  to  the  console
  area. Some (e.g. dir and file, will  generate  a  report  if  a  destination
  buffer is given or a status value if the file or directory does not exist.
   
  In most cases the target buffer, indicated by <bufferKey>, is the buffer  to
  receive the  result.  The  exceptions  are  dir,  file,  SameFlag1  and  the
  hashtable queries. In all cases the first line of output  to  the  nominated
  buffer is the original %q command. Valid queries are:
  
  All report-generating queries may be give  the  optional  qualifier  -Append
  this appends the report to  the  end  of  any  preexisting  content  in  the
  specified buffer. By default the buffer is first cleared. 
  
  %q~=... is a special case, the ~ buffer is created on the stack - see `about
  the operand stack`.
    - `query SYstem` - Returns current system settings to specified buffer.
    - `query Linux` fails if not running under linux.
    - `query WINDOWS` fails if not running under windows.
    - `query WD` -  Returns  users  current  working  directory  to  specified
      buffer.
    - `query WIndow` -  Reports  window  allocation  parameters  to  specified
      buffer.
    - `query BAcktrace` reports command-script calls
    - `query TIme` - pushes time in seconds since start of unix epoch.
    - `query CPutime` - pushes on stack current cputime from system (n.b. this
      is a real (floating-point) value.
    - `query Pid` - pushes on stack current process ID.
    - `query DAte` - Reports current data and time to specified buffer.
    - `query Env`  -  Reports  value  of  specified  environment  variable  to
      specified buffer.
    - `query STack` - Dumps stack contents to specified buffer.
    - `query TABStops` - Fails if no tabstops set in current buffer.
    - `query TABCells` - Fails if no tabcells set in current buffer.
    - `query Buffer` - Reports buffer status to specified buffer.
    - `query SAMESINCEIO` - Fails if current buffer  has  been  changed  since
      last read or written.
    - `query SAMESINCEINdexed` - Fails if  current  buffer  has  been  changed
      since last hash-table entry was added.
    - `query SAMESINCECompiled` - Fails if current  macro-command  buffer  has
      been changed since it was last compiled.
    - `Query SAMEFlag1` - Fails if current buffer has been changed since  user
      flag 1 was last reset.
    - `query Case` - Fails if case sensitivity is off.
    - `query Inview` - Fails if current character of current buffer is out  of
      view.
    - `query Version` - Reports jot version to buffer, if specified or else as
      a message to the console area.
    - `query DIr` - Reports contents of to buffer if specified or fails if not
      a valid directory.
    - `query File` - Reports system file data to buffer if specified, fails if
      not a valid pathname.
    - `query KEYS`[ -key=<name>] Writes a diagnostic dump of buffer hash-table
      keys to specified buffer.
    - `query TAgs` - lists the tags (hash-table target points and colour tags)
      in current buffer.
    - `query HEap` - in linux sends heap-status to the nominated buffer.
    - `query History` - Dumps command history to specified buffer.
    - `query VERIfy` - Checks consistency of current  buffer's  internal  data
      structures.

3.28.10.1 Query system
----------------------
%q<key>=[ -Append ]SYstem
  
  Reports current state of system settings to nominated buffer followed  by  a
  list of primary buffers i.e. not stack-based or data-object buffers.
	          Trace vector = <hex value> - of trace vector - (see `%S=trace`)
	      Case sensitivity = <hex value> - case sensitivity vector - (see `%S=case`)
	          Command mode = <hex value> - the command-mode vector (see `%S=commandMode`)
	 Table-entry separator = <hex value> - the character used to separate  entries
                                        in tabular text (see `%S=tab`).
	   Hold screen on exit = {On|Off}    - Set by `-hold` CLI qualifier.
	Buffers:
	  buffer <key1>                   - First in list of defined buffers.
	  buffer <key2>
	  ...
	Data-object buffers:
	  data obj <path> 
	  ...
  
  The list of buffers contains all primary  buffers  that  have  been  created
  thus-far in the session, including some with lower-case alpha keys (i, t and
  p) - these are set up and used internally and  are  not  accessible  to  the
  user.

3.28.10.2 Query linux
---------------------
%q=Linux
  
  Used to test the underlying OS, this  one  fails  for  anything  other  than
  linux.

3.28.10.3 Query windows
-----------------------
%q=WINDOWS
  
  A simple test the underlying OS, this one fails for anything other than some
  flavour of NT-windows.
  
  Note - this has nothing  to  do  with  the  `query  window`  command,  which
  generates a window-assignments report.

3.28.10.4 Query wd
------------------
%q<key>=[ -Append ]WD
  N.B: Not available in windows.
  
  Returns the users current working directory or fails and returns <undefined>
  if, for whatever reason, the PWD cannot be determined. The  windows  version
  *always* fails and returns <undefined>.
     
3.28.10.5 Query window
----------------------
%q<key>=[ -Append ]WIndow - reports window assignments.
   
  Lists  screen  size,  details  of  all  allocated  windows  and  number   of
  unallocated lines on the screen.
  
  Then follows a screen dump - the current contents of the screen is copied to
  the end of the  report.  Note  that  the  screen  dump  does  not  show  any
  highlights, reverse video, colour tags or the cursor position.
  
  Note - this has nothing to do with the `query windows` command, which  is  a
  simple go-nogo test on your OS architecture.

3.28.10.6 Query Time
--------------------
%q=TIme - pushes time, in milliseconds, since beginning of unix epoch onto stack.
  
  This uses the system clock to calculate how many seconds have elapsed  since
  the begining of unix time (zero o'clock on the first of January  1970).  See
  also `query cputime`.

3.28.10.7 Query cputime
-----------------------
%q=CPutime - pushes to stack, time elapsed since last query cputime.
  
  N.B: Not available in the windows version.
  
  This uses the system clock to measure the time interval  between  calls,  it
  pushes a real number (cpu seconds) onto the stack. The value returned by the
  first call should be discarded. 
  
  It calculates gives  a  floating-point  value  calculated  from  the  system
  seconds and nanoseconds elapsed-time counters.  Each  time  it's  called  it
  subtracts the previous values of these counters from  their  current  values
  and converts the difference to a floating-point number, which is pushed onto
  the stack. It is envisaged that this may be useful for some future profiling
  tool. See also `query time`.
  
  In the windows version it always returns the value 0.0

3.28.10.8 Query date
--------------------
%q<key>=[ -Append ]DAte - reports date and time.
   
  Returns the current date and time in the form dd/mm/yy, hh:mm:ss
         
3.28.10.9 Query env
-------------------
%q<key>=[ -Append ]Env <name> - reports value of nominated env variable.
   
  Returns the current value of the specified variable in the users env.
      
3.28.10.10 Query pid
--------------------
%q<key>=[ -Append ]Pid - Query the ID of the ediors process.
  
  This reports just the process-ID number of the editor process.

3.28.10.11 Query stack
----------------------
%q<key>=[ -Append ]STack
  - reports state of stack.
   
  Returns the current state of the stack in decimal hex and character format -
  see also `O?`.
      
3.28.10.12 Query tabstops
-------------------------
%q=TABStops
  
  This is a quick test to identify buffers which have been set up  for  simple
  tabular text. The command succeeds  if  tabstops  are  set  in  the  current
  buffer, otherwise it fails - see `%b=tabstops`.

3.28.10.13 Query tabcells
-------------------------
%q=TABCells
  
  This is a quick test to identify buffers which have been set up for  tabular
  text. The command succeeds if  tabcells  are  set  in  the  current  buffer,
  otherwise it fails - see `%b=tabcells`.

3.28.10.14 Query backtrace
--------------------------
%q<key>=[ -Append ]BAcktrace
  
  Lists macros, functions and scripts in the active call stack - for debugging
  only. 
  
  When called from a  normal  interactive  command  line  it,  unsurprisingly,
  doesn't report very much. When called from a debugger break point prompt, it
  shows all the call frames that led to  the  breakpoint.  It  also  dutifully
  reports the debugger as a frame in the call stack.
  
  In addition to the various scripts, macros and function calls you may notice
  a few lower-case alpha macros you don't recognize:
    - i - the initialization commands passed in via the CLI qualifier `-init`
    - c - the normal interactive command buffer.
    - d - the debuggers own command buffer,
  
  See also `bt.jot`

3.28.10.15 Query buffer
-----------------------
%q<key>=[ -Append ]Buffer
  - reports internal state of buffer.
   
  Returns the state of  the  current  buffer  in  tabular  form  N.B.  if  the
  nominated buffer is the current buffer  this  command  will  fail  and  will
  return an empty report. e.g:
> %qa=buffer
  In buffer A it inserted the following text:
	buffer
	                  key = .                    The key for the buffer.
	             pathName = t.t                  The pathname of the file read into the buffer.
	     currentDatestamp = 2011/10/04, 16:27:16 The file's datestamp at the time of the query.
	          SameSinceIO = TRUE                 This flag is set true when the file was originally read and reset by  a change to any text in the buffer.
	     SameSinceIndexed = FALSE                This flag is set true by adding some hashtable entries and reset by  a change to any text in the buffer.
	    SameSinceCompiled = FALSE                This flag is set TRUE when a new hash-table entry is added.
	            SameFlag1 = FALSE                This flag is set by the `%b=sameflag1` command and reset by a change to any text in the buffer.
	            NoUnicode = FALSE                Unicode support is enabled (controlled by `%b=unicode` command)
	           lineNumber = 1                    The normal line number of the record.
	           CurrentChr = 0                    The current character position, in this case it is the leftmost character of the record.
	      SubstringLength = 0                    The length, in bytes, of the currently-selected substring.
	         wholeRecords = TRUE                 Indicates that, if inserted into text it will not break lines.
	          predecessor = =                    When called as a macro, this indicates the parent macro.
	             editLock = Unrestricted         Other options are WriteIfChanged and ReadOnly.
	           LeftOffset = 0                    See `%b=leftoffset`
	    CurrentRec length = 209                  Indicates the current character in the current record, counting from the leftmost ( 0 )
	 CurrentRec protected = 0                    Indicates that the current record of the buffer is a hash-table target and has been protected.
	     ProtectedRecords = 0                    Indicates that the buffer contains at least one protected record.
	               Header = "A"~"B"~"C" ...      See `%b=header`
	             FileType = ascii                Currently the only valid entries are ascii or binary.
	                        No tag types         If the buffer had tag types defined then these would be listed here (see `About Tagged text`).
	        HashTableMode = 0                    Valid modes are 0 (No hashtable), 1 (ProtectEntries), 
	                                               2 (AdjustEntries), 3 (DeleteEntries) and 4 (DestroyHashtables)
	                                               see `hashtable create` for details.
	             TabStops = 17 41 62 89 172 ...  Indicates columns in tabular text - see `about tabular text`.
	                 htab = FALSE                Indicates that there is no hash table associated with this buffer.

3.28.10.16 Query samesinceio
----------------------------
%q=SAMESINCEIO
  - tests state of SameSinceIO flag in current buffer.
   
  Use this command to test for changes to the buffer since it was last read or
  written back to the filing system.
   
  Command exits with failure if  the  buffer  has  been  changed  in  any  way
  compared to the  version  on  the  filing  system,  exits  with  success  if
  unchanged. 
  
  Text buffers  which  are  not  images  of  files  are  always  created  with
  samesinceio set false.

3.28.10.17 Query samesincecompiled
----------------------------------
%q=SAMESINCECompiled;
  - tests state of buffers SameSinceCompiled flag.
  
  This command is used to determine if the current  buffer  has  been  changed
  since the code it contains last compiled. It is therefore only  relevant  to
  macro-command buffers.

3.28.10.18 Query samesinceindexed
---------------------------------
%q=SAMESINCEINdexed
  - tests state of buffers SameSinceIndexed flag.
   
  Use this command to test for changes to the the buffer since making the last
  hash table entry.
   
  Command exits with failure if the buffer has been changed in any  way  since
  it was indexed with the `%H` commands, exits with success if unchanged. Note
  that text buffers which have  not  been  indexed  are  always  created  with
  samesinceindexed set false.

3.28.10.19 Query sameflag1
--------------------------
%q=SAMEFlag1
  - tests state of buffers SameFlag1 flag.
   
  Use this command to test for changes to the buffer since the flag was set.
   
  Command exits with failure if the buffer has been changed in any  way  since
  the SameFlag1 was set (see `%b=sameflag1`), exits with success if unchanged.
  Note that text buffers  are  initially  created  with  samesinceindexed  set
  false.

3.28.10.20 Query case
---------------------
%q=Case
  -  Success if case sensitivity is on.
   
  This simply sets the failure flag - it fails if case sensitivity is off.

3.28.10.21 Query inview
-----------------------
%q=Inview
  - Success if current character is visible on the screen, adds other  details
    to stack.
  
  Verifies that current character is  visible  with  the  current  setting  of
  leftoffset - see `%b=leftoffset` and `about long lines`.  This  query  works
  independently of the display management, the consequence of this is that  it
  is not necessary to update the display (see `%W`=refresh)  before  launching
  the query.
 
  This query always pushes three values onto the stack:
    - perceived current character offset - i.e. if tabstops are set, it  takes
      these into account.
    - width of the screen and
    - the current buffer's leftoffset,
    
  For a tabcells buffer (see `about tabular text`) the query  fails  when  the
  current character is in a truncated cell - even  if  the  current  character
  falls somewhere between the screen margins.
  
  This command fails if the current character is outside the visible area. i.e
  if the current character is off to the right of the screen  when  leftoffset
  has been set too low or left of the left margin when the leftoffset has been
  set to high.
  
  The values placed on the stack are designed to be a  useful  starting  point
  for calculation of a revised  leftoffset  -  for  an  example  look  at  the
  definition of `WordLeft` and `WordRight` in the standard startup script.

3.28.10.22 Query commandmode
----------------------------
%q=commandmode
  - Success if editor is in command mode.
  
  This does not affect any buffers or the stack - it  just  returns  a  status
  result - Success indicates that the editor is indeed in command  mode,  fail
  indicates that it is in insert mode.

3.28.10.23 Query version
------------------------
%q[<key>]=Version
  - reports editor version and, where appropriate, curses version.
  
  If the optional key character is not given, then the report is  directed  to
  the console area.
   
  This delivers a brief informational message about the editor  version  build
  date and host system. If the buffer key is given this message goes  to  that
  buffer otherwise it goes to the console area of the screen. A typical report
  looks like this:
version
jot for chrome v2.0, built 27/12/16 16:59:42 using crouton  ncurses 6.0.20150808
  
  The  majority  of  the  reply  is  defined  by   the   compile-time   string
  VERSION_STRING. This is typically defined with using the output of the uname
  command.
  
  The  final  section   is   obtained   by   calling   the   curses   function
  curses_version().

3.28.10.24 Query dir
--------------------
%q[<key>]=DIr [<fmt1> [<fmt2> [ <fmt3> ...]]] <path>
  - reports contents of directory.
  
  If the specified pathname does not exit or does not point  to  a  directory,
  then the command fails. If no destination buffer is specified then  the  dir
  query will only verify the path.
  
  If the destination buffer is specified (i.e. if the optional buffer  key  is
  given) then the dir query lists the contents of the nominated  directory  to
  the nominated buffer. Note that the order is just as returned by the  filing
  system - you will need to use `%b=sort` to get them in order.  This  command
  will always check that the path exists and  destination  node  really  is  a
  directory and will fail if this is not  so.  If  no  destination  buffer  is
  specified this query will only check that the given path  exists  and  is  a
  directory.
  
  If any format specifiers are included then the relevant information is added
  to  the  file  entries.  The  following  format  specifiers  are   currently
  supported:
    - -MTime - the file's modification time in the form yyyy/mm/dd-hh:mm:ss
    - -Atime - the file's usage time in the form yyyy/mm/dd-hh:mm:ss
    - -Ctime - the file's creation time in the form yyyy/mm/dd-hh:mm:ss
    - -Uid - the uid of the file's owner (not available in Windows version),
    - -Gid - the gid of the file's owner (not available in Windows version),
    - -Size - the file size in bytes,
    - -MOde - file permissions, in  windows  it  only  indicates  Readonly  or
      Writable,
    - -Inode - the file's inode number (not available in Windows version),
    
  In the report sent to the specified destination buffer,  the  optional  data
  fields are separated from the file names by a tab (VT)  character.  To  make
  this a bit easier on the eye run the `autotab.jot` script.

3.28.10.25 Query file
---------------------
%q[<key>]=File[ -Nofollowlinks][<pathName>]
  - reports on state of file.
  
  The file query will always check that the pathName exists and will  fail  if
  this is not the case. If no destination buffer is specified, this  check  is
  all it does.
  
  It normally follows symbolic links but If the  -nofollowlinks  qualifier  is
  given this behaviour is suppressed.
  
  If no file name is specified then the pathName  of  the  current  buffer  is
  used. If no pathname is specified and the destination buffer is the same  as
  the current buffer then this command fails without completing the report.
  
  When the destination buffer is specified, the file query lists various  bits
  of system information about the  specified  file.  Note  that  there  is  no
  stripping of additional whitespace following the delimiter blank  after  the
  file keyword.
  
  The following report is written to the destination buffer:
	file <pathName>
	                 Name = "<pathName>"
	                inode = <inodeNumber>
	                 Mode = <modeInOctal>
	                  uid = <userID>
	                  gid = <groupID>
	                 size = <fileSizeInBytes>
	 writable by this UID = <yes|no>
	            directory = <1_IfDirectory_0_IfNot>
	          Access time = <fileAccessTime>
	          Modify time = <fileModifyTime>
	        Creation time = <fileCreationTime>
  All datestamps are in the following format: YYYY/MM/DD, HH:MM:SS

3.28.10.26 Query keys
---------------------
%q[<destinationBuffer>]=KEYS[ -key=<name>][ <path>]
  
  This dumps all the keys associated with the specified buffer to a report  in
  the nominated destination  buffer  it  fails  if  there  is  no  hash  table
  associated with the current buffer. If no destination  buffer  is  specified
  then it simply returns the status result. In addition to  listing  each  key
  in full, it also the first 30 characters of the  text  associated  with  the
  key.
  
  The report shows the key string and relevant data for hashtable objects:
    - JumpObj -- a simple jump to some point in some buffer.
    - DataObj  -- shows the data value or current record for buffers
    - SetsectObj -- shows the seek point and size.
    - SetfilesectObj  -- shows the file name, seek point and size.
    - CodeObj -- shows the first  line  of  the  code  and  indicates  if  the
      function has been compiled.
    - ZombieObj -- shows only the hashtable key.
  
  If <path> is given, this specifies some buffer otherwise it reports  on  the
  current buffers hashtable.
  
  The keys are part of the internal  hash-table  data  structure.  While  this
  query may be useful for diagnosis of problems with  macros  -  it's  primary
  purpose is the detection of errors in the editors internal  hash-table-entry
  handling operations.
  
  If  the  optional  -key=<name>  argument  is  given,  this  reports  on  the
  specified hash-table entry the report is sent to the  specified  buffer.  If
  the key has not been set up in that hash table then the command fails.

3.28.10.27 Query tags
---------------------
%q<destinationBuffer>=[ -Append ][ -Here] TAgs
  
  In the  internal  data  structure,  each  record  has  any  number  of  tags
  associated with it. These tags are used  to  maintain  hashtables,  optional
  text colours and user-specified metadata in the form of text  strings.  This
  query lists the tags (hash-table target points, colour tags and  text  tags)
  in current buffer the report goes to a nominated destination buffer.
  
  The optional qualifier -here will return  only  those  tags  active  at  the
  current character. Currently, this is the only mechanism for  extraction  of
  user-specified metadata from the record. One useful application for this  is
  storage of hash-table keys  associated  with  the  text  -  especially  when
  combined with a mouse-event handler. The `linkdocs.jot`  and  `bookings.jot`
  scripts are examples of this.

3.28.10.28 Query heap
---------------------
%q=HEap
  - reports heap statistics.
  
  Reports raw data from the mallinfo routine (see the mallinfo man page).

3.28.10.29 Query history
------------------------
%q<buf>=[ -Append ]History
  - reports command history.
   
  Reports all entries in the history  buffer  in  chronological  order  -  the
  report is directed to the nominated buffer. The size of the  history  buffer
  is limited but can be changed with the `-history` cli qualifier. This report
  is used in the command-edit screen - see `about command editing`.
   
  N.B. The history maintained for the history query is entirety independent of
  the history file in the journal area - see `about journal files`.

3.28.10.30 Query verify
-----------------------
%q=VERIfy
   - Verify integrity of current buffer's internal data structures.
  
  This command performs a few simple checks aimed at detection  of  errors  in
  the internal record structures. The main test is to ensure that  the  string
  length of each record is never longer than the allocated string  size.  This
  situation should *never* occur, if it were to, the editor would crash before
  long as other internal data gets corrupted.
  
  If the verbosity level is more than 1 (See `%S=verbose`) then  the  contents
  of the buffer are echoed to the console area.

3.29 %H
-------
  The %H commands provide the  main  interface for  hashtables  -  see  `about
  hashtables`.  In  most  cases  these  the  syntax  of  these   commands   is
    %h[<bufferKey>]=<commandName>  ...  
  where the bufferKey is an optional single-character buffer  identifier  and,
  if omitted, the current buffer is the target of the command.
  
  Note that any buffer may hold a hashtable and any  hashtable  may  hold  any
  number of sub-buffers.  Root  buffers  are  those  with  a  single-character
  identifier key (A-Z, 0-9 and most of the ASCII  punctuation  characters.  In
  contrast, floating buffers are either on the stack  or a  child
  of some other buffer. A buffer at the top of the  stack  may  be  referenced
  with the buffer key ( ~ ).
  
  In the context of hahstables, the term path usually refers  to  a  hashtable
  path, where one or more hashtables  are  children  of  the  hashtable  in  a
  primary buffer. In some cases this terminology comes into conflict with  the
  more general understanding of path - a filing-system path. In particular  in
  the discussion of `hashtable setfsect` and to  a  lesser  extent  `hashtable
  setsect` as these interface with the filing system.
  
  For example, the  primary  buffer  (  Q  )  has  a  hashtable  containing  a
  sub-buffer below the key Fred,  it's  hashtable  has  a  further  sub-buffer
  below the key Jim - to reference an item named thingie in Jim the  following
  path expression would be used:
> q:=Fred|Jim|thingie
  See `about hashtables` for details.
  
  Many of  these  commands  also  support  a  -buffer=<path>  qualifier  which
  permits the  specification  of  non-root  buffers  i.e.  buffers  which  are
  sub-buffers  of  some  other  buffers  hashtable  see   below   and   `about
  hashtables`.
  
  See also `Query keys` - this command reports  the  keys  associated  with  a
  specified hashtable.
  
%H[<bufferKey>]=create {-delete|-destroy|-protect|-adjust} <n>[ <path>];
  - Creates a new hashtable. See `hashtable create`
    
%H[<bufferKey>]=addjump <path> - Create a hashtable  for jumping back to 
  current focus point. See `hashtable addjump`
    
%H[<bufferKey>]=newjump <path> - Create a new hashtable jump entry, fails if
  path  does not define a unique name. See `hashtable newjump`
  
%H[<bufferKey>]=data <path> - creates a hashtable object which can hold a 
  stack frame - see `hashtable data`.
  
%H[<bufferKey>]=setdata [-new] <path> - Sets specified data object to the 
  value at the top of the stack - see `hashtable setdata`.
  
%H[<bufferKey>]=getdata <path> - Copies the specified data object's value 
  to the stack - see `hashtable getdata`.
  
%H[<bufferKey>]=setsect <path> - creates a hashtable object for use in a 
  %i=<pathName> ... -section; command - see `hashtable setsect`
  
%H[<bufferKey>]=setfsect <path> - creates a hashtable object for use in a 
  %i= ... -fsection; command - see `hashtable setfsect`
  
%H[<bufferKey>]=delete <path> - Removes specified hash-table entry.
  See `hashtable delete`
  
%H[<bufferKey>]=jump <path>
  - Search for a match to path - see `hashtable jump`.
      
%H[<bufferKey>]=code <path> -  Enter a function startpoint
  See `hashtable code`
  
%H[<bufferKey>]=call <path>[ <Args] -  Search for routine then run it.
  See `hashtable call`
  
%H[<bufferKey>]=fix - resets line numbers for referencing hashtables.
  See `hashtable fix`
  
%H[<bufferKey>]=destroy[ -all] -  Destroys the hashtable.
  See `hashtable destroy`
  
%H[<bufferKey>]=testkey [<string>] -  Verifies the hashtable entry exists.
  See `hashtable testkey`

3.29.1.1 Hashtable create
--------------------------
%H[<bufferKey>]=CReate  [-delete|-destroy|-protect|-adjust] <size>[ <path>]; - Create a new hashtable.
   
  Create an empty hashtable in specified buffer, or  the  current  buffer,  if
  none specified. The size parameter specifies the size  of  the  table.  Take
  care to not underestimate the required size. The value can be  specified  on
  the command line or picked up from the top of the stack.
  
  If the buffer already has a hashtable and the new size is  sufficient,  then
  this is destroyed and it's mode and entries are copied to the new hashtable,
  if the new size is insufficient then the command fails. As the hashtable  is
  copied over, any zombies are removed (zombies are  entries  that  have  been
  deleted with the `hashtable delete` command). This behaviour is intended  to
  allow purging and re-sizing while preserving existing entries.
  
  If the size is set to 0 or any negative value then any preexisting  hastable
  is destroyed and no new  hashtable  is  created  -  the  overall  effect  is
  identical to `hashtable destroy`.
  
  The optional path parameter  defines  the  hashtable  pathname  (see  `about
  Hashtables`), by default, the hashtable is create  in  the  current  buffer.
  When a valid path is set the hashtable is created in the specified buffer or
  sub-buffer, sub-sub-buffer ... etc. to any depth.
  
  The hashtable contains pointers to various classes  of  object  (see  `about
  hashtables`):
  
   - 'target strings' in your text - allowing fast access to sections of text,
   
   - data objects (see `hashtable data`), which can be copied to and from  the
     stack and
     
   - file-section objects (see `%I`)
   
  There are several options regarding behaviour when the targeted strings  are
  to be deleted (see `about hashtables`). Essentially these are:
  
    - -adjust - When  any  target  string  is  deleted  the  relevant  entries
      targeting hashtables are silently redirected to some nearby point.  This
      is the default mode of operation.
      
    - -delete - When any target string  is  changed  the  relevant  hash-table
      entries are marked as deleted.
      
    - -destroy - When any target record is deleted the targeting hashtable  is
      silently destroyed and all of it's target tags are  removed.  Any  other
      changes in the vicinity of the hashtable target points cause the targets
      to be adjusted.
      
    - -protect - Any record containing  a  target  string  is  protected  from
      deletion Any other changes in  the  vicinity  of  the  hashtable  target
      points cause the targets to be adjusted.

3.29.1.2 Hashtable addjump
--------------------------
%H[<bufferKey>]=Addjump <hashtableKey> - adds a jump-point hashtable key.
   
  Adds a new jump entry (see `hashtable jump`)  to  the  hash  table  for  the
  specified or, current buffer, if none is specified.  The  hash  table  entry
  will store the exact location  of  the  current  character  in  the  current
  buffer. In the event of a collision (i.e. the  key  already  exists  in  the
  hashtable) the original value is silently replaced by  the  new  value.  See
  `about hashtables`.

3.29.1.3 Hashtable newjump
--------------------------
%h[<bufferKey>]=Newjump <path> - adds a new jump-point hashtable key.
   
  Similar to addjump (above) except that, in the event  of  a  collision,  the
  original entry is unchanged and the command fails. See `about hashtables`.

3.29.1.4 Hashtable jump
------------------------
%h[<bufferKey>]=Jump <path> - performs a hashtable lookup and jump.
   
  The hash table in the specified buffer  (or  the  current  buffer,  if  none
  specified) is searched. If the key exists then the focus is restored to  the
  point at which the key was entered  by  `hashtable  addjump`  or  `hashtable
  newjump`. If the key is not found, then  the  command  fails  -  see  `about
  hashtables`.

3.29.1.5 Hashtable data
------------------------
%h[<bufferKsy>]=DAta <path>|<name>; - creates a hashtable entry for storage of generic data.
  
  If no path is specified, this creates  an  entry  in  the  current  buffer's
  hashtable, when path is specified the entry  is  created  in  the  hashtable
  specified by the path. 
  
  This creates a hashtable entry which can be used  for  storage  of  a  stack
  frame. The command creates a blank entry and does not affect  the  state  of
  the stack. The data value can be refined with the  `OV`  command  and  later
  retrieved using the `OQ` commands. 
  
  Note the absence of any typing with this command, any  of  the  three  valid
  stack datatypes (integer value, floating-point value or buffer) may be  used
  with any data object and the datatype is allowed to change. In this example,
  the data object fred is first set to an integer, then a float and,  finally,
  a buffer - it's all allowed.
> %h=create 100;
> %h=data fred;
>ol123456789 ov/fred/
> ol123.456 ov/fred/
> %d~=Hello world; ov/fred/

3.29.1.6 Hashtable setdata
--------------------------
%H[<bufferKey>]=SETData -New <path>
  
  Sets the specified data object to the value at the top of the stack  -  this
  duplicates the function of the `OV` command. If the  -new  option  is  given
  the data object is created (otherwise this must be created  beforehand  with
  the `Hashtable data` command) - see `percent-command syntax`.
  
  The command fails if the specified object  does  not  exist.  When  -new  is
  given, the command fails if the specified data object does exist already.

3.29.1.7 Hashtable getdata
--------------------------
%H[<bufferKey>]=Getdata <path>
  
  This copies the specified data value to the top  of  the  stack  -  in  this
  respect  it  duplicates  the  function   of   the   `OQ`   command   -   see
  `percent-command syntax`.
  
  While the oq command has a simpler and, arguably, less clonky  syntax;  this
  command allows references to buffers and other  data  objects  to  be  mixed
  with simple text.

3.29.1.8 Hashtable setsect
---------------------------
%h[<bufferKey>]=SETSEct <path>; - creates a hashtable entry for use in %i;
  
  This takes the top two items on the stack and creates a hashtable entry  for
  use by the -section=<key> qualifier of the `%I`  command.  
    - The top item is taken to be the section offset (from the  start  of  the
      file), in bytes.
    - the second item is taken to be the section length, in bytes.
  
  This is a rare example of a magic command in jot - it is designed for use by
  scripts reading index tables for large files and probably  only  useful  for
  this purpose (see `about large files`).
  
  Another unusual feature of this command - although it uses two values at the
  top of the stack, it does not remove them. This feature is designed for  the
  benefit of scripts which re-use each startpoint and length to calculate  the
  startpoint of the next section.

3.29.1.9 Hashtable setfsect
----------------------------
%h[<bufferKey>]=SETFsect <path>; - creates a hashtable entry for use in %i;
  
  This takes the top three items on the stack and creates  a  hashtable  entry
  for use by the -fsection=<key> qualifier of the `%I` command. It is designed
  for use by scripts reading index tables for large numbers of  files  and  is
  probably only useful for this purpose.  (see  `about  large  collections  of
  files`).
  
  Another unusual feature of this command,  similar  to  `hashtable  setsect`,
  although it uses three values at the top of the stack, it  does  not  remove
  them. This feature is designed for the computational convenience of  scripts
  calculating section byte counts by  subtracting  the  previous-section  seek
  point from the current-section seek point.
  
  Note that consecutive setfsect calls referring to the same pathname will all
  share the same internally-held copy  of  the  pathname.  This  behaviour  is
  designed  to  minimize  memory  usage  by  the  internal  data   structures.
  Fortunately most practical  indexation  methods  will  generate  index  file
  structured in this way.

3.29.1.10 Hashtable delete
--------------------------
%h[<bufferKey>]=Delete <path>;
  
  This changes the state of the selected key to a  sort  of  half-dead  zombie
  state. Unfortunately it is not possible to delete keys from hashtables built
  using the gnu-library hashtables. So we do the next-best thing.
  
  The hash key can be re-assigned - this, for example, will work:
> %h=addjump fred;
> %h=delete fred;
> %h=data fred;
  
  The zombies are removed  if  the  hashtable  is  rebuilt  -  see  `hashtable
  create`.

3.29.1.11 Hashtable code
-----------------------
%h[<bufferKey>]=COde <functionName>;
  
  Creates an entry point for the  specified  function  at  the  start  of  the
  current line. The function  may  then  invoked  with  the  `Hashtable  call`
  command.

3.29.1.12 Hashtable call
------------------------
%h[<bufferKey>]=CAll[ -Oneline] <functionName>[ <Args>]
   
  The buffer indicated by the key is usually a code repository ( see  `calling
  functions by name` ), the entry point  must  have  been  previously  defined
  using the `Hashtable code` command. The `startup.jot` script,  for  example,
  defines and creates hash-table entries for a number of  routines  in  the  '
  buffer.
  
  The -oneline qualifier causes the  compiler  to  stop  at  the  end  of  the
  specified line. By default, the compiler continues to  read  code  until  it
  reaches either the end of the buffer, or at the start of the  next  function
  header.
  
  In the event of the named sequence header is not in  the  specified  buffer,
  then the call fails silently.
  
  There are two ways to pass parameters into a  %h=call function: 
    - By placing the parameters in the ( $ ) buffer before  calling  or  
    - by adding the parameters at the end of the  %H  line,  if  no  args  are
      passed then the ( $ ) buffer is left unchanged. 
  See  `translation  of keyboard events to actions`

3.29.1.13 Hashtable fix
-----------------------
%h[<bufferKey>]=Fix
  This corrects the linenumbers held in  any  hashtable  it  also  resets  the
  linenumber of the first line to 1 and returns to the first line.
  
  If records are added or removed after the  buffer  has  been  indexed  in  a
  hashtable, the linenumbers held in the hashtable may be incorrect. This  can
  result in errors when using these linenumbers to calculate  offsets  between
  indexed records. The fix operation assigns the new, correct, linenumbers  in
  the referencing hashtables and resets the buffer so that any errors  in  the
  line numbering are resolved.

3.29.1.14 Hashtable destroy
---------------------------
%h[<bufferKey>]=Destroy[ -all]
  
  This removes the entire hashtable, destroying all entries. The optional -all
  qualifier will destroy all hash tables in all buffers - N.B.  including  any
  system hashtables like the code-repository functions set up in  the  (  '  )
  buffer.

3.29.1.15 Hashtable testkey
---------------------------
%H[<bufferKey>]=Testkey[ -type] [<path>]
  
  By default this tests the hashtable of  the  current  buffer.  The  optional
  bufferKey or path may specify some other buffer's hashtable to be tested. 
  
  If the -type qualifier is given, then the type code for the object is  added
  to the stack. Type codes are:
    - 0 - a jump object.
    - 1 - a data object. 
    - 2 - a setsect object.
    - 3 - a setfilesect object.
    - 4 - a code object.
    - 5 - a zombie (the object has been deleted but has not been removed  from
      the hashtable)
  
  The %h=testkey command verifies the hashtable contains the key matching  the
  given string. This is used to find out if a hashtable has been set  up  and,
  if a search string is given, that a one key matches the string.
  
  If the string parameter is not  given,  then  this  command  checks  that  a
  hashtable exists.
  
  This command does not write any report, it simply returns a Success or  Fail
  status.

3.29.2 %D
----------
%D<key>=[ -Append] <string>[;] 
  - General case - special characters must be escaped with a backslash.
  
%D<key>= -LITERAL_DEFINITION <string> -BUFFERDEFINITIONENDSHERE; 
  - Special case - no escapes required  but  the  string  may  no  contain  the
    special termination string " -BUFFERDEFINITIONENDSHERE:"
  
  Defines the specified buffer directly from the console. If -append is  given
  then the new string is appended to any preexisting string.
  
  The first parameter is the buffer identifier key - a single character  which
  identifies the buffer to be defined.
  
  One particularly important variant is %d~=...; -  this  creates  a  one-line
  buffer on the top of the stack and is often followed by  the  `OV`  command.
  This combination is used to set a data object to a string value. See  `about
  hashtables` and `using Hashtable data`
  
  Whereas %D will define a single-line buffer (usually a macro) `%G` is useful
  for defining any-number of lines.
  
  The terminating semicolon ( ; ) is optional, unless more commands follow  on
  the same line. While the string may contain any number of  semicolons,  each
  of these must be escaped by prefixing with  a  backslash  (  \  ).  In  some
  circumstances it is not convenient to escape special characters in the usual
  way (see `percent-command syntax`). 
  
  Any whitespace following the '=' or the ' -append ' is normally ignored  and
  will not appear in the defined string.  To  define  a  string  with  leading
  blanks, you must escape the first blank with a backslash e.g:
> %dq=\   123456789; %dq= -append \ 0;
  Will place the string "   123456789 0" in buffer ( Q ).
  
  One particular case is when %D is used to pick up  search-string  parameters
  etc. for function keys and escape sequences. Users would generally prefer to
  avoid having to fuss over special characters and just type  in  stings  they
  want.  The  special  terminator  string  "  -bufferDefinitionEndsHere;"  was
  designed for this situation. When this terminator is given,  the  string  is
  taken as-is, ignoring any special characters.
  
  For  most  purposes,  the  -bufferDefinitionEndsHere;  option  is   entirely
  useless - just a  long-winded  way  of  avoiding  having  to  escape  a  few
  semicolons when a simple backslash is easier and simpler.  It  is,  however,
  very useful for picking up and processing  user  keyboard  replies  -  users
  will appreciate not having to escape semicolons as they  are  typed  in,  so
  you will find them in the hot-key translation table - the ( ^ ) buffer.

3.29.3 %G
---------
%G<key>=[ -Append][ <label>][;] 
<line1>
<line2>
...
<lastLine>
<label>:
  
  Reads a buffer from current command stream or macro,  the  single  character
  key specifies which buffer. If -append is given then the lines are  appended
  to any preexisting text in the buffer. By  default  the  list  of  lines  is
  terminated by a line containing colon ( : ) in the first  character  and  no
  other characters. If a  label  is  specified  then  the  list  of  lines  is
  terminated by a line containing that label followed by a colon ( : ) and  no
  other characters (including whitespace).
  
  The equals sign may be omitted if no label is specified.
  
  This is similar to the `G` command,  except  that  whereas  G  always  takes
  input from the console, %G will take from whatever command  input  currently
  active - typically a script. Thus %G is a handy way for  scripts  to  define
  multi-line macros.
  
  Buffer specifications  are  nestable  (provided  the  end-point  labels  are
  chosen correctly) i.e: a %G can define a macro and  the  macro  may  defines
  other buffers when active.
  
  Whereas %G defines any number  of  records  `%D`  is  a  convenient  way  of
  defining a single-line macro.

3.29.4 %I
----------
%I[<bufferKey>]=[ -Seek=<ByteNo>][ -Bytes=<bytes>|-BLock=<bytes>|-Records=<n>]|
    [ -SECtion=<name>|-Fsection=<name>][ -Insert | -Append][ -Hold]
    [ -BInary[=<recordSize>]]
  [<pathName>]
    - Input (read) a secondary file.
  
  This loads the file to buffer specified by the buffer identifier key. If  no
  key is given, it reads to the current buffer.
  
  It can return a failure under the following circumstances:
    - The file does not exist,
    - you do not have read rights on the file,
    - the specified byte-count, record-count  or  seek  offset  imply  reading
      past the end of the file,
    - the specified section of fsection name does not exist or
    - with the -hold qualifier, the file handle is already at EOF.
  
  The pathname defaults to the pathname of the currently-edited file.  If  the
  new filename is incompletely specified then the missing fields are filled in
  using the current-buffer's pathname. Note  that  this  behaviour  can  cause
  difficulties. If the new file is in your pwd and the current file is in some
  other directory, you must prefix the name with the path "./". If the  target
  file has no name extension and the current file does, you must change  focus
  to a buffer with no pathname set.
  
  Files may be plain ASCII or  unicode  encoded  in  UTF-8  or  UTF-16LE  (see
  `Unicode - the gruesome details`) 
  
  Briefly %I has the following optional qualifiers several dedicated  in  some
  way to the loading of sections of large files - see `about large files`:
    - -Seek - specifies a byte-offset section start point,
    - -Bytes - specifies a section length in bytes,
    - -SECtion - loads a named section, previously defined in a hashtable,
    - -Fsection - as -section but object also specifies pathname,
    - -Append - adds the section to the end of an existing file image,
    - -Insert - inserts the text at the current-character position,
    - -Hold - holds the file-handle open for reading multiple sections,
    - -Records - limits the number of records (lines) read from the file,
    - -BInary - loads the (possibly binary) file in the form of a hex dump
  
  The -bytes qualifier gives it an end count which restricts the read to  that
  many bytes. It can be combined freely with the  -hold,  the  -seek  and  the
  -binary options. The -records=<n> qualifier  sets  an  upper  limit  on  the
  number of records to be read.
  
  The -block qualifier is similar in that it specifies a limit on  the  number
  of bytes but, with -block, blocks of data are read into one  record  of  the
  specified  size.  Use  -block  with  -hold  to  read  successive  blocks  of
  characters from the same file. This feature is  designed  to  speed  up  the
  movement  of  large  blocks  of   data   by   bypassing   all   the   normal
  record-building activity associated with normal reads. e.g:
> n.aq %i$= -block=100 -hold ${JOT_RESOURCES}/Richard_III_Entire_Play.txt; (zqh$b %i$= -block=100 -hold;)0
  this reads the entire file as 100 byte records into buffer q.
  
  The -seek can be used for reading sections of file, provided you know  where
  the desired section is and how big it is. It can be useful for  reading  the
  important bits from large files.
  
  The -section qualifier sets the seek and limit from the top two items on the
  stack. This is designed to  be  used  in  conjunction  with  the  `hashtable
  setsect` command. Unlike the -fsection variant, -section  assumes  that  the
  pathname is known and constant. It is therefore more suitable for situations
  where only one file is required - typically a very large file  containing  a
  great many sections.
  
  The -hold qualifier causes the file handle associated with the buffer and to
  be left open, this is to facilitate reading of files in  blocks.  Subsequent
  reads to  the  same  buffer,  using  the  -hold  qualifier  can  index  more
  efficiently, starting from where the previous read ended.  The  actual  file
  handle is associated with the buffer and therefore cannot be  used  to  read
  into other buffers. This option is intended to be used in  conjunction  with
  the -section option, on very large files.
  
  The -fsection qualifier  is  very  similar  to  -section,  except  that  the
  hashtable object it accepts is the form created by the `hashtable  setfsect`
  command. These objects are created by the `hashtable setfsect` command. Like
  the  setsect  object,  this  contains  a  seek-offset  byte  count   and   a
  section-length bytecount but it also contains the pathname of the file to be
  read. This  makes  the  -fsection  variant  suitable  for  situations  where
  sections are distributed over a number of files.
  
  The -binary option reads the file and displays it in the form of a hex dump.
  The optional recordSize value, which specifies how many Hex pairs  to  place
  in each line, defaults to 16.  To  view  ascii  characters  use  the  script
  `hex2ascii.jot`, this annotates  each  line  of  hex  dump  with  the  ascii
  translation. The hex dump can then be written  back  as  binary  -  see  the
  -binary qualifier to  the  `%O`  command  but  note,  for  %O  the  optional
  parameter to -binary is the conversion radix.
  
  The -insert  qualifier  causes  the  file  text  to  be  inserted  into  the
  current-character position of the buffer,  the  current  character  is  left
  pointing to the start of  the  inserted  text..  The  -append  qualifier  is
  similar except that the new records are delivered to the end of the  current
  buffer and the current character is left  unchanged.  By  default  (i.e.  no
  -insert or -append) the buffer is first cleared and the new file  completely
  defines the buffer text and the current character is left  pointing  to  the
  start of the first line of the file.
  
  If the buffer has already been reading a file with -hold, the  new  pathname
  is ignored and the old file handle is reused. To prevent this  happening  it
  is necessary to perform a read without the -hold qualifier - something  like
  this should do the trick:
> %iz=/dev/null -append;

3.29.5 %L
----------
%L=[<width>[ <height>]] - Sets the terminal line length and number of lines.
  
  This is a throwback to the  days  of  VT200-series  terminals,  the  DECCOLM
  function allowed 80/132 switches.
  
  In a modern windowing environment the terminal  size  is  changed  by,  say,
  dragging the window boundaries. After this,  %l  can  be  used  without  the
  terminal-size parameter. It reads back  the  new  screen  height  and  width
  henceforth these new values are  used  in  internal  calculations  involving
  screen dimensions. Note that adjusting the window size has no effect on  jot
  until the new screen size is read back by the %L command.
  
  If a terminal size is specified, each of the given dimensions should be less
  that the than or  equal  to  the  corresponding  dimensions  of  the  actual
  terminal you are using - if not then %L fails and both are set to the actual
  screen size.
  
  If The width is specified without the height,  the  height  is  set  by  the
  actual terminal height.
  
  The allowable width must not  exceed  the  actual  terminal  width  and  the
  allowable height is constrained by both the actual terminal height  and  the
  current window configuration - the specified height must  be  sufficient  to
  accommodate all the currently-defined windows and at least one console line.
  An easy way of avoiding this second constraint  is  to  only  apply  the  %L
  command after deleting all windows (see the `%W` command).
  
  If the size is specified, the command may fail if either
    - 1 the total width or height of the current window configuration  exceeds
      the relevant dimension of the actual screen or
    - 2 the specified height is insufficient to accommodate the current window
      configuration. The width of the  current  window  configuration  is  not
      checked.
      
    This command also completely redraws all windows on the screen,  hence  it
    is useful if, for  whatever  reason  (but  typically  because  of  a  `%E`
    operation), the screen happens to get messed up.
    
  The screen size can also be set at the start of day by the `-screensize` CLI
  qualifier

3.29.6 %O
----------
%O[ -Append][ -binary[=<radix>]][<pathName>] 
  - Output current buffer as specified file.
  
  The current buffer is written out using the given pathname.
  
  The -Append qualifier adds the contents of the buffer  to  the  end  of  the
  file. Whether or not the -append qualifier is given, if the  file  does  not
  exist, then a new one is created.
  
  The -binary qualifier is designed for use with hex  dumps  of  binary  files
  (see the -binary section of `%I`). It translates the hex dump back to binary
  for writing. Octal and binary dumps are also supported by setting the  radix
  modifier to either 8 or 2, respectively. As implied above, it defaults to 16
  for hex dumps.
  
  Note: the -binary qualifier is ignored if the  buffer  encoding  is  set  to
  anything other than 'Plain' (see `%B=encoding`).
  
  The hex (or octal/binary) dump must be formatted as follows:
    - each entry represents one byte,
    - each entry is one or two hex digits (one-to-three octal digits or up  to
      8 bits),
    - each one-byte entry must be separated by one or more blanks,
    - any additional blanks are  ignored  -  including  leading  and  trailing
      blanks,
    - line breaks are ignored,
    - Any text following a hashmark ( # ) is assumed to be a  comment  and  is
      ignored,
    - any other character is flagged as an error.
  
  The pathName defaults to the pathname of the current buffer. If the new file
  name is incompletely specified then the missing fields are filled  in  using
  the current pathname.

3.29.7 %R
----------
%R=[ -asConsole] [pathname][ <ArgList>] - Run a command file.
  
  If no path is explicitly specified, then JOT first  searches  your  PWD,  if
  it's not found there, it  searches  the  directory  ${JOT_HOME}/coms  -  see
  `installation`.
  
  The ArgList is a list of whitespace-separated  parameters  that  are  copied
  into the ( $ ) buffer to be picked up by your script.
  
  The file contains editor commands, these are all executed in the same way as
  with console input, the default file name is startup.jot.
  
  In the event of an un-trapped error (i.e.  a  command  failed  and  no  else
  clause applies), then execution of the script is  normally  terminated.  The
  -asConsole qualifier changes this behaviour.
  
  When the -asConsole qualifier is  given,  the  behaviour  is  more  like  an
  interactive session:
    - Errors are reported normally then, instead of abandoning the script, the
      error is changed to an  ordinary  command  failure  so  that  processing
      resumes at the else block or the next line of the script.
    - The script may contain escape sequences - in practice the only ones that
      are likely to contain these are recovery scripts -  see  `about  journal
      files`.
    - While the script is active  all  console  reads  (e.g.  commands  and  g
      command input) are from this script.
    - The principal purpose for -asConsole  operation  is  to  allow  recovery
      scripts to behave as the  original  interactive  session  -  see  `about
      journal Files`.
  
  Command files may be nested to a depth of 20.

3.29.8 %U
----------
%U - Undo = Undo last substitution.
  
  The current substring (irrespective of whether selected by `F`, `V`, `I`  or
  `S`) is replaced by the last specified search string. Normally,  of  course,
  this would have been set as a result of a S (substitute) command,  following
  a F (Find) command, hence the substitution is undone.
  
  If the original find substring had a different case pattern to the  replaced
  substring (i.e. the find was done in case-insensitive mode)  then  the  undo
  will not reflect the original case pattern.

3.29.9 %W
----------
%W[<key>]={new|modify=<winNo>}
  [ -height=<height>][ -width=<width>[+<guard>]]]]      
  [ -popup[=<xOffset>[,<yOffset>]]][ -delim]
  [ -delete][ -insert=<winNo>][ -freeze=[0|1]]
  or
%W=refresh;
  or
%W=clear;
            
  The %W command controls how the  the  screen  is  divided  up  into  viewing
  windows. The simplest is the  default  configuration  given  by  the  normal
  startup script - a single window, displaying whatever buffer is the  current
  focus, occupying the full width of the terminal and  all  lines  except  the
  last. Should the window get messed  up  the  default  configuration  can  be
  restored by invoking the `WindowOne` function.
  
  If a single-character key is specified in <key>, this  identifies  a  buffer
  to be displayed in the  window,  if  -key=<newKey>  is  also  specified  the
  buffer identified by newKey overrides  the  key.  If  no  key  is  specified
  anywhere the window will display the current buffer.
  
  In the event that the current buffer is  displayed  in  some  other  window,
  maybe because of  there  being  more  than  one  floating  window,  or,  one
  floating window, Then  the  floating  window  is  left  displaying  whatever
  buffer it is currently displaying or, at  the  start  of  day,  it  displays
  blank lines.
    
  Windows may be defined as a number  of  screen  lines  or  may  be  vertical
  slices of <height> lines and <width> columns. Windows  may  be  assigned  to
  specific buffers or can be left unassigned - in which case they display  the
  current buffer.
  
  The %W command indirectly defines  the  height  of  the  console  area,  the
  window size and the total height of all  the  windows  together  define  the
  console area height. The console area  can  be  set  to  temporarily  expand
  upwards by borrowing lines from the bottom of the display window -  see  the
  `%s=console` command. The console normally displays a  command  prompt  but,
  in the event of errors  or  other  messages,  these  are  displayed  in  the
  borrowed console area.
  
  An existing window configuration may be changed with  the  %w=modify=<winNo>
  command the winNo parameter specifies a particular window . Any other  valid
  %W modifier may be  included  to  change  the  selected  properties  of  the
  selected window. The window number (winNo) is assigned by the system and  is
  given in the `query window` report.
  
  New windows, or vertical slices of windows,  are  added  in  sequence  by  a
  series of %W commands - each adding just  one  new  window  to  the  screen.
  Before adding a new window, the %W command checks that there  is  sufficient
  window height and width to accommodate the requested window if this  is  not
  the case then the %W command fails.
  
  - -height=<height> - Specifies the number of screen  lines  to  allocate  to
    the window.
  - -delim requests that the  last  line  of  the  window  be  filled  with  a
    delimiter line. The window delimiter is in reverse video and, by  default,
    set to the pathname and the buffer key - see `%b=footer`.
    
  - -width=<width> specifies the width of a vertical slice of the  window.  If
    it is mixed with %W=<height> ... this becomes the leftmost slice in a  new
    window of that height. When the window-height is  set  to  0  or  is  left
    unspecified, it's predecessor window must also be  a  vertical  slice  and
    the new window inherits it's height from the predecessor.
    
    When it is required to change the height of an existing group  of  slices,
    this can only be accomplished by changing only the  height  of  the  first
    (leftmost) slice in the group. Any attempt to change the height  of  other
    members of the group will fail.
        
    By default, the left margin of the second and subsequent slices will  abut
    the right margin of the predecessor slice. The  +<guard>  modifier  (where
    <guard> is a small integer) will insert that many  blank  columns  between
    the slice and it's predecessor slice.
  
  - -delete is used, in combination  with  the  %w=modify<winNo>  command,  to
    remove a selected preexisting window. The  -delete  command  can  also  be
    used in a %W=new command -  but  the  overall  effect  could  scarcely  be
    described as useful.
    
  - -insert=<winNo> - inserts the newly-specified  window  immediately  before
    the specified window. This can only be used  in  the  %w=new  command,  it
    allows a new window to be created at some point other than after  all  the
    existing windows. The window numbers are assigned by the  system  and  are
    displayed in a `query window` report.
  
  - -key=<key> - a single-character buffer key. This  specifies  which  buffer
    is to be associated with the screen window, if this is not given then  the
    current buffer is displayed in the window - a  floating  window.  
    
    Although the -key option may appear  redundant,  the  window  key  can  be
    specified as the <key> - the syntax does not permit  indirect  expressions
    there. Also when used in the modify command, an  unspecified  key  has  no
    effect - any previous buffer  assignment  for  that  window  will  persist
    after modification. However an unspecified newKey will  cause  the  window
    to display the current buffer, even if  it  was  previously  fixed  to  a
    buffer.
    
  - -freeze={0|1} This controls the frozen attribute of the new (or  selected)
    window. The -freeze option can be  applied  to  any  window  and  it  will
    remain displaying whatever was displayed as the  %w  ...  -freeze  command
    was issued. Note that the -freeze modifier is ignored for  popup  windows.
    The -freeze=0 modifier unfreezes the window.
    
    Note that jot does not maintain a record of the state of  frozen  windows.
    It simply avoids updating them as  the  state  of  the  underlying  buffer
    changes. Any subsequent `%W`=clear; or `%L` command will clear the  window
    and, should a `%E` corrupt  the  display  by  scrolling  into  the  frozen
    section of the display, then the %E output will replace the original view.
  
  - -popup Specifies that the new or selected window is to be a  popup.  Popup
    windows can be used to display information or  to  provide  some  sort  of
    menu-driven interface.  These  are  displayed  only  when  the  associated
    buffer has a non-empty first line - this is a  feature  intended  to  make
    them easily disappear from the screen, while preserving their content.
    
    Popups overwrite rectangular sections of the display, in order  to  ensure
    that the popup becomes visible the popup window should  be  defined  after
    the definition of the underlying windows.
    
    There is no limit to the number  of  popups  but  since  each  requires  a
    dedicated buffer and it is quite easy to share them between  a  number  of
    activities it is recommended practice to use as few as possible.
    
    Note that the actual position of the popup is calculated as the %W command
    is processed. If the screen width is reduced (see the `%L`  command)  then
    the popup will remain at the same position on the physical screen.
    
    For -popup windows, the height and -width dimensions specify  the  maximum
    size that the window can be allowed to grow to - if unspecified the  popup
    may grow to fill the entire terminal  screen.  By  default,  the  top-left
    character of the popup is normally  aligned  to  the  top  left  character
    position of the screen but this can be changed by specifying  an  optional
    xOffset and yOffset. 
    
    A positive xOffset will push the popup leftwards by <xOffset>  characters,
    a negative offset positions  relative  to  the  terminal's  right  margin.
    Similarly, the popup's y-coordinate may be set by  specifying  a  yOffset,
    in this case a positive yOffset specifies the  position  relative  to  the
    terminal's top  margin  and  a  negative  yOffset  specifies  the  popup's
    position relative to the terminal's bottom margin.
    
    Note that, by default, the popup appears in the same colour pair and  font
    as the surrounding text with no delimiter  markers.  It  is  left  to  the
    programmer to make suitable arrangements for the popup stand out from  the
    surrounding text. Failure to do this will make the display very confusing.
    
  See also `%S=guardband` `%S=console`.

3.29.10 %%
----------
  A JOT comment.
  
  The command scanner ignores all text to the right of the %%.

3.29.11 %~
----------
%~ - Display character in hex.
  or
%~=<hexDigits> - Insert a character at the current cursor position.
  
  This operation is  now  obsolete,  the  preferred  method  if  investigating
  characters is to use `OC` and check the top of stack. The  preferred  method
  of specifying control or unicode character in hex is `OL` followed by `OO`.
   
  All nonprinting characters (i.e. characters having an  ASCII  code  of  less
  than 0x20 and invalid unicode characters) are represented on the screen as a
  '~'. To investigate such a character, the %~ command returns the ASCII code,
  in hex, for the character at  the  cursor  position.  This  command  has  an
  optional hex-value parameter, if given then the command will instead  insert
  a control character of the specified value, at the cursor position.

4 JOT techniques
-----------------
  This section attempts to reveal some insights into JOT usage.

4.1 Do that again
-----------------
  Simply typing a number at the console will repeat the last command that many
  times. This is how the <<Again>> function works. Typically you will want  to
  do  this  when  you've  typed  in  a  short  command  string  and  want   to
  interactively control how many times it gets repeated.
  
  e.g. The following command removes any indentation from the current line and
  replaces it with two blanks:
> (v/ /e)0i/ /m
  To repeat the treatment  on  subsequent  lines  just  keep  on  pumping  the
  <<Again>> key.

4.2 Case blocks
---------------
  A block can have any number of failure handlers, thus each case becomes  the
  failure handler for the previous one e.g. (v/fred/..., v/jim/..., ...)

4.3 Match to any number of equal-priority conditions.
-----------------------------------------------------
  A block without a failure handler will pass it's status  up  to  the  parent
  block, so if there are a list of conditions, any of  which  may  be  met  we
  could write something like this:
    ( ... (v/fred/\v/jim/\v/bill/\) abc, def )
  If the cursor is at the start of any of those names, then the command string
  abc is executed, otherwise it's command def.

4.4 Tabulated text
------------------
  Several scripts are available for handling tabulated text.  These  apply  to
  the entire buffer. To limit the scope of these scripts, abstract the section
  containing the tabular data into a temporary buffer and apply the scripts in
  there.
  
  By default, the tab character is the ASCII HT (Horizontal  Tab  0x0B),  this
  can be redefined with the `%s=tab` command.
  
  The scripts are all based on the  tab  character  indicating  the  alignment
  points.
    - `retab.jot` <string> - inserts tabs based on text content.
      
    - `retabhere.jot` - inserts tabs based on position.
      
    - `autotab.jot` - replaces the first instance of a tab with blanks  so  as
      to align the following text.
      
    - `autotabdp.jot` - similar to autotab but aligns decimal points in column
      following the first tab.
      
    - `autotabjust.jot` - similar to autotab but aligns the following  tabs  -
      the effect is to right-justify the column.

5 Command-Line qualifiers
-------------------------
  The following command-line qualifiers are allowed,  the  keywords  are  case
  insensitive, the  upper-case  alphas  indicate  the  minimum  requirement  -
  briefly:
    - `-` - stream-in mode - edit the stdin stream (only required  by  windows
      version).
    - `-HOld` - holds screen on exit.
    - `-Help` - displays a brief help page.
    - `-History`=<n> - specifies size of internal history buffer.
    - `-Init`=<jotCommands> - some initialization commands, run after startup.
    - `-Journal` - create a journal file for recovery from crashes.
    - `-New` - The specified primary file does not exist.
    - `-Obey` - stdin stream is commands.
    - `-Quiet` - suppresses most messages.
    - `-STartup` <pathName> - specifies a nonstandard startup script.
    - `-SCreensize`=<width>x<height> - specifies screen size.
    - `-STACksize`=<n> - specifies operand-stack size.
    - `-To`=<pathName> - specifies the new default filename
    - `-Tty` - run in a simple teletype mode.
    - `-Locale`=<locale> - Set the locale appropriately (unix version only).
    - `-Codepage`=<codepage> - sets codepage (windows version only)

5.1 -
-----
$ <cmd> | jot - ...
  
  The shell command <cmd> generates a text stream which is picked  up  by  jot
  and loaded into the primary buffer ( . ) - this is  only  necessary  in  the
  windows version.

5.2 -New
--------
$ jot -new <pathName> ...
  
  Either the file does not exist or, if it does it will be ignored. The editor
  starts with an empty buffer but with with the  specified  pathname  and  the
  file will be created by a `%o` or `%c` command.

5.3 -To
-------
$ jot <origPathName -to=<toPathName> ...
  
  Sets the `%o` and `%c` destination file name.

5.4 -STartup
------------
$ jot <pathName> -startup=[<startupPathName>] ...
  
  A  pathName  to  a  special  startup  sequence.  If  specified,  this  takes
  precedence  over  the  other   possible   startup-file   locations   -   see
  `startup.jot`. 
  
  If -startup is specified with no pathName argument then no startup is run.

5.5 -Init
---------
$ jot <pathName> -init=<jotCommandString> ...
  
  The jotCommandString commands are processed after running the normal startup
  sequence - this can be used to initialize the editor in some special way  or
  for stream editing. This qualifier is also useful when jot is  being  driven
  by a shell script.
  
  When a very long initialization sequence is required, this may be broken  up
  and applied over any number of -init commands, in order to avoid exceptional
  long command lines and complicated escaping of special characters in scripts
  the commands are concatenated into one long command sequence in the  correct
  order e.g: 
$ jot someFile -in="i/This was set by the first line of initialization commands./b" \
               -in="i/This was set by the second line of initialization commands./b" \
               -in="...

5.6 -Tty
--------
$ jot <pathName> -tty ...
  
  Teletype mode, for use  in  environments  where  the  normal  screen-control
  operations won't work or, when jot is driven by a script.
  
  With -tty any window setup in the startup file has no effect, on  completion
  of each command line, the current line is displayed,  the  position  of  the
  current character is indicated by a carat ( ^ ) in the  following  line  and
  the current substring by a string of tildes ( ~ ).

5.7 -Codepage
-------------
$ jot <pathName> -codepage <value> ...
  
  This qualifier is available only  in  the  windows  version,  in  linux  the
  -locale qualifier performs a similar function. This qualifier sets  codepage
  to specified value, by default codepage  is  set  to  65001  -  UTF8  -  see
  `Practicalities of unicode etc. and jot`

5.8 -Locale
-----------
$ jot <pathName> -locale=<locale> ...
  
  This qualifier is available only  in  the  linux  version,  in  windows  the
  `-Codepage` qualifier performs a similar function.
  
  This sets the default locale for all buffers. Locale currently only  affects
  the rendering of unicode characters. e.g:
$jot ${JOT_RESOURCES}/t.t -locale=en_US.utf-8
  
  For linux the default locale is inherited from the shell env XTERM_LOCALE.

5.9 -Obey
---------
$ jot pathName -obey << EndOfCommands ...
cmd1
cmd2
cmd3
EndOfCommands
  
  By default, when jot detects that stdin is not a keyboard, it is assumed  to
  be a text stream to be picked up and processed in  the  primary  buffer.  In
  this  case,  however,  it's  a  series  of  commands.  The  -obey  qualifier
  identifies these as such
  
  To push short sequences of in from the command line, the -init=<...>  method
  is generally preferable.
  
  Note that the last command in the -obey sequence  *must*  be  %c  or  %a  to
  terminate the editor session.
  
  This option is really only useful in shell scripts in order to make the  jot
  commands visible and accessible in the same context as the shell commands it
  interacts with. For an example look at Test 8 in ${JOT_HOME}/test.sh.

5.10 -Journal
-------------
$ jot ... -journal ...
  
  This creates a directory to hold the journal files. The  journal  files  are
  used to recover your work following a crash. See `About Journal  Files`  and
  `recover.jot` for details.

5.11 -Quiet
-----------
$ jot ... -quiet ...
  
  Suppresses all prompts and messages except for `P` commands. In -tty mode it
  also suppresses any indication of substrings and the current character.
  
  It achieves this by initializing the verbosity bit mask  (see  `%s=verbose`)
  to zero at the start of  day.  This  ensures  that  any  messages,  normally
  delivered at initialization time, are also suppressed.

5.12 -SCreensize
----------------
$ jot ... -screensize=<width>x<height> ...
  
  Sets the  screen  dimension  as  specified.  The  width  is  denominated  in
  characters the height in lines.
  
  The screen dimensions can also be specified by the `%L` command.

5.13 -STACksize
---------------
$ jot ... -stacksize=<n> ...
  
  Sets the size of the operand stack to n. By default it is 100, if  you  need
  more then there's probably something gone badly wrong with your scripts.

5.14 -HOld
----------
$ jot ... -hold ...
  
  On exit, this holds the  curses  screen  until  any  keyboard  character  is
  detected. This allows you see any messages generated by a script before  the
  session finally terminates as you hit any key.
  
  It displays a prompt in the console area:
	Exiting now (123456) hit C to continue, E to exit script or any other key to exit now
  
  The number in brackets is the number of commands processed since  the  start
  of day or the most recent interactive input (the  command  counter)  -  this
  behaviour makes  the  -hold  option  important  for  debugging  scripts  and
  functions - see `using %s=commandcounter in debugging`.

5.15 -History
-------------
$ jot ... -History=<n> ...
  
  Sets the size of the internal command-history buffer, by default it's set to
  to 20 lines. The first element of the history array is the current  command,
  which must always exist. Hence you must specify a value in of 1 or more  for
  this.
  
  This buffer holds the last few typed-in commands. You  cannot,  at  present,
  edit history directly but you can only view  the  contents  of  the  history
  buffer with the %q<buf>=history command - see `query history`.
  
  This internal command-history buffer is  used  in  the  jot  command-editing
  interface - see `CmdEditStart` and `CmdEditGo`.
    
  N.B. The size of this history buffer has no effect on the operation  of  the
  journal history - see `about journal files`.

5.16 -Help
----------
$ jot -help
 
  Displays a brief description of the jot CLI qualifiers and exits.

6 Installation
--------------
  The jot installation process is pretty simple. For details see  the  INSTALL
  guide in ${JOT_HOME}.

6.1 Manual setup
----------------
  For those that like to get their hands dirty, these notes describe the basic
  installation structure, compilation procedure and trouble shooting.
  
  Start  by  downloading  either  jot_v<version>.tz   or   jot_v<version>.zip,
  whichever you fancy - both archives contain exactly the same files.
    
  Before you can run the editor a certain amount of system-dependent setup may
  be necessary - see either `unix and linux setup` or `ms-windows setup`.
  
  These envs are referenced  by  either  the  main  editor  programme  or  the
  scripts:
    - JOT_HOME - points to the installation tree root
    - JOT_JOURNAL - if set then all sessions create a journal.
    - JOT_RESOURCES  -  used  by  some  scripts  (e.g.  `dic.jot`)  to  locate
      resources such as dictionaries, the startup script uses  it  to  find  a
      help-file tree. If this file exists ${JOT_RESOURCES}/help/help.hlp, then
      this is taken to be the root help entry.
      
  Of these, the only essential one, for a working installation,  is  JOT_HOME,
  it uses this to locate the coms subdirectory (where  it  picks  up  scripts,
  including the all-important startup  scripts).  When  JOT_RESOURCES  is  not
  defined, the startup script  defaults  it  to  ${JOT_HOME}/resources  -  the
  resources directory  from  the  archive  contains  test,  demonstration  and
  training samples.
     
  Typically jot will be started from the command line  from  an  xterm  (or  a
  windows console) with a pathName argument, the editor takes over the  screen
  and displays an image of the specified file. It also reads a  setup  script,
  by default ${JOT_HOME}/coms/startup.jot,  this  defines  functions  and  the
  mapping of keyboard events to functions. To do this the  JOT_HOME  env  must
  point to the correct point in the installation tree.
  
  Also, if you have a shared jot installation then you may prefer to  maintain
  your own ${JOT_RESOURCES} files. This is a collection  of  bits  and  pieces
  used by some jot scripts.
  
	JOT_HOME should point here -->   v<version>                                  
	                                     |                                    
	                  ---------------------------------------------                  
	                 |      |      |                  |            |                  
	                bin    coms   releasenote.txt    resources    source                     
	                 |      |                         |            |
	                ...    ...                       ...          ...   
  
  In addition to files in the jot archives you may feel the need  for  one  or
  more of the following:
  
    - Websters dictionary, useful for authors, available as a plain-text Ebook
      from the Gutenberg project - gutenberg.org
      
    - Roget's thesaurus, another must-have for authors, again  it's  available
      as an Ebook from Gutenberg.
      
    - aspell - a GNU spelling checker. This one was chosen because  it  has  a
      command-driven interface, most of the others will only  work  via  their
      GUI.
      
    - gnumeric - this can be downloaded from the GNU project. It  is  used  to
      convert Microsoft XL spreadsheets to plain text, for `get.jot`
      
    - Apache Tika - this is  a  very  useful  format  conversion  utility.  In
      particular it is used by `get.jot` to convert the following  formats  to
      plain text: MS-word and PDF and MS-XL.
      
    - iconv - a gnu unicode converter (see the GNU libiconv project), used  by
      get.jot to convert the  various  other  unicode  formats  to  UTF-8  for
      display in jot.
      
    - Windows users will probably find life much  easier  with  the  UnixUtils
      toolset. Even if thy do not personally  have  any  use  for  basic  unix
      utilities like ls etc, many jot scripts are written assuming them to  be
      available.
      
    - xsel  -  this  little  utility  provides  an  interface   to   X-windows
      selections. This is used by `copy.jot` and  `paste.jot`  to  access  the
      X-windows selection buffer.
      
      Although not always  available  by  default,  xsel  is  available  as  a
      download from your linux disto provider.
      
      Windows users need  not  fret  about  xsel,  windows  does  not  support
      selections so you will have to use cut and paste instead.
      
    - cabextract, used by get.jot to unpack  these  microsoft  archives,  it's
      available by default with most linux distributions.

6.2 Unix and linux setup
------------------------
  Wherever you decide to unpack the archive, JOT_HOME should be set  to  point
  at the v<version> directory. You will also  need  to  set  search  path.  In
  linux/bourne-shell:
$ export JOT_HOME=/<path>/v<version>
$ export PATH=${JOT_HOME}/bin/<arch>/;${PATH}
  
  In order to minimize the number of statically-linked libraries in the  linux
  version, the `%s=copy` and `%s=paste`commands are  not  available  with  the
  linux executables supplied in the download. This deficiency can be corrected
  by recompiling with X11 enabled and, if necessary, installation of  the  X11
  libs and header files.
  
  If you have to recompile the jot executable,  these  commands  should  work,
  there may be a few _devl and sharable libraries to be installed:
$ versionString="jot <version>, built `\date +%d/%m/%y\ %H:%M:%S` `\uname -nspr`  "
$ cc -D LINUX -g -Wall ${JOT_HOME}/source/jot.c -D_FILE_OFFSET_BITS=64 -D VERSION_STRING="\"${versionString}\"" \
     -lncursesw -lX11 -lXt -o ${JOT_HOME}/bin/<arch>/jot
$ gcc -g source/jot.c -D VERSION_STRING="${versionString}" -lncursesw -o bin/<arch>/jot
  
   The linux executables supplied in the tarball were statically linked to the
   curses library, with cut and paste disabled by  the  noX11  flag,  using  a
   command similar to this:
$ gcc -DLINUX -DnoX11 $debug -g -Wall source/jot.c \
     -D_FILE_OFFSET_BITS=64   -D    VERSION_STRING="\"${versionString}\""    \
     -Xlinker -dn -lncursesw -lncurses -Xlinker -dy -lgcc_s -o ed/bin/jot
  
  See also `X-windows setup`.
  
  To use the spelling checker functions (see `text document preparation`), you
  will need aspell on your search path.

6.2.1 Things that might go wrong
--------------------------------
  - bash: jot: command not found
      Check your search path like this:
$ echo $PATH
      You should see the path to the bin subdir in the colon-separated list it
      returns - if not check the following:
        - did you remember to start a new bash after setting up your .bashrc?
        - is the spelling and case pattern correct.
        
      If the path is correct then check  the  binary  is  giving  you  execute
      permission:
$ ls -l <binPath>/jot
      you should see something like this "-rwxr-xr-x" if you don't see  the  x
      characters then make it executable - like this:
$ chmod ugo+x <binPath>/jot
  
  - /lib64/libc.so.6: version 'GLIBC_2.17' not found 
      This is probably because you are using an old  linux  distribution.  Try
      installing a newer glibc - either glibc.x86_64 or glibc.i686  for  older
      32-bit machines. Another  approach  would  be  to  try  recompiling  the
      source, you will need various libraries including some _dev libs  and  a
      gcc - see the previous section for details of the gcc command.
    
  - Error opening terminal: <termName>.
      Check your TERM env:
$ echo $TERM
      Most distributions default it to "xterm" if  it's  something  different,
      then try setting it to xterm like this:
$ export TERM=xterm
      If that works out, and you have no reason to want it  to  be  different,
      put that export line into ~/.bashrc so you don't have to keep on setting
      it in every new shell.
      
      If, however, your TERM is set to xterm, then you've got a problem. Check
      your terminfos:
$ ls -l /usr/share/terminfo/x/xterm*
  or, maybe:
$ ls -l /lib/terminfo/x/xterm*
      There will probably be several flavours of xterm to chose from - pick  a
      likely looking one and export that one.
      
      The Ubuntu crouton system (and perhaps other Ubuntu systems  -  possibly
      also Debian) it may be necessary to install xterm:
$ sudo apt-get install xterm
      and/or set your TERM env to xterm1:
$ export TERM=xterm1
    
  - Failure to render unicode correctly
    - first check your TERM setting (see above),
    - check that you have a good xterm version installed (see above).
    - check your locale setting - this might help:
export XTERM_LOCALE=C.UTF-8 

6.2.2 X-windows setup
---------------------
  The mapping of keyboard function keys is dependent on  various  elements  of
  operating system and it's setup. This is done in several stages, ultimately,
  JOT picks up text characters, control codes and VT100-like escape sequences.
  
  Jot is implemented using functions from the curses library - these provide a
  consistent mapping of most function keys to control codes which jot can  map
  to your selected actions at setup time.
  
  In addition to function keys and other keys supported by  curses,  jot  will
  recognize   vt220-like   escape   sequences   generated   in   response   to
  numeric-keypad actions. The mapping of these is not consistent and different
  installations may give different results. Use  xev  and  xmodmap  to  define
  these mappings. See also `Keyboard functions defined at startup`
  
  The  jot  setup  assumes  unique  keycodes  from   the   numeric   keyboard,
  unfortunately,  in  the  linux-curses  environment,   the   numeric   keypad
  keystrokes are indistinguishable from their twins in other sections  of  the
  keyboard. The windows version does not use curses and does not  suffer  from
  this  problem.  The  solution  for  linux  users,  wanting  to   use   their
  bean-counters keypad, is to redefine the numeric keyboard keys with xmodmap.
  e.g:
$ xmodmap ${JOT_RESOURCES}/my_xmodmap
 
  This version of my_xmodmap works for PC keyboards:
!! Make the numeric keypad keys unique.
keycode  63 = KP_Multiply
keycode  82 = KP_Subtract
keycode  86 = KP_Add
keycode  91 = KP_Decimal
keycode 108 = KP_Enter
keycode  79 = KP_7
keycode  80 = KP_8
keycode  81 = KP_9
keycode  83 = KP_4
keycode  84 = KP_5
keycode  85 = KP_6
keycode  87 = KP_1
keycode  88 = KP_2
keycode  89 = KP_3
keycode  90 = KP_0

6.3 MS-Windows setup
--------------------
  Wherever you unpack the archive, JOT_HOME should be  set  to  point  at  the
  v<version> directory. You will also need to set search path. System registry
  entries are the recommended method but, hey, life is short maybe  this  will
  be good enough for now:
$ setx JOT_HOME=C:\<unpackPath>\v<version>\
$ set PATH=C:\<unpackPath>\v<version>n.m\bin\win32;%PATH%
  
  In windowsland it is most unlikely you will need to recompile, which is just
  as well since compiling just about anything in windowsland is  going  to  be
  painful. If you have a working cl installation and libgcc and  libgw32c  gnu
  libraries (try sourceforge) then something like this might work:
$ cl /c /DVC /D__value=_value /Zi /D_DEBUG /DVERSION_STRING="jot for WindowsNT v<version>" %JOT_HOME%\jot.c /Fojot.obj
$ link /debug /out:%JOT_HOME%/bin/jot.exe jot.obj ^
    <MSDKsPath>\v7.1\Lib\*.Lib  ^
    <gnuLibPath>\libgw32c-0.4\lib\libgw32c.a  ^
    <gnuLibPath>\libgcc\lib\libgcc.lib
